[
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  FUN_0000b0d1(param_1 + 0x1f0,param_2,*(undefined8 *)(param_1 + 0x230));\n  return;\n}\n\n",
        "output": "The predicted function name is parse_expected_server_ca_names"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,void *param_2,long param_3)\n\n{\n  int iVar1;\n  undefined8 *puVar2;\n  void *pvVar3;\n  undefined8 uVar4;\n  \n  puVar2 = (undefined8 *)FUN_0001f967(0x10);\n  pvVar3 = memchr(param_2,0x2f,param_3 - (long)param_2);\n  if (pvVar3 == (void *)0x0) {\n    uVar4 = wget_strmemdup(param_2,param_3 - (long)param_2);\n    *puVar2 = uVar4;\n    puVar2[1] = 0;\n  }\n  else {\n    uVar4 = wget_strmemdup(param_2,(long)pvVar3 - (long)param_2);\n    *puVar2 = uVar4;\n    uVar4 = wget_strmemdup((long)pvVar3 + 1,(param_3 - (long)pvVar3) + -1);\n    puVar2[1] = uVar4;\n  }\n  iVar1 = wget_vector_find(param_1,puVar2);\n  if (iVar1 < 0) {\n    wget_vector_insert_sorted(param_1,puVar2);\n  }\n  else {\n    FUN_000208e1(puVar2);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is add_tag"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  long lVar1;\n  \n  if (param_1 != 0) {\n    *(undefined8 *)(param_1 + 0x20) = 0;\n    **(undefined **)(param_1 + 8) = 0;\n    *(undefined *)(*(long *)(param_1 + 8) + 1) = 0;\n    *(undefined8 *)(param_1 + 0x10) = *(undefined8 *)(param_1 + 8);\n    *(undefined4 *)(param_1 + 0x30) = 1;\n    *(undefined4 *)(param_1 + 0x40) = 0;\n    if (DAT_00215a00 == 0) {\n      lVar1 = 0;\n    }\n    else {\n      lVar1 = *(long *)(DAT_00215a00 + DAT_002159f0 * 8);\n    }\n    if (lVar1 == param_1) {\n      FUN_0000e524();\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yy_flush_buffer"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_000036d5(0x30,2,0);\n  return;\n}\n\n",
        "output": "The predicted function name is test_http_keep_alive_0_require_no"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  EVP_PKEY_CTX *ctx;\n  EVP_PKEY_CTX **ppEVar3;\n  \n  iVar1 = OBJ_sn2nid(param_2);\n  if ((iVar1 == 0) && (iVar1 = OBJ_ln2nid(param_2), iVar1 == 0)) {\n    uVar2 = 0;\n  }\n  else {\n    iVar1 = FUN_00011e4a(param_2);\n    if (iVar1 == 0) {\n      ctx = (EVP_PKEY_CTX *)EVP_PKEY_CTX_new_from_name(DAT_002241a8,param_2,0);\n      iVar1 = FUN_00018f92(\"test/evp_test.c\",0xc03,\n                           \"genctx = EVP_PKEY_CTX_new_from_name(libctx, alg, NULL)\",ctx);\n      if (iVar1 != 0) {\n        iVar1 = EVP_PKEY_keygen_init(ctx);\n        if (iVar1 < 1) {\n          *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KEYGEN_INIT_ERROR\";\n        }\n        else {\n          ppEVar3 = (EVP_PKEY_CTX **)CRYPTO_malloc(0x10,\"test/evp_test.c\",0xc0b);\n          iVar1 = FUN_00018f92(\"test/evp_test.c\",0xc0b,\"data = OPENSSL_malloc(sizeof(*data))\",\n                               ppEVar3);\n          if (iVar1 != 0) {\n            *ppEVar3 = ctx;\n            ppEVar3[1] = (EVP_PKEY_CTX *)0x0;\n            *(EVP_PKEY_CTX ***)(\"EVP_PKEY_verify_recover_init\" + param_1) = ppEVar3;\n            *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n            return 1;\n          }\n        }\n      }\n      EVP_PKEY_CTX_free(ctx);\n      uVar2 = 0;\n    }\n    else {\n      *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n      uVar2 = 1;\n    }\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is keygen_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nuint [MASK](undefined8 param_1,undefined8 param_2,void *param_3,uint param_4)\n\n{\n  uint local_24;\n  \n  local_24 = param_4;\n  if (0x14 < param_4) {\n    local_24 = 0x14;\n  }\n  memset(param_3,0x5a,(ulong)local_24);\n  return local_24;\n}\n\n",
        "output": "The predicted function name is srvr_psk_callback"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  EVP_PKEY_CTX **ppEVar1;\n  \n  ppEVar1 = *(EVP_PKEY_CTX ***)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  EVP_PKEY_CTX_free(*ppEVar1);\n  CRYPTO_free(ppEVar1[1]);\n  CRYPTO_free(*(void **)(\"EVP_PKEY_verify_recover_init\" + param_1));\n  *(undefined8 *)(\"EVP_PKEY_verify_recover_init\" + param_1) = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is keygen_test_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined4 param_1)\n\n{\n  FUN_00009e5e(&PTR_DAT_0021f1a0,3,param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is ssl_ct_validation_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  long in_FS_OFFSET;\n  uint local_120;\n  uint local_11c;\n  long local_118 [28];\n  byte abStack56 [26];\n  byte local_1e;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  FUN_00006f10(param_1,param_2);\n  FUN_00006d1a(0x3a);\n  FUN_0000690c(param_1,param_2,local_118);\n  for (local_120 = 0; local_120 < local_1e; local_120 = local_120 + 1) {\n    for (local_11c = 0; local_11c < abStack56[local_120]; local_11c = local_11c + 1) {\n      FUN_00006d1a(0x20);\n      FUN_00006f10(0,local_118[(ulong)local_120 + 2]);\n    }\n  }\n  if (local_118[1] != 0) {\n    FUN_00006d1a(0x20);\n    FUN_00006f10(local_118[1],local_118[0]);\n  }\n  FUN_00006d1a(10);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is print_factors_single"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,long param_2)\n\n{\n  CRYPTO_strdup(*(char **)(param_2 + 0x28),\"test/helpers/handshake_srp.c\",0x18);\n  return;\n}\n\n",
        "output": "The predicted function name is client_srp_cb"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  wget_hashmap_set_key_destructor(param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is wget_stringmap_set_key_destructor"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8\n[MASK](long param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n            undefined8 param_5,FILE *param_6)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined8 uVar3;\n  int *piVar4;\n  long in_FS_OFFSET;\n  undefined8 local_138 [4];\n  undefined local_118 [264];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((param_1 == 0) || (param_6 == (FILE *)0x0)) {\n    uVar3 = 0xffffffff;\n  }\n  else {\n    iVar1 = fileno(param_6);\n    if (iVar1 < 0) {\n      uVar3 = 0xffffffff;\n    }\n    else {\n      iVar2 = FUN_0001f423(\"user.mime_type\",param_3,iVar1);\n      if (iVar2 < 0) {\n        piVar4 = __errno_location();\n        if (*piVar4 == 0x5f) {\n          uVar3 = 0xffffffff;\n          goto LAB_0001f781;\n        }\n      }\n      FUN_0001f423(\"user.charset\",param_4,iVar1);\n      wget_buffer_init(local_138,local_118,0x100);\n      wget_iri_get_connection_part(param_1,local_138);\n      wget_buffer_memcat(local_138,&DAT_00041a79,1);\n      wget_iri_get_escaped_resource(param_1,local_138);\n      FUN_0001f423(\"user.xdg.origin.url\",local_138[0],iVar1);\n      wget_buffer_reset(local_138);\n      wget_iri_get_connection_part(param_2,local_138);\n      FUN_0001f423(\"user.xdg.referrer.url\",local_138[0],iVar1);\n      wget_buffer_deinit(local_138);\n      uVar3 = FUN_0001f539(param_5,iVar1);\n    }\n  }\nLAB_0001f781:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is set_file_metadata"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](void)\n\n{\n  byte bVar1;\n  long lVar2;\n  long in_FS_OFFSET;\n  bool local_31;\n  undefined local_28 [8];\n  void *local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_31 = true;\n  FUN_0000a036(local_28);\n  while( true ) {\n    lVar2 = FUN_0000a0ef(stdin,&DAT_0001159d,3,local_28);\n    if (lVar2 == -1) break;\n    bVar1 = FUN_000071b3(local_20);\n    local_31 = (bVar1 & local_31) != 0;\n  }\n  free(local_20);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_31;\n}\n\n",
        "output": "The predicted function name is do_stdin"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  ASN1_OBJECT *o;\n  char *pcVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined4 local_24;\n  undefined8 local_20;\n  undefined8 local_18;\n  \n  local_20 = 0;\n  local_18 = 0;\n  local_24 = 1;\n  o = OBJ_nid2obj(0x45);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x5f0,\"obj = OBJ_nid2obj(NID_id_pbkdf2)\",o);\n  if (iVar1 == 0) {\nLAB_00009ad5:\n    local_24 = 0;\n  }\n  else {\n    local_20 = EVP_KDF_fetch(0,\"PBKDF2\",0);\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x5f1,\n                         \"kdf1 = EVP_KDF_fetch(NULL, OSSL_KDF_NAME_PBKDF2, NULL)\",local_20);\n    if (iVar1 == 0) goto LAB_00009ad5;\n    iVar1 = OBJ_obj2nid(o);\n    pcVar2 = OBJ_nid2sn(iVar1);\n    local_18 = EVP_KDF_fetch(0,pcVar2,0);\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x5f3,\n                         \"kdf2 = EVP_KDF_fetch(NULL, OBJ_nid2sn(OBJ_obj2nid(obj)), NULL)\",local_18);\n    if (iVar1 == 0) goto LAB_00009ad5;\n    iVar1 = FUN_00009921(local_20,local_18);\n    if (iVar1 == 0) goto LAB_00009ad5;\n  }\n  EVP_KDF_free(local_20);\n  EVP_KDF_free(local_18);\n  local_18 = 0;\n  uVar3 = EVP_KDF_fetch(0,\"TLS1-PRF\",0);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x5fb,\"kdf1 = EVP_KDF_fetch(NULL, SN_tls1_prf, NULL)\",\n                       uVar3);\n  if (iVar1 == 0) {\nLAB_00009b95:\n    local_24 = 0;\n  }\n  else {\n    local_18 = EVP_KDF_fetch(0,\"tls1-prf\",0);\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x5fc,\"kdf2 = EVP_KDF_fetch(NULL, LN_tls1_prf, NULL)\"\n                         ,local_18);\n    if (iVar1 == 0) goto LAB_00009b95;\n    iVar1 = FUN_00009921(uVar3,local_18);\n    if (iVar1 == 0) goto LAB_00009b95;\n  }\n  EVP_KDF_free(local_18);\n  pcVar2 = OBJ_nid2sn(0x3fd);\n  uVar4 = EVP_KDF_fetch(0,pcVar2,0);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x603,\n                       \"kdf2 = EVP_KDF_fetch(NULL, OBJ_nid2sn(NID_tls1_prf), NULL)\",uVar4);\n  if (iVar1 != 0) {\n    iVar1 = FUN_00009921(uVar3,uVar4);\n    if (iVar1 != 0) goto LAB_00009c11;\n  }\n  local_24 = 0;\nLAB_00009c11:\n  EVP_KDF_free(uVar3);\n  EVP_KDF_free(uVar4);\n  return local_24;\n}\n\n",
        "output": "The predicted function name is test_kdf_get_kdf"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_00003bff(0,1);\n  return;\n}\n\n",
        "output": "The predicted function name is test_kdf_hkdf_gettables"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](int *param_1,char *param_2)\n\n{\n  undefined8 uVar1;\n  int local_c;\n  \n  if (param_2 == (char *)0x0) {\n    uVar1 = 0;\n  }\n  else {\n    local_c = OBJ_sn2nid(param_2);\n    if (local_c == 0) {\n      local_c = OBJ_ln2nid(param_2);\n    }\n    if (local_c == 0) {\n      uVar1 = 0;\n    }\n    else {\n      *param_1 = local_c;\n      uVar1 = 1;\n    }\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is parse_expected_sign_hash"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  long lVar1;\n  char cVar2;\n  undefined *puVar3;\n  \n  lVar1 = *(long *)(*(long *)(param_1 + 0x38) + 8);\n  cVar2 = FUN_00001be7();\n  if (cVar2 == '\\0') {\n    cVar2 = FUN_00001be7();\n    if (cVar2 == '\\0') {\n      cVar2 = FUN_00001be7();\n      if (cVar2 == '\\0') {\n        cVar2 = FUN_00001be7();\n        if (cVar2 == '\\0') {\n          cVar2 = FUN_00001c1d(param_1);\n          if (cVar2 == '\\0') {\n            printf(\"\\t<!-- 3dface-%d -->\\n\",(ulong)*(uint *)(param_1 + 0x14));\n            if (*(short *)(lVar1 + 0x70) == 0) {\n              printf(*(char **)(lVar1 + 0x10),*(undefined8 *)(lVar1 + 0x18),\n                     *(undefined8 *)(lVar1 + 0x28),*(undefined8 *)(lVar1 + 0x30),\n                     *(undefined8 *)(lVar1 + 0x40),*(undefined8 *)(lVar1 + 0x48),\n                     *(undefined8 *)(lVar1 + 0x58),*(undefined8 *)(lVar1 + 0x60),\n                     \"\\t<polygon id=\\\"dwg-object-%d\\\" points=\\\"%f,%f %f,%f %f,%f %f,%f\\\"\\n\\t\",\n                     (ulong)*(uint *)(param_1 + 0x14));\n            }\n            else {\n              printf(*(char **)(lVar1 + 0x10),*(undefined8 *)(lVar1 + 0x18),\n                     \"\\t<path id=\\\"dwg-object-%d\\\" d=\\\"M %f,%f\",(ulong)*(uint *)(param_1 + 0x14));\n              if ((*(ushort *)(lVar1 + 0x70) & 1) == 0) {\n                puVar3 = &DAT_0000629f;\n              }\n              else {\n                puVar3 = &DAT_0000629d;\n              }\n              printf(*(char **)(lVar1 + 0x28),*(undefined8 *)(lVar1 + 0x30),\" %s %f,%f\",puVar3);\n              if ((*(ushort *)(lVar1 + 0x70) & 2) == 0) {\n                puVar3 = &DAT_0000629f;\n              }\n              else {\n                puVar3 = &DAT_0000629d;\n              }\n              printf(*(char **)(lVar1 + 0x40),*(undefined8 *)(lVar1 + 0x48),\" %s %f,%f\",puVar3);\n              if ((*(ushort *)(lVar1 + 0x70) & 4) == 0) {\n                puVar3 = &DAT_0000629f;\n              }\n              else {\n                puVar3 = &DAT_0000629d;\n              }\n              printf(*(char **)(lVar1 + 0x58),*(undefined8 *)(lVar1 + 0x60),\" %s %f,%f\",puVar3);\n              if ((*(ushort *)(lVar1 + 0x70) & 8) == 0) {\n                puVar3 = &DAT_0000629f;\n              }\n              else {\n                puVar3 = &DAT_0000629d;\n              }\n              printf(*(char **)(lVar1 + 0x10),*(undefined8 *)(lVar1 + 0x18),\" %s %f,%f\\\"\\n\\t\",puVar3\n                    );\n            }\n            FUN_00001e87(*(undefined8 *)(param_1 + 0x38));\n          }\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is output_3DFACE"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong * [MASK](undefined8 *param_1,long param_2)\n\n{\n  undefined8 uVar1;\n  int iVar2;\n  long lVar3;\n  __off_t _Var4;\n  undefined8 uVar5;\n  int *piVar6;\n  ulong *puVar7;\n  ulong local_48;\n  \n  lVar3 = FUN_0000bc4d(param_1,param_2);\n  if (lVar3 == 0) {\n    lVar3 = param_1[3] * (param_2 + 1);\n    _Var4 = lseek(*(int *)(param_1 + 1),lVar3,0);\n    if (lVar3 == _Var4) {\n      lVar3 = FUN_0000b93e(param_1);\n      if (lVar3 == 0) {\n        puVar7 = (ulong *)0x0;\n      }\n      else {\n        iVar2 = FUN_0000b4eb(param_1,*(undefined8 *)(lVar3 + 0x10),param_1[3]);\n        if (iVar2 == 0) {\n          *(int *)(lVar3 + 8) = *(int *)(lVar3 + 8) + 1;\n          puVar7 = *(ulong **)(lVar3 + 0x10);\n          for (local_48 = 0; local_48 < *puVar7; local_48 = local_48 + 1) {\n            puVar7[local_48 * 7 + 0xd] = puVar7[local_48 * 7 + 7] + (long)puVar7;\n          }\n        }\n        else {\n          puVar7 = (ulong *)0x0;\n        }\n      }\n    }\n    else {\n      uVar1 = *param_1;\n      uVar5 = gettext(\"seek error on `%s\\' while positioning to %lu\");\n      piVar6 = __errno_location();\n      dico_log(4,*piVar6,uVar5,uVar1,lVar3);\n      puVar7 = (ulong *)0x0;\n    }\n  }\n  else {\n    puVar7 = *(ulong **)(lVar3 + 0x10);\n  }\n  return puVar7;\n}\n\n",
        "output": "The predicted function name is _idx_get_page"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](int *param_1,char *param_2)\n\n{\n  undefined8 uVar1;\n  long in_FS_OFFSET;\n  int local_1c;\n  EVP_PKEY_ASN1_METHOD *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 == (char *)0x0) {\n    uVar1 = 0;\n  }\n  else {\n    local_18 = EVP_PKEY_asn1_find_str((ENGINE **)0x0,param_2,-1);\n    if (local_18 == (EVP_PKEY_ASN1_METHOD *)0x0) {\n      local_1c = OBJ_sn2nid(param_2);\n    }\n    else {\n      EVP_PKEY_asn1_get0_info(&local_1c,(int *)0x0,(int *)0x0,(char **)0x0,(char **)0x0,local_18);\n    }\n    if (local_1c == 0) {\n      local_1c = OBJ_ln2nid(param_2);\n    }\n    if (local_1c == 0) {\n      local_1c = EC_curve_nist2nid(param_2);\n    }\n    if (local_1c == 0) {\n      uVar1 = 0;\n    }\n    else {\n      *param_1 = local_1c;\n      uVar1 = 1;\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is parse_expected_key_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0000fe57(param_1,param_2,1,1);\n  return;\n}\n\n",
        "output": "The predicted function name is oneshot_digestverify_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8\n[MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,long param_4,long param_5,\n            long param_6,long param_7)\n\n{\n  int iVar1;\n  char *pcVar2;\n  \n  if (*(long *)(param_4 + 0x68) != 0) {\n    SSL_CTX_set_srp_username_callback(param_1,FUN_0000999d);\n    pcVar2 = CRYPTO_strdup(*(char **)(param_4 + 0x68),\"test/helpers/handshake_srp.c\",0x32);\n    *(char **)(param_5 + 0x20) = pcVar2;\n    pcVar2 = CRYPTO_strdup(*(char **)(param_4 + 0x70),\"test/helpers/handshake_srp.c\",0x33);\n    *(char **)(param_5 + 0x28) = pcVar2;\n    if ((*(long *)(param_5 + 0x20) == 0) || (*(long *)(param_5 + 0x28) == 0)) {\n      CRYPTO_free(*(void **)(param_5 + 0x20));\n      CRYPTO_free(*(void **)(param_5 + 0x28));\n      *(undefined8 *)(param_5 + 0x20) = 0;\n      *(undefined8 *)(param_5 + 0x28) = 0;\n      return 0;\n    }\n    SSL_CTX_set_srp_cb_arg(param_1,param_5);\n  }\n  if (*(long *)(param_4 + 0xa8) != 0) {\n    iVar1 = FUN_000146a7(\"test/helpers/handshake_srp.c\",0x3e,\"server2_ctx\",param_2);\n    if (iVar1 == 0) {\n      return 0;\n    }\n    SSL_CTX_set_srp_username_callback(param_2,FUN_0000999d);\n    pcVar2 = CRYPTO_strdup(*(char **)(param_4 + 0xa8),\"test/helpers/handshake_srp.c\",0x41);\n    *(char **)(param_6 + 0x20) = pcVar2;\n    pcVar2 = CRYPTO_strdup(*(char **)(param_4 + 0xb0),\"test/helpers/handshake_srp.c\",0x42);\n    *(char **)(param_6 + 0x28) = pcVar2;\n    if ((*(long *)(param_6 + 0x20) == 0) || (*(long *)(param_6 + 0x28) == 0)) {\n      CRYPTO_free(*(void **)(param_6 + 0x20));\n      CRYPTO_free(*(void **)(param_6 + 0x28));\n      *(undefined8 *)(param_6 + 0x20) = 0;\n      *(undefined8 *)(param_6 + 0x28) = 0;\n      return 0;\n    }\n    SSL_CTX_set_srp_cb_arg(param_2,param_6);\n  }\n  if (*(long *)(param_4 + 0x30) != 0) {\n    iVar1 = SSL_CTX_set_srp_username(param_3,*(undefined8 *)(param_4 + 0x30));\n    iVar1 = FUN_0001471c(\"test/helpers/handshake_srp.c\",0x4e,\n                         \"SSL_CTX_set_srp_username(client_ctx, extra->client.srp_user)\",iVar1 != 0);\n    if (iVar1 == 0) {\n      return 0;\n    }\n    SSL_CTX_set_srp_client_pwd_callback(param_3,FUN_00009967);\n    pcVar2 = CRYPTO_strdup(*(char **)(param_4 + 0x38),\"test/helpers/handshake_srp.c\",0x51);\n    *(char **)(param_7 + 0x28) = pcVar2;\n    if (*(long *)(param_7 + 0x28) == 0) {\n      return 0;\n    }\n    SSL_CTX_set_srp_cb_arg(param_3,param_7);\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is configure_handshake_ctx_for_srp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = 0;\n  local_30 = 0;\n  local_28 = 0;\n  local_20 = 0;\n  ptr = (void *)FUN_000076f4(\"sha256\",&DAT_00014269,&DAT_00219203,1,&DAT_00014265,&DAT_00014260);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x496,\"params\",ptr);\n  if (iVar1 == 0) {\n    uVar2 = 0;\n    goto LAB_00007ed3;\n  }\n  uVar3 = FUN_00002d68(\"KBKDF\");\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x49a,&DAT_000141f4,uVar3);\n  if (iVar1 == 0) {\nLAB_00007ea4:\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = EVP_KDF_derive(uVar3,&local_38,0x20,ptr);\n    iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x49b,\n                         \"EVP_KDF_derive(kctx, result, sizeof(result), params)\",&DAT_00013c2d,uVar2,\n                         0);\n    if (iVar1 == 0) goto LAB_00007ea4;\n    uVar2 = 1;\n  }\n  EVP_KDF_CTX_free(uVar3);\n  CRYPTO_free(ptr);\nLAB_00007ed3:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_kbkdf_1byte_key"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined4 local_2c;\n  \n  uVar2 = EVP_SIGNATURE_fetch(param_1,&DAT_0000e368,param_3);\n  local_2c = 0;\n  iVar1 = FUN_0000879a(\"test/provider_pkey_test.c\",0x1e,&DAT_0000e36c,uVar2);\n  if (iVar1 == 0) {\n    local_2c = 0;\n  }\n  else {\n    uVar3 = EVP_SIGNATURE_get0_provider(uVar2);\n    iVar1 = FUN_0000879a(\"test/provider_pkey_test.c\",0x21,\"prov = EVP_SIGNATURE_get0_provider(sig)\",\n                         uVar3);\n    if (iVar1 != 0) {\n      iVar1 = FUN_00008627(\"test/provider_pkey_test.c\",0x24,&DAT_0000e3c6,\"expected_prov\",uVar3,\n                           param_4,param_4,param_3,param_2);\n      if (iVar1 == 0) {\n        uVar4 = OSSL_PROVIDER_get0_name(param_4);\n        uVar3 = OSSL_PROVIDER_get0_name(uVar3);\n        FUN_0000670e(\"test/provider_pkey_test.c\",0x27,\"Fetched provider: %s, Expected provider: %s\",\n                     uVar3,uVar4);\n      }\n      else {\n        local_2c = 1;\n      }\n    }\n    EVP_SIGNATURE_free(uVar2);\n  }\n  return local_2c;\n}\n\n",
        "output": "The predicted function name is fetch_sig"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,char *param_2)\n\n{\n  char cVar1;\n  undefined8 uVar2;\n  char *local_20;\n  \n  local_20 = param_2;\n  if (param_2 != (char *)0x0) {\n    for (; *local_20 != '\\0'; local_20 = local_20 + 1) {\n      switch(*local_20) {\n      case 'H':\n        DAT_002533fc = 0;\n        break;\n      default:\n        cVar1 = *local_20;\n        uVar2 = gettext(\"Unknown option \\'-n%c\\'\\n\");\n        wget_error_printf(uVar2,(int)cVar1);\n        return 0xffffffff;\n      case 'c':\n        DAT_002533f5 = 0;\n        break;\n      case 'd':\n        DAT_002533fe = 0;\n        break;\n      case 'p':\n        DAT_002533e9 = 0;\n        break;\n      case 'v':\n        DAT_0025340c = 0;\n      }\n      wget_debug_printf(\"name=-n%c value=0\\n\");\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is parse_n_option"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](long param_1)\n\n{\n  undefined4 uVar1;\n  \n  if (param_1 == 0) {\n    uVar1 = 0xffffffff;\n  }\n  else {\n    uVar1 = *(undefined4 *)(param_1 + 4);\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is trace_udp_sock"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](SSL *param_1)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = SSL_get_ex_data(param_1,DAT_002200e4);\n  *(undefined4 *)((long)pvVar1 + 0xc) = 1;\n  return 0;\n}\n\n",
        "output": "The predicted function name is do_not_call_session_ticket_cb"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](long param_1)\n\n{\n  undefined4 local_c;\n  \n  local_c = 1;\n  if (param_1 == 0) {\n    fwrite(\"object is NULL\\n\",1,0xf,stderr);\n    local_c = 0;\n  }\n  else {\n    switch(*(undefined4 *)(param_1 + 0x10)) {\n    default:\n      local_c = 0;\n      if (*(int *)(param_1 + 0x30) == 0) {\n        fprintf(stderr,\"%s ignored\\n\",*(undefined8 *)(param_1 + 0x20));\n      }\n      break;\n    case 1:\n      FUN_00001ef7(param_1);\n      break;\n    case 6:\n    case 0x22:\n      break;\n    case 7:\n      FUN_00003f96(param_1);\n      break;\n    case 0xf:\n      FUN_000039fa(param_1);\n      break;\n    case 0x11:\n      FUN_00002e4b(param_1);\n      break;\n    case 0x12:\n      FUN_00002ba3(param_1);\n      break;\n    case 0x13:\n      FUN_000021bf(param_1);\n      break;\n    case 0x1b:\n      FUN_00002cf9(param_1);\n      break;\n    case 0x1c:\n      FUN_000036ff(param_1);\n      break;\n    case 0x1f:\n      FUN_00003326(param_1);\n      break;\n    case 0x23:\n      FUN_00003140(param_1);\n      break;\n    case 0x28:\n      FUN_00002732(param_1);\n      break;\n    case 0x29:\n      FUN_0000236f(param_1);\n      break;\n    case 0x4d:\n      FUN_00003cc7(param_1);\n    }\n  }\n  return local_c;\n}\n\n",
        "output": "The predicted function name is output_object"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  SSL_METHOD *meth;\n  SSL_CTX *ctx;\n  undefined8 uVar2;\n  SSL_CIPHER *c;\n  char *__s1;\n  undefined8 uVar3;\n  int local_30;\n  int local_2c;\n  \n  local_2c = 0;\n  meth = (SSL_METHOD *)DTLS_method();\n  ctx = SSL_CTX_new(meth);\n  iVar1 = FUN_0000a946(\"test/dtls_mtu_test.c\",0x96,\"ctx = SSL_CTX_new(DTLS_method())\",ctx);\n  if (iVar1 != 0) {\n    SSL_CTX_set_psk_server_callback(ctx,FUN_00003adb);\n    SSL_CTX_set_psk_client_callback(ctx,FUN_00003a78);\n    SSL_CTX_set_security_level(ctx,0);\n    iVar1 = SSL_CTX_set_cipher_list(ctx,\"PSK\");\n    iVar1 = FUN_0000a9bb(\"test/dtls_mtu_test.c\",0xa2,\"SSL_CTX_set_cipher_list(ctx, \\\"PSK\\\")\",\n                         iVar1 != 0);\n    if (iVar1 != 0) {\n      uVar2 = SSL_CTX_get_ciphers(ctx);\n      local_30 = 0;\n      while( true ) {\n        uVar3 = FUN_00003a6a(uVar2);\n        iVar1 = OPENSSL_sk_num(uVar3);\n        if (iVar1 <= local_30) break;\n        uVar3 = FUN_00003a6a(uVar2);\n        c = (SSL_CIPHER *)OPENSSL_sk_value(uVar3,local_30);\n        __s1 = SSL_CIPHER_get_name(c);\n        iVar1 = strncmp(__s1,\"PSK-\",4);\n        if (iVar1 == 0) {\n          local_2c = FUN_00003b18(ctx,__s1,0);\n          iVar1 = FUN_00009103(\"test/dtls_mtu_test.c\",0xae,\"ret = mtu_test(ctx, cipher_name, 0)\",\n                               &DAT_00010311,local_2c,0);\n          if (iVar1 == 0) break;\n          FUN_000088ba(\"test/dtls_mtu_test.c\",0xb0,\"%s OK\",__s1);\n          if (local_2c != 1) {\n            local_2c = FUN_00003b18(ctx,__s1,1);\n            iVar1 = FUN_00009103(\"test/dtls_mtu_test.c\",0xb5,\"ret = mtu_test(ctx, cipher_name, 1)\",\n                                 &DAT_00010311,local_2c,0);\n            if (iVar1 == 0) break;\n            FUN_000088ba(\"test/dtls_mtu_test.c\",0xb7,\"%s without EtM OK\",__s1);\n          }\n        }\n        local_30 = local_30 + 1;\n      }\n    }\n  }\n  SSL_CTX_free(ctx);\n  return local_2c;\n}\n\n",
        "output": "The predicted function name is run_mtu_tests"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](undefined4 *param_1)\n\n{\n  undefined4 uVar1;\n  \n  if (param_1 == (undefined4 *)0x0) {\n    uVar1 = 0xffffffff;\n  }\n  else {\n    uVar1 = *param_1;\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is trace_icmp_sock"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,char *param_2)\n\n{\n  char *pcVar1;\n  \n  CRYPTO_free(*(void **)(param_1 + 0x1d0));\n  pcVar1 = CRYPTO_strdup(param_2,\"test/helpers/ssl_test_ctx.c\",0x164);\n  *(char **)(param_1 + 0x1d0) = pcVar1;\n  FUN_000146a7(\"test/helpers/ssl_test_ctx.c\",0x164,\"ctx->expected_alpn_protocol\",\n               *(undefined8 *)(param_1 + 0x1d0));\n  return;\n}\n\n",
        "output": "The predicted function name is parse_test_expected_alpn_protocol"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  BIO_METHOD *type;\n  BIO *bp;\n  ulong uVar2;\n  long in_FS_OFFSET;\n  undefined4 local_34;\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_34 = 0;\n  type = BIO_s_mem();\n  bp = BIO_new(type);\n  iVar1 = FUN_000078e9(\"test/bio_memleak_test.c\",0x9b,&DAT_0000d168,bp);\n  if (iVar1 != 0) {\n    iVar1 = BIO_puts(bp,\"Hello World\\n\");\n    iVar1 = FUN_00005eaa(\"test/bio_memleak_test.c\",0x9d,\"BIO_puts(bio, \\\"Hello World\\\\n\\\")\",\n                         &DAT_0000d1c5,iVar1,0xc);\n    if (iVar1 != 0) {\n      BIO_set_flags(bp,0x200);\n      iVar1 = BIO_read(bp,local_28,0x10);\n      iVar1 = FUN_00005eaa(\"test/bio_memleak_test.c\",0xa1,\"BIO_read(bio, data, 16)\",&DAT_0000d1c5,\n                           iVar1,0xc);\n      if ((iVar1 != 0) &&\n         (iVar1 = FUN_00007e1c(\"test/bio_memleak_test.c\",0xa3,&DAT_0000d24e,\"\\\"Hello World\\\\n\\\"\",\n                               local_28,0xc,\"Hello World\\n\",0xc), iVar1 != 0)) {\n        uVar2 = BIO_ctrl(bp,1,0,(void *)0x0);\n        iVar1 = FUN_000060a6(\"test/bio_memleak_test.c\",0xa5,\"BIO_reset(bio)\",&DAT_0000d1ee,\n                             uVar2 & 0xffffffff,0);\n        if (iVar1 != 0) {\n          BIO_clear_flags(bp,0x200);\n          iVar1 = BIO_puts(bp,\"Hi!\\n\");\n          iVar1 = FUN_00005eaa(\"test/bio_memleak_test.c\",0xa9,\"BIO_puts(bio, \\\"Hi!\\\\n\\\")\",\n                               &DAT_0000d305,iVar1,4);\n          if (iVar1 != 0) {\n            iVar1 = BIO_read(bp,local_28,0x10);\n            iVar1 = FUN_00005eaa(\"test/bio_memleak_test.c\",0xab,\"BIO_read(bio, data, 16)\",\n                                 &DAT_0000d31e,iVar1,0x10);\n            if ((iVar1 != 0) &&\n               (iVar1 = FUN_00007e1c(\"test/bio_memleak_test.c\",0xae,&DAT_0000d24e,\n                                     \"\\\"Hello World\\\\nHi!\\\\n\\\"\",local_28,0x10,\"Hello World\\nHi!\\n\",\n                                     0x10), iVar1 != 0)) {\n              local_34 = 1;\n            }\n          }\n        }\n      }\n    }\n  }\n  BIO_free(bp);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_34;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_bio_rdwr_rdonly"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  if (*(long *)(*(long *)(\"EVP_PKEY_verify_recover_init\" + param_1) + 8) == 0) {\n    FUN_00009bff(param_1);\n  }\n  else {\n    FUN_0000a19f(param_1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is mac_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](undefined8 param_1,int param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  undefined8 uVar4;\n  void *pvVar5;\n  long in_FS_OFFSET;\n  long local_40;\n  void *local_38;\n  long local_30;\n  long local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = (void *)0x0;\n  local_30 = 0;\n  local_40 = dico_mapfile_stream_create(param_1,1);\n  if (local_40 == 0) {\n    uVar2 = gettext(\"cannot create stream `%s\\'\");\n    piVar3 = __errno_location();\n    dico_log(2,*piVar3,uVar2,param_1);\n    pvVar5 = (void *)0x0;\n  }\n  else {\n    iVar1 = dico_stream_open(local_40);\n    if (iVar1 == 0) {\n      if (param_2 == 0) {\n        iVar1 = dico_stream_size(local_40,&local_28);\n        if (iVar1 == 0) {\n          local_30 = local_28;\n          local_38 = malloc(local_28 + 1);\n          if (local_38 == (void *)0x0) {\n            uVar2 = gettext(\"cannot allocate dictionary information buffer\");\n            piVar3 = __errno_location();\n            dico_log(4,*piVar3,uVar2);\n          }\n          else {\n            iVar1 = dico_stream_read(local_40,local_38,local_30,0);\n            if (iVar1 == 0) {\n              *(undefined *)(local_30 + (long)local_38) = 0;\n            }\n            else {\n              uVar2 = dico_stream_strerror(local_40,iVar1);\n              uVar4 = gettext(\"read error in stream `%s\\': %s\");\n              dico_log(4,0,uVar4,param_1,uVar2);\n              free(local_38);\n              local_38 = (void *)0x0;\n            }\n          }\n        }\n        else {\n          uVar2 = dico_stream_strerror(local_40,iVar1);\n          uVar4 = gettext(\"cannot get size of stream `%s\\': %s\");\n          dico_log(4,0,uVar4,param_1,uVar2);\n        }\n      }\n      else {\n        iVar1 = dico_stream_getline(local_40,&local_38,&local_30,&local_28);\n        if (iVar1 == 0) {\n          dico_string_trim(local_38,local_28,FUN_00009e73);\n        }\n        else {\n          uVar2 = dico_stream_strerror(local_40,iVar1);\n          uVar4 = gettext(\"read error in stream `%s\\': %s\");\n          dico_log(4,0,uVar4,param_1,uVar2);\n        }\n      }\n      dico_stream_destroy(&local_40);\n      pvVar5 = local_38;\n    }\n    else {\n      uVar2 = dico_stream_strerror(local_40,iVar1);\n      uVar4 = gettext(\"cannot open stream `%s\\': %s\");\n      dico_log(4,0,uVar4,param_1,uVar2);\n      dico_stream_destroy(&local_40);\n      pvVar5 = (void *)0x0;\n    }\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return pvVar5;\n}\n\n",
        "output": "The predicted function name is read_info_file"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  OSSL_PROVIDER_unload(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is fake_rsa_finish"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  uint local_c;\n  \n  for (local_c = 0; local_c < 3; local_c = local_c + 1) {\n    dico_strategy_add(&PTR_s_exact_002041a0 + (long)(int)local_c * 7);\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is outline_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined4 local_34;\n  EVP_PKEY_CTX *local_30;\n  undefined8 local_28;\n  \n  local_30 = (EVP_PKEY_CTX *)0x0;\n  local_28 = 0;\n  local_34 = 0;\n  uVar2 = OSSL_PROVIDER_load(DAT_002130d0,\"default\");\n  iVar1 = FUN_0000879a(\"test/provider_pkey_test.c\",0x80,\n                       \"deflt = OSSL_PROVIDER_load(libctx, \\\"default\\\")\",uVar2);\n  if (iVar1 != 0) {\n    local_30 = (EVP_PKEY_CTX *)EVP_PKEY_CTX_new_from_name(DAT_002130d0,&DAT_0000e368,0);\n    iVar1 = FUN_0000879a(\"test/provider_pkey_test.c\",0x84,\n                         \"ctx = EVP_PKEY_CTX_new_from_name(libctx, \\\"RSA\\\", NULL)\",local_30);\n    if (iVar1 != 0) {\n      iVar1 = EVP_PKEY_keygen_init(local_30);\n      iVar1 = FUN_00006f57(\"test/provider_pkey_test.c\",0x87,\"EVP_PKEY_keygen_init(ctx)\",\n                           &DAT_0000e686,iVar1,0);\n      if (iVar1 != 0) {\n        uVar3 = EVP_PKEY_CTX_get0_provider(local_30);\n        iVar1 = FUN_0000879a(\"test/provider_pkey_test.c\",0x8a,\n                             \"provider = EVP_PKEY_CTX_get0_provider(ctx)\",uVar3);\n        if (iVar1 != 0) {\n          uVar3 = OSSL_PROVIDER_get0_name(uVar3);\n          iVar1 = FUN_0000879a(\"test/provider_pkey_test.c\",0x8d,\n                               \"provname = OSSL_PROVIDER_get0_name(provider)\",uVar3);\n          if ((iVar1 != 0) &&\n             (iVar1 = FUN_000088e7(\"test/provider_pkey_test.c\",0x90,\"provname\",\"\\\"default\\\"\",uVar3,\n                                   \"default\"), iVar1 != 0)) {\n            EVP_PKEY_CTX_free(local_30);\n            local_28 = FUN_00003dc0(DAT_002130d0);\n            iVar1 = FUN_0000879a(\"test/provider_pkey_test.c\",0x97,\n                                 \"fake_rsa = fake_rsa_start(libctx)\",local_28);\n            if (iVar1 == 0) {\n              return 0;\n            }\n            local_30 = (EVP_PKEY_CTX *)\n                       EVP_PKEY_CTX_new_from_name(DAT_002130d0,&DAT_0000e368,\"?provider=fake-rsa\");\n            iVar1 = FUN_0000879a(\"test/provider_pkey_test.c\",0x9b,\n                                 \"ctx = EVP_PKEY_CTX_new_from_name(libctx, \\\"RSA\\\", \\\"?provider=fake-rsa\\\")\"\n                                 ,local_30);\n            if (iVar1 != 0) {\n              iVar1 = EVP_PKEY_keygen_init(local_30);\n              iVar1 = FUN_00006f57(\"test/provider_pkey_test.c\",0x9e,\"EVP_PKEY_keygen_init(ctx)\",\n                                   &DAT_0000e686,iVar1,0);\n              if (iVar1 != 0) {\n                uVar3 = EVP_PKEY_CTX_get0_provider(local_30);\n                iVar1 = FUN_0000879a(\"test/provider_pkey_test.c\",0xa1,\n                                     \"provider = EVP_PKEY_CTX_get0_provider(ctx)\",uVar3);\n                if (iVar1 != 0) {\n                  uVar3 = OSSL_PROVIDER_get0_name(uVar3);\n                  iVar1 = FUN_0000879a(\"test/provider_pkey_test.c\",0xa4,\n                                       \"provname = OSSL_PROVIDER_get0_name(provider)\",uVar3);\n                  if ((iVar1 != 0) &&\n                     (iVar1 = FUN_000088e7(\"test/provider_pkey_test.c\",0xa7,\"provname\",\n                                           \"\\\"fake-rsa\\\"\",uVar3,\"fake-rsa\"), iVar1 != 0)) {\n                    local_34 = 1;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  FUN_00003e58(local_28);\n  OSSL_PROVIDER_unload(uVar2);\n  EVP_PKEY_CTX_free(local_30);\n  return local_34;\n}\n\n",
        "output": "The predicted function name is test_alternative_keygen_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,long *param_2)\n\n{\n  int iVar1;\n  void *pvVar2;\n  long lVar3;\n  \n  pvVar2 = CRYPTO_malloc(0x20,\"test/evp_test.c\",0x8a);\n  iVar1 = FUN_00018f92(\"test/evp_test.c\",0x8a,\"db = OPENSSL_malloc(sizeof(*db))\",pvVar2);\n  if ((iVar1 != 0) && (iVar1 = FUN_000066e2(param_1,pvVar2,(long)pvVar2 + 8), iVar1 != 0)) {\n    *(undefined8 *)((long)pvVar2 + 0x10) = 1;\n    *(undefined4 *)((long)pvVar2 + 0x18) = 0;\n    if (*param_2 == 0) {\n      lVar3 = FUN_00006064();\n      *param_2 = lVar3;\n      iVar1 = FUN_00018f92(\"test/evp_test.c\",0x92,\"*sk = sk_EVP_TEST_BUFFER_new_null()\",*param_2);\n      if (iVar1 == 0) goto LAB_000062e4;\n    }\n    iVar1 = FUN_0000606f(*param_2,pvVar2);\n    if (iVar1 != 0) {\n      return 1;\n    }\n  }\nLAB_000062e4:\n  FUN_000061a0(pvVar2);\n  return 0;\n}\n\n",
        "output": "The predicted function name is evp_test_buffer_append"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00010a35(stderr,param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is write_debug_stderr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 *param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  ulong e;\n  char *__s1;\n  \n  if ((param_1[0x335] == 0) && (param_1[0x337] == 0)) {\n    uVar2 = 1;\n  }\n  else if ((param_1[0x335] == 0) || (param_1[0x337] != 0)) {\n    if ((param_1[0x335] == 0) && (param_1[0x337] != 0)) {\n      FUN_00016f06(\"test/evp_test.c\",0xdba,\"%s:%d: Succeeded but was expecting %s\",*param_1,\n                   *(undefined4 *)((long)param_1 + 0x14),param_1[0x337]);\n      uVar2 = 0;\n    }\n    else {\n      uVar2 = 0x10bb5;\n      iVar1 = strcmp((char *)param_1[0x335],(char *)param_1[0x337]);\n      if (iVar1 == 0) {\n        if (param_1[0x338] == 0) {\n          uVar2 = 1;\n        }\n        else if (param_1[0x338] == 0) {\n          FUN_00016f06(\"test/evp_test.c\",0xdc9,\"%s:%d: Test is missing function or reason code\",\n                       *param_1,*(undefined4 *)((long)param_1 + 0x14));\n          uVar2 = 0;\n        }\n        else {\n          e = ERR_peek_error();\n          if (e == 0) {\n            FUN_00016f06(\"test/evp_test.c\",0xdd0,\"%s:%d: Expected error \\\"%s\\\" not set\",*param_1,\n                         *(undefined4 *)((long)param_1 + 0x14),param_1[0x338]);\n            uVar2 = 0;\n          }\n          else {\n            __s1 = ERR_reason_error_string(e);\n            if (__s1 == (char *)0x0) {\n              FUN_00016f06(\"test/evp_test.c\",0xdd8,\n                           \"%s:%d: Expected error \\\"%s\\\", no strings available. Assuming ok.\",\n                           *param_1,*(undefined4 *)((long)param_1 + 0x14),param_1[0x338]);\n              uVar2 = 1;\n            }\n            else {\n              uVar2 = 0x10d4b;\n              iVar1 = strcmp(__s1,(char *)param_1[0x338]);\n              if (iVar1 == 0) {\n                uVar2 = 1;\n              }\n              else {\n                FUN_00016f06(\"test/evp_test.c\",0xde0,\"%s:%d: Expected error \\\"%s\\\", got \\\"%s\\\"\",\n                             *param_1,*(undefined4 *)((long)param_1 + 0x14),param_1[0x338],__s1,\n                             uVar2);\n                uVar2 = 0;\n              }\n            }\n          }\n        }\n      }\n      else {\n        FUN_00016f06(\"test/evp_test.c\",0xdc0,\"%s:%d: Expected %s got %s\",*param_1,\n                     *(undefined4 *)((long)param_1 + 0x14),param_1[0x337],param_1[0x335],uVar2);\n        uVar2 = 0;\n      }\n    }\n  }\n  else {\n    if (param_1[0x336] == 0) {\n      FUN_00016f06(\"test/evp_test.c\",0xdb4,\"%s:%d: Source of above error; unexpected error %s\",\n                   *param_1,*(undefined4 *)((long)param_1 + 0x14),param_1[0x335]);\n    }\n    else {\n      FUN_00016f06(\"test/evp_test.c\",0xdb1,\"%s:%d: Source of above error (%s); unexpected error %s\",\n                   *param_1,*(undefined4 *)((long)param_1 + 0x14),param_1[0x336],param_1[0x335]);\n    }\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is check_test_error"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,undefined8 param_2)\n\n{\n  undefined8 uVar1;\n  long in_FS_OFFSET;\n  long local_28;\n  undefined8 local_20;\n  long local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = 0;\n  local_18 = FUN_0000e00f(param_1);\n  if (local_18 != 0) {\n    param_1 = local_18;\n  }\n  local_28 = dlopen(param_1,1);\n  if (local_18 != 0) {\n    (*wget_free)(local_18);\n    local_18 = 0;\n  }\n  if (local_28 == 0) {\n    uVar1 = dlerror();\n    FUN_0000defe(param_2,uVar1);\n  }\n  else {\n    local_20 = wget_memdup(&local_28,8);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_20;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is dl_file_open"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  char *__name;\n  DIR *__dirp;\n  long lVar3;\n  undefined8 uVar4;\n  dirent *pdVar5;\n  int local_44;\n  \n  iVar1 = wget_vector_size(param_1);\n  for (local_44 = 0; local_44 < iVar1; local_44 = local_44 + 1) {\n    __name = (char *)wget_vector_get(param_1,local_44);\n    __dirp = opendir(__name);\n    if (__dirp != (DIR *)0x0) {\n      while (pdVar5 = readdir(__dirp), pdVar5 != (dirent *)0x0) {\n        lVar3 = FUN_0000e3dc(pdVar5->d_name);\n        if (lVar3 != 0) {\n          uVar4 = wget_aprintf(\"%s/%s\",__name,pdVar5->d_name);\n          iVar2 = FUN_0000e363(uVar4);\n          (*wget_free)(uVar4);\n          if (iVar2 == 0) {\n            (*wget_free)(lVar3);\n          }\n          else {\n            wget_vector_add(param_2);\n          }\n        }\n      }\n      closedir(__dirp);\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is dl_list"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  char *local_20;\n  char *local_18;\n  \n  uVar1 = **(undefined8 **)(param_1 + 0x18);\n  if (param_2 == (char *)0x0) {\n    FUN_0001f9db(uVar1);\n  }\n  else {\n    FUN_0001f9db(uVar1);\n    local_20 = param_2;\n    local_18 = param_2;\n    while (*local_18 != '\\0') {\n      local_18 = strchrnul(local_20,0x2c);\n      if (local_18 != local_20) {\n        uVar2 = wget_strmemdup(local_20,(long)local_18 - (long)local_20);\n        FUN_0001f9ae(uVar1,uVar2,0);\n      }\n      local_20 = local_18 + 1;\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is parse_stringset"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return 1;\n}\n\n",
        "output": "The predicted function name is verify_accept_cb"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  undefined8 uVar3;\n  \n  puVar1 = *(undefined8 **)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  iVar2 = strcmp(param_2,\"Output\");\n  if (iVar2 == 0) {\n    uVar3 = FUN_000066e2(param_3,puVar1 + 1,puVar1 + 2);\n  }\n  else {\n    iVar2 = strncmp(param_2,\"Ctrl\",4);\n    if (iVar2 == 0) {\n      uVar3 = FUN_0000ed1c(param_1,*puVar1,param_3);\n    }\n    else {\n      uVar3 = 0;\n    }\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is kdf_test_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 *param_2,undefined8 *param_3,int param_4)\n\n{\n  undefined8 uVar1;\n  \n  if (param_2 == (undefined8 *)0x0) {\n    *param_3 = &DAT_00003d64;\n    uVar1 = 1;\n  }\n  else if (param_4 == 6) {\n    *param_2 = DAT_00205348;\n    uVar1 = 1;\n  }\n  else {\n    *param_2 = 0;\n    uVar1 = 0;\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is dasync_pkey"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ASN1_VALUE **param_1,uchar **param_2,long param_3)\n\n{\n  ASN1_ITEM *it;\n  \n  it = (ASN1_ITEM *)FUN_000029aa();\n  ASN1_item_d2i(param_1,param_2,param_3,it);\n  return;\n}\n\n",
        "output": "The predicted function name is d2i_ASN1_LONG_DATA"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  long in_FS_OFFSET;\n  undefined8 local_30;\n  undefined local_1a [10];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = 0;\n  ptr = (void *)FUN_000037e4(\"sha256\",\"secret\",6,&DAT_00013cf5,\"label\");\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x19c,\"params\",ptr);\n  if (iVar1 != 0) {\n    local_30 = FUN_00002d68(&DAT_00013d1b);\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x19d,\"kctx = get_kdfbyname(OSSL_KDF_NAME_HKDF)\",\n                         local_30);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_30,ptr);\n      iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0x19e,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        uVar2 = EVP_KDF_derive(local_30,local_1a,0,0);\n        iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x19f,\"EVP_KDF_derive(kctx, out, 0, NULL)\",\n                             &DAT_00013c2d,uVar2,0);\n        if (iVar1 != 0) {\n          uVar2 = 1;\n          goto LAB_00004818;\n        }\n      }\n    }\n  }\n  uVar2 = 0;\nLAB_00004818:\n  EVP_KDF_CTX_free(local_30);\n  CRYPTO_free(ptr);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_hkdf_zero_output_size"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                 undefined8 param_5,undefined8 param_6)\n\n{\n  FUN_0003ff98(param_1,param_2,param_3,param_4,param_5,param_6,1);\n  return;\n}\n\n",
        "output": "The predicted function name is rpl_posix_spawnp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](FILE *param_1,long param_2,long param_3,int param_4,long param_5)\n\n{\n  bool bVar1;\n  int iVar2;\n  tm *ptVar3;\n  ssize_t sVar4;\n  long in_FS_OFFSET;\n  undefined8 uVar5;\n  int local_10a0;\n  FILE *local_1098;\n  time_t local_1088;\n  long local_1080;\n  void *local_1078;\n  size_t local_1070;\n  tm local_1058;\n  undefined local_1018 [4104];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_10a0 = -1;\n  if ((param_2 != 0) && (0 < param_3)) {\n    local_1098 = param_1;\n    if (DAT_00253188 != (char *)0x0) {\n      iVar2 = strcmp(DAT_00253188,\"-\");\n      if (iVar2 == 0) {\n        local_1098 = stdout;\n      }\n      else {\n        local_1098 = (FILE *)0x0;\n        if (DAT_00253417 != '\\x01') {\n          local_10a0 = open(DAT_00253188,0x441,0x1a4);\n        }\n        if (local_10a0 == -1) {\n          local_1098 = param_1;\n        }\n      }\n    }\n    wget_buffer_init(&local_1078,local_1018,0x1000);\n    bVar1 = false;\n    if ((local_1098 != (FILE *)0x0) && (param_5 != 0)) {\n      iVar2 = fileno(local_1098);\n      iVar2 = isatty(iVar2);\n      if (iVar2 != 0) {\n        bVar1 = true;\n      }\n    }\n    if (bVar1) {\n      wget_buffer_strcpy(&local_1078,param_5);\n    }\n    if (param_4 != 0) {\n      FUN_0002882f(&local_1088);\n      uVar5 = 0x10889;\n      ptVar3 = localtime_r(&local_1088,&local_1058);\n      wget_buffer_printf_append\n                (&local_1078,\"%02d.%02d%02d%02d.%03d \",ptVar3->tm_mday,ptVar3->tm_hour,\n                 ptVar3->tm_min,ptVar3->tm_sec,local_1080 / 1000000 & 0xffffffff,uVar5);\n    }\n    wget_buffer_memcat(&local_1078,param_2,param_3);\n    if (*(char *)(param_2 + param_3 + -1) != '\\n') {\n      wget_buffer_memcat(&local_1078,&DAT_00041567,1);\n    }\n    if (bVar1) {\n      wget_buffer_strcat(&local_1078,&DAT_00041569);\n    }\n    if (local_1098 == (FILE *)0x0) {\n      if (local_10a0 != -1) {\n        sVar4 = write(local_10a0,local_1078,local_1070);\n        if (sVar4 == -1) {\n          fwrite(local_1078,1,local_1070,stderr);\n        }\n        close(local_10a0);\n      }\n    }\n    else {\n      fwrite(local_1078,1,local_1070,local_1098);\n    }\n    wget_buffer_deinit(&local_1078);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is write_out"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  wget_hashmap_iterator_next(param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is wget_stringmap_iterator_next"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Removing unreachable block (ram,0x00011ce3) */\n\nundefined4 [MASK](void)\n\n{\n  long lVar1;\n  int iVar2;\n  long lVar3;\n  long in_FS_OFFSET;\n  undefined4 local_60;\n  int local_5c;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  local_60 = 1;\n  local_5c = 0;\n  do {\n    iVar2 = wget_vector_size(DAT_00253c30);\n    if (iVar2 <= local_5c) {\nLAB_00011cda:\n      if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return local_60;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    lVar3 = wget_vector_get(DAT_00253c30,local_5c);\n    if ((*(long *)(lVar3 + 0x38) != 0) && (iVar2 = (**(code **)(lVar3 + 0x38))(lVar3), iVar2 == 0))\n    {\n      local_60 = 0;\n      goto LAB_00011cda;\n    }\n    local_5c = local_5c + 1;\n  } while( true );\n}\n\n",
        "output": "The predicted function name is plugin_db_forward_downloaded_file"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void *param_1)\n\n{\n  CRYPTO_free(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is fake_rsa_sig_freectx"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_000036d5(0x31,1,1);\n  return;\n}\n\n",
        "output": "The predicted function name is test_http_keep_alive_1_prefer_yes"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x18);\n}\n\n",
        "output": "The predicted function name is impl_file_get_size"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined * [MASK](void)\n\n{\n  return &DAT_002106e0;\n}\n\n",
        "output": "The predicted function name is ASN1_LONG_DATA_it"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long *param_1,long param_2)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  if ((param_2 != 0) && (*param_1 != 0)) {\n    lVar1 = *param_1;\n    uVar2 = gettext(\"Piling up error \\'%s\\' over error \\'%s\\'\");\n    wget_error_printf(uVar2,param_2,lVar1);\n  }\n  (*wget_free)(*param_1);\n  *param_1 = param_2;\n  return;\n}\n\n",
        "output": "The predicted function name is dl_error_set_noalloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ASN1_VALUE *param_1)\n\n{\n  ASN1_ITEM *it;\n  \n  it = (ASN1_ITEM *)FUN_00002f18();\n  ASN1_item_free(param_1,it);\n  return;\n}\n\n",
        "output": "The predicted function name is INVALIDTEMPLATE_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ASN1_VALUE *param_1,uchar **param_2)\n\n{\n  ASN1_ITEM *it;\n  \n  it = (ASN1_ITEM *)FUN_00002e02();\n  ASN1_item_i2d(param_1,param_2,it);\n  return;\n}\n\n",
        "output": "The predicted function name is i2d_ASN1_UINT64_DATA"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00003860(param_1,1,param_2,0);\n  return;\n}\n\n",
        "output": "The predicted function name is set_altname_email"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  FUN_00009d51(param_2,param_1 + 0x218);\n  return;\n}\n\n",
        "output": "The predicted function name is parse_test_enable_server_sctp_label_bug"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = 0;\n  local_30 = 0;\n  local_28 = 0;\n  local_20 = 0;\n  ptr = (void *)FUN_000076f4(\"sha256\",&DAT_00014269,&DAT_00219204,1,&DAT_00014265,&DAT_00014260);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x4ac,\"params\",ptr);\n  if (iVar1 == 0) {\n    uVar2 = 0;\n    goto LAB_0000806a;\n  }\n  uVar3 = FUN_00002d68(\"KBKDF\");\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x4b1,&DAT_000141f4,uVar3);\n  if (iVar1 == 0) {\nLAB_0000803b:\n    uVar2 = 0;\n  }\n  else {\n    iVar1 = EVP_KDF_CTX_set_params(uVar3,ptr);\n    iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0x4b2,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                         iVar1 != 0);\n    if (iVar1 == 0) goto LAB_0000803b;\n    uVar2 = EVP_KDF_derive(uVar3,&local_38,0,0);\n    iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x4b3,\"EVP_KDF_derive(kctx, result, 0, NULL)\",\n                         &DAT_00013c2d,uVar2,0);\n    if (iVar1 == 0) goto LAB_0000803b;\n    uVar2 = 1;\n  }\n  EVP_KDF_CTX_free(uVar3);\n  CRYPTO_free(ptr);\nLAB_0000806a:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_kbkdf_zero_output_size"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void *param_1)\n\n{\n  CRYPTO_free(param_1);\n  return 1;\n}\n\n",
        "output": "The predicted function name is fake_rsa_st_close"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined4 param_1)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined8 uVar3;\n  \n  puVar2 = (undefined4 *)FUN_00002b1c(param_1);\n  if (puVar2 != (undefined4 *)0x0) {\n    if (*(long *)(puVar2 + 2) == 0) {\n      uVar3 = EVP_CIPHER_meth_new(param_1,0x10,*puVar2);\n      *(undefined8 *)(puVar2 + 2) = uVar3;\n      if ((((*(long *)(puVar2 + 2) == 0) ||\n           (iVar1 = EVP_CIPHER_meth_set_iv_length(*(undefined8 *)(puVar2 + 2),0x10), iVar1 == 0)) ||\n          (iVar1 = EVP_CIPHER_meth_set_flags(*(undefined8 *)(puVar2 + 2),2), iVar1 == 0)) ||\n         (((iVar1 = EVP_CIPHER_meth_set_init(*(undefined8 *)(puVar2 + 2),FUN_00002773), iVar1 == 0\n           || (iVar1 = EVP_CIPHER_meth_set_do_cipher(*(undefined8 *)(puVar2 + 2),FUN_000028e5),\n              iVar1 == 0)) ||\n          ((iVar1 = EVP_CIPHER_meth_set_cleanup(*(undefined8 *)(puVar2 + 2),FUN_00002a8a),\n           iVar1 == 0 ||\n           (iVar1 = EVP_CIPHER_meth_set_impl_ctx_size(*(undefined8 *)(puVar2 + 2),0x80), iVar1 == 0)\n           ))))) {\n        EVP_CIPHER_meth_free(*(undefined8 *)(puVar2 + 2));\n        *(undefined8 *)(puVar2 + 2) = 0;\n      }\n    }\n    return *(undefined8 *)(puVar2 + 2);\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is afalg_aes_cbc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](int param_1)\n\n{\n  undefined8 uVar1;\n  \n  if ((((param_1 == 0x20) || (param_1 == 9)) || (param_1 == 0xd)) || (param_1 == 0xc)) {\n    uVar1 = 1;\n  }\n  else {\n    uVar1 = 0;\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is isws"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined4 param_1)\n\n{\n  wget_bar_set_slots(DAT_00253bd8,param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is bar_update_slots"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](long param_1)\n\n{\n  char *__s;\n  char *pcVar1;\n  \n  if (*(long *)(param_1 + 0x30) == 0) {\n    __s = (char *)0x0;\n  }\n  else {\n    __s = (char *)FUN_00002b0e(param_1,*(undefined8 *)(param_1 + 0x30),0);\n    pcVar1 = strchr(__s,10);\n    if (pcVar1 != (char *)0x0) {\n      *pcVar1 = '\\0';\n    }\n  }\n  return __s;\n}\n\n",
        "output": "The predicted function name is outline_descr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 * [MASK](undefined4 *param_1)\n\n{\n  memset(param_1,0,0x20);\n  *param_1 = 0;\n  return param_1;\n}\n\n",
        "output": "The predicted function name is make_null_string"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](undefined8 param_1)\n\n{\n  undefined8 *puVar1;\n  bool bVar2;\n  int iVar3;\n  int *piVar4;\n  char *pcVar5;\n  long in_FS_OFFSET;\n  undefined4 local_40;\n  int local_3c;\n  undefined4 local_38;\n  ulong local_28;\n  undefined8 local_20;\n  undefined8 *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = 0;\n  bVar2 = false;\n  reset_internal_getopt();\nLAB_000013cc:\n  do {\n    iVar3 = internal_getopt(param_1,&DAT_00001645);\n    if (iVar3 == -1) {\n      puVar1 = *(undefined8 **)PTR_loptend_00201fe8;\n      if ((puVar1 == (undefined8 *)0x0) && (bVar2)) {\n        local_40 = 0;\n      }\n      else if (puVar1 == (undefined8 *)0x0) {\n        iVar3 = FUN_000012d6();\n        if (iVar3 < 0) {\n          piVar4 = __errno_location();\n          pcVar5 = strerror(*piVar4);\n          builtin_error(\"can\\'t get max fd: %s\",pcVar5);\n          local_40 = 1;\n        }\n        else {\n          for (local_3c = 0; local_3c < iVar3; local_3c = local_3c + 1) {\n            FUN_00000ed3(local_3c,0,local_38);\n          }\n          local_40 = 0;\n        }\n      }\n      else {\n        local_40 = 0;\n        for (local_18 = puVar1; local_18 != (undefined8 *)0x0; local_18 = (undefined8 *)*local_18) {\n          iVar3 = legal_number(*(undefined8 *)local_18[1],&local_28);\n          if ((iVar3 == 0) || ((long)local_28 < 0)) {\n            builtin_error(\"%s: invalid file descriptor\",*(undefined8 *)local_18[1]);\n            local_40 = 1;\n          }\n          else if (bVar2) {\n            FUN_0000115f(local_28 & 0xffffffff,local_20,local_38);\n          }\n          else {\n            FUN_00000ed3(local_28 & 0xffffffff,1,local_38);\n          }\n        }\n      }\nLAB_00001535:\n      if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return local_40;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    if (iVar3 != 0x73) {\n      if (iVar3 != 0x76) {\n        if (iVar3 == -99) {\n          builtin_help();\n          local_40 = 0x102;\n        }\n        else {\n          builtin_usage();\n          local_40 = 0x102;\n        }\n        goto LAB_00001535;\n      }\n      local_38 = 1;\n      goto LAB_000013cc;\n    }\n    bVar2 = true;\n    local_20 = *(undefined8 *)PTR_list_optarg_00201fe0;\n  } while( true );\n}\n\n",
        "output": "The predicted function name is fdflags_builtin"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](undefined8 param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  long in_FS_OFFSET;\n  undefined8 local_58;\n  char *local_50;\n  void *local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  void *local_30;\n  undefined8 local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_50 = (char *)0x0;\n  iVar1 = FUN_0000268a(param_1);\n  if (iVar1 == 0) {\n    mu_sieve_get_arg(param_1,0,2,&local_58);\n    local_38 = mu_sieve_get_message(param_1);\n    mu_message_get_header(local_38,&local_40);\n    iVar1 = mu_sieve_get_tag(param_1,\"sender\",2,&local_50);\n    if (iVar1 == 0) {\n      iVar1 = mu_sieve_get_message_sender(local_38,&local_50);\n      if (iVar1 != 0) {\n        uVar2 = mu_strerror(iVar1);\n        uVar3 = mu_sieve_get_message_num(param_1);\n        uVar4 = dgettext(\"mailutils\",\"%lu: cannot get sender address: %s\");\n        mu_sieve_error(param_1,uVar4,uVar3,uVar2);\n        mu_sieve_abort(param_1);\n      }\n    }\n    else {\n      local_50 = strdup(local_50);\n      if (local_50 == (char *)0x0) {\n        uVar2 = mu_strerror(0xc);\n        uVar3 = mu_sieve_get_message_num(param_1);\n        mu_sieve_error(param_1,\"%lu: %s\",uVar3,uVar2);\n        mu_sieve_abort(param_1);\n      }\n    }\n    local_30 = (void *)mu_get_user_email(0);\n    iVar1 = mu_sieve_get_tag(param_1,\"always_reply\",0,0);\n    if (iVar1 == 0) {\n      local_28 = mu_sieve_get_tag_untyped(param_1,\"aliases\");\n      iVar1 = FUN_00002709(param_1,local_40,local_30,local_28,&local_48);\n      if (iVar1 == 0) {\n        free(local_30);\n        iVar1 = 0;\n        goto LAB_00004076;\n      }\n    }\n    else {\n      local_48 = local_30;\n    }\n    iVar1 = FUN_00002977(param_1,local_50);\n    if (((iVar1 == 0) && (iVar1 = FUN_00002a65(local_40), iVar1 == 0)) &&\n       (iVar1 = FUN_00002d2f(param_1,local_50), iVar1 == 0)) {\n      mu_sieve_get_tag(param_1,\"return_address\",2,&local_48);\n      iVar1 = FUN_0000372c(param_1,local_38,local_58,local_50,local_48);\n      free(local_50);\n      free(local_30);\n      if (iVar1 == -1) {\n        mu_sieve_abort(param_1);\n      }\n    }\n    else {\n      free(local_50);\n      free(local_30);\n      iVar1 = 0;\n    }\n  }\n  else {\n    iVar1 = 0;\n  }\nLAB_00004076:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is sieve_action_vacation"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  code *pcVar1;\n  __pid_t _Var2;\n  int *piVar3;\n  \n  _Var2 = wait((void *)0x0);\n  if (_Var2 < 0) {\n    pcVar1 = *(code **)(DAT_00202178 + 0x80);\n    piVar3 = __errno_location();\n    (*pcVar1)(DAT_00202180,*piVar3);\n  }\n  FUN_00000c70((double)_Var2,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is do_wait"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ASN1_VALUE **param_1,uchar **param_2,long param_3)\n\n{\n  ASN1_ITEM *it;\n  \n  it = (ASN1_ITEM *)FUN_00002e02();\n  ASN1_item_d2i(param_1,param_2,param_3,it);\n  return;\n}\n\n",
        "output": "The predicted function name is d2i_ASN1_UINT64_DATA"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,long param_2)\n\n{\n  FUN_0000c6ad(\"Server signing\",*(undefined4 *)(param_2 + 0x1e8),*(undefined4 *)(param_1 + 0x6c));\n  return;\n}\n\n",
        "output": "The predicted function name is check_server_sign_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nushort [MASK](ushort *param_1,int param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  int local_44;\n  ushort *local_28;\n  \n  uVar1 = 0;\n  local_28 = param_1;\n  for (local_44 = param_2; 1 < local_44; local_44 = local_44 + -2) {\n    uVar1 = uVar1 + *local_28;\n    local_28 = local_28 + 1;\n  }\n  if (local_44 == 1) {\n    uVar1 = uVar1 + *(byte *)local_28;\n  }\n  iVar2 = ((int)uVar1 >> 0x10) + (uVar1 & 0xffff);\n  if (*(long *)(in_FS_OFFSET + 0x28) != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return ~((short)iVar2 + (short)((uint)iVar2 >> 0x10));\n}\n\n",
        "output": "The predicted function name is icmp_cksum"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  FUN_00009d51(param_2,param_1 + 0x18);\n  return;\n}\n\n",
        "output": "The predicted function name is parse_server_broken_session_ticket"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8\n[MASK](ulong *param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,uint param_5,\n            ulong *param_6)\n\n{\n  undefined8 uVar1;\n  long in_FS_OFFSET;\n  uint local_3c;\n  ulong local_38;\n  ulong local_30;\n  ulong local_28;\n  ulong local_20;\n  ulong local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_28 = FUN_0000394a(&local_38,param_3,param_4,param_1,param_2,param_6);\n  local_30 = local_38;\n  if ((local_28 == *param_6) && (local_38 == param_6[1])) {\n    uVar1 = 1;\n  }\n  else {\n    local_18 = *param_1 - *param_6;\n    local_20 = (param_1[1] - param_6[1]) - (ulong)(*param_1 < *param_6);\n    if ((local_28 == local_18) && (local_38 == local_20)) {\n      uVar1 = 1;\n    }\n    else {\n      for (local_3c = 1; local_3c < param_5; local_3c = local_3c + 1) {\n        local_28 = FUN_00003660(&local_38,local_38,local_28,local_38,local_28,param_1[1],*param_1,\n                                param_2);\n        local_30 = local_38;\n        if ((local_28 == local_18) && (local_38 == local_20)) {\n          uVar1 = 1;\n          goto LAB_00003d60;\n        }\n        if ((local_28 == *param_6) && (local_38 == param_6[1])) {\n          uVar1 = 0;\n          goto LAB_00003d60;\n        }\n      }\n      uVar1 = 0;\n      local_30 = local_38;\n    }\n  }\nLAB_00003d60:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is millerrabin2"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](undefined8 param_1,undefined4 param_2,int param_3,void *param_4,int param_5,\n                undefined8 param_6)\n\n{\n  int iVar1;\n  void **ppvVar2;\n  void *__dest;\n  EVP_CIPHER *pEVar3;\n  code *pcVar4;\n  uint local_30;\n  \n  ppvVar2 = (void **)EVP_CIPHER_CTX_get_cipher_data(param_1);\n  if (ppvVar2 == (void **)0x0) {\n    return 0;\n  }\n  switch(param_2) {\n  case 8:\n    iVar1 = EVP_CIPHER_impl_ctx_size(param_6);\n    __dest = CRYPTO_malloc(iVar1,\"engines/e_dasync.c\",599);\n    if (__dest == (void *)0x0) {\n      return -1;\n    }\n    memcpy(__dest,*ppvVar2,(long)iVar1);\n    *ppvVar2 = __dest;\n    break;\n  default:\n    return 0;\n  case 0x16:\n    if ((param_5 == 0) || (param_3 != 0xd)) {\n      return -1;\n    }\n    if (0x1f < *(uint *)(ppvVar2 + 0x39)) {\n      return -1;\n    }\n    memcpy((void *)((long)ppvVar2 + (ulong)*(uint *)(ppvVar2 + 0x39) * 0xd + 0x28),param_4,0xd);\n    *(int *)(ppvVar2 + 0x39) = *(int *)(ppvVar2 + 0x39) + 1;\n    local_30 = (uint)CONCAT11(*(undefined *)((long)param_4 + 0xb),\n                              *(undefined *)((long)param_4 + 0xc));\n    iVar1 = EVP_CIPHER_CTX_is_encrypting(param_1);\n    if (iVar1 != 0) {\n      if (0x301 < CONCAT11(*(undefined *)((long)param_4 + 9),*(undefined *)((long)param_4 + 10))) {\n        if (local_30 < 0x10) {\n          return 0;\n        }\n        local_30 = local_30 - 0x10;\n      }\n      return (local_30 + 0x24 & 0xfffffff0) - local_30;\n    }\n    return 0x14;\n  case 0x17:\n    if (param_5 == 0) {\n      return -1;\n    }\n    EVP_CIPHER_CTX_set_cipher_data(param_1,*ppvVar2);\n    pEVar3 = EVP_aes_128_cbc_hmac_sha1();\n    pcVar4 = (code *)EVP_CIPHER_meth_get_ctrl(pEVar3);\n    iVar1 = (*pcVar4)(param_1,param_2,param_3,param_4);\n    EVP_CIPHER_CTX_set_cipher_data(param_1,ppvVar2);\n    return iVar1;\n  case 0x22:\n    *(int *)(ppvVar2 + 1) = param_3;\n    ppvVar2[3] = param_4;\n    break;\n  case 0x23:\n    *(int *)(ppvVar2 + 1) = param_3;\n    ppvVar2[2] = param_4;\n    break;\n  case 0x24:\n    *(int *)(ppvVar2 + 1) = param_3;\n    ppvVar2[4] = param_4;\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is dasync_cipher_ctrl_helper"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SSL **param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = FUN_00012c68(\"test/helpers/handshake.c\",0x413,\"peer->status\",\"PEER_RETRY\",\n                       *(undefined4 *)((long)param_1 + 0x2c),1);\n  if (iVar1 == 0) {\n    *(undefined4 *)((long)param_1 + 0x2c) = 4;\n  }\n  else {\n    iVar1 = SSL_shutdown(*param_1);\n    if (iVar1 == 1) {\n      *(undefined4 *)((long)param_1 + 0x2c) = 0;\n    }\n    else if (iVar1 < 0) {\n      iVar1 = SSL_get_error(*param_1,iVar1);\n      if ((iVar1 != 2) && (iVar1 != 3)) {\n        *(undefined4 *)((long)param_1 + 0x2c) = 2;\n      }\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is do_shutdown_step"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](long param_1)\n\n{\n  *(undefined8 *)(param_1 + 0x30) = 0xffffffffffffffff;\n  return param_1;\n}\n\n",
        "output": "The predicted function name is cache_stat_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 *param_1)\n\n{\n  *param_1 = 0;\n  param_1[1] = 0;\n  param_1[2] = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is mp_factor_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8\n[MASK](undefined8 param_1,undefined8 param_2,long param_3,int param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  char *local_38;\n  void *local_30;\n  ulong local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = mu_property_sget_value(param_1,param_2,&local_38);\n  if (iVar1 == 0) {\n    if (param_4 == 0) {\n      uVar2 = 1;\n      goto LAB_00002d14;\n    }\n    local_28 = strtoul(local_38,(char **)0x0,0);\n    if (param_3 < (long)(local_28 + (uint)(param_4 * 0x15180))) {\n      uVar2 = 1;\n      goto LAB_00002d14;\n    }\n  }\n  else if (iVar1 != 0x1029) {\n    uVar2 = mu_strerror(iVar1);\n    uVar3 = mu_sieve_get_message_num(param_5);\n    mu_sieve_error(param_5,\"%lu: mu_property_sget_value: %s\",uVar3,uVar2);\n    uVar2 = 0xffffffff;\n    goto LAB_00002d14;\n  }\n  iVar1 = mu_asprintf(&local_30,&DAT_00004280,param_3);\n  if (iVar1 == 0) {\n    iVar1 = mu_property_set_value(param_1,param_2,local_30,1);\n    free(local_30);\n    if (iVar1 == 0) {\n      iVar1 = mu_property_save(param_1);\n      if (iVar1 == 0) {\n        uVar2 = 0;\n      }\n      else {\n        uVar2 = mu_strerror(iVar1);\n        uVar3 = mu_sieve_get_message_num(param_5);\n        mu_sieve_error(param_5,\"%lu: mu_property_save: %s\",uVar3,uVar2);\n        uVar2 = 0xffffffff;\n      }\n    }\n    else {\n      uVar2 = mu_strerror(iVar1);\n      uVar3 = mu_sieve_get_message_num(param_5);\n      mu_sieve_error(param_5,\"%lu: mu_property_set_value: %s\",uVar3,uVar2);\n      uVar2 = 0xffffffff;\n    }\n  }\n  else {\n    uVar2 = mu_strerror(iVar1);\n    uVar3 = mu_sieve_get_message_num(param_5);\n    mu_sieve_error(param_5,\"%lu: mu_asprintf: %s\",uVar3,uVar2);\n    uVar2 = 0xffffffff;\n  }\nLAB_00002d14:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_and_update_prop"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,ulong param_2)\n\n{\n  undefined *puVar1;\n  void *__src;\n  size_t __n;\n  long in_FS_OFFSET;\n  ulong local_40;\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  __src = (void *)FUN_000078a0(param_1,local_28);\n  __n = 0x14 - ((long)__src - (long)local_28);\n  for (local_40 = __n; local_40 < param_2; local_40 = local_40 + 1) {\n    puVar1 = DAT_00215128 + 1;\n    *DAT_00215128 = 0x30;\n    DAT_00215128 = puVar1;\n  }\n  memcpy(DAT_00215128,__src,__n);\n  DAT_00215128 = DAT_00215128 + __n;\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is lbuf_putint"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  FUN_00009f56(param_1 + 0x1b0,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is parse_server_alert"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  fwrite(\"No memory\\n\",1,10,stderr);\n                    /* WARNING: Subroutine does not return */\n  exit(1);\n}\n\n",
        "output": "The predicted function name is no_memory"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  undefined8 uVar4;\n  char *pcVar5;\n  char *pcVar6;\n  undefined *puVar7;\n  int local_28;\n  ulong local_20;\n  long local_18;\n  \n  puVar1 = *(undefined8 **)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  local_28 = 0;\n  if (puVar1[3] == 0) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"NO_KEY\";\n    uVar4 = 0;\n  }\n  else {\n    if (((puVar1[6] == 0) && (iVar2 = EVP_CIPHER_get_iv_length(*puVar1), iVar2 != 0)) &&\n       (iVar2 = EVP_CIPHER_get_mode(*puVar1), iVar2 != 0x10002)) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"NO_IV\";\n      return 0;\n    }\n    if (((*(int *)((long)puVar1 + 0x14) == 0) || (puVar1[0x17] != 0)) ||\n       (*(int *)(puVar1 + 0x16) != 0)) {\n      local_20 = 0;\n      while (local_20 < 2) {\n        *(undefined **)(\"EVP_CIPHER_CTX_set_flags\" + param_1 + 1) = &DAT_002241c0;\n        for (local_18 = -1; local_18 != 2; local_18 = local_18 + 1) {\n          if (local_18 == -1) {\n            if (local_28 == 0) {\n              puVar7 = &DAT_0001cc92;\n            }\n            else {\n              puVar7 = &DAT_0001cc91;\n            }\n            if (local_20 == 0) {\n              pcVar5 = \"aligned\";\n            }\n            else {\n              pcVar5 = \"misaligned\";\n            }\n            BIO_snprintf(&DAT_002241c0,0x40,\"%s in-place, %sfragmented\",pcVar5,puVar7);\n          }\n          else {\n            if (local_28 == 0) {\n              puVar7 = &DAT_0001cc92;\n            }\n            else {\n              puVar7 = &DAT_0001cc91;\n            }\n            if (local_18 == 0) {\n              pcVar5 = \"aligned\";\n            }\n            else {\n              pcVar5 = \"misaligned\";\n            }\n            if (local_20 == 0) {\n              pcVar6 = \"aligned\";\n            }\n            else {\n              pcVar6 = \"misaligned\";\n            }\n            BIO_snprintf(&DAT_002241c0,0x40,\"%s output and %s input, %sfragmented\",pcVar6,pcVar5,\n                         puVar7);\n          }\n          if ((*(int *)(puVar1 + 2) != 0) &&\n             (iVar2 = FUN_00007ac2(param_1,1,local_20,local_18,local_28), iVar2 != 1)) {\n            if (iVar2 < 0) {\n              return 0;\n            }\n            return 1;\n          }\n          if ((*(int *)(puVar1 + 2) != 1) &&\n             (iVar2 = FUN_00007ac2(param_1,0,local_20,local_18,local_28), iVar2 != 1)) {\n            if (iVar2 < 0) {\n              return 0;\n            }\n            return 1;\n          }\n        }\n        if ((local_20 == 1) && (local_28 == 0)) {\n          if ((((*(int *)((long)puVar1 + 0x14) == 7) || (*(int *)((long)puVar1 + 0x14) == 2)) ||\n              ((*(int *)((long)puVar1 + 0x14) == -1 &&\n               (iVar2 = EVP_CIPHER_get_mode(*puVar1), iVar2 == 0)))) ||\n             ((((uVar3 = EVP_CIPHER_get_flags(*puVar1), (uVar3 & 0x4000) != 0 ||\n                (iVar2 = EVP_CIPHER_get_mode(*puVar1), iVar2 == 0x10004)) ||\n               (iVar2 = EVP_CIPHER_get_mode(*puVar1), iVar2 == 0x10001)) ||\n              (iVar2 = EVP_CIPHER_get_mode(*puVar1), iVar2 == 0x10002)))) break;\n          local_20 = 0;\n          local_28 = 1;\n        }\n        else {\n          local_20 = local_20 + 1;\n        }\n      }\n      *(undefined8 *)(\"EVP_CIPHER_CTX_set_flags\" + param_1 + 1) = 0;\n      uVar4 = 1;\n    }\n    else {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"NO_TAG\";\n      uVar4 = 0;\n    }\n  }\n  return uVar4;\n}\n\n",
        "output": "The predicted function name is cipher_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void *param_1,ulong param_2)\n\n{\n  size_t __size;\n  void *pvVar1;\n  \n  pvVar1 = DAT_00215a50;\n  __size = DAT_00215a58;\n  if (DAT_00215a58 - DAT_00215a60 < param_2) {\n    __size = DAT_00215a58 * 2;\n    pvVar1 = realloc(DAT_00215a50,__size);\n    if (pvVar1 == (void *)0x0) {\n      FUN_0000c95a(\"text_add\");\n    }\n  }\n  DAT_00215a58 = __size;\n  DAT_00215a50 = pvVar1;\n  memcpy((void *)((long)DAT_00215a50 + DAT_00215a60),param_1,param_2);\n  DAT_00215a60 = param_2 + DAT_00215a60;\n  return;\n}\n\n",
        "output": "The predicted function name is text_add_str"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char param_1)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  int iVar3;\n  ulong uVar4;\n  char *local_20;\n  \n  pcVar1 = DAT_00215128 + 1;\n  *DAT_00215128 = param_1;\n  DAT_00215128 = pcVar1;\n  if (param_1 == '\\n') {\n    uVar4 = (long)DAT_00215128 - (long)DAT_00215120;\n    if (DAT_00215014 == -1) {\n      iVar3 = isatty(0);\n      if ((iVar3 == 0) && (iVar3 = isatty(1), iVar3 == 0)) {\n        DAT_00215014 = 0;\n      }\n      else {\n        DAT_00215014 = 1;\n      }\n    }\n    pcVar1 = DAT_00215128;\n    if (DAT_00215014 == 0) {\n      if (0x1ff < uVar4) {\n        pcVar2 = (char *)((long)DAT_00215120 + 0x200);\n        do {\n          local_20 = pcVar2;\n          pcVar2 = local_20 + -1;\n        } while (local_20[-1] != '\\n');\n        DAT_00215128 = local_20;\n        FUN_00006c91();\n        memcpy(DAT_00215120,local_20,(long)pcVar1 - (long)local_20);\n        DAT_00215128 = (char *)((long)DAT_00215120 + ((long)pcVar1 - (long)local_20));\n      }\n    }\n    else {\n      FUN_00006c91();\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is lbuf_putc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void *param_1)\n\n{\n  CRYPTO_free(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is openssl_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,char *param_2)\n\n{\n  char *pcVar1;\n  \n  CRYPTO_free(*(void **)(param_1 + 0x18));\n  pcVar1 = CRYPTO_strdup(param_2,\"test/helpers/ssl_test_ctx.c\",0x162);\n  *(char **)(param_1 + 0x18) = pcVar1;\n  FUN_000146a7(\"test/helpers/ssl_test_ctx.c\",0x162,\"ctx->alpn_protocols\",\n               *(undefined8 *)(param_1 + 0x18));\n  return;\n}\n\n",
        "output": "The predicted function name is parse_client_alpn_protocols"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 [MASK](void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = CRYPTO_zalloc(1,\"test/fake_rsaprov.c\",0x21);\n  FUN_0000879a(\"test/fake_rsaprov.c\",0x23,\"keydata\",uVar1);\n  _DAT_002130c4 = 0;\n  _DAT_002130c8 = 0;\n  _DAT_002130cc = 0;\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is fake_rsa_keymgmt_new"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ASN1_VALUE *param_1,uchar **param_2)\n\n{\n  ASN1_ITEM *it;\n  \n  it = (ASN1_ITEM *)FUN_00002f18();\n  ASN1_item_i2d(param_1,param_2,it);\n  return;\n}\n\n",
        "output": "The predicted function name is i2d_INVALIDTEMPLATE"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2,char *param_3)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  undefined8 local_d8;\n  undefined8 local_d0;\n  undefined8 local_c8;\n  undefined8 local_c0;\n  undefined8 local_b8;\n  char *local_a0;\n  char *local_98;\n  long local_90;\n  int local_84;\n  char *local_80;\n  ulong local_78;\n  undefined8 *local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_70 = *(undefined8 **)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  local_84 = 0;\n  local_a0 = param_3;\n  local_98 = param_2;\n  local_90 = param_1;\n  iVar1 = strcmp(param_2,\"PeerKeyValidate\");\n  if (iVar1 == 0) {\n    local_84 = 1;\n  }\n  if (local_84 == 0) {\n    iVar1 = strcmp(local_98,\"PeerKey\");\n    if (iVar1 != 0) {\n      iVar1 = strcmp(local_98,\"SharedSecret\");\n      if (iVar1 == 0) {\n        uVar2 = FUN_000066e2(local_a0,local_70 + 4,local_70 + 5);\n      }\n      else {\n        iVar1 = strcmp(local_98,\"Ctrl\");\n        if (iVar1 == 0) {\n          uVar2 = FUN_0000b5de(local_90,*local_70,local_a0);\n        }\n        else {\n          iVar1 = strcmp(local_98,\"KDFType\");\n          if (iVar1 == 0) {\n            OSSL_PARAM_construct_utf8_string(&local_d8,\"kdf-type\",local_a0,0);\n            local_68 = local_d8;\n            local_60 = local_d0;\n            local_58 = local_c8;\n            local_50 = local_c0;\n            local_48 = local_b8;\n            OSSL_PARAM_construct_end(&local_d8);\n            local_40 = local_d8;\n            local_38 = local_d0;\n            local_30 = local_c8;\n            local_28 = local_c0;\n            local_20 = local_b8;\n            iVar1 = EVP_PKEY_CTX_set_params(*local_70,&local_68);\n            if (iVar1 == 0) {\n              uVar2 = 0xffffffff;\n            }\n            else {\n              uVar2 = 1;\n            }\n          }\n          else {\n            iVar1 = strcmp(local_98,\"KDFDigest\");\n            if (iVar1 == 0) {\n              OSSL_PARAM_construct_utf8_string(&local_d8,\"kdf-digest\",local_a0,0);\n              local_68 = local_d8;\n              local_60 = local_d0;\n              local_58 = local_c8;\n              local_50 = local_c0;\n              local_48 = local_b8;\n              OSSL_PARAM_construct_end(&local_d8);\n              local_40 = local_d8;\n              local_38 = local_d0;\n              local_30 = local_c8;\n              local_28 = local_c0;\n              local_20 = local_b8;\n              iVar1 = EVP_PKEY_CTX_set_params(*local_70,&local_68);\n              if (iVar1 == 0) {\n                uVar2 = 0xffffffff;\n              }\n              else {\n                uVar2 = 1;\n              }\n            }\n            else {\n              iVar1 = strcmp(local_98,\"CEKAlg\");\n              if (iVar1 == 0) {\n                OSSL_PARAM_construct_utf8_string(&local_d8,\"cekalg\",local_a0,0);\n                local_68 = local_d8;\n                local_60 = local_d0;\n                local_58 = local_c8;\n                local_50 = local_c0;\n                local_48 = local_b8;\n                OSSL_PARAM_construct_end(&local_d8);\n                local_40 = local_d8;\n                local_38 = local_d0;\n                local_30 = local_c8;\n                local_28 = local_c0;\n                local_20 = local_b8;\n                iVar1 = EVP_PKEY_CTX_set_params(*local_70,&local_68);\n                if (iVar1 == 0) {\n                  uVar2 = 0xffffffff;\n                }\n                else {\n                  uVar2 = 1;\n                }\n              }\n              else {\n                iVar1 = strcmp(local_98,\"KDFOutlen\");\n                if (iVar1 == 0) {\n                  local_78 = strtoul(local_a0,&local_80,0);\n                  if (*local_80 == '\\0') {\n                    OSSL_PARAM_construct_size_t(&local_d8,\"kdf-outlen\",&local_78);\n                    local_68 = local_d8;\n                    local_60 = local_d0;\n                    local_58 = local_c8;\n                    local_50 = local_c0;\n                    local_48 = local_b8;\n                    OSSL_PARAM_construct_end(&local_d8);\n                    local_40 = local_d8;\n                    local_38 = local_d0;\n                    local_30 = local_c8;\n                    local_28 = local_c0;\n                    local_20 = local_b8;\n                    iVar1 = EVP_PKEY_CTX_set_params(*local_70,&local_68);\n                    if (iVar1 == 0) {\n                      uVar2 = 0xffffffff;\n                    }\n                    else {\n                      uVar2 = 1;\n                    }\n                  }\n                  else {\n                    uVar2 = 0xffffffff;\n                  }\n                }\n                else {\n                  uVar2 = 0;\n                }\n              }\n            }\n          }\n        }\n      }\n      goto LAB_0000c1fb;\n    }\n  }\n  iVar1 = FUN_00010ea5(&local_78,local_a0,DAT_002241b8);\n  if (iVar1 == 0) {\n    uVar2 = 0xffffffff;\n  }\n  else {\n    iVar1 = EVP_PKEY_derive_set_peer_ex(*local_70,local_78,local_84);\n    if (iVar1 < 1) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + local_90 + 0x17) = \"DERIVE_SET_PEER_ERROR\";\n      uVar2 = 1;\n    }\n    else {\n      *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + local_90 + 0x17) = 0;\n      uVar2 = 1;\n    }\n  }\nLAB_0000c1fb:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is pderive_test_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  long lVar1;\n  int local_14;\n  \n  lVar1 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  CRYPTO_free(*(void **)(lVar1 + 0x18));\n  CRYPTO_free(*(void **)(lVar1 + 0x30));\n  CRYPTO_free(*(void **)(lVar1 + 0x38));\n  CRYPTO_free(*(void **)(lVar1 + 0x60));\n  CRYPTO_free(*(void **)(lVar1 + 0x50));\n  for (local_14 = 0; local_14 < 4; local_14 = local_14 + 1) {\n    CRYPTO_free(*(void **)(lVar1 + ((long)local_14 + 0xe) * 8));\n  }\n  CRYPTO_free(*(void **)(lVar1 + 0xb8));\n  CRYPTO_free(*(void **)(lVar1 + 0xd8));\n  EVP_CIPHER_free(*(undefined8 *)(lVar1 + 8));\n  return;\n}\n\n",
        "output": "The predicted function name is cipher_test_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](FILE **param_1,FILE *param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  FILE **ppFVar4;\n  undefined4 uVar5;\n  \n  piVar3 = __errno_location();\n  iVar1 = *piVar3;\n  gcide_markup_yy_flush_buffer(param_1);\n  *param_1 = param_2;\n  *(undefined4 *)((long)param_1 + 0x3c) = 1;\n  if (DAT_00215a00 == 0) {\n    ppFVar4 = (FILE **)0x0;\n  }\n  else {\n    ppFVar4 = *(FILE ***)(DAT_00215a00 + DAT_002159f0 * 8);\n  }\n  if (ppFVar4 != param_1) {\n    *(undefined4 *)((long)param_1 + 0x34) = 1;\n    *(undefined4 *)(param_1 + 7) = 0;\n  }\n  if (param_2 != (FILE *)0x0) {\n    iVar2 = fileno(param_2);\n    iVar2 = isatty(iVar2);\n    if (0 < iVar2) {\n      uVar5 = 1;\n      goto LAB_0000e78a;\n    }\n  }\n  uVar5 = 0;\nLAB_0000e78a:\n  *(undefined4 *)((long)param_1 + 0x2c) = uVar5;\n  piVar3 = __errno_location();\n  *piVar3 = iVar1;\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yy_init_buffer"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](int param_1,long param_2)\n\n{\n  int local_c;\n  \n  if (0x613cf < param_1) {\n    puts(\"Unknown AS number. Please upgrade this program.\");\n  }\n  local_c = 0;\n  while( true ) {\n    if (*(long *)(param_2 + (long)local_c * 0x10 + 8) == 0) {\n      return \"whois.arin.net\";\n    }\n    if (((int)(uint)*(ushort *)(param_2 + (long)local_c * 0x10) <= param_1) &&\n       (param_1 <= (int)(uint)*(ushort *)(param_2 + (long)local_c * 0x10 + 2))) break;\n    local_c = local_c + 1;\n  }\n  return *(char **)(param_2 + (long)local_c * 0x10 + 8);\n}\n\n",
        "output": "The predicted function name is whereas"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](char *param_1)\n\n{\n  int iVar1;\n  undefined **local_10;\n  \n  local_10 = &PTR_s_set_CN__host_____example_com__ma_00212740;\n  while( true ) {\n    if (*local_10 == (char *)0x0) {\n      return 0;\n    }\n    iVar1 = strcmp(param_1,*local_10);\n    if (iVar1 == 0) break;\n    local_10 = local_10 + 1;\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is is_exception"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long *param_1,char *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  long lVar2;\n  bool bVar3;\n  \n  if (param_2 == (char *)0x0) {\n    bVar3 = false;\n  }\n  else {\n    iVar1 = strcmp(param_2,\"empty\");\n    if (iVar1 == 0) {\n      lVar2 = OPENSSL_sk_new_null();\n      *param_1 = lVar2;\n    }\n    else {\n      lVar2 = SSL_load_client_CA_file_ex(param_2,param_3,0);\n      *param_1 = lVar2;\n    }\n    bVar3 = *param_1 != 0;\n  }\n  return bVar3;\n}\n\n",
        "output": "The predicted function name is parse_expected_ca_names"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  int __ecode;\n  char *pcVar1;\n  int *piVar2;\n  long in_FS_OFFSET;\n  addrinfo *local_78;\n  char *local_70;\n  char *local_68;\n  undefined1 *local_60;\n  addrinfo local_58;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((DAT_0020f348 != (char *)0x0) && (*DAT_0020f348 != '\\0')) {\n    memset(&local_58,0,0x30);\n    local_58.ai_family = 2;\n    local_58.ai_socktype = 2;\n    memset(&DAT_0020f400,0,0x28);\n    local_60 = &DAT_0020f400;\n    local_70 = DAT_0020f348;\n    DAT_0020f400 = 0x83;\n    DAT_0020f401 = 3;\n    DAT_0020f402 = 4;\n    while (((local_70 != (char *)0x0 && (*local_70 != '\\0')) && ((char)local_60[2] < '$'))) {\n      pcVar1 = strpbrk(local_70,\" ,;:\");\n      local_68 = pcVar1;\n      if (pcVar1 != (char *)0x0) {\n        local_68 = pcVar1 + 1;\n        *pcVar1 = '\\0';\n      }\n      __ecode = getaddrinfo(local_70,(char *)0x0,&local_58,&local_78);\n      if (__ecode != 0) {\n        pcVar1 = gai_strerror(__ecode);\n        piVar2 = __errno_location();\n        error(1,*piVar2,\"gateway `%s\\' %s\",local_70,pcVar1);\n      }\n      *(undefined4 *)(local_60 + (char)local_60[1]) =\n           *(undefined4 *)(local_78->ai_addr->sa_data + 2);\n      freeaddrinfo(local_78);\n      local_60[1] = local_60[1] + '\\x04';\n      local_70 = local_68;\n    }\n    if ((local_70 != (char *)0x0) && (*local_70 != '\\0')) {\n      error(1,0,\"too many gateways specified\");\n    }\n    *(undefined4 *)(local_60 + (char)local_60[1]) = *(undefined4 *)(param_1 + 4);\n    local_60[1] = local_60[1] + '\\x04';\n    DAT_0020f338 = (long)((char)local_60[1] + 1);\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is trace_ip_opts"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  long in_FS_OFFSET;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_28 = param_2;\n  local_20 = param_3;\n  FUN_0000efba(*(undefined8 *)(param_1 + 0x10),&local_28);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_parse_tree_inorder"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined8 uVar3;\n  code *pcVar4;\n  \n  wget_console_init();\n  if (DAT_0025340e == '\\0') {\n    pcVar4 = (code *)0x0;\n  }\n  else {\n    pcVar4 = FUN_00010afd;\n  }\n  uVar3 = wget_get_logger(3);\n  wget_logger_set_func(uVar3,pcVar4);\n  if (DAT_0025340d == '\\0') {\n    pcVar4 = FUN_00010b57;\n  }\n  else {\n    pcVar4 = (code *)0x0;\n  }\n  uVar3 = wget_get_logger(2);\n  wget_logger_set_func(uVar3,pcVar4);\n  if ((DAT_0025340c == '\\0') || (DAT_0025340d == '\\x01')) {\n    pcVar4 = (code *)0x0;\n  }\n  else {\n    iVar1 = fileno(stdout);\n    iVar2 = fileno(stderr);\n    if (iVar1 == iVar2) {\n      pcVar4 = FUN_00010bb1;\n    }\n    else {\n      pcVar4 = FUN_00010bde;\n    }\n  }\n  uVar3 = wget_get_logger(1);\n  wget_logger_set_func(uVar3,pcVar4);\n  return;\n}\n\n",
        "output": "The predicted function name is log_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](undefined8 param_1,char *param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  int iVar3;\n  char *pcVar4;\n  bool bVar5;\n  char *local_38;\n  int local_24;\n  char *local_20;\n  char *local_18;\n  \n  if (param_2 == (char *)0x0) {\n    bVar5 = false;\n  }\n  else {\n    local_38 = param_2;\n    if (*param_2 == '/') {\n      local_38 = param_2 + 1;\n    }\n    pcVar4 = strrchr(local_38,0x2f);\n    if (pcVar4 == (char *)0x0) {\n      local_18 = (char *)wget_strdup(&DAT_00041a79);\n    }\n    else {\n      local_18 = (char *)wget_strmemdup(local_38,(long)pcVar4 - (long)local_38);\n    }\n    pcVar4 = (char *)wget_vector_get(param_1,0);\n    cVar1 = *pcVar4;\n    local_24 = wget_vector_size(param_1);\n    do {\n      while( true ) {\n        local_24 = local_24 + -1;\n        if (local_24 < 0) {\n          (*wget_free)(local_18);\n          return cVar1 == '+';\n        }\n        pcVar4 = (char *)wget_vector_get(param_1,local_24);\n        bVar5 = *pcVar4 != '+';\n        local_20 = pcVar4 + 1;\n        if (*local_20 == '/') {\n          local_20 = pcVar4 + 2;\n        }\n        wget_debug_printf(\"directory[%d] \\'%s\\' - \\'%s\\' %c\\n\",local_24,local_20,local_18,\n                          (int)(char)(&DAT_00041a9e)[(int)(uint)bVar5]);\n        pcVar4 = strpbrk(local_20,\"*?[]\");\n        if (pcVar4 == (char *)0x0) break;\n        if (DAT_002533e1 == '\\0') {\n          iVar3 = 1;\n        }\n        else {\n          iVar3 = 0x11;\n        }\n        iVar3 = fnmatch(local_20,local_18,iVar3);\n        if (iVar3 == 0) {\n          (*wget_free)(local_18);\n          return bVar5;\n        }\n      }\n      cVar2 = FUN_0001318b(local_20,local_18,DAT_002533e1);\n    } while (cVar2 == '\\0');\n    (*wget_free)(local_18);\n  }\n  return bVar5;\n}\n\n",
        "output": "The predicted function name is in_directory_pattern_list"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](undefined8 *param_1,undefined8 *param_2)\n\n{\n  int local_c;\n  \n  local_c = wget_strcasecmp_ascii(*param_1,*param_2);\n  if (local_c == 0) {\n    if (param_1[1] == 0) {\n      if (param_2[1] == 0) {\n        local_c = 0;\n      }\n      else {\n        local_c = -1;\n      }\n    }\n    else if (param_2[1] == 0) {\n      local_c = 1;\n    }\n    else {\n      local_c = wget_strcasecmp_ascii(param_1[1],param_2[1]);\n    }\n  }\n  return local_c;\n}\n\n",
        "output": "The predicted function name is compare_tag"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined4 param_1,undefined4 param_2,int param_3)\n\n{\n  switch(param_1) {\n  case 0:\n    switch(param_2) {\n    case 0:\n      return 0;\n    case 1:\n    case 3:\n      return 4;\n    case 2:\n      return 3;\n    case 4:\n      return 3;\n    }\n    break;\n  case 1:\n    return 4;\n  case 2:\n    switch(param_2) {\n    case 0:\n      if (param_3 != 0) {\n        return 1;\n      }\n      return 2;\n    case 1:\n      return 4;\n    case 2:\n      if (param_3 != 0) {\n        return 2;\n      }\n      return 1;\n    case 3:\n      if (param_3 != 0) {\n        return 1;\n      }\n      return 3;\n    case 4:\n      return 3;\n    }\n    break;\n  case 3:\n    return 3;\n  case 4:\n    return 3;\n  }\n  return 3;\n}\n\n",
        "output": "The predicted function name is handshake_status"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x30);\n}\n\n",
        "output": "The predicted function name is gcide_idx_headwords"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ASN1_VALUE **param_1,uchar **param_2,long param_3)\n\n{\n  ASN1_ITEM *it;\n  \n  it = (ASN1_ITEM *)FUN_00002bd6();\n  ASN1_item_d2i(param_1,param_2,param_3,it);\n  return;\n}\n\n",
        "output": "The predicted function name is d2i_ASN1_UINT32_DATA"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2,char *param_3)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined8 uVar3;\n  long lVar4;\n  long in_FS_OFFSET;\n  int local_28;\n  char *local_20;\n  long local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  iVar1 = strcmp(param_2,\"Key\");\n  if (iVar1 == 0) {\n    uVar3 = FUN_000066e2(param_3,local_18 + 0x18,local_18 + 0x20);\n  }\n  else {\n    iVar1 = strcmp(param_2,\"Rounds\");\n    if (iVar1 == 0) {\n      iVar1 = atoi(param_3);\n      if (iVar1 < 0) {\n        uVar3 = 0xffffffff;\n      }\n      else {\n        *(int *)(local_18 + 0x40) = iVar1;\n        uVar3 = 1;\n      }\n    }\n    else {\n      iVar1 = strcmp(param_2,\"IV\");\n      if (iVar1 == 0) {\n        uVar3 = FUN_000066e2(param_3,local_18 + 0x30,local_18 + 0x48);\n      }\n      else {\n        iVar1 = strcmp(param_2,\"NextIV\");\n        if (iVar1 == 0) {\n          uVar3 = FUN_000066e2(param_3,local_18 + 0x38,local_18 + 0x48);\n        }\n        else {\n          iVar1 = strcmp(param_2,\"Plaintext\");\n          if (iVar1 == 0) {\n            uVar3 = FUN_000066e2(param_3,local_18 + 0x50,local_18 + 0x58);\n          }\n          else {\n            iVar1 = strcmp(param_2,\"Ciphertext\");\n            if (iVar1 == 0) {\n              uVar3 = FUN_000066e2(param_3,local_18 + 0x60,local_18 + 0x68);\n            }\n            else {\n              iVar1 = strcmp(param_2,\"KeyBits\");\n              if (iVar1 == 0) {\n                iVar1 = atoi(param_3);\n                if (iVar1 < 0) {\n                  uVar3 = 0xffffffff;\n                }\n                else {\n                  *(long *)(local_18 + 0x28) = (long)iVar1;\n                  uVar3 = 1;\n                }\n              }\n              else {\n                if (*(int *)(local_18 + 0x14) != 0) {\n                  iVar1 = strcmp(param_2,\"TLSAAD\");\n                  if (iVar1 == 0) {\n                    *(undefined4 *)(local_18 + 0xb0) = 1;\n                  }\n                  iVar2 = strcmp(param_2,\"AAD\");\n                  if ((iVar2 == 0) || (iVar1 == 0)) {\n                    for (local_28 = 0; local_28 < 4; local_28 = local_28 + 1) {\n                      if (*(long *)(local_18 + ((long)local_28 + 0xe) * 8) == 0) {\n                        uVar3 = FUN_000066e2(param_3,((long)local_28 + 0xe) * 8 + local_18,\n                                             ((long)local_28 + 0x12) * 8 + local_18);\n                        goto LAB_00007aac;\n                      }\n                    }\n                    uVar3 = 0xffffffff;\n                    goto LAB_00007aac;\n                  }\n                  iVar1 = strcmp(param_2,\"Tag\");\n                  if (iVar1 == 0) {\n                    uVar3 = FUN_000066e2(param_3,local_18 + 0xb8,local_18 + 200);\n                    goto LAB_00007aac;\n                  }\n                  iVar1 = strcmp(param_2,\"SetTagLate\");\n                  if (iVar1 == 0) {\n                    iVar1 = strcmp(param_3,\"TRUE\");\n                    if (iVar1 == 0) {\n                      *(undefined4 *)(local_18 + 0xd0) = 1;\n                    }\n                    else {\n                      iVar1 = strcmp(param_3,\"FALSE\");\n                      if (iVar1 != 0) {\n                        uVar3 = 0xffffffff;\n                        goto LAB_00007aac;\n                      }\n                      *(undefined4 *)(local_18 + 0xd0) = 0;\n                    }\n                    uVar3 = 1;\n                    goto LAB_00007aac;\n                  }\n                  iVar1 = strcmp(param_2,\"MACKey\");\n                  if (iVar1 == 0) {\n                    uVar3 = FUN_000066e2(param_3,local_18 + 0xd8,local_18 + 0xe0);\n                    goto LAB_00007aac;\n                  }\n                  iVar1 = strcmp(param_2,\"TLSVersion\");\n                  if (iVar1 == 0) {\n                    lVar4 = strtol(param_3,&local_20,0);\n                    *(int *)(local_18 + 0xb4) = (int)lVar4;\n                    if ((*param_3 == '\\0') || (*local_20 != '\\0')) {\n                      uVar3 = 0;\n                    }\n                    else {\n                      uVar3 = 1;\n                    }\n                    goto LAB_00007aac;\n                  }\n                }\n                iVar1 = strcmp(param_2,\"Operation\");\n                if (iVar1 == 0) {\n                  iVar1 = strcmp(param_3,\"ENCRYPT\");\n                  if (iVar1 == 0) {\n                    *(undefined4 *)(local_18 + 0x10) = 1;\n                  }\n                  else {\n                    iVar1 = strcmp(param_3,\"DECRYPT\");\n                    if (iVar1 != 0) {\n                      uVar3 = 0xffffffff;\n                      goto LAB_00007aac;\n                    }\n                    *(undefined4 *)(local_18 + 0x10) = 0;\n                  }\n                  uVar3 = 1;\n                }\n                else {\n                  iVar1 = strcmp(param_2,\"CTSMode\");\n                  if (iVar1 == 0) {\n                    *(char **)(local_18 + 0xc0) = param_3;\n                    uVar3 = 1;\n                  }\n                  else {\n                    uVar3 = 0;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_00007aac:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is cipher_test_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  if (DAT_00215120 == 0) {\n    DAT_00215120 = FUN_0000b2d0(0x400);\n    DAT_00215128 = DAT_00215120;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is lbuf_alloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1,long *param_2,ulong *param_3)\n\n{\n  char *__s;\n  char *__s_00;\n  int iVar1;\n  size_t __n;\n  size_t __n_00;\n  long local_48;\n  long local_40;\n  long local_38;\n  ulong local_30;\n  \n  local_40 = 0;\n  for (local_48 = 0; *(char *)(local_48 + param_1) != '\\0'; local_48 = local_48 + 1) {\n    if (*(char *)(local_48 + param_1) == '/') {\n      local_40 = local_48 + 1;\n    }\n  }\n  local_38 = local_40;\n  local_30 = local_48 - local_40;\n  local_48 = 0;\n  do {\n    if ((&PTR_DAT_0024e200)[local_48 * 2] == (undefined *)0x0) {\nLAB_0000e32c:\n      *param_2 = local_38;\n      *param_3 = local_30;\n      return (&PTR_DAT_0024e200)[local_48 * 2] != (undefined *)0x0;\n    }\n    __s = (&PTR_DAT_0024e200)[local_48 * 2];\n    __s_00 = (&PTR_DAT_0024e208)[local_48 * 2];\n    __n = strlen(__s);\n    __n_00 = strlen(__s_00);\n    if (__n_00 + __n < local_30) {\n      iVar1 = memcmp((void *)(((local_30 + local_40) - __n_00) + param_1),__s_00,__n_00);\n      if (iVar1 == 0) {\n        iVar1 = memcmp((void *)(param_1 + local_40),__s,__n);\n        if (iVar1 == 0) {\n          local_38 = local_40 + __n;\n          local_30 = local_30 - (__n_00 + __n);\n          goto LAB_0000e32c;\n        }\n      }\n    }\n    local_48 = local_48 + 1;\n  } while( true );\n}\n\n",
        "output": "The predicted function name is dl_match"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](byte **param_1)\n\n{\n  int local_14;\n  byte *local_10;\n  \n  local_14 = *(int *)(param_1 + 2);\n  for (local_10 = *param_1; (local_10 != (byte *)0x0 && (*local_10 != 0)); local_10 = local_10 + 1)\n  {\n    local_14 = (uint)*local_10 + local_14 * 0x65;\n  }\n  for (local_10 = param_1[1]; (local_10 != (byte *)0x0 && (*local_10 != 0)); local_10 = local_10 + 1\n      ) {\n    local_14 = (uint)*local_10 + local_14 * 0x65;\n  }\n  return local_14;\n}\n\n",
        "output": "The predicted function name is host_hash"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ASN1_VALUE *param_1)\n\n{\n  ASN1_ITEM *it;\n  \n  it = (ASN1_ITEM *)FUN_00002cec();\n  ASN1_item_free(param_1,it);\n  return;\n}\n\n",
        "output": "The predicted function name is ASN1_INT64_DATA_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1)\n\n{\n  long lVar1;\n  bool bVar2;\n  \n  if (*(short *)(*(long *)(param_1 + 0x38) + 0x90) == 0) {\n    if ((*(long *)(*(long *)(param_1 + 0x38) + 0xe0) == 0) ||\n       (**(long **)(*(long *)(param_1 + 0x38) + 0xe0) == 0)) {\n      bVar2 = false;\n    }\n    else {\n      lVar1 = **(long **)(*(long *)(param_1 + 0x38) + 0xe0);\n      if (*(int *)(lVar1 + 0x18) == 0x33) {\n        bVar2 = *(char *)(*(long *)(*(long *)(lVar1 + 0x38) + 8) + 0x29) == '\\0';\n      }\n      else {\n        bVar2 = false;\n      }\n    }\n  }\n  else {\n    bVar2 = true;\n  }\n  return bVar2;\n}\n\n",
        "output": "The predicted function name is entity_invisible"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](int param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long in_FS_OFFSET;\n  int local_b4;\n  int local_b0;\n  int local_ac;\n  int local_a8;\n  undefined4 local_a4;\n  EVP_CIPHER *local_a0;\n  undefined *local_98;\n  EVP_CIPHER_CTX *local_90;\n  uchar local_88 [64];\n  uchar local_48 [56];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_98 = (undefined *)0x0;\n  local_a4 = 0;\n  if (param_1 == 1) {\n    local_a0 = EVP_aes_192_cbc();\n    local_98 = &DAT_0000c7b0;\n  }\n  else if (param_1 == 2) {\n    local_a0 = EVP_aes_256_cbc();\n    local_98 = &DAT_0000c7d0;\n  }\n  else if (param_1 == 0) {\n    local_a0 = EVP_aes_128_cbc();\n    local_98 = &DAT_0000c790;\n  }\n  else {\n    local_a0 = (EVP_CIPHER *)0x0;\n  }\n  local_90 = EVP_CIPHER_CTX_new();\n  iVar1 = FUN_00006d04(\"test/afalgtest.c\",0x52,\"ctx = EVP_CIPHER_CTX_new()\",local_90);\n  if (iVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    iVar1 = EVP_CipherInit_ex(local_90,local_a0,DAT_002110c8,&DAT_0000c800,&DAT_0000c830,1);\n    iVar1 = FUN_00006d79(\"test/afalgtest.c\",0x55,\"EVP_CipherInit_ex(ctx, cipher, e, key, iv, 1)\",\n                         iVar1 != 0);\n    if (iVar1 != 0) {\n      iVar1 = EVP_CipherUpdate(local_90,local_88,&local_b4,(uchar *)\"Single block msg\\n\",0x11);\n      iVar1 = FUN_00006d79(\"test/afalgtest.c\",0x56,\n                           \"EVP_CipherUpdate(ctx, ebuf, &encl, in, BUFFER_SIZE)\",iVar1 != 0);\n      if (iVar1 != 0) {\n        iVar1 = EVP_CipherFinal_ex(local_90,local_88 + local_b4,&local_b0);\n        iVar1 = FUN_00006d79(\"test/afalgtest.c\",0x57,\"EVP_CipherFinal_ex(ctx, ebuf + encl, &encf)\",\n                             iVar1 != 0);\n        if (iVar1 != 0) {\n          local_b4 = local_b0 + local_b4;\n          iVar1 = FUN_00007237(\"test/afalgtest.c\",0x5b,\"enc_result\",&DAT_0000c664,local_98,0x11,\n                               local_88,0x11);\n          if (iVar1 != 0) {\n            iVar1 = EVP_CIPHER_CTX_reset(local_90);\n            iVar1 = FUN_00006d79(\"test/afalgtest.c\",0x5e,\"EVP_CIPHER_CTX_reset(ctx)\",iVar1 != 0);\n            if (iVar1 != 0) {\n              iVar1 = EVP_CipherInit_ex(local_90,local_a0,DAT_002110c8,&DAT_0000c800,&DAT_0000c830,0\n                                       );\n              iVar1 = FUN_00006d79(\"test/afalgtest.c\",0x5f,\n                                   \"EVP_CipherInit_ex(ctx, cipher, e, key, iv, 0)\",iVar1 != 0);\n              if (iVar1 != 0) {\n                iVar1 = EVP_CipherUpdate(local_90,local_48,&local_ac,local_88,local_b4);\n                iVar1 = FUN_00006d79(\"test/afalgtest.c\",0x60,\n                                     \"EVP_CipherUpdate(ctx, dbuf, &decl, ebuf, encl)\",iVar1 != 0);\n                if (iVar1 != 0) {\n                  iVar1 = EVP_CipherFinal_ex(local_90,local_48 + local_ac,&local_a8);\n                  iVar1 = FUN_00006d79(\"test/afalgtest.c\",0x61,\n                                       \"EVP_CipherFinal_ex(ctx, dbuf + decl, &decf)\",iVar1 != 0);\n                  if (iVar1 != 0) {\n                    local_ac = local_a8 + local_ac;\n                    iVar1 = FUN_000052c5(\"test/afalgtest.c\",0x65,&DAT_0000c728,\"BUFFER_SIZE\",\n                                         local_ac,0x11);\n                    if ((iVar1 != 0) &&\n                       (iVar1 = FUN_00007237(\"test/afalgtest.c\",0x66,&DAT_0000c730,&DAT_0000c72d,\n                                             local_48,0x11,\"Single block msg\\n\",0x11), iVar1 != 0))\n                    {\n                      local_a4 = 1;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    EVP_CIPHER_CTX_free(local_90);\n    uVar2 = local_a4;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_afalg_aes_cbc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  if (DAT_00205338 == 0) {\n    DAT_00205338 = ERR_get_next_error_library();\n  }\n  if (DAT_0020533c == 0) {\n    ERR_load_strings(DAT_00205338,(ERR_STRING_DATA *)&DAT_00205300);\n    DAT_0020533c = 1;\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is ERR_load_DASYNC_strings"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long in_FS_OFFSET;\n  undefined8 local_b8;\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined4 local_88;\n  undefined4 local_84;\n  undefined8 local_80;\n  undefined8 local_78;\n  undefined8 local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined local_1a [10];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_84 = 0;\n  local_88 = 0;\n  local_80 = 0;\n  local_80 = FUN_00002d68(&DAT_00013d1b);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x146,\"kctx = get_kdfbyname(OSSL_KDF_NAME_HKDF)\",\n                       local_80);\n  if (iVar1 != 0) {\n    OSSL_PARAM_construct_int(&local_b8,\"digest\",&local_88);\n    local_78 = local_b8;\n    local_70 = local_b0;\n    local_68 = local_a8;\n    local_60 = local_a0;\n    local_58 = local_98;\n    OSSL_PARAM_construct_end(&local_b8);\n    local_50 = local_b8;\n    local_48 = local_b0;\n    local_40 = local_a8;\n    local_38 = local_a0;\n    local_30 = local_98;\n    uVar2 = EVP_KDF_derive(local_80,local_1a,10,&local_78);\n    iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x14e,\n                         \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar2,0);\n    if (iVar1 != 0) {\n      local_84 = 1;\n    }\n  }\n  EVP_KDF_CTX_free(local_80);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_84;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_kdf_hkdf_derive_set_params_fail"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ASN1_VALUE **param_1,uchar **param_2,long param_3)\n\n{\n  ASN1_ITEM *it;\n  \n  it = (ASN1_ITEM *)FUN_00002f18();\n  ASN1_item_d2i(param_1,param_2,param_3,it);\n  return;\n}\n\n",
        "output": "The predicted function name is d2i_INVALIDTEMPLATE"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  int iVar3;\n  undefined4 uVar4;\n  long in_FS_OFFSET;\n  undefined8 local_128;\n  undefined8 local_120;\n  undefined8 local_118;\n  undefined8 local_110;\n  undefined8 local_108;\n  undefined4 local_ec;\n  undefined8 *local_e8;\n  undefined8 local_e0;\n  undefined8 local_d8;\n  undefined8 uStack208;\n  undefined8 uStack200;\n  undefined8 uStack192;\n  undefined8 uStack184;\n  undefined8 auStack176 [16];\n  undefined local_2e [14];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_e8 = auStack176;\n  OSSL_PARAM_construct_utf8_string(&local_128,\"digest\",\"sha224\",0);\n  puVar2 = local_e8;\n  local_d8 = local_128;\n  uStack208 = local_120;\n  uStack200 = local_118;\n  uStack192 = local_110;\n  uStack184 = local_108;\n  local_e8 = local_e8 + 5;\n  OSSL_PARAM_construct_octet_string(&local_128,&DAT_00013cfa,&DAT_00219020,0x38);\n  uVar1 = local_120;\n  *puVar2 = local_128;\n  puVar2[1] = uVar1;\n  uVar1 = local_110;\n  puVar2[2] = local_118;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_108;\n  puVar2 = local_e8;\n  local_e8 = local_e8 + 5;\n  OSSL_PARAM_construct_octet_string(&local_128,&DAT_00013cfe,&DAT_00219060,0x2f);\n  uVar1 = local_120;\n  *puVar2 = local_128;\n  puVar2[1] = uVar1;\n  uVar1 = local_110;\n  puVar2[2] = local_118;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_108;\n  puVar2 = local_e8;\n  OSSL_PARAM_construct_end(&local_128);\n  *puVar2 = local_128;\n  puVar2[1] = local_120;\n  puVar2[2] = local_118;\n  puVar2[3] = local_110;\n  puVar2[4] = local_108;\n  local_e0 = FUN_00002d68(\"SSKDF\");\n  iVar3 = FUN_0000e315(\"test/evp_kdf_test.c\",0x372,\"kctx = get_kdfbyname(OSSL_KDF_NAME_SSKDF)\",\n                       local_e0);\n  if (iVar3 != 0) {\n    uVar4 = EVP_KDF_derive(local_e0,local_2e,0xe,&local_d8);\n    iVar3 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x373,\n                         \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar4,0);\n    if (iVar3 != 0) {\n      iVar3 = FUN_0000e848(\"test/evp_kdf_test.c\",0x374,&DAT_00013c68,\"expected\",local_2e,0xe,\n                           &DAT_00014b00,0xe);\n      if (iVar3 != 0) {\n        local_ec = 1;\n        goto LAB_0000697b;\n      }\n    }\n  }\n  local_ec = 0;\nLAB_0000697b:\n  EVP_KDF_CTX_free(local_e0);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_ec;\n}\n\n",
        "output": "The predicted function name is test_kdf_ss_hash"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nX509 * [MASK](void)\n\n{\n  int iVar1;\n  X509 *x;\n  \n  x = X509_new();\n  iVar1 = FUN_000085b0(\"test/v3nametest.c\",0xfe,\"crt = X509_new()\",x);\n  if (iVar1 == 0) {\n    x = (X509 *)0x0;\n  }\n  else {\n    iVar1 = X509_set_version(x,2);\n    iVar1 = FUN_00008625(\"test/v3nametest.c\",0x100,\"X509_set_version(crt, X509_VERSION_3)\",\n                         iVar1 != 0);\n    if (iVar1 == 0) {\n      X509_free(x);\n      x = (X509 *)0x0;\n    }\n  }\n  return x;\n}\n\n",
        "output": "The predicted function name is make_cert"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x10);\n}\n\n",
        "output": "The predicted function name is outline_result_count"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](SSL *param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  int iVar2;\n  undefined8 uVar3;\n  long lVar4;\n  long in_FS_OFFSET;\n  long local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar1 = SSL_client_hello_get0_legacy_version(param_1);\n  if ((uVar1 < 0x304) && (0x2ff < uVar1)) {\n    SSL_client_hello_get0_session_id(param_1,&local_18);\n    if (local_18 != 0) {\n      lVar4 = SSL_client_hello_get0_random(param_1,&local_18);\n      if (lVar4 != 0) {\n        lVar4 = SSL_client_hello_get0_ciphers(param_1,&local_18);\n        if (lVar4 != 0) {\n          lVar4 = SSL_client_hello_get0_compression_methods(param_1,&local_18);\n          if (lVar4 != 0) {\n            iVar2 = FUN_00006555(param_1,param_3,0);\n            SSL_ctrl(param_1,0x7c,0x302,(void *)0x0);\n            if (iVar2 == 0) {\n              *param_2 = 0x70;\n              uVar3 = 0;\n            }\n            else {\n              uVar3 = 1;\n            }\n            goto LAB_000069a6;\n          }\n        }\n      }\n    }\n    *param_2 = 0x50;\n    uVar3 = 0;\n  }\n  else {\n    *param_2 = 0x46;\n    uVar3 = 0;\n  }\nLAB_000069a6:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is client_hello_nov12_cb"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined *param_1)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  \n  *param_1 = 0;\n  param_1[10] = 1;\n  param_1[9] = 1;\n  param_1[8] = 0;\n  *(undefined4 *)(param_1 + 4) = 5;\n  param_1[0x19] = 0;\n  param_1[0x1a] = 0;\n  param_1[0x1b] = 1;\n  uVar1 = FUN_000140c7(&DAT_00225120);\n  *(undefined8 *)(param_1 + 0x10) = uVar1;\n  if (*(long *)(param_1 + 0x10) == 0) {\n    uVar1 = FUN_00013893(4,&DAT_0001d6e6);\n    uVar2 = gettext(\"failed to get attributes of %s\");\n    piVar3 = __errno_location();\n    error(1,*piVar3,uVar2,uVar1);\n  }\n  param_1[0x18] = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is rm_option_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                undefined8 param_5)\n\n{\n  uint uVar1;\n  int iVar2;\n  long lVar3;\n  code *pcVar4;\n  int local_1c;\n  uint local_18;\n  \n  local_1c = 1;\n  lVar3 = EVP_CIPHER_CTX_get_cipher_data(param_1);\n  uVar1 = *(uint *)(lVar3 + 8);\n  EVP_CIPHER_CTX_set_cipher_data(param_1);\n  if (uVar1 == 0) {\n    if (*(int *)(lVar3 + 0x1c8) != 0) {\n      if (*(int *)(lVar3 + 0x1c8) != 1) {\n        return -1;\n      }\n      pcVar4 = (code *)EVP_CIPHER_meth_get_ctrl(param_5);\n      (*pcVar4)(param_1,0x16,0xd,lVar3 + 0x28);\n    }\n    pcVar4 = (code *)EVP_CIPHER_meth_get_do_cipher(param_5);\n    local_1c = (*pcVar4)(param_1,param_2,param_3,param_4);\n  }\n  else {\n    if ((*(int *)(lVar3 + 0x1c8) != 0) && (uVar1 != *(uint *)(lVar3 + 0x1c8))) {\n      return -1;\n    }\n    for (local_18 = 0; local_18 < uVar1; local_18 = local_18 + 1) {\n      if (*(int *)(lVar3 + 0x1c8) != 0) {\n        pcVar4 = (code *)EVP_CIPHER_meth_get_ctrl(param_5);\n        (*pcVar4)(param_1,0x16,0xd,lVar3 + (ulong)local_18 * 0xd + 0x28);\n      }\n      if (local_1c == 0) {\nLAB_0000361c:\n        local_1c = 0;\n      }\n      else {\n        pcVar4 = (code *)EVP_CIPHER_meth_get_do_cipher(param_5);\n        iVar2 = (*pcVar4)(param_1,*(undefined8 *)(*(long *)(lVar3 + 0x18) + (ulong)local_18 * 8),\n                          *(undefined8 *)(*(long *)(lVar3 + 0x10) + (ulong)local_18 * 8),\n                          *(undefined8 *)(*(long *)(lVar3 + 0x20) + (ulong)local_18 * 8));\n        if (iVar2 == 0) goto LAB_0000361c;\n        local_1c = 1;\n      }\n    }\n    *(undefined4 *)(lVar3 + 8) = 0;\n  }\n  *(undefined4 *)(lVar3 + 0x1c8) = 0;\n  EVP_CIPHER_CTX_set_cipher_data(param_1,lVar3);\n  return local_1c;\n}\n\n",
        "output": "The predicted function name is dasync_cipher_helper"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined8 uVar3;\n  EVP_CIPHER *pEVar4;\n  char *pcVar5;\n  EVP_CIPHER **ppEVar6;\n  EVP_CIPHER *local_20;\n  \n  iVar1 = FUN_00011e77(param_2);\n  if (iVar1 == 0) {\n    ERR_set_mark();\n    pEVar4 = (EVP_CIPHER *)EVP_CIPHER_fetch(DAT_002241a8,param_2,0);\n    local_20 = pEVar4;\n    if ((pEVar4 == (EVP_CIPHER *)0x0) &&\n       (local_20 = EVP_get_cipherbyname(param_2), local_20 == (EVP_CIPHER *)0x0)) {\n      pcVar5 = strstr(param_2,\"HMAC\");\n      if (pcVar5 == (char *)0x0) {\n        ERR_clear_last_mark();\n        uVar3 = 0;\n      }\n      else {\n        ERR_pop_to_mark();\n        *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n        FUN_00016f06(\"test/evp_test.c\",0x238,\"skipping, \\'%s\\' is not available\",param_2);\n        uVar3 = 1;\n      }\n    }\n    else {\n      ERR_clear_last_mark();\n      ppEVar6 = (EVP_CIPHER **)CRYPTO_zalloc(0xe8,\"test/evp_test.c\",0x240);\n      iVar1 = FUN_00018f92(\"test/evp_test.c\",0x240,\"cdat = OPENSSL_zalloc(sizeof(*cdat))\",ppEVar6);\n      if (iVar1 == 0) {\n        uVar3 = 0;\n      }\n      else {\n        *ppEVar6 = local_20;\n        ppEVar6[1] = pEVar4;\n        *(undefined4 *)(ppEVar6 + 2) = 0xffffffff;\n        iVar1 = EVP_CIPHER_get_mode(local_20);\n        uVar2 = EVP_CIPHER_get_flags(local_20);\n        if ((uVar2 & 0x200000) == 0) {\n          *(undefined4 *)((long)ppEVar6 + 0x14) = 0;\n        }\n        else {\n          if (iVar1 == 0) {\n            iVar1 = -1;\n          }\n          *(int *)((long)ppEVar6 + 0x14) = iVar1;\n        }\n        *(EVP_CIPHER ***)(\"EVP_PKEY_verify_recover_init\" + param_1) = ppEVar6;\n        if (pEVar4 != (EVP_CIPHER *)0x0) {\n          FUN_00016f06(\"test/evp_test.c\",0x24e,\"%s is fetched\",param_2);\n        }\n        uVar3 = 1;\n      }\n    }\n  }\n  else {\n    *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n    FUN_00016f06(\"test/evp_test.c\",0x22d,\"skipping, \\'%s\\' is disabled\",param_2);\n    uVar3 = 1;\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is cipher_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](char *param_1)\n\n{\n  int iVar1;\n  FILE *__stream;\n  long in_FS_OFFSET;\n  long local_48;\n  char local_38 [40];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48 = 0;\n  __stream = fopen(param_1,\"r\");\n  if (__stream != (FILE *)0x0) {\n    iVar1 = fileno(__stream);\n    iVar1 = FUN_0001f4ae(\"user.last_modified\",local_38,0x20,iVar1);\n    if (0 < iVar1) {\n      local_48 = atoll(local_38);\n    }\n    FUN_000285bb(__stream);\n  }\n  if (local_48 == 0) {\n    local_48 = FUN_0001c045(param_1);\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_48;\n}\n\n",
        "output": "The predicted function name is get_file_lmtime"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  timespec local_48;\n  undefined8 local_38;\n  undefined8 local_30;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  FUN_0002882f();\n  local_30 = 0;\n  local_38 = param_2;\n  iVar1 = futimens(param_1,&local_48);\n  if (iVar1 == -1) {\n    piVar2 = __errno_location();\n    iVar1 = *piVar2;\n    uVar3 = gettext(\"Failed to set file date (%d)\\n\");\n    wget_error_printf(uVar3,iVar1);\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is set_file_mtime"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_00003bff(1,0);\n  return;\n}\n\n",
        "output": "The predicted function name is test_kdf_hkdf_gettables_no_digest"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  EVP_MD *pEVar1;\n  code *pcVar2;\n  \n  FUN_00002e1a();\n  pEVar1 = EVP_sha1();\n  pcVar2 = (code *)EVP_MD_meth_get_final(pEVar1);\n  (*pcVar2)(param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_sha1_final"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  code *pcVar1;\n  int iVar2;\n  int *piVar3;\n  long lVar4;\n  undefined8 uVar5;\n  long in_FS_OFFSET;\n  undefined local_d8 [8];\n  char *local_d0;\n  undefined local_b8 [48];\n  undefined8 local_88;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  FUN_00000be0(param_2);\n  (**(code **)(DAT_00202118 + 0x90))(DAT_00202120);\n  iVar2 = (**(code **)(DAT_00202118 + 0x98))(DAT_00202120,0,2,local_d8);\n  if (iVar2 == 0) {\n    if (*(int *)(DAT_00202118 + 0x18) != 0) {\n      pcVar1 = *(code **)(DAT_00202118 + 0x70);\n      uVar5 = gettext(\"readfile: called with wrong kind of argument\");\n      (*pcVar1)(DAT_00202120,uVar5);\n    }\n  }\n  else {\n    iVar2 = FUN_00001390(local_d0,local_b8);\n    if (iVar2 < 0) {\n      pcVar1 = *(code **)(DAT_00202118 + 0x80);\n      piVar3 = __errno_location();\n      (*pcVar1)(DAT_00202120,*piVar3);\n    }\n    else {\n      iVar2 = open(local_d0,0);\n      if (iVar2 < 0) {\n        pcVar1 = *(code **)(DAT_00202118 + 0x80);\n        piVar3 = __errno_location();\n        (*pcVar1)(DAT_00202120,*piVar3);\n      }\n      else {\n        lVar4 = FUN_00000c12(iVar2,local_b8);\n        if (lVar4 == 0) {\n          close(iVar2);\n        }\n        else {\n          close(iVar2);\n          FUN_00000b8f(DAT_00202118,DAT_00202120,lVar4,local_88,0,param_2);\n        }\n      }\n    }\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return param_2;\n}\n\n",
        "output": "The predicted function name is do_readfile"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  ASN1_ITEM *it;\n  \n  it = (ASN1_ITEM *)FUN_00002ac0();\n  ASN1_item_new(it);\n  return;\n}\n\n",
        "output": "The predicted function name is ASN1_INT32_DATA_new"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](char *param_1)\n\n{\n  int iVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  FILE *local_260;\n  undefined local_258 [64];\n  char local_218 [256];\n  undefined local_118 [264];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = strcmp(param_1,\"-\");\n  if ((iVar1 == 0) && (DAT_00253417 != '\\x01')) {\n    local_260 = stdin;\n  }\n  else {\n    local_260 = fopen(param_1,\"r\");\n    if (local_260 == (FILE *)0x0) {\n      uVar3 = gettext(\"Failed to open %s\");\n      wget_error_printf(uVar3,param_1);\n      uVar3 = 0xffffffff;\n      goto LAB_0002403b;\n    }\n  }\n  while (pcVar2 = fgets(local_218,0x100,local_260), pcVar2 != (char *)0x0) {\n    iVar1 = sscanf(local_218,\"%63[0-9.:] %255[a-zA-Z0-9.-]\",local_258,local_118);\n    if (iVar1 == 2) {\n      wget_strtolower(local_118);\n      wget_debug_printf(\"Adding DNS Mapping: %s -> %s\\n\",local_118,local_258);\n      wget_dns_cache_ip(DAT_00253d70,local_258,local_118,0x50);\n      wget_dns_cache_ip(DAT_00253d70,local_258,local_118,0x1bb);\n    }\n  }\n  if (local_260 != stdin) {\n    FUN_000285bb(local_260);\n  }\n  uVar3 = 0;\nLAB_0002403b:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is preload_dns_cache"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return *(undefined8 *)PTR_gcide_markup_yyout_00212fd8;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyget_out"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Type propagation algorithm not settling */\n\nvoid [MASK](byte *param_1)\n\n{\n  byte bVar1;\n  uint16_t uVar2;\n  ushort uVar3;\n  uint16_t uVar4;\n  undefined *puVar5;\n  char *pcVar6;\n  ulong local_30;\n  byte *local_28;\n  ulong local_20;\n  \n  bVar1 = *param_1;\n  if ((DAT_00214a48 & 0x20) != 0) {\n    printf(\"IP Hdr Dump:\\n \");\n    for (local_20 = 0; local_20 < 0x14; local_20 = local_20 + 1) {\n      if ((local_20 & 1) == 0) {\n        puVar5 = &DAT_0000fbdd;\n      }\n      else {\n        puVar5 = &DAT_0000fbdb;\n      }\n      printf(\"%02x%s\",(ulong)param_1[local_20],puVar5);\n    }\n    putchar(10);\n  }\n  puts(\"Vr HL TOS  Len   ID Flg  off TTL Pro  cks      Src\\tDst\\tData\");\n  printf(\" %1x  %1x  %02x\",(ulong)(*param_1 >> 4),(ulong)(*param_1 & 0xf),(ulong)param_1[1]);\n  uVar2 = ntohs(*(uint16_t *)(param_1 + 4));\n  if (*(ushort *)(param_1 + 2) < 0x2001) {\n    uVar3 = *(ushort *)(param_1 + 2);\n  }\n  else {\n    uVar3 = ntohs(*(uint16_t *)(param_1 + 2));\n  }\n  printf(\" %04x %04x\",(ulong)uVar3,(ulong)uVar2);\n  uVar2 = ntohs(*(uint16_t *)(param_1 + 6));\n  uVar4 = ntohs(*(uint16_t *)(param_1 + 6));\n  printf(\"   %1x %04x\",(ulong)(uVar4 >> 0xd),(ulong)(uVar2 & 0x1fff));\n  uVar2 = ntohs(*(uint16_t *)(param_1 + 10));\n  printf(\"  %02x  %02x %04x\",(ulong)param_1[8],(ulong)param_1[9],(ulong)uVar2);\n  pcVar6 = inet_ntoa((in_addr)((in_addr *)(param_1 + 0xc))->s_addr);\n  printf(\" %s \",pcVar6);\n  pcVar6 = inet_ntoa((in_addr)((in_addr *)(param_1 + 0x10))->s_addr);\n  printf(\" %s \",pcVar6);\n  local_30 = (long)(int)((uint)(bVar1 & 0xf) << 2);\n  local_28 = param_1 + 0x14;\n  while (0x14 < local_30) {\n    printf(\"%02x\",(ulong)*local_28);\n    local_30 = local_30 - 1;\n    local_28 = local_28 + 1;\n  }\n  putchar(10);\n  return;\n}\n\n",
        "output": "The predicted function name is print_ip_header"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x38);\n}\n\n",
        "output": "The predicted function name is gcide_idx_defs"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined4 param_1)\n\n{\n  *(undefined4 *)PTR_gcide_markup_yy_flex_debug_00212fe0 = param_1;\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyset_debug"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  wget_hashmap_free(&DAT_00253c00);\n  return;\n}\n\n",
        "output": "The predicted function name is hosts_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  short sVar1;\n  short sVar2;\n  void *__ptr;\n  char *pcVar3;\n  size_t sVar4;\n  size_t sVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  long in_FS_OFFSET;\n  char local_3c [12];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  __ptr = (void *)FUN_000029a3(param_1);\n  sprintf(local_3c,\"%ld\",(long)*(int *)(param_1 + 4));\n  if (DAT_0020a178 == (char *)0x0) {\n    pcVar3 = (char *)gettext(\"term=\");\n    sVar4 = strlen(pcVar3);\n    pcVar3 = (char *)gettext(\"exit=\");\n    sVar5 = strlen(pcVar3);\n    DAT_0020a178 = (char *)FUN_000069b0(sVar5 + sVar4 + 0xe);\n  }\n  sVar1 = *(short *)(param_1 + 0x14e);\n  uVar6 = gettext(\"exit=\");\n  sVar2 = *(short *)(param_1 + 0x14c);\n  uVar7 = gettext(\"term=\");\n  sprintf(DAT_0020a178,\"%s%d %s%d\",uVar7,(ulong)(uint)(int)sVar2,uVar6,(ulong)(uint)(int)sVar1);\n  pcVar3 = DAT_0020a178;\n  uVar6 = FUN_00002192(param_1);\n  FUN_00002228(0xffffffff,&DAT_000073d6,0x20,0x20,param_1 + 8,uVar6,&DAT_000073d6,local_3c,__ptr,\n               pcVar3);\n  free(__ptr);\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is print_deadprocs"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined *param_1,undefined *param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = FUN_0000879a(\"test/fake_rsaprov.c\",0xc5,\"sigctx\",param_1);\n  if (((iVar1 != 0) &&\n      (iVar1 = FUN_0000879a(\"test/fake_rsaprov.c\",0xc9,\"keydata\",param_2), iVar1 != 0)) &&\n     (iVar1 = FUN_00006f57(\"test/fake_rsaprov.c\",0xc9,\"keydata[0]\",&DAT_0000e138,*param_2,0),\n     iVar1 != 0)) {\n    *param_1 = 1;\n    return 1;\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is fake_rsa_sig_sign_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  return *(undefined4 *)PTR_gcide_markup_yylineno_00212fc8;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyget_lineno"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,long param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  if ((param_2 == 0) || (iVar1 = wget_strcasecmp_ascii(param_2,\"posix\"), iVar1 == 0)) {\n    **(undefined **)(param_1 + 0x18) = 0;\n  }\n  else {\n    iVar1 = wget_strcasecmp_ascii(param_2,&DAT_00043513);\n    if (iVar1 != 0) {\n      uVar2 = gettext(\"Unsupported regex type \\'%s\\'\\n\");\n      wget_error_printf(uVar2,param_2);\n      return 0xffffffff;\n    }\n    **(undefined **)(param_1 + 0x18) = 1;\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is parse_regex_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1,long param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  \n  iVar1 = FUN_000147f4(\"test/ssl_test.c\",0xad,\"result->client_npn_negotiated\",\n                       \"result->server_npn_negotiated\",*(undefined8 *)(param_1 + 0x38),\n                       *(undefined8 *)(param_1 + 0x40));\n  iVar2 = FUN_000147f4(\"test/ssl_test.c\",0xb0,\"test_ctx->expected_npn_protocol\",\n                       \"result->client_npn_negotiated\",*(undefined8 *)(param_2 + 0x1c8),\n                       *(undefined8 *)(param_1 + 0x38));\n  return iVar2 != 0 && iVar1 != 0;\n}\n\n",
        "output": "The predicted function name is check_npn"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Removing unreachable block (ram,0x00001b88) */\n\nundefined4 [MASK](void)\n\n{\n  return 0;\n}\n\n",
        "output": "The predicted function name is isnan_2BD"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                 undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n                 undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  undefined8 uVar1;\n  long in_FS_OFFSET;\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined *local_d0;\n  undefined *local_c8;\n  long local_c0;\n  undefined local_b8 [16];\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = param_1;\n    local_78 = param_2;\n    local_68 = param_3;\n    local_58 = param_4;\n    local_48 = param_5;\n    local_38 = param_6;\n    local_28 = param_7;\n    local_18 = param_8;\n  }\n  local_c0 = *(long *)(in_FS_OFFSET + 0x28);\n  local_d8 = 0x10;\n  local_d4 = 0x30;\n  local_d0 = &stack0x00000008;\n  local_c8 = local_b8;\n  local_a8 = param_11;\n  local_a0 = param_12;\n  local_98 = param_13;\n  local_90 = param_14;\n  uVar1 = wget_vaprintf(param_10,&local_d8);\n  FUN_0000de87(param_9,uVar1);\n  if (local_c0 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is dl_error_set_printf"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 * [MASK](char *param_1,undefined8 param_2,char *param_3,undefined8 param_4)\n\n{\n  undefined8 *puVar1;\n  size_t sVar2;\n  undefined8 *puVar3;\n  long in_FS_OFFSET;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  undefined8 local_70;\n  undefined8 local_68;\n  undefined8 local_58;\n  char *local_50;\n  undefined8 local_48;\n  char *local_40;\n  undefined8 *local_30;\n  undefined8 *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_58 = param_4;\n  local_50 = param_3;\n  local_48 = param_2;\n  local_40 = param_1;\n  local_30 = (undefined8 *)CRYPTO_malloc(200,\"test/evp_kdf_test.c\",0x1df);\n  local_28 = local_30;\n  if (local_30 == (undefined8 *)0x0) {\n    puVar3 = (undefined8 *)0x0;\n  }\n  else {\n    sVar2 = strlen(local_40);\n    puVar3 = local_28;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_octet_string(&local_88,&DAT_00013eb0,local_40,sVar2);\n    *puVar3 = local_88;\n    puVar3[1] = local_80;\n    puVar3[2] = local_78;\n    puVar3[3] = local_70;\n    puVar3[4] = local_68;\n    sVar2 = strlen(local_50);\n    puVar3 = local_28;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_octet_string(&local_88,&DAT_00013cf5,local_50,sVar2);\n    puVar1 = local_28;\n    *puVar3 = local_88;\n    puVar3[1] = local_80;\n    puVar3[2] = local_78;\n    puVar3[3] = local_70;\n    puVar3[4] = local_68;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_uint(&local_88,&DAT_00013eb5,local_58);\n    puVar3 = local_28;\n    *puVar1 = local_88;\n    puVar1[1] = local_80;\n    puVar1[2] = local_78;\n    puVar1[3] = local_70;\n    puVar1[4] = local_68;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_utf8_string(&local_88,\"digest\",local_48,0);\n    puVar1 = local_28;\n    *puVar3 = local_88;\n    puVar3[1] = local_80;\n    puVar3[2] = local_78;\n    puVar3[3] = local_70;\n    puVar3[4] = local_68;\n    OSSL_PARAM_construct_end(&local_88);\n    *puVar1 = local_88;\n    puVar1[1] = local_80;\n    puVar1[2] = local_78;\n    puVar1[3] = local_70;\n    puVar1[4] = local_68;\n    puVar3 = local_30;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar3;\n}\n\n",
        "output": "The predicted function name is construct_pbkdf1_params"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *param_1,char param_2)\n\n{\n  long lVar1;\n  char *pcVar2;\n  char *__new;\n  int iVar3;\n  size_t sVar4;\n  undefined8 uVar5;\n  int *piVar6;\n  long in_FS_OFFSET;\n  undefined8 uStack1328;\n  char acStack1320 [4];\n  char local_524;\n  char *local_520;\n  int local_510;\n  int local_50c;\n  int local_508;\n  int local_504;\n  char *local_500;\n  char *local_4f8;\n  char *local_4f0;\n  long local_4e8;\n  char *local_4e0;\n  undefined local_4d8 [24];\n  uint local_4c0;\n  char local_448 [1032];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  uStack1328 = 0x279f3;\n  local_524 = param_2;\n  local_520 = param_1;\n  sVar4 = strlen(param_1);\n  uStack1328 = 0x27a11;\n  local_4f8 = (char *)wget_strmemcpy_a(local_448,0x400,local_520,sVar4);\n  local_500 = local_4f8;\nLAB_00027d5b:\n  local_500 = local_500 + 1;\n  if (*local_500 == '\\0') {\nLAB_00027d92:\n    if ((local_4f8 != local_448) && (local_4f8 != (char *)0x0)) {\n      uStack1328 = 0x27dbf;\n      (*wget_free)(local_4f8);\n      local_4f8 = (char *)0x0;\n    }\n    if (local_524 != '\\x01') {\n      uStack1328 = 0x27dec;\n      local_504 = mkdir(local_520,0x1ed);\n      if (local_504 < 0) {\n        uStack1328 = 0x27e00;\n        piVar6 = __errno_location();\n        if (*piVar6 != 0x11) {\n          uStack1328 = 0x27e0c;\n          piVar6 = __errno_location();\n          uStack1328 = 0x27e2f;\n          wget_debug_printf(\"mkdir(%s)=%d errno=%d\\n\",local_520,local_504,*piVar6);\n        }\n      }\n    }\n    if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n      uStack1328 = 0x27e44;\n      __stack_chk_fail();\n    }\n    return;\n  }\n  uStack1328 = 0x27d7d;\n  local_4f0 = strchr(local_500,0x2f);\n  if (local_4f0 == (char *)0x0) goto LAB_00027d92;\n  *local_4f0 = '\\0';\n  if ((*local_500 == '.') && (local_500[1] == '.')) {\n    uStack1328 = 0x27a65;\n    uVar5 = gettext(\"Internal error: Unexpected relative path: \\'%s\\'\\n\");\n    uStack1328 = 0x27a7f;\n    wget_error_printf_exit(uVar5,local_4f8);\n  }\n  uStack1328 = 0x27a93;\n  local_508 = mkdir(local_4f8,0x1ed);\n  if (local_508 < 0) {\n    uStack1328 = 0x27aa7;\n    piVar6 = __errno_location();\n    if (*piVar6 != 0x11) {\n      uStack1328 = 0x27ab3;\n      piVar6 = __errno_location();\n      uStack1328 = 0x27ad6;\n      wget_debug_printf(\"mkdir(%s)=%d errno=%d\\n\",local_4f8,local_508,*piVar6);\n    }\n  }\n  if (local_508 == 0) {\n    uStack1328 = 0x27d3c;\n    wget_debug_printf(\"created dir %s\\n\",local_4f8);\n  }\n  else {\n    uStack1328 = 0x27ae8;\n    piVar6 = __errno_location();\n    if (*piVar6 == 0x11) {\n      uStack1328 = 0x27b0c;\n      iVar3 = FUN_000410c0(local_4f8,local_4d8);\n      if ((iVar3 == 0) && ((local_4c0 & 0xf000) == 0x8000)) {\n        local_510 = 0;\n        local_50c = 1;\n        while ((local_50c < 1000 && (local_510 == 0))) {\n          uStack1328 = 0x27b58;\n          sVar4 = strlen(local_4f8);\n          pcVar2 = local_4f8;\n          iVar3 = local_50c;\n          local_4e8 = sVar4 + 0x20;\n          lVar1 = ((sVar4 + 0x30) / 0x10) * -0x10;\n          local_4e0 = acStack1320 + lVar1;\n          *(undefined8 *)(acStack1320 + lVar1 + -8) = 0x27bd8;\n          wget_snprintf(acStack1320 + lVar1,sVar4 + 0x21,\"%s.%d\",pcVar2,iVar3);\n          pcVar2 = local_4e0;\n          *(undefined8 *)(acStack1320 + lVar1 + -8) = 0x27bec;\n          iVar3 = access(pcVar2,0);\n          __new = local_4e0;\n          pcVar2 = local_4f8;\n          if (iVar3 != 0) {\n            *(undefined8 *)(acStack1320 + lVar1 + -8) = 0x27c09;\n            iVar3 = rename(pcVar2,__new);\n            if (iVar3 == 0) {\n              local_510 = 1;\n            }\n          }\n          local_50c = local_50c + 1;\n        }\n        if (local_510 != 0) {\n          uStack1328 = 0x27c57;\n          local_508 = mkdir(local_4f8,0x1ed);\n          if (local_508 == 0) goto LAB_00027d3f;\n          uStack1328 = 0x27c6f;\n          piVar6 = __errno_location();\n          iVar3 = *piVar6;\n          uStack1328 = 0x27c7d;\n          uVar5 = gettext(\"Failed to make directory \\'%s\\' (errno=%d)\\n\");\n          uStack1328 = 0x27c99;\n          wget_error_printf(uVar5,local_4f8,iVar3);\n          *local_4f0 = '/';\n          goto LAB_00027d92;\n        }\n        uStack1328 = 0x27cad;\n        piVar6 = __errno_location();\n        iVar3 = *piVar6;\n        uStack1328 = 0x27cbb;\n        uVar5 = gettext(\"Failed to rename \\'%s\\' (errno=%d)\\n\");\n        uStack1328 = 0x27cd7;\n        wget_error_printf(uVar5,local_4f8,iVar3);\n        goto LAB_00027d3f;\n      }\n    }\n    uStack1328 = 0x27cde;\n    piVar6 = __errno_location();\n    if (*piVar6 != 0x11) {\n      uStack1328 = 0x27cea;\n      piVar6 = __errno_location();\n      iVar3 = *piVar6;\n      uStack1328 = 0x27cf8;\n      uVar5 = gettext(\"Failed to make directory \\'%s\\' (errno=%d)\\n\");\n      uStack1328 = 0x27d14;\n      wget_error_printf(uVar5,local_4f8,iVar3);\n      *local_4f0 = '/';\n      goto LAB_00027d92;\n    }\n  }\nLAB_00027d3f:\n  *local_4f0 = '/';\n  local_500 = local_4f0;\n  goto LAB_00027d5b;\n}\n\n",
        "output": "The predicted function name is mkdir_path"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long *param_1,void *param_2,uint param_3)\n\n{\n  *(undefined4 *)(param_1 + 1) = 0x117;\n  *(undefined4 *)((long)param_1 + 0xc) = 2;\n  *param_1 = (ulong)param_3 + 0x14;\n  *(uint *)(param_1 + 2) = param_3;\n  memcpy((void *)((long)param_1 + 0x14),param_2,(ulong)param_3);\n  return;\n}\n\n",
        "output": "The predicted function name is afalg_set_iv_sk"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](undefined8 param_1,FILE *param_2)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  char cVar7;\n  uint uVar8;\n  uint uVar9;\n  undefined8 uVar10;\n  size_t sVar11;\n  int *piVar12;\n  char *pcVar13;\n  bool bVar14;\n  \n  cVar7 = DAT_0020a286;\n  if (DAT_0020a286 == '\\x01') {\n    if (DAT_0020a2ba == DAT_0020a014) {\n      bVar14 = true;\n    }\n    else {\n      uVar8 = (uint)DAT_0020a284;\n      uVar9 = (uint)DAT_0020a2ba;\n      if (DAT_0020a030 == 0xffffffff) {\n        DAT_0020a030 = FUN_0000255d(uVar9);\n      }\n      uVar6 = DAT_0020a034;\n      uVar5 = DAT_0020a030;\n      uVar4 = DAT_0020a028;\n      uVar3 = DAT_0020a020;\n      uVar2 = DAT_0020a018;\n      uVar1 = DAT_0020a010;\n      if ((DAT_0020a030 == 3) || (uVar8 == DAT_0020a030)) {\n        if ((DAT_0020a034 == 3) || (uVar8 == DAT_0020a034)) {\n          if ((DAT_0020a010 == 0xffffffff) || (uVar9 == DAT_0020a010)) {\n            uVar9 = (uint)DAT_0020a2b8;\n            if ((DAT_0020a018 == 0xffffffff) || (uVar9 == DAT_0020a018)) {\n              uVar9 = (uint)DAT_0020a287;\n              if ((DAT_0020a020 == 0xffffffff) || (uVar9 == DAT_0020a020)) {\n                uVar9 = (uint)(byte)DAT_0020a288;\n                if ((DAT_0020a028 == 0xffffffff) || (uVar9 == DAT_0020a028)) {\n                  if (uVar8 == 1) {\n                    if (DAT_0020a014 != 0xffffffff) {\n                      (*DAT_0020a378)(&DAT_0020a2f2,(long)(int)DAT_0020a014,2);\n                    }\n                    if (DAT_0020a01c != -1) {\n                      (*DAT_0020a378)(&DAT_0020a2f0,(long)DAT_0020a01c,2);\n                    }\n                    if (DAT_0020a024 != -1) {\n                      DAT_0020a2e7 = (undefined)DAT_0020a024;\n                    }\n                    if (DAT_0020a02c != -1) {\n                      DAT_0020a2e8 = (undefined)DAT_0020a02c;\n                    }\n                    sVar11 = fwrite(&DAT_0020a2e0,0x34,1,param_2);\n                  }\n                  else {\n                    if (uVar8 != 2) {\n                    /* WARNING: Subroutine does not return */\n                      abort();\n                    }\n                    if (DAT_0020a014 != 0xffffffff) {\n                      (*DAT_0020a378)(&DAT_0020a332,(long)(int)DAT_0020a014,2);\n                    }\n                    if (DAT_0020a01c != -1) {\n                      (*DAT_0020a378)(&DAT_0020a330,(long)DAT_0020a01c,2);\n                    }\n                    if (DAT_0020a024 != -1) {\n                      DAT_0020a327 = (undefined)DAT_0020a024;\n                    }\n                    if (DAT_0020a02c != -1) {\n                      DAT_0020a328 = (undefined)DAT_0020a02c;\n                    }\n                    sVar11 = fwrite(&DAT_0020a320,0x40,1,param_2);\n                  }\n                  bVar14 = sVar11 == 1;\n                  if (!bVar14) {\n                    piVar12 = __errno_location();\n                    pcVar13 = strerror(*piVar12);\n                    uVar10 = gettext(\"%s: Failed to update ELF header: %s\\n\");\n                    error(uVar10,param_1,pcVar13);\n                  }\n                }\n                else {\n                  uVar10 = gettext(\"%s: Unmatched EI_ABIVERSION: %d is not %d\\n\");\n                  error(uVar10,param_1,uVar9,uVar4);\n                  bVar14 = false;\n                }\n              }\n              else {\n                uVar10 = gettext(\"%s: Unmatched EI_OSABI: %d is not %d\\n\");\n                error(uVar10,param_1,uVar9,uVar3);\n                bVar14 = false;\n              }\n            }\n            else {\n              uVar10 = gettext(\"%s: Unmatched e_type: %d is not %d\\n\");\n              error(uVar10,param_1,uVar9,uVar2);\n              bVar14 = false;\n            }\n          }\n          else {\n            uVar10 = gettext(\"%s: Unmatched e_machine: %d is not %d\\n\");\n            error(uVar10,param_1,uVar9,uVar1);\n            bVar14 = false;\n          }\n        }\n        else {\n          uVar10 = gettext(\"%s: Unmatched output EI_CLASS: %d is not %d\\n\");\n          error(uVar10,param_1,uVar8,uVar6);\n          bVar14 = false;\n        }\n      }\n      else {\n        uVar10 = gettext(\"%s: Unmatched input EI_CLASS: %d is not %d\\n\");\n        error(uVar10,param_1,uVar8,uVar5);\n        bVar14 = false;\n      }\n    }\n  }\n  else {\n    uVar10 = gettext(\"%s: Unsupported EI_VERSION: %d is not %d\\n\");\n    error(uVar10,param_1,cVar7,1);\n    bVar14 = false;\n  }\n  return bVar14;\n}\n\n",
        "output": "The predicted function name is update_elf_header"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = DAT_00215a68;\n  FUN_0000ca59(0);\n  DAT_00215a68 = DAT_00215a60;\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is text_segment_finish"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined4 param_1)\n\n{\n  FUN_00009e5e(&PTR_DAT_0021f000,6,param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is ssl_servername_callback_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  DAT_00253be8 = 1;\n  wget_thread_join(&DAT_00253be0);\n  wget_bar_free(&DAT_00253bd8);\n  return;\n}\n\n",
        "output": "The predicted function name is bar_deinit"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_00003407(0);\n  return;\n}\n\n",
        "output": "The predicted function name is test_http_post_x509"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,byte *param_2,byte *param_3,int param_4)\n\n{\n  byte bVar1;\n  undefined8 uVar2;\n  uint *local_20;\n  \n  bVar1 = *param_2;\n  if (((DAT_00214a48 & 0x20) != 0) || (*(int *)(param_3 + 0x18) == *(int *)(DAT_00214a50 + 0x2c))) {\n    uVar2 = FUN_0000434f(param_1,0x10);\n    printf(\"%d bytes from %s: \",(ulong)(param_4 + (uint)(bVar1 & 0xf) * -4),uVar2);\n    FUN_0000be7b(uVar2);\n    for (local_20 = &DAT_00214700; local_20 < &DAT_002148e0; local_20 = local_20 + 8) {\n      if (*local_20 == (uint)*param_3) {\n        if (*(long *)(local_20 + 2) != 0) {\n          puts(*(char **)(local_20 + 2));\n        }\n        if (*(long *)(local_20 + 4) == 0) {\n          return;\n        }\n        (**(code **)(local_20 + 4))(param_3,*(undefined8 *)(local_20 + 6));\n        return;\n      }\n    }\n    printf(\"Bad ICMP type: %d\\n\",(ulong)*param_3);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is print_icmp_header"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00010a35(stdout,param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is write_debug_stdout"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 * [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  long lVar2;\n  int *piVar3;\n  undefined8 uVar4;\n  undefined4 *local_20;\n  \n  local_20 = (undefined4 *)0x0;\n  lVar2 = FUN_0000a214(param_1,param_2);\n  if (lVar2 != 0) {\n    local_20 = (undefined4 *)calloc(1,0x28);\n    if (local_20 == (undefined4 *)0x0) {\n      piVar3 = __errno_location();\n      dico_log(4,*piVar3,\"%s:%d:%s\",\"gcide.c\",0x253,\"gcide_define\");\n      gcide_iterator_free(lVar2);\n      local_20 = (undefined4 *)0x0;\n    }\n    else {\n      *local_20 = 1;\n      *(undefined8 *)(local_20 + 2) = param_1;\n      uVar4 = FUN_0000a3c8(0);\n      *(undefined8 *)(local_20 + 8) = uVar4;\n      if (*(long *)(local_20 + 8) == 0) {\n        free(local_20);\n        gcide_iterator_free(lVar2);\n        local_20 = (undefined4 *)0x0;\n      }\n      else {\n        do {\n          uVar4 = gcide_iterator_ref(lVar2);\n          FUN_0000a46a(*(undefined8 *)(local_20 + 8),uVar4);\n          iVar1 = gcide_iterator_next(lVar2);\n        } while (iVar1 == 0);\n        uVar4 = gcide_iterator_compare_count(lVar2);\n        *(undefined8 *)(local_20 + 4) = uVar4;\n        gcide_iterator_free(lVar2);\n      }\n    }\n  }\n  return local_20;\n}\n\n",
        "output": "The predicted function name is gcide_define"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  sockaddr local_68;\n  undefined local_50 [64];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  *(undefined4 *)(param_1 + 4) = 0xffffffff;\n  *(undefined4 *)(param_1 + 8) = *(undefined4 *)(param_1 + 4);\n  memset(&local_68,0,0x58);\n  local_68.sa_family = 0x26;\n  OPENSSL_strlcpy(local_68.sa_data,param_2,0xe);\n  OPENSSL_strlcpy(local_50,param_3,0x40);\n  iVar1 = socket(0x26,5,0);\n  *(int *)(param_1 + 8) = iVar1;\n  if (*(int *)(param_1 + 8) == -1) {\n    fprintf(*(FILE **)PTR_stderr_00203ff8,\"ALG_PERR: %s(%d): Failed to open socket : \",\n            \"engines/e_afalg.c\",0x1b1);\n    perror((char *)0x0);\n    FUN_00001a71(0,0x6d,\"engines/e_afalg.c\",0x1b2);\n  }\n  else {\n    iVar1 = bind(*(int *)(param_1 + 8),&local_68,0x58);\n    if (iVar1 < 0) {\n      fprintf(*(FILE **)PTR_stderr_00203ff8,\"ALG_PERR: %s(%d): Failed to bind socket : \",\n              \"engines/e_afalg.c\",0x1b8);\n      perror((char *)0x0);\n      FUN_00001a71(0,0x67,\"engines/e_afalg.c\",0x1b9);\n    }\n    else {\n      iVar1 = accept(*(int *)(param_1 + 8),(sockaddr *)0x0,(socklen_t *)0x0);\n      *(int *)(param_1 + 4) = iVar1;\n      if (-1 < *(int *)(param_1 + 4)) {\n        uVar2 = 1;\n        goto LAB_0000259c;\n      }\n      fprintf(*(FILE **)PTR_stderr_00203ff8,\"ALG_PERR: %s(%d): Socket Accept Failed : \",\n              \"engines/e_afalg.c\",0x1bf);\n      perror((char *)0x0);\n      FUN_00001a71(0,0x6e,\"engines/e_afalg.c\",0x1c0);\n    }\n  }\n  if (-1 < *(int *)(param_1 + 8)) {\n    close(*(int *)(param_1 + 8));\n  }\n  if (-1 < *(int *)(param_1 + 4)) {\n    close(*(int *)(param_1 + 4));\n  }\n  *(undefined4 *)(param_1 + 4) = 0xffffffff;\n  *(undefined4 *)(param_1 + 8) = *(undefined4 *)(param_1 + 4);\n  uVar2 = 0;\nLAB_0000259c:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is afalg_create_sk"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](char *param_1,long param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  long lVar3;\n  \n  iVar1 = atoi(param_1);\n  if (((0 < iVar1) && (param_2 != 0)) && (iVar2 = FUN_00006028(param_2), iVar2 != 0)) {\n    iVar2 = FUN_00006028(param_2);\n    lVar3 = FUN_00006042(param_2,iVar2 + -1);\n    if (*(int *)(lVar3 + 0x18) == 0) {\n      *(long *)(lVar3 + 0x10) = (long)iVar1;\n      *(undefined4 *)(lVar3 + 0x18) = 1;\n      return 1;\n    }\n    return 0;\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is evp_test_buffer_set_count"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SSL *param_1,uint param_2,int param_3)\n\n{\n  int iVar1;\n  int *piVar2;\n  char *pcVar3;\n  \n  if ((param_2 & 0x4000) != 0) {\n    piVar2 = (int *)SSL_get_ex_data(param_1,DAT_002200e4);\n    if ((param_2 & 8) == 0) {\n      piVar2[2] = param_3;\n    }\n    else {\n      *piVar2 = param_3;\n      pcVar3 = SSL_alert_type_string(param_3);\n      iVar1 = strcmp(pcVar3,\"F\");\n      if (iVar1 != 0) {\n        pcVar3 = SSL_alert_desc_string(param_3);\n        iVar1 = strcmp(pcVar3,\"CN\");\n        if (iVar1 != 0) {\n          return;\n        }\n      }\n      piVar2[1] = piVar2[1] + 1;\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is info_cb"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](char *param_1,void **param_2,long *param_3)\n\n{\n  int iVar1;\n  size_t __n;\n  void *pvVar2;\n  ulong local_20;\n  ulong local_18;\n  \n  __n = strlen(param_1);\n  iVar1 = FUN_00014632(\"test/helpers/handshake.c\",0x160,&DAT_00017970,*param_2);\n  if (iVar1 != 0) {\n    pvVar2 = CRYPTO_malloc((int)__n + 1,\"test/helpers/handshake.c\",0x162);\n    *param_2 = pvVar2;\n    iVar1 = FUN_000146a7(\"test/helpers/handshake.c\",0x162,\"*out = OPENSSL_malloc(len + 1)\",*param_2)\n    ;\n    if (iVar1 != 0) {\n      *param_3 = __n + 1;\n      memcpy((void *)((long)*param_2 + 1),param_1,__n);\n      local_18 = 0;\n      for (local_20 = 1; local_20 <= __n; local_20 = local_20 + 1) {\n        if (*(char *)(local_20 + (long)*param_2) == ',') {\n          iVar1 = FUN_00012e64(\"test/helpers/handshake.c\",0x170,\"i - 1\",\"prefix\",(int)local_20 + -1,\n                               local_18 & 0xffffffff);\n          if (iVar1 == 0) goto LAB_00006dbd;\n          *(char *)(local_18 + (long)*param_2) = ((char)local_20 - (char)local_18) + -1;\n          local_18 = local_20;\n        }\n      }\n      iVar1 = FUN_00012e64(\"test/helpers/handshake.c\",0x177,&DAT_000179a4,\"prefix\",__n & 0xffffffff,\n                           local_18 & 0xffffffff);\n      if (iVar1 != 0) {\n        *(char *)(local_18 + (long)*param_2) = (char)__n - (char)local_18;\n        return 1;\n      }\nLAB_00006dbd:\n      CRYPTO_free(*param_2);\n      *param_2 = (void *)0x0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is parse_protos"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,long param_2)\n\n{\n  long lVar1;\n  ulong uVar2;\n  undefined8 uVar3;\n  long local_28;\n  \n  if (DAT_00253cf4 < 2) {\n    local_28 = DAT_00253378;\n  }\n  else {\n    local_28 = DAT_00253378 / (long)DAT_00253cf4;\n  }\n  *(long *)(param_1 + 0x28) = *(long *)(param_1 + 0x28) + param_2;\n  lVar1 = wget_get_timemillis();\n  if (*(long *)(param_1 + 0x30) != 0) {\n    *(long *)(param_1 + 0x28) =\n         *(long *)(param_1 + 0x28) - ((lVar1 - *(long *)(param_1 + 0x30)) * local_28) / 1000;\n  }\n  if (*(long *)(param_1 + 0x28) < 1) {\n    *(undefined8 *)(param_1 + 0x28) = 0;\n    *(long *)(param_1 + 0x30) = lVar1;\n  }\n  else {\n    uVar2 = (*(long *)(param_1 + 0x28) * 1000) / local_28;\n    wget_millisleep(uVar2 & 0xffffffff);\n    uVar3 = wget_get_timemillis();\n    *(undefined8 *)(param_1 + 0x30) = uVar3;\n    *(long *)(param_1 + 0x28) =\n         (long)((uVar2 - (*(long *)(param_1 + 0x30) - lVar1)) * local_28) / 1000;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is limit_transfer_rate"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  dico_list_count(*(undefined8 *)(param_1 + 0x20));\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_result_count"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  undefined8 uVar1;\n  \n  if (*(long *)(param_1 + 0x10) != 0) {\n    (*wget_free)(*(undefined8 *)(param_1 + 0x10));\n  }\n  uVar1 = wget_strdup(param_2);\n  *(undefined8 *)(param_1 + 0x10) = uVar1;\n  return;\n}\n\n",
        "output": "The predicted function name is impl_action_set_local_filename"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  wget_thread_mutex_destroy(&DAT_00253c08);\n  return;\n}\n\n",
        "output": "The predicted function name is host_exit"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  long lVar1;\n  \n  if (param_1 != 0) {\n    if (DAT_00215a00 == 0) {\n      lVar1 = 0;\n    }\n    else {\n      lVar1 = *(long *)(DAT_00215a00 + DAT_002159f0 * 8);\n    }\n    if (lVar1 == param_1) {\n      *(undefined8 *)(DAT_00215a00 + DAT_002159f0 * 8) = 0;\n    }\n    if (*(int *)(param_1 + 0x28) != 0) {\n      gcide_markup_yyfree(*(undefined8 *)(param_1 + 8));\n    }\n    gcide_markup_yyfree(param_1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yy_delete_buffer"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](uint param_1,char *param_2)\n\n{\n  undefined *puVar1;\n  size_t __n;\n  undefined8 uVar2;\n  \n  if (((int)param_1 < 1) || (0x7f < param_1)) {\n    uVar2 = 7;\n  }\n  else {\n    if (((param_1 == 0x74) || (param_1 == 0x76)) || (param_1 == 0x71)) {\n      DAT_00220fc8 = 1;\n    }\n    if (DAT_00221060 == DAT_00221058) {\n      _obstack_newchunk(&DAT_00221040,1);\n    }\n    puVar1 = DAT_00221058 + 1;\n    *DAT_00221058 = 0x2d;\n    DAT_00221058 = puVar1;\n    if (DAT_00221060 == DAT_00221058) {\n      _obstack_newchunk(&DAT_00221040,1);\n    }\n    puVar1 = DAT_00221058 + 1;\n    *DAT_00221058 = (char)param_1;\n    DAT_00221058 = puVar1;\n    if (param_2 != (char *)0x0) {\n      if (DAT_00221060 == DAT_00221058) {\n        _obstack_newchunk(&DAT_00221040,1);\n      }\n      puVar1 = DAT_00221058 + 1;\n      *DAT_00221058 = 0x20;\n      DAT_00221058 = puVar1;\n      __n = strlen(param_2);\n      if ((ulong)((long)DAT_00221060 - (long)DAT_00221058) < __n) {\n        _obstack_newchunk(&DAT_00221040,__n);\n      }\n      memcpy(DAT_00221058,param_2,__n);\n      DAT_00221058 = DAT_00221058 + __n;\n    }\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is ripe_argp_parser"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00003658(param_1,0x30,param_2,0xd,\"www.example.org\",0);\n  return;\n}\n\n",
        "output": "The predicted function name is set_email_and_cn"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  long lVar1;\n  int iVar2;\n  \n  lVar1 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  iVar2 = EVP_DigestVerify(*(undefined8 *)(lVar1 + 0x10),*(undefined8 *)(lVar1 + 0x38),\n                           *(undefined8 *)(lVar1 + 0x40),*(undefined8 *)(lVar1 + 0x28),\n                           *(undefined8 *)(lVar1 + 0x30));\n  if (iVar2 < 1) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"VERIFY_ERROR\";\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is oneshot_digestverify_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  long lVar1;\n  int iVar2;\n  char *__name;\n  int *piVar3;\n  undefined8 uVar4;\n  long in_FS_OFFSET;\n  int local_cc;\n  long local_c8;\n  long local_60;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  local_c8 = 0;\n  local_cc = 0;\n  do {\n    if (s_ABCDEFGHIJKLMNOPQRSTUVWXYZ_00213370[local_cc] == '\\0') {\n      *(long *)(param_1 + 0x30) = local_c8;\n      uVar4 = 0;\nLAB_00009771:\n      if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n      return uVar4;\n    }\n    __name = (char *)FUN_000093b3(param_1,(int)s_ABCDEFGHIJKLMNOPQRSTUVWXYZ_00213370[local_cc]);\n    iVar2 = access(__name,4);\n    if (iVar2 != 0) {\n      uVar4 = gettext(\"gcide: `%s\\' is not readable\");\n      dico_log(4,0,uVar4,__name);\n      uVar4 = 1;\n      goto LAB_00009771;\n    }\n    iVar2 = FUN_0000f6f0(__name);\n    if (iVar2 != 0) {\n      uVar4 = gettext(\"gcide: can\\'t stat `%s\\'\");\n      piVar3 = __errno_location();\n      dico_log(4,*piVar3,uVar4,__name);\n      uVar4 = 1;\n      goto LAB_00009771;\n    }\n    if (local_c8 < local_60) {\n      local_c8 = local_60;\n    }\n    local_cc = local_cc + 1;\n  } while( true );\n}\n\n",
        "output": "The predicted function name is gcide_check_files"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2,long param_3,undefined8 param_4,undefined4 param_5\n                 )\n\n{\n  long lVar1;\n  int iVar2;\n  undefined8 *puVar3;\n  int *piVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  int local_48;\n  undefined8 *local_40;\n  long local_38;\n  \n  local_40 = (undefined8 *)0x0;\n  for (local_48 = 0; iVar2 = wget_vector_size(param_2), puVar3 = local_40, local_48 < iVar2;\n      local_48 = local_48 + 1) {\n    puVar3 = (undefined8 *)wget_vector_get(param_2,local_48);\n    iVar2 = wget_strcasecmp_ascii(*puVar3,\"digest\");\n    if (iVar2 == 0) break;\n    iVar2 = wget_strcasecmp_ascii(*puVar3);\n    if ((iVar2 == 0) && (local_40 == (undefined8 *)0x0)) {\n      local_40 = puVar3;\n    }\n  }\n  local_40 = puVar3;\n  if (local_40 != (undefined8 *)0x0) {\n    if (param_3 == 0) {\n      if (DAT_00253248 == 0) {\n        wget_http_add_credentials(param_1,local_40,0,param_4,param_5);\n      }\n      else {\n        wget_thread_mutex_lock(DAT_00253d30);\n        if (DAT_00253320 == 0) {\n          DAT_00253320 = wget_netrc_db_init(0);\n          iVar2 = wget_netrc_db_load(DAT_00253320,DAT_00253248);\n          if ((iVar2 < 0) && (piVar4 = __errno_location(), *piVar4 != 2)) {\n            uVar5 = wget_strerror(iVar2);\n            piVar4 = __errno_location();\n            lVar1 = DAT_00253248;\n            iVar2 = *piVar4;\n            uVar6 = gettext(\"Failed to open .netrc file \\'%s\\' (%d): %s\\n\");\n            wget_error_printf(uVar6,lVar1,iVar2,uVar5);\n          }\n        }\n        wget_thread_mutex_unlock(DAT_00253d30);\n        local_38 = wget_netrc_get(DAT_00253320,*(undefined8 *)(param_1 + 0x58));\n        if (local_38 == 0) {\n          local_38 = wget_netrc_get(DAT_00253320,\"default\");\n        }\n        if (local_38 == 0) {\n          wget_http_add_credentials(param_1,local_40,0,param_4,param_5);\n        }\n        else {\n          wget_http_add_credentials\n                    (param_1,local_40,*(undefined8 *)(local_38 + 8),*(undefined8 *)(local_38 + 0x10)\n                     ,param_5);\n        }\n      }\n    }\n    else {\n      wget_http_add_credentials(param_1,local_40,param_3,param_4,param_5);\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is add_authorize_header"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  wget_hashmap_clear(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is wget_stringmap_clear"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_14;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_00009ddc(&PTR_s_Ignore_0021f0a0,3,&local_14,param_2);\n  if (iVar1 != 0) {\n    *(undefined4 *)(param_1 + 0x21c) = local_14;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1 != 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is parse_session_id"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  if (DAT_00204344 == 0) {\n    DAT_00204344 = ERR_get_next_error_library();\n  }\n  if (DAT_00204348 == 0) {\n    ERR_load_strings(DAT_00204344,(ERR_STRING_DATA *)&DAT_00204260);\n    DAT_00204348 = 1;\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is ERR_load_AFALG_strings"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return 0;\n}\n\n",
        "output": "The predicted function name is address_finish"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  EVP_PKEY_CTX **ppEVar1;\n  \n  ppEVar1 = *(EVP_PKEY_CTX ***)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  CRYPTO_free(ppEVar1[1]);\n  EVP_PKEY_CTX_free(*ppEVar1);\n  return;\n}\n\n",
        "output": "The predicted function name is pkey_kdf_test_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid [MASK](long param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  char cVar3;\n  uint uVar4;\n  long in_FS_OFFSET;\n  double dVar5;\n  double dVar6;\n  double dVar7;\n  double local_70;\n  double local_68;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar2 = *(long *)(*(long *)(param_1 + 0x38) + 8);\n  cVar3 = FUN_00001be7();\n  if (((cVar3 == '\\0') && (cVar3 = FUN_00001be7(), cVar3 == '\\0')) &&\n     (cVar3 = FUN_00001c1d(param_1), cVar3 == '\\0')) {\n    local_68 = DAT_000067c0 / *(double *)(lVar2 + 0x20);\n    dVar5 = DAT_000067c0 / *(double *)(lVar2 + 0x28);\n    dVar6 = DAT_000067c0 / *(double *)(lVar2 + 0x30);\n    uVar4 = (uint)(local_68 < 0.0);\n    _DAT_00209240 = DAT_002091f8;\n    _DAT_00209248 = DAT_00209200;\n    _DAT_00209258 = DAT_00209208;\n    _DAT_00209260 = DAT_00209200;\n    printf(\"\\t<!-- xline-%d -->\\n\",(ulong)*(uint *)(param_1 + 0x14));\n    local_70 = (*(double *)(&DAT_00209240 + (long)(int)uVar4 * 0x18) - *(double *)(lVar2 + 8)) *\n               local_68;\n    local_68 = (*(double *)(&DAT_00209240 + (long)(int)(1 - uVar4) * 0x18) - *(double *)(lVar2 + 8))\n               * local_68;\n    dVar7 = (*(double *)(&DAT_00209240 + (long)(int)(uint)(dVar5 < 0.0) * 0x18) -\n            *(double *)(lVar2 + 0x10)) * dVar5;\n    dVar5 = (*(double *)(&DAT_00209240 + (long)(int)(1 - (uint)(dVar5 < 0.0)) * 0x18) -\n            *(double *)(lVar2 + 0x10)) * dVar5;\n    if ((local_70 <= dVar5) && (dVar7 <= local_68)) {\n      if (local_70 < dVar7) {\n        local_70 = dVar7;\n      }\n      if (local_68 < dVar5) {\n        local_68 = dVar5;\n      }\n      if ((local_70 <=\n           (*(double *)(&DAT_00209250 + (long)(int)(1 - uVar4) * 0x18) - *(double *)(lVar2 + 0x18))\n           * dVar6) &&\n         ((*(double *)(&DAT_00209250 + (long)(int)uVar4 * 0x18) - *(double *)(lVar2 + 0x18)) * dVar6\n          <= local_68)) {\n        printf(\"\\t<path id=\\\"dwg-object-%d\\\" d=\\\"M %f,%f L %f,%f\\\"\\n\\t\",\n               (ulong)*(uint *)(param_1 + 0x14));\n        FUN_00001e87(*(undefined8 *)(param_1 + 0x38));\n      }\n    }\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is output_XLINE"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  long lVar1;\n  undefined4 uVar2;\n  int iVar3;\n  undefined8 uVar4;\n  long lVar5;\n  long in_FS_OFFSET;\n  int local_54;\n  long local_50;\n  long local_38;\n  long local_30;\n  int local_28;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar1 = *(long *)(param_1 + 0x18);\n  if (lVar1 != 0) {\n    memset(&local_38,0,0x28);\n    if (*(long *)(param_1 + 0x30) == 0) {\n      uVar2 = wget_vector_size(*(undefined8 *)(lVar1 + 0x18));\n      uVar4 = wget_vector_create(uVar2,0);\n      *(undefined8 *)(param_1 + 0x30) = uVar4;\n    }\n    else {\n      wget_vector_clear(*(undefined8 *)(param_1 + 0x30));\n    }\n    local_50 = *(long *)(lVar1 + 0x20);\n    for (local_54 = 0; iVar3 = wget_vector_size(*(undefined8 *)(lVar1 + 0x18)), local_54 < iVar3;\n        local_54 = local_54 + 1) {\n      lVar5 = wget_vector_get(*(undefined8 *)(lVar1 + 0x18),local_54);\n      if (local_50 < *(long *)(lVar5 + 0xa0)) {\n        local_30 = local_50;\n      }\n      else {\n        local_30 = *(long *)(lVar5 + 0xa0);\n      }\n      local_28 = local_54 + 1;\n      wget_vector_add_memdup(*(undefined8 *)(param_1 + 0x30),&local_38,0x28);\n      local_38 = local_30 + local_38;\n      local_50 = local_50 - *(long *)(lVar5 + 0xa0);\n    }\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is job_create_parts"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long *param_1,undefined8 *param_2)\n\n{\n  undefined8 uVar1;\n  long lVar2;\n  bool bVar3;\n  \n  if ((*(byte *)((long)param_2 + 0x36) & 1) == 0) {\n    lVar2 = param_2[4] - param_1[1];\n    if (lVar2 < 1) {\n      if (param_2[1] == 0) {\n        wget_list_browse(param_2[3],FUN_0000eadd,param_1);\n        bVar3 = *param_1 != 0;\n      }\n      else if ((*(byte *)(param_2[1] + 0xa8) >> 1 & 1) == 1) {\n        wget_debug_printf(\"robot job still in progress\\n\");\n        bVar3 = false;\n      }\n      else {\n        lVar2 = param_2[1];\n        *(byte *)(lVar2 + 0xa8) = *(byte *)(lVar2 + 0xa8) | 4;\n        *(byte *)(param_2[1] + 0xa8) =\n             *(byte *)(param_2[1] + 0xa8) & 0xfd | (*(byte *)(lVar2 + 0xa8) >> 2 & 1) * '\\x02';\n        lVar2 = param_2[1];\n        uVar1 = wget_thread_self();\n        *(undefined8 *)(lVar2 + 0x70) = uVar1;\n        *param_1 = param_2[1];\n        wget_debug_printf(\"host %s dequeue robot job\\n\",*param_2);\n        bVar3 = true;\n      }\n    }\n    else {\n      wget_debug_printf(\"host %s is paused %lldms\\n\",*param_2,lVar2);\n      if ((param_1[2] == 0) || (param_1[2] < lVar2)) {\n        param_1[2] = lVar2;\n      }\n      bVar3 = false;\n    }\n  }\n  else {\n    wget_debug_printf(\"host %s is blocked (qsize=%d)\\n\",*param_2,*(undefined4 *)(param_2 + 5));\n    bVar3 = false;\n  }\n  return bVar3;\n}\n\n",
        "output": "The predicted function name is _search_host_for_free_job"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0000b38a(param_1,param_2,1,PTR_EVP_PKEY_verify_recover_init_00223fb0,\n               PTR_EVP_PKEY_verify_recover_00223fd8);\n  return;\n}\n\n",
        "output": "The predicted function name is verify_recover_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](byte *param_1,ulong param_2,byte **param_3,byte **param_4)\n\n{\n  byte bVar1;\n  short sVar2;\n  undefined2 uVar3;\n  long lVar4;\n  undefined8 uVar5;\n  byte *pbVar6;\n  \n  bVar1 = *param_1;\n  lVar4 = (long)(int)((uint)(bVar1 & 0xf) * 4);\n  if (param_2 < lVar4 + 8U) {\n    uVar5 = 0xffffffff;\n  }\n  else {\n    pbVar6 = param_1 + lVar4;\n    *param_3 = param_1;\n    *param_4 = pbVar6;\n    sVar2 = *(short *)(pbVar6 + 2);\n    *(undefined2 *)(pbVar6 + 2) = 0;\n    uVar3 = FUN_00006cfc(pbVar6,(int)param_2 + (uint)(bVar1 & 0xf) * -4);\n    *(undefined2 *)(pbVar6 + 2) = uVar3;\n    if (sVar2 == *(short *)(pbVar6 + 2)) {\n      uVar5 = 0;\n    }\n    else {\n      uVar5 = 1;\n    }\n  }\n  return uVar5;\n}\n\n",
        "output": "The predicted function name is icmp_generic_decode"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1)\n\n{\n  if (param_1 != 0) {\n    *(undefined8 *)(param_1 + 0x18) = 0xf6d;\n  }\n  return param_1 != 0;\n}\n\n",
        "output": "The predicted function name is readfile_take_control_of"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined4 param_1)\n\n{\n  FUN_00009e5e(&PTR_DAT_0021f0e0,2,param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is ssl_test_method_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  return;\n}\n\n",
        "output": "The predicted function name is libcharset_set_relocation_prefix"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  long in_FS_OFFSET;\n  undefined8 local_30;\n  undefined local_1a [10];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = 0;\n  ptr = (void *)FUN_000037e4(\"sha256\",&DAT_00013cc4,1,&DAT_00013cf5,\"label\");\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x1c1,\"params\",ptr);\n  if (iVar1 != 0) {\n    local_30 = FUN_00002d68(&DAT_00013d1b);\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x1c2,\"kctx = get_kdfbyname(OSSL_KDF_NAME_HKDF)\",\n                         local_30);\n    if (iVar1 != 0) {\n      uVar2 = EVP_KDF_derive(local_30,local_1a,10,ptr);\n      iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x1c3,\n                           \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar2,0);\n      if (iVar1 != 0) {\n        uVar2 = 1;\n        goto LAB_00004a86;\n      }\n    }\n  }\n  uVar2 = 0;\nLAB_00004a86:\n  EVP_KDF_CTX_free(local_30);\n  CRYPTO_free(ptr);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_hkdf_1byte_key"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  uint local_74;\n  uint local_70;\n  ulong local_68;\n  undefined8 local_60;\n  long local_58;\n  long local_50;\n  ulong local_48;\n  undefined local_38 [24];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_00006ab1(&local_68,&local_60,param_1);\n  if (iVar1 == 0) {\n    if ((local_68 & 0x7fffffffffffffff) == local_68) {\n      if (DAT_00215110 != '\\0') {\n        fwrite(\"[using single-precision arithmetic] \",1,0x24,stderr);\n      }\n      FUN_00007084(local_68,local_60);\n      uVar2 = 1;\n      goto LAB_000073a9;\n    }\n  }\n  else if (iVar1 != 1) {\n    uVar2 = FUN_0000a017(param_1);\n    uVar3 = gettext(\"%s is not a valid positive integer\");\n    error(0,0,uVar3,uVar2);\n    uVar2 = 0;\n    goto LAB_000073a9;\n  }\n  if (DAT_00215110 != '\\0') {\n    fwrite(\"[using arbitrary-precision arithmetic] \",1,0x27,stderr);\n  }\n  __gmpz_init_set_str(local_38,param_1,10);\n  __gmp_printf(&DAT_00011448,local_38);\n  FUN_000069eb(local_38,&local_58);\n  for (local_74 = 0; local_74 < local_48; local_74 = local_74 + 1) {\n    for (local_70 = 0; (ulong)local_70 < *(ulong *)(local_50 + (ulong)local_74 * 8);\n        local_70 = local_70 + 1) {\n      __gmp_printf(&DAT_0001144d,local_58 + (ulong)local_74 * 0x10);\n    }\n  }\n  FUN_00002c73(&local_58);\n  __gmpz_clear(local_38);\n  putchar_unlocked(10);\n  fflush_unlocked(stdout);\n  uVar2 = 1;\nLAB_000073a9:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is print_factors"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  *(undefined8 *)(param_1 + 0x20) = param_2;\n  return;\n}\n\n",
        "output": "The predicted function name is impl_register_finalizer"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4\n[MASK](undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n            undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n            X509 *param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n            undefined8 param_13,undefined8 param_14)\n\n{\n  long lVar1;\n  char in_AL;\n  int iVar2;\n  X509_NAME *name;\n  uchar **ppuVar3;\n  uchar **ppuVar4;\n  ulong uVar5;\n  long in_FS_OFFSET;\n  undefined4 local_f0;\n  uint local_d8;\n  uchar **local_d0;\n  uchar *local_b8 [4];\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = param_1;\n    local_78 = param_2;\n    local_68 = param_3;\n    local_58 = param_4;\n    local_48 = param_5;\n    local_38 = param_6;\n    local_28 = param_7;\n    local_18 = param_8;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  local_f0 = 0;\n  local_d8 = 8;\n  local_d0 = (uchar **)&stack0x00000008;\n  local_b8[1] = (uchar *)param_10;\n  local_b8[2] = (uchar *)param_11;\n  local_b8[3] = (uchar *)param_12;\n  local_98 = param_13;\n  local_90 = param_14;\n  name = X509_NAME_new();\n  if (name != (X509_NAME *)0x0) {\n    do {\n      if (local_d8 < 0x30) {\n        uVar5 = (ulong)local_d8;\n        local_d8 = local_d8 + 8;\n        ppuVar3 = (uchar **)((long)local_b8 + uVar5);\n      }\n      else {\n        ppuVar3 = local_d0;\n        local_d0 = local_d0 + 1;\n      }\n      if (*(int *)ppuVar3 == 0) {\n        iVar2 = X509_set_subject_name(param_9,name);\n        if (iVar2 != 0) {\n          local_f0 = 1;\n        }\n        break;\n      }\n      if (local_d8 < 0x30) {\n        uVar5 = (ulong)local_d8;\n        local_d8 = local_d8 + 8;\n        ppuVar4 = (uchar **)((long)local_b8 + uVar5);\n      }\n      else {\n        ppuVar4 = local_d0;\n        local_d0 = local_d0 + 1;\n      }\n      iVar2 = X509_NAME_add_entry_by_NID(name,*(int *)ppuVar3,0x1001,*ppuVar4,-1,-1,1);\n    } while (iVar2 != 0);\n  }\n  X509_NAME_free(name);\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_f0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is set_cn"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  FUN_0000643e(param_1,param_3,1);\n  return;\n}\n\n",
        "output": "The predicted function name is servername_ignore_cb"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  int iVar3;\n  undefined4 uVar4;\n  long in_FS_OFFSET;\n  undefined8 local_1a8;\n  undefined8 local_1a0;\n  undefined8 local_198;\n  undefined8 local_190;\n  undefined8 local_188;\n  undefined4 local_174;\n  undefined8 local_170;\n  undefined8 *local_168;\n  undefined8 local_160;\n  undefined8 local_158;\n  undefined8 uStack336;\n  undefined8 uStack328;\n  undefined8 uStack320;\n  undefined8 uStack312;\n  undefined8 auStack304 [25];\n  undefined local_68 [72];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_170 = 0x14;\n  local_168 = auStack304;\n  OSSL_PARAM_construct_utf8_string(&local_1a8,&DAT_000141e1,\"KMAC128\",0);\n  puVar2 = local_168;\n  local_158 = local_1a8;\n  uStack336 = local_1a0;\n  uStack328 = local_198;\n  uStack320 = local_190;\n  uStack312 = local_188;\n  local_168 = local_168 + 5;\n  OSSL_PARAM_construct_octet_string(&local_1a8,&DAT_00013cfa,&DAT_00219320,0xe);\n  uVar1 = local_1a0;\n  *puVar2 = local_1a8;\n  puVar2[1] = uVar1;\n  uVar1 = local_190;\n  puVar2[2] = local_198;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_188;\n  puVar2 = local_168;\n  local_168 = local_168 + 5;\n  OSSL_PARAM_construct_octet_string(&local_1a8,&DAT_00013cfe,&DAT_00219330,0xc);\n  uVar1 = local_1a0;\n  *puVar2 = local_1a8;\n  puVar2[1] = uVar1;\n  uVar1 = local_190;\n  puVar2[2] = local_198;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_188;\n  puVar2 = local_168;\n  local_168 = local_168 + 5;\n  OSSL_PARAM_construct_octet_string(&local_1a8,&DAT_00013cf5,&DAT_00219340,0x10);\n  uVar1 = local_1a0;\n  *puVar2 = local_1a8;\n  puVar2[1] = uVar1;\n  uVar1 = local_190;\n  puVar2[2] = local_198;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_188;\n  puVar2 = local_168;\n  local_168 = local_168 + 5;\n  OSSL_PARAM_construct_size_t(&local_1a8,\"maclen\",&local_170);\n  uVar1 = local_1a0;\n  *puVar2 = local_1a8;\n  puVar2[1] = uVar1;\n  uVar1 = local_190;\n  puVar2[2] = local_198;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_188;\n  puVar2 = local_168;\n  OSSL_PARAM_construct_end(&local_1a8);\n  *puVar2 = local_1a8;\n  puVar2[1] = local_1a0;\n  puVar2[2] = local_198;\n  puVar2[3] = local_190;\n  puVar2[4] = local_188;\n  local_160 = FUN_00002d68(\"SSKDF\");\n  iVar3 = FUN_0000e315(\"test/evp_kdf_test.c\",0x59a,\"kctx = get_kdfbyname(OSSL_KDF_NAME_SSKDF)\",\n                       local_160);\n  if (iVar3 != 0) {\n    uVar4 = EVP_KDF_derive(local_160,local_68,0x40,&local_158);\n    iVar3 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x59b,\n                         \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar4,0);\n    if (iVar3 != 0) {\n      iVar3 = FUN_0000e848(\"test/evp_kdf_test.c\",0x59c,&DAT_00013c68,\"expected\",local_68,0x40,\n                           &DAT_00014bc0,0x40);\n      if (iVar3 != 0) {\n        local_174 = 1;\n        goto LAB_00009554;\n      }\n    }\n  }\n  local_174 = 0;\nLAB_00009554:\n  EVP_KDF_CTX_free(local_160);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_174;\n}\n\n",
        "output": "The predicted function name is test_kdf_ss_kmac"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined local_a8 [88];\n  undefined8 local_50;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_000410c0(param_1,local_a8);\n  if (iVar1 != 0) {\n    local_50 = 0;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_50;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is get_file_mtime"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 *param_1)\n\n{\n  return *param_1;\n}\n\n",
        "output": "The predicted function name is dl_error_get_msg"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,long param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 local_10;\n  \n  local_10 = 0;\n  if (param_2 == 0) {\n    local_10 = 0;\n  }\n  else {\n    uVar2 = OPENSSL_strnlen(param_1,param_2);\n    iVar1 = FUN_00013eb0(\"test/helpers/handshake.c\",0x4d0,\"OPENSSL_strnlen((const char*)(in), len)\",\n                         &DAT_000179a4,uVar2,param_2);\n    if (iVar1 != 0) {\n      local_10 = CRYPTO_strndup(param_1,param_2,\"test/helpers/handshake.c\",0x4d1);\n      FUN_000146a7(\"test/helpers/handshake.c\",0x4d1,\"ret = OPENSSL_strndup((const char*)(in), len)\",\n                   local_10);\n    }\n  }\n  return local_10;\n}\n\n",
        "output": "The predicted function name is dup_str"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,ulong param_2)\n\n{\n  undefined8 uVar1;\n  ulong local_18;\n  \n  local_18 = 0;\n  while( true ) {\n    if (*(ulong *)(param_1 + 0x48) <= local_18) {\n      return 0;\n    }\n    if (param_2 == **(ulong **)(*(long *)(param_1 + 0x50) + local_18 * 8)) break;\n    local_18 = local_18 + 1;\n  }\n  uVar1 = *(undefined8 *)(*(long *)(param_1 + 0x50) + local_18 * 8);\n  FUN_0000bb5f(param_1,param_2 & 0xffffffff);\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is _cache_find_page"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nuint [MASK](char *param_1,uint *param_2,uint *param_3)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  char *local_30;\n  uint local_24;\n  uint *local_20;\n  ulong local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_24 = 0;\n  *param_3 = 0;\n  *param_2 = *param_3;\n  local_30 = strtok(param_1,\",\");\n  do {\n    if (local_30 == (char *)0x0) {\n      if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n      return local_24;\n    }\n    if (*local_30 == '+') {\n      local_30 = local_30 + 1;\n      local_20 = param_2;\n    }\n    else if (*local_30 == '-') {\n      local_30 = local_30 + 1;\n      local_20 = param_3;\n    }\n    else {\n      local_20 = &local_24;\n    }\n    for (local_18 = 0; local_18 < 10; local_18 = local_18 + 1) {\n      iVar1 = strcmp(local_30,(&PTR_s_append_00201d60)[local_18 * 2]);\n      if (iVar1 == 0) {\n        *local_20 = *local_20 | *(uint *)(&DAT_00201d68 + local_18 * 0x10);\n        break;\n      }\n    }\n    if (local_18 == 10) {\n      builtin_error(\"invalid flag `%s\\'\",local_30);\n    }\n    local_30 = strtok((char *)0x0,\",\");\n  } while( true );\n}\n\n",
        "output": "The predicted function name is parseflags"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  wget_hashmap_put(param_1,param_2,param_3);\n  return;\n}\n\n",
        "output": "The predicted function name is wget_stringmap_put"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  EVP_PKEY_CTX **ptr;\n  EVP_PKEY_CTX *pEVar3;\n  \n  iVar1 = FUN_00011e68(param_2);\n  if (iVar1 == 0) {\n    ptr = (EVP_PKEY_CTX **)CRYPTO_zalloc(0x18,\"test/evp_test.c\",0xb1c);\n    iVar1 = FUN_00018f92(\"test/evp_test.c\",0xb1c,\"kdata = OPENSSL_zalloc(sizeof(*kdata))\",ptr);\n    if (iVar1 == 0) {\n      uVar2 = 0;\n    }\n    else {\n      pEVar3 = (EVP_PKEY_CTX *)EVP_PKEY_CTX_new_from_name(DAT_002241a8,param_2,0);\n      *ptr = pEVar3;\n      if ((*ptr != (EVP_PKEY_CTX *)0x0) && (iVar1 = EVP_PKEY_derive_init(*ptr), 0 < iVar1)) {\n        *(EVP_PKEY_CTX ***)(\"EVP_PKEY_verify_recover_init\" + param_1) = ptr;\n        return 1;\n      }\n      EVP_PKEY_CTX_free(*ptr);\n      CRYPTO_free(ptr);\n      uVar2 = 0;\n    }\n  }\n  else {\n    FUN_00016f06(\"test/evp_test.c\",0xb17,\"skipping, \\'%s\\' is disabled\",param_2);\n    *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is pkey_kdf_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Removing unreachable block (ram,0x00001c0c) */\n\nundefined4 [MASK](void)\n\n{\n  return 0;\n}\n\n",
        "output": "The predicted function name is isnan_3BD"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](char *param_1,int param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  ulong uVar3;\n  undefined8 uVar4;\n  int *piVar5;\n  long in_FS_OFFSET;\n  bool bVar6;\n  int local_22e0;\n  uint local_22dc;\n  long local_22d0;\n  ulong local_22c8;\n  undefined local_22b8 [656];\n  byte local_2028 [8200];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_22d0 = 0;\n  local_22dc = 0;\n  iVar1 = strcmp(param_1,\"-\");\n  bVar6 = iVar1 != 0;\n  if (bVar6) {\n    local_22e0 = open(param_1,0);\n    if (local_22e0 == -1) {\n      uVar4 = FUN_00005321(0,3,param_1);\n      piVar5 = __errno_location();\n      error(0,*piVar5,&DAT_00007786,uVar4);\n      uVar4 = 0;\n      goto LAB_0000244c;\n    }\n  }\n  else {\n    local_22e0 = 0;\n    DAT_0020a0e9 = 1;\n    FUN_00006265(0,0);\n  }\n  while( true ) {\n    uVar3 = FUN_000055d5(local_22e0,local_2028,0x2000);\n    if (uVar3 == 0) break;\n    if (uVar3 == 0xffffffffffffffff) {\n      uVar4 = FUN_00005321(0,3,param_1);\n      piVar5 = __errno_location();\n      error(0,*piVar5,&DAT_00007786,uVar4);\n      if (bVar6) {\n        close(local_22e0);\n      }\n      uVar4 = 0;\n      goto LAB_0000244c;\n    }\n    for (local_22c8 = 0; local_22c8 < uVar3; local_22c8 = local_22c8 + 1) {\n      local_22dc = local_22dc + local_2028[local_22c8];\n    }\n    local_22d0 = local_22d0 + uVar3;\n  }\n  if (bVar6) {\n    iVar1 = close(local_22e0);\n    if (iVar1 != 0) {\n      uVar4 = FUN_00005321(0,3,param_1);\n      piVar5 = __errno_location();\n      error(0,*piVar5,&DAT_00007786,uVar4);\n      uVar4 = 0;\n      goto LAB_0000244c;\n    }\n  }\n  uVar2 = (local_22dc & 0xffff) + (local_22dc >> 0x10);\n  uVar4 = FUN_00002a64(local_22d0,local_22b8,0,1,0x200);\n  printf(\"%d %s\",(ulong)((uVar2 & 0xffff) + ((int)uVar2 >> 0x10)),uVar4);\n  if (param_2 != 0) {\n    printf(\" %s\",param_1);\n  }\n  putchar_unlocked(10);\n  uVar4 = 1;\nLAB_0000244c:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar4;\n}\n\n",
        "output": "The predicted function name is sysv_sum_file"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](int param_1)\n\n{\n  bool bVar1;\n  int iVar2;\n  X509 *a;\n  undefined **local_20;\n  \n  bVar1 = false;\n  FUN_00006524(\"test/v3nametest.c\",0x15d,&DAT_0000eb42,(&PTR_s_set_CN_00212868)[(long)param_1 * 3]);\n  local_20 = &PTR_DAT_002125a0;\n  do {\n    if (*local_20 == (undefined *)0x0) {\n      return !bVar1;\n    }\n    a = (X509 *)FUN_00003d8a();\n    iVar2 = FUN_000085b0(\"test/v3nametest.c\",0x15f,\"crt = make_cert()\",a);\n    if (iVar2 == 0) {\nLAB_000043d1:\n      bVar1 = true;\n    }\n    else {\n      iVar2 = (*(code *)(&PTR_FUN_00212860)[(long)param_1 * 3])(a,*local_20);\n      iVar2 = FUN_00008625(\"test/v3nametest.c\",0x160,\"pfn->fn(crt, *pname)\",iVar2 != 0);\n      if (iVar2 == 0) goto LAB_000043d1;\n      iVar2 = FUN_00003f2b(a,*local_20,&PTR_FUN_00212860 + (long)param_1 * 3);\n      if (iVar2 == 0) goto LAB_000043d1;\n    }\n    X509_free(a);\n    local_20 = local_20 + 1;\n  } while( true );\n}\n\n",
        "output": "The predicted function name is call_run_cert"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  long in_FS_OFFSET;\n  undefined8 local_38;\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = 0;\n  ptr = (void *)FUN_00002d87(\"sha256\",&DAT_00013cc3,&DAT_00013be2);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x80,\"params\",ptr);\n  if (iVar1 != 0) {\n    local_38 = FUN_00002d68(\"TLS1-PRF\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x81,\"kctx = get_kdfbyname(OSSL_KDF_NAME_TLS1_PRF)\",\n                         local_38);\n    if (iVar1 != 0) {\n      uVar2 = EVP_KDF_derive(local_38,local_28,0x10,ptr);\n      iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x82,\n                           \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar2,0);\n      if (iVar1 != 0) {\n        uVar2 = 1;\n        goto LAB_000033e8;\n      }\n    }\n  }\n  uVar2 = 0;\nLAB_000033e8:\n  EVP_KDF_CTX_free(local_38);\n  CRYPTO_free(ptr);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_tls1_prf_empty_secret"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Removing unreachable block (ram,0x0000263e) */\n\nundefined8\n[MASK](long param_1,void *param_2,size_t param_3,undefined8 param_4,undefined4 param_5)\n\n{\n  cmsghdr *pcVar1;\n  size_t sVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  iovec local_a8;\n  msghdr local_98;\n  cmsghdr local_58 [4];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  memset(&local_98,0,0x38);\n  memset(local_58,0,0x40);\n  local_98.msg_controllen = 0x40;\n  local_98.msg_control = local_58;\n  FUN_000021eb(local_58,param_5);\n  pcVar1 = __cmsg_nxthdr(&local_98,local_58);\n  FUN_00002227(pcVar1,param_4,0x10);\n  local_98.msg_flags = 0x8000;\n  local_98.msg_iovlen = 1;\n  local_98.msg_iov = &local_a8;\n  local_a8.iov_base = param_2;\n  local_a8.iov_len = param_3;\n  sVar2 = sendmsg(*(int *)(param_1 + 4),&local_98,0);\n  if ((long)sVar2 < 0) {\n    fprintf(*(FILE **)PTR_stderr_00203ff8,\"ALG_PERR: %s(%d): sendmsg failed for cipher operation : \"\n            ,\"engines/e_afalg.c\",0x21a);\n    perror((char *)0x0);\n    uVar3 = 0;\n  }\n  else if (sVar2 == param_3) {\n    uVar3 = 1;\n  }\n  else {\n    uVar3 = 0;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is afalg_start_cipher_sk"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined4 param_1)\n\n{\n  FUN_00009e5e(&PTR_DAT_0021ef80,4,param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is ssl_verify_callback_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint * [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                  undefined8 param_5,long param_6)\n\n{\n  long in_FS_OFFSET;\n  undefined8 uVar1;\n  SSL_SESSION *local_28;\n  SSL_SESSION *local_20;\n  int *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_28 = (SSL_SESSION *)0x0;\n  local_20 = (SSL_SESSION *)0x0;\n  local_18 = (int *)FUN_0000887f(param_1,param_2,param_3,param_6,param_6 + 0x18,0,0,&local_28,\n                                 &local_20);\n  if (((local_18 != (int *)0x0) && (*(int *)(param_6 + 4) == 1)) && (*local_18 != 3)) {\n    if (*local_18 == 0) {\n      uVar1 = 0x98f2;\n      FUN_0000617d(local_18);\n      local_18 = (int *)FUN_0000887f(param_4,0,param_5,param_6,param_6 + 0xe0,local_28,local_20,0,0,\n                                     uVar1);\n    }\n    else {\n      *local_18 = 4;\n    }\n  }\n  SSL_SESSION_free(local_28);\n  SSL_SESSION_free(local_20);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_18;\n}\n\n",
        "output": "The predicted function name is do_handshake"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ASN1_VALUE *param_1,uchar **param_2)\n\n{\n  ASN1_ITEM *it;\n  \n  it = (ASN1_ITEM *)FUN_00002bd6();\n  ASN1_item_i2d(param_1,param_2,it);\n  return;\n}\n\n",
        "output": "The predicted function name is i2d_ASN1_UINT32_DATA"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1,EVP_PKEY_CTX *param_2,char *param_3)\n\n{\n  int iVar1;\n  char *__s;\n  char *pcVar2;\n  int local_1c;\n  char *local_18;\n  \n  local_1c = 0;\n  __s = CRYPTO_strdup(param_3,\"test/evp_test.c\",0x6c4);\n  iVar1 = FUN_00018f92(\"test/evp_test.c\",0x6c4,\"tmpval = OPENSSL_strdup(value)\",__s);\n  if (iVar1 != 0) {\n    pcVar2 = strchr(__s,0x3a);\n    local_18 = pcVar2;\n    if (pcVar2 != (char *)0x0) {\n      local_18 = pcVar2 + 1;\n      *pcVar2 = '\\0';\n      local_1c = EVP_PKEY_CTX_ctrl_str(param_2,__s,local_18);\n    }\n    if (local_1c == -2) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"PKEY_CTRL_INVALID\";\n      local_1c = 1;\n    }\n    else if ((local_18 != (char *)0x0) && (local_1c < 1)) {\n      iVar1 = FUN_00011e19(local_18);\n      if ((iVar1 == 0) && (iVar1 = FUN_00011e77(local_18), iVar1 == 0)) {\n        *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"PKEY_CTRL_ERROR\";\n        local_1c = 1;\n      }\n      else {\n        FUN_00016f06(\"test/evp_test.c\",0x6d0,\"skipping, \\'%s\\' is disabled\",local_18);\n        *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n        local_1c = 1;\n      }\n    }\n    CRYPTO_free(__s);\n    return 0 < local_1c;\n  }\n  return false;\n}\n\n",
        "output": "The predicted function name is pkey_test_ctrl"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1,long param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = FUN_00012c68(\"test/ssl_test.c\",0xa4,\"result->compression\",\"test_ctx->compression_expected\"\n                       ,*(undefined4 *)(param_1 + 0x2c),*(undefined4 *)(param_2 + 0x1c0));\n  return iVar1 != 0;\n}\n\n",
        "output": "The predicted function name is check_compression"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_00004240(&PTR_FUN_00214b40);\n  return;\n}\n\n",
        "output": "The predicted function name is test_long_32bit"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined4 param_1)\n\n{\n  FUN_00009e5e(&PTR_s_Ignore_0021f0a0,3,param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is ssl_session_id_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *param_1,char *param_2,char param_3)\n\n{\n  bool bVar1;\n  int iVar2;\n  int iVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  long in_FS_OFFSET;\n  bool bVar6;\n  char *local_68;\n  char *local_60;\n  int local_54;\n  uint local_50;\n  char *local_48;\n  char local_38 [40];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  bVar1 = false;\n  local_54 = 0;\n  pcVar4 = strchr(param_1,0x3d);\n  local_68 = param_2;\n  local_60 = param_1;\n  if (pcVar4 != (char *)0x0) {\n    if (0x1a < (long)pcVar4 - (long)param_1) {\n      uVar5 = gettext(\"Unknown option \\'%s\\'\\n\");\n      wget_error_printf(uVar5,param_1);\n      local_54 = -1;\n      goto LAB_000229c9;\n    }\n    memcpy(local_38,param_1,(long)pcVar4 - (long)param_1);\n    pcVar4[(long)(local_38 + -(long)param_1)] = '\\0';\n    local_60 = local_38;\n    local_68 = pcVar4 + 1;\n    bVar1 = true;\n  }\n  iVar2 = strncmp(local_60,\"--\",2);\n  if (iVar2 == 0) {\n    local_60 = local_60 + 2;\n  }\n  iVar3 = strncmp(local_60,\"no-\",3);\n  bVar6 = iVar3 == 0;\n  if (bVar6) {\n    local_60 = local_60 + 3;\n  }\n  if ((param_3 == '\\0') || (iVar2 == 0)) {\n    local_48 = (char *)bsearch(local_60,s_accept_0024e220,0xba,0x58,FUN_00022401);\n  }\n  else {\n    local_48 = (char *)bsearch(local_60,s_accept_0024e220,0xba,0x58,FUN_00022426);\n    if (local_48 == (char *)0x0) {\n      local_50 = 0;\n      while ((local_50 < 0xba && (local_48 == (char *)0x0))) {\n        iVar2 = FUN_0002244b(local_60,s_accept_0024e220 + (ulong)local_50 * 0x58);\n        if (iVar2 == 0) {\n          local_48 = s_accept_0024e220 + (ulong)local_50 * 0x58;\n        }\n        local_50 = local_50 + 1;\n      }\n    }\n  }\n  if (local_48 == (char *)0x0) {\n    uVar5 = gettext(\"Unknown option \\'%s\\'\\n\");\n    wget_error_printf(uVar5,local_60);\n    local_54 = -1;\n    goto LAB_000229c9;\n  }\n  wget_debug_printf(\"name=%s value=%s invert=%d\\n\",local_48,local_68,bVar6);\n  if (bVar1) {\n    if (bVar6) {\n      if (((*(int *)(local_48 + 0x28) == 0) || (*(code **)(local_48 + 0x20) == FUN_0001ffad)) ||\n         (((*(code **)(local_48 + 0x20) == FUN_0002001c ||\n           (((*(code **)(local_48 + 0x20) == FUN_00020639 ||\n             (*(code **)(local_48 + 0x20) == FUN_0001ff14)) ||\n            (*(code **)(local_48 + 0x20) == FUN_000208b0)))) ||\n          (*(code **)(local_48 + 0x20) == FUN_00021552)))) {\n        uVar5 = gettext(\"Option \\'no-%s\\' doesn\\'t allow an argument\\n\");\n        wget_error_printf(uVar5,local_60);\n        local_54 = -1;\n        goto LAB_000229c9;\n      }\n    }\n    else if (*(int *)(local_48 + 0x28) == 0) {\n      uVar5 = gettext(\"Option \\'%s\\' doesn\\'t allow an argument\\n\");\n      wget_error_printf(uVar5,local_60);\n      local_54 = -1;\n      goto LAB_000229c9;\n    }\n  }\n  else {\n    iVar2 = *(int *)(local_48 + 0x28);\n    if (iVar2 == 0) {\n      local_68 = (char *)0x0;\n    }\n    else if (iVar2 == 1) {\n      if (local_68 == (char *)0x0) {\n        uVar5 = gettext(\"Missing argument for option \\'%s\\'\\n\");\n        wget_error_printf(uVar5,local_60);\n        local_54 = -1;\n        goto LAB_000229c9;\n      }\n      if ((bVar6) &&\n         ((((*(code **)(local_48 + 0x20) == FUN_0001ffad ||\n            (*(code **)(local_48 + 0x20) == FUN_0002001c)) ||\n           (*(code **)(local_48 + 0x20) == FUN_00020639)) ||\n          (((*(code **)(local_48 + 0x20) == FUN_0001ff14 ||\n            (*(code **)(local_48 + 0x20) == FUN_000208b0)) ||\n           (*(code **)(local_48 + 0x20) == FUN_00021552)))))) {\n        local_68 = (char *)0x0;\n      }\n      else {\n        local_54 = *(int *)(local_48 + 0x28);\n      }\n    }\n    else if (iVar2 == -1) {\n      if (param_3 == '\\0') {\n        local_68 = (char *)0x0;\n      }\n      else if (local_68 != (char *)0x0) {\n        local_54 = 1;\n      }\n    }\n  }\n  iVar2 = (**(code **)(local_48 + 0x20))(local_48,local_68,bVar6);\n  if (iVar2 < 0) {\n    local_54 = iVar2;\n  }\nLAB_000229c9:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_54;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is set_long_option"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](int *param_1)\n\n{\n  int iVar1;\n  void *pvVar2;\n  undefined8 uVar3;\n  \n  iVar1 = *param_1;\n  pvVar2 = realloc(*(void **)(param_1 + 2),(long)(iVar1 + 8) << 5);\n  if (pvVar2 == (void *)0x0) {\n    uVar3 = 0xc;\n  }\n  else {\n    *(void **)(param_1 + 2) = pvVar2;\n    *param_1 = iVar1 + 8;\n    uVar3 = 0;\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is gl_posix_spawn_file_actions_realloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  long in_FS_OFFSET;\n  undefined8 local_38;\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = 0;\n  ptr = (void *)FUN_00002d87(\"sha256\",\"secret\",&DAT_00013cc3);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0xa5,\"params\",ptr);\n  if (iVar1 != 0) {\n    local_38 = FUN_00002d68(\"TLS1-PRF\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0xa6,\"kctx = get_kdfbyname(OSSL_KDF_NAME_TLS1_PRF)\",\n                         local_38);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_38,ptr);\n      iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0xa7,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        uVar2 = EVP_KDF_derive(local_38,local_28,0x10,0);\n        iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0xa8,\n                             \"EVP_KDF_derive(kctx, out, sizeof(out), NULL)\",&DAT_00013c2d,uVar2,0);\n        if (iVar1 != 0) {\n          uVar2 = 1;\n          goto LAB_00003679;\n        }\n      }\n    }\n  }\n  uVar2 = 0;\nLAB_00003679:\n  EVP_KDF_CTX_free(local_38);\n  CRYPTO_free(ptr);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_tls1_prf_empty_seed"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  code *pcVar1;\n  int iVar2;\n  int *piVar3;\n  long in_FS_OFFSET;\n  __pid_t local_50;\n  undefined local_48 [8];\n  double local_40;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_50 = -1;\n  iVar2 = (**(code **)(DAT_00202178 + 0x98))(DAT_00202180,0,1,local_48);\n  if (iVar2 != 0) {\n    local_50 = waitpid((int)local_40,(int *)0x0,3);\n    if (local_50 < 0) {\n      pcVar1 = *(code **)(DAT_00202178 + 0x80);\n      piVar3 = __errno_location();\n      (*pcVar1)(DAT_00202180,*piVar3);\n    }\n  }\n  FUN_00000c70((double)local_50,param_2);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is do_waitpid"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  wget_bar_write_line(DAT_00253bd8,param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is error_write"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](ulong param_1,ulong param_2)\n\n{\n  byte bVar1;\n  char cVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  long lVar6;\n  long lVar7;\n  long in_FS_OFFSET;\n  bool bVar8;\n  uint uStack556;\n  int iStack552;\n  uint uStack548;\n  long lStack544;\n  ulong uStack536;\n  ulong uStack528;\n  ulong uStack520;\n  ulong uStack512;\n  ulong uStack504;\n  long lStack496;\n  ulong uStack392;\n  ulong uStack384;\n  ulong local_178;\n  ulong local_170;\n  ulong uStack360;\n  ulong uStack352;\n  ulong uStack344;\n  ulong uStack336;\n  ulong uStack328;\n  ulong uStack320;\n  ulong uStack312;\n  ulong uStack304;\n  ulong uStack296;\n  ulong uStack288;\n  ulong auStack280 [31];\n  byte bStack30;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == 0) {\n    uVar3 = FUN_00003e57(param_2);\n  }\n  else {\n    local_170 = param_1 - (param_2 == 0);\n    local_178 = param_2 - 1;\n    if (local_178 == 0) {\n      lVar6 = 0;\n      if (local_170 != 0) {\n        for (; (local_170 >> lVar6 & 1) == 0; lVar6 = lVar6 + 1) {\n        }\n      }\n      uStack392 = local_170 >> ((byte)lVar6 & 0x3f);\n      uStack384 = 0;\n      iStack552 = (int)lVar6 + 0x40;\n    }\n    else {\n      lVar6 = 0;\n      if (local_178 != 0) {\n        for (; (local_178 >> lVar6 & 1) == 0; lVar6 = lVar6 + 1) {\n        }\n      }\n      iStack552 = (int)lVar6;\n      bVar1 = (byte)lVar6;\n      uStack392 = local_178 >> (bVar1 & 0x3f) | local_170 << (0x40 - bVar1 & 0x3f);\n      uStack384 = local_170 >> (bVar1 & 0x3f);\n    }\n    uStack520 = 2;\n    uVar4 = (ulong)(byte)(&DAT_00011220)[(uint)(param_2 >> 1) & 0x7f];\n    lVar6 = uVar4 * 2 - uVar4 * uVar4 * param_2;\n    lVar6 = lVar6 * 2 - lVar6 * lVar6 * param_2;\n    lVar6 = lVar6 * 2 - lVar6 * lVar6 * param_2;\n    if (param_1 < 2) {\n      uStack536 = 0;\n      uStack528 = 1;\n      lStack544 = 0x80;\n    }\n    else {\n      uStack536 = 1;\n      uStack528 = 0;\n      lStack544 = 0x40;\n    }\n    while (lVar7 = lStack544 + -1, lStack544 != 0) {\n      uStack536 = uStack528 >> 0x3f | uStack536 * 2;\n      uStack528 = uStack528 * 2;\n      lStack544 = lVar7;\n      if ((param_1 < uStack536) || ((uStack536 == param_1 && (param_2 <= uStack528)))) {\n        bVar8 = uStack528 < param_2;\n        uStack528 = uStack528 - param_2;\n        uStack536 = (uStack536 - param_1) - (ulong)bVar8;\n      }\n    }\n    uStack336 = uStack536;\n    uStack344 = uStack528;\n    uStack360 = uStack528 * 2;\n    uStack352 = uStack536 * 2 + (ulong)CARRY8(uStack528,uStack528);\n    if ((param_1 < uStack352) || ((param_1 == uStack352 && (param_2 <= uStack360)))) {\n      bVar8 = uStack360 < param_2;\n      uStack360 = uStack360 - param_2;\n      uStack352 = (uStack352 - param_1) - (ulong)bVar8;\n    }\n    uStack328 = param_2;\n    uStack320 = param_1;\n    cVar2 = FUN_00003be1(&uStack328,lVar6,&uStack360,&uStack392,iStack552,&uStack344);\n    if (cVar2 == '\\x01') {\n      if (DAT_00215010 != '\\0') {\n        FUN_0000690c(local_170,local_178,auStack280);\n      }\n      uStack556 = 0;\n      while( true ) {\n        if (0x29b < uStack556) {\n          uVar3 = gettext(\"Lucas prime test failure.  This should not happen\");\n          error(0,0,uVar3);\n                    /* WARNING: Subroutine does not return */\n          abort();\n        }\n        if (DAT_00215010 == '\\0') {\n          bVar8 = uStack556 == 0x18;\n        }\n        else {\n          bVar8 = true;\n          if (auStack280[1] != 0) {\n            uVar4 = (ulong)(byte)(&DAT_00011220)[(uint)(auStack280[0] >> 1) & 0x7f];\n            lVar7 = uVar4 * 2 - uVar4 * uVar4 * auStack280[0];\n            lVar7 = lVar7 * 2 - lVar7 * lVar7 * auStack280[0];\n            uStack312 = local_178 * (lVar7 * 2 - lVar7 * lVar7 * auStack280[0]);\n            uStack304 = 0;\n            uStack296 = FUN_0000394a(&uStack288,&uStack360,&uStack312,&uStack328,lVar6,&uStack344);\n            if ((uStack296 == uStack344) && (uStack288 == uStack336)) {\n              bVar8 = false;\n            }\n            else {\n              bVar8 = true;\n            }\n          }\n          uStack548 = 0;\n          while ((uStack548 < bStack30 && (bVar8))) {\n            if (auStack280[(ulong)uStack548 + 2] == 2) {\n              uStack312 = local_178 >> 1 | local_170 << 0x3f;\n              uStack304 = local_170 >> 1;\n            }\n            else {\n              uVar4 = auStack280[(ulong)uStack548 + 2];\n              uVar5 = (ulong)(byte)(&DAT_00011220)[(uint)(uVar4 >> 1) & 0x7f];\n              lVar7 = uVar5 * 2 - uVar5 * uVar5 * uVar4;\n              lVar7 = lVar7 * 2 - lVar7 * lVar7 * uVar4;\n              lVar7 = lVar7 * 2 - lVar7 * lVar7 * uVar4;\n              uStack312 = local_178 * lVar7;\n              if (local_170 < auStack280[(ulong)uStack548 + 2]) {\n                uStack304 = 0;\n              }\n              else {\n                uStack304 = (local_170 -\n                            SUB168(ZEXT816(uStack312) * ZEXT816(auStack280[(ulong)uStack548 + 2]) >>\n                                   0x40,0)) * lVar7;\n              }\n            }\n            uStack296 = FUN_0000394a(&uStack288,&uStack360,&uStack312,&uStack328,lVar6,&uStack344);\n            if ((uStack296 == uStack344) && (uStack288 == uStack336)) {\n              bVar8 = false;\n            }\n            else {\n              bVar8 = true;\n            }\n            uStack548 = uStack548 + 1;\n          }\n        }\n        if (bVar8) break;\n        uStack520 = uStack520 + (byte)(&DAT_0000e240)[uStack556];\n        if (uStack520 < param_1) {\n          uStack504 = 0;\n          lStack496 = 0x40;\n          uStack512 = uStack520;\n        }\n        else {\n          uStack512 = 0;\n          lStack496 = 0x80;\n          uStack504 = uStack520;\n        }\n        while (lVar7 = lStack496 + -1, lStack496 != 0) {\n          uStack512 = uStack504 >> 0x3f | uStack512 * 2;\n          uStack504 = uStack504 * 2;\n          lStack496 = lVar7;\n          if ((param_1 < uStack512) || ((uStack512 == param_1 && (param_2 <= uStack504)))) {\n            bVar8 = uStack504 < param_2;\n            uStack504 = uStack504 - param_2;\n            uStack512 = (uStack512 - param_1) - (ulong)bVar8;\n          }\n        }\n        uStack352 = uStack512;\n        uStack360 = uStack504;\n        cVar2 = FUN_00003be1(&uStack328,lVar6,&uStack360,&uStack392,iStack552,&uStack344);\n        if (cVar2 != '\\x01') {\n          uVar3 = 0;\n          goto LAB_00004f0b;\n        }\n        uStack556 = uStack556 + 1;\n      }\n      uVar3 = 1;\n    }\n    else {\n      uVar3 = 0;\n    }\n  }\nLAB_00004f0b:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is prime2_p"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined * [MASK](void)\n\n{\n  return &DAT_00210720;\n}\n\n",
        "output": "The predicted function name is ASN1_INT32_DATA_it"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined4 *param_2,long param_3)\n\n{\n  int iVar1;\n  char *__s2;\n  undefined8 uVar2;\n  \n  __s2 = (char *)SSL_get_srp_username(param_1);\n  iVar1 = strcmp(*(char **)(param_3 + 0x20),__s2);\n  if (iVar1 == 0) {\n    iVar1 = SSL_set_srp_server_param_pw\n                      (param_1,*(undefined8 *)(param_3 + 0x20),*(undefined8 *)(param_3 + 0x28),\n                       &DAT_000183cd);\n    if (iVar1 < 0) {\n      *param_2 = 0x50;\n      uVar2 = 2;\n    }\n    else {\n      uVar2 = 0;\n    }\n  }\n  else {\n    uVar2 = 2;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is server_srp_cb"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 * [MASK](undefined8 *param_1)\n\n{\n  int iVar1;\n  undefined8 *puVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  undefined8 *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  wget_thread_mutex_lock(DAT_00253bf8);\n  iVar1 = wget_hashmap_get(DAT_00253bf0,param_1,&local_28);\n  if (iVar1 == 0) {\n    puVar2 = (undefined8 *)FUN_0000d50a(0x10);\n    *puVar2 = param_1;\n    local_28 = puVar2;\n    uVar3 = FUN_0000d9e1(param_1);\n    puVar2[1] = uVar3;\n    wget_hashmap_put(DAT_00253bf0,param_1,local_28);\n    wget_thread_mutex_unlock(DAT_00253bf8);\n    puVar2 = local_28;\n  }\n  else {\n    wget_thread_mutex_unlock(DAT_00253bf8);\n    wget_debug_printf(\"not requesting \\'%s\\'. (Already Seen)\\n\",*param_1);\n    puVar2 = (undefined8 *)0x0;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar2;\n}\n\n",
        "output": "The predicted function name is blacklist_add"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  undefined8 uVar1;\n  \n  if (*(long *)(param_1 + 8) != 0) {\n    wget_iri_free(param_1 + 8);\n  }\n  uVar1 = wget_iri_clone(param_2);\n  *(undefined8 *)(param_1 + 8) = uVar1;\n  return;\n}\n\n",
        "output": "The predicted function name is impl_action_set_alt_url"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_00012593(&DAT_00253c70);\n  wget_vector_free(&DAT_00253c60);\n  wget_thread_mutex_destroy(&DAT_00253c68);\n  return;\n}\n\n",
        "output": "The predicted function name is site_stats_exit"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1,void *param_2,socklen_t param_3)\n\n{\n  int iVar1;\n  \n  iVar1 = setsockopt(*(int *)(param_1 + 8),0x117,1,param_2,param_3);\n  if (-1 >= iVar1) {\n    fprintf(*(FILE **)PTR_stderr_00203ff8,\"ALG_PERR: %s(%d): Failed to set socket option : \",\n            \"engines/e_afalg.c\",0x19b);\n    perror((char *)0x0);\n    FUN_00001a71(0,0x6a,\"engines/e_afalg.c\",0x19c);\n  }\n  return -1 < iVar1;\n}\n\n",
        "output": "The predicted function name is afalg_set_key"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  FUN_00009d51(param_2,param_1 + 0x1c0);\n  return;\n}\n\n",
        "output": "The predicted function name is parse_test_compression_expected"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return 1;\n}\n\n",
        "output": "The predicted function name is dasync_finish"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (DAT_00205398 == (code *)0x0) {\n    EVP_PKEY_meth_get_keygen(DAT_00205350,&DAT_00205398,0);\n  }\n  if (DAT_00205398 == (code *)0x0) {\n    uVar1 = 1;\n  }\n  else {\n    uVar1 = (*DAT_00205398)(param_1);\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is dasync_rsa_keygen_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *param_1,char param_2)\n\n{\n  char *pcVar1;\n  size_t sVar2;\n  char *pcVar3;\n  char *local_20;\n  char *local_18;\n  \n  if ((param_1 == (char *)0x0) || (*param_1 == '\\0')) {\n    pcVar3 = (char *)0x0;\n  }\n  else {\n    sVar2 = strlen(param_1);\n    pcVar3 = (char *)FUN_0001f967(sVar2 * 3 + 1);\n    local_20 = pcVar3 + 1;\n    *pcVar3 = param_2;\n    for (local_18 = param_1; *local_18 != '\\0'; local_18 = local_18 + 1) {\n      if (*local_18 == '\\\\') {\n        *local_20 = *local_18;\n        pcVar1 = local_20 + 1;\n        if (local_18[1] != '\\0') {\n          local_18 = local_18 + 1;\n          local_20[1] = *local_18;\n          pcVar1 = local_20 + 2;\n        }\n      }\n      else if (*local_18 == ',') {\n        for (; local_20[-1] == '/'; local_20 = local_20 + -1) {\n        }\n        *local_20 = *local_18;\n        local_20[1] = param_2;\n        pcVar1 = local_20 + 2;\n      }\n      else {\n        *local_20 = *local_18;\n        pcVar1 = local_20 + 1;\n      }\n      local_20 = pcVar1;\n    }\n    for (; local_20[-1] == '/'; local_20 = local_20 + -1) {\n    }\n    *local_20 = '\\0';\n  }\n  return pcVar3;\n}\n\n",
        "output": "The predicted function name is set_char_prefix"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined * [MASK](undefined8 param_1)\n\n{\n  int iVar1;\n  undefined *puVar2;\n  \n  iVar1 = FUN_0000879a(\"test/fake_rsaprov.c\",0x86,&DAT_0000e0c4,param_1);\n  if ((iVar1 != 0) &&\n     (iVar1 = FUN_00008ccd(\"test/fake_rsaprov.c\",0x87,&DAT_0000e0c4,\"inited\",param_1,1,&DAT_0000e322\n                           ,1), iVar1 != 0)) {\n    puVar2 = (undefined *)FUN_000033da(0);\n    iVar1 = FUN_0000879a(\"test/fake_rsaprov.c\",0x8a,\"keydata = fake_rsa_keymgmt_new(NULL)\",puVar2);\n    if (iVar1 == 0) {\n      return (undefined *)0x0;\n    }\n    *puVar2 = 2;\n    return puVar2;\n  }\n  return (undefined *)0x0;\n}\n\n",
        "output": "The predicted function name is fake_rsa_gen"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](ulong param_1,ulong param_2,ulong param_3,long param_4)\n\n{\n  ulong uVar1;\n  ulong uVar2;\n  long local_38;\n  \n  uVar1 = SUB168(ZEXT816(param_1) * ZEXT816(param_2) >> 0x40,0);\n  uVar2 = SUB168(ZEXT816((ulong)(SUB168(ZEXT816(param_1) * ZEXT816(param_2),0) * param_4)) *\n                 ZEXT816(param_3) >> 0x40,0);\n  local_38 = uVar1 - uVar2;\n  if (uVar1 < uVar2) {\n    local_38 = local_38 + param_3;\n  }\n  return local_38;\n}\n\n",
        "output": "The predicted function name is mulredc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  int iVar1;\n  char *pcVar2;\n  long in_FS_OFFSET;\n  undefined8 uVar3;\n  int local_1c8;\n  long local_1c0;\n  long local_1b8;\n  long local_1b0;\n  undefined4 local_1a8;\n  undefined4 local_1a4;\n  int local_1a0;\n  int local_19c;\n  int local_198;\n  undefined4 local_194;\n  undefined auStack400 [256];\n  char local_90 [128];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_1c0 = 0;\n  local_1b8 = 0;\n  do {\n    iVar1 = __isoc99_fscanf(stdin,\"%255s\",auStack400);\n    if (iVar1 != 1) {\n      if (local_1b8 != 0) {\n        (*wget_free)(local_1b8);\n        local_1b8 = 0;\n      }\n      if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return 0;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    if (local_1b8 != 0) {\n      (*wget_free)(local_1b8);\n      local_1b8 = 0;\n    }\n    iVar1 = wget_strncasecmp_ascii(auStack400,\"http://\",7);\n    if (iVar1 == 0) {\n      local_1b8 = wget_strdup(auStack400);\n    }\n    else {\n      iVar1 = wget_strncasecmp_ascii(auStack400,\"https://\",8);\n      if (iVar1 == 0) {\n        local_1b8 = wget_strdup(auStack400);\n      }\n      else {\n        local_1b8 = wget_aprintf(\"http://%s\",auStack400);\n      }\n    }\n    local_1a4 = 0;\n    local_1a8 = 0;\n    local_1a0 = -1;\n    local_194 = 0;\n    local_198 = 0;\n    local_19c = 0;\n    local_90[0] = '\\0';\n    for (local_1c8 = 0; local_1c8 < 5; local_1c8 = local_1c8 + 1) {\n      wget_http_free_response(&local_1c0);\n      if (local_1c8 == 0) {\n        pcVar2 = \"\";\n      }\n      else {\n        pcVar2 = \"  -> \";\n      }\n      uVar3 = 0x1a2b;\n      wget_info_printf(\"%s%s\\n\",pcVar2,local_1b8);\n      local_1c0 = wget_http_get(2000,local_1b8,0x7d4,\"User-Agent\",\"Mozilla/5.0\",0x7d4,\n                                \"Accept-Encoding\",\"gzip, br\",0x7d4,\"Accept\",\n                                \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\n                                0x7d4,\"Accept-Encoding\",\"gzip, br\",0x7da,0,0,uVar3);\n      if (local_1c0 == 0) {\n        wget_info_printf(\"  No connection / response\\n\");\n        break;\n      }\n      snprintf(local_90,0x80,\"%s\",*(undefined8 *)(local_1c0 + 0x30));\n      local_1a0 = (int)*(short *)(local_1c0 + 0xc0);\n      if (*(short *)(local_1c0 + 0xc0) == 200) {\n        iVar1 = wget_strncasecmp(local_1b8,\"https://\",8);\n        if (iVar1 == 0) {\n          local_194 = 1;\n        }\n        break;\n      }\n      if (*(long *)(local_1c0 + 0x48) == 0) {\n        wget_info_printf(\"  Response code %hd\\n\",(int)*(short *)(local_1c0 + 0xc0));\n        break;\n      }\n      local_19c = local_19c + 1;\n      wget_info_printf(\"  Response code %hd, %s\\n\",(int)*(short *)(local_1c0 + 0xc0),\n                       *(undefined8 *)(local_1c0 + 0x48));\n      local_1b0 = FUN_00001544(local_1b8,*(undefined8 *)(local_1c0 + 0x48));\n      if (local_1b0 == 0) {\n        wget_info_printf(\"  Failed to normalize \\'%s\\', \\'%s\\'\\n\",local_1b8,\n                         *(undefined8 *)(local_1c0 + 0x48));\n        break;\n      }\n      if (local_1b8 != 0) {\n        (*wget_free)(local_1b8);\n      }\n      local_1b8 = local_1b0;\n      iVar1 = wget_strncasecmp(local_1b0,\"https://\",8);\n      if (iVar1 != 0) {\n        local_198 = local_198 + 1;\n      }\n    }\n    wget_http_free_response(&local_1c0);\n    FUN_0000134a(&local_1a8);\n  } while( true );\n}\n\n",
        "output": "The predicted function name is downloader_thread"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,char *param_2)\n\n{\n  char *pcVar1;\n  \n  CRYPTO_free(*(void **)(param_1 + 0x10));\n  pcVar1 = CRYPTO_strdup(param_2,\"test/helpers/ssl_test_ctx.c\",0x163);\n  *(char **)(param_1 + 0x10) = pcVar1;\n  FUN_000146a7(\"test/helpers/ssl_test_ctx.c\",0x163,\"ctx->alpn_protocols\",\n               *(undefined8 *)(param_1 + 0x10));\n  return;\n}\n\n",
        "output": "The predicted function name is parse_server_alpn_protocols"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined4 param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  long in_FS_OFFSET;\n  undefined8 local_30;\n  void *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_00006d5b(param_1,&local_30,&local_28,param_2);\n  if (iVar1 != 0) {\n    uVar2 = FUN_00005ba4(0,3,param_1);\n    piVar3 = __errno_location();\n    error(1,*piVar3,&DAT_0000759b,uVar2);\n  }\n  if (DAT_0020a101 == '\\0') {\n    FUN_000030af(local_30,local_28);\n  }\n  else {\n    FUN_00002f39(local_30,local_28);\n  }\n  free(local_28);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is who"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *param_1,void **param_2,char **param_3)\n\n{\n  char *pcVar1;\n  void *__dest;\n  size_t __n;\n  char *local_30;\n  char *local_28;\n  \n  local_28 = strchr(param_1,0x3a);\n  local_30 = local_28;\n  if (local_28 == (char *)0x0) {\n    pcVar1 = \"sieve_action_vacation\";\n  }\n  else {\n    while (((param_1 < local_30 && (-1 < local_30[-1])) &&\n           ((*(uint *)(PTR_mu_c_tab_00204fe8 + (ulong)(uint)(int)local_30[-1] * 4) & 0x200) != 0)))\n    {\n      local_30 = local_30 + -1;\n    }\n    if (local_30 == param_1) {\n      pcVar1 = \"sieve_action_vacation\";\n    }\n    else {\n      __n = (long)local_30 - (long)param_1;\n      __dest = malloc(__n + 1);\n      if (__dest == (void *)0x0) {\n        pcVar1 = \"\";\n      }\n      else {\n        memcpy(__dest,param_1,__n);\n        *(undefined *)(__n + (long)__dest) = 0;\n        do {\n          local_28 = local_28 + 1;\n          if ((*local_28 == '\\0') || (*local_28 < '\\0')) break;\n        } while ((*(uint *)(PTR_mu_c_tab_00204fe8 + (ulong)(uint)(int)*local_28 * 4) & 0x200) != 0);\n        pcVar1 = strdup(local_28);\n        if (pcVar1 == (char *)0x0) {\n          free(__dest);\n          pcVar1 = \"\";\n        }\n        else {\n          *param_2 = __dest;\n          *param_3 = pcVar1;\n          pcVar1 = (char *)0x0;\n        }\n      }\n    }\n  }\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is header_split"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  *(undefined8 *)PTR_gcide_markup_yyin_00212fc0 = param_1;\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyset_in"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                 undefined8 param_5)\n\n{\n  if (DAT_002053c0 == (code *)0x0) {\n    EVP_PKEY_meth_get_encrypt(DAT_00205350,0,&DAT_002053c0);\n  }\n  (*DAT_002053c0)(param_1,param_2,param_3,param_4,param_5);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_rsa_decrypt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = wget_hashmap_get(DAT_00253bf0,param_1,&local_18);\n  if (iVar1 == 0) {\n    local_18 = 0;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_18;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is blacklist_get"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined * [MASK](void)\n\n{\n  return &DAT_002107a0;\n}\n\n",
        "output": "The predicted function name is ASN1_INT64_DATA_it"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,long param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  if (*(int *)(param_2 + 0x21c) == 0) {\n    uVar2 = 1;\n  }\n  else {\n    iVar1 = FUN_00012c68(\"test/ssl_test.c\",0x99,\"result->session_id\",\"test_ctx->session_id_expected\"\n                         ,*(undefined4 *)(param_1 + 0x90),*(undefined4 *)(param_2 + 0x21c));\n    if (iVar1 == 0) {\n      uVar2 = FUN_0000a3b9(*(undefined4 *)(param_1 + 0x90));\n      uVar3 = FUN_0000a3b9(*(undefined4 *)(param_2 + 0x21c));\n      FUN_0001261b(\"test/ssl_test.c\",0x9c,\n                   \"Client SessionIdExpected mismatch, expected %s, got %s\\n.\",uVar3,uVar2);\n      uVar2 = 0;\n    }\n    else {\n      uVar2 = 1;\n    }\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is check_session_id"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *param_1,int param_2,uint param_3)\n\n{\n  int iVar1;\n  \n  iVar1 = open(param_1,param_2,(ulong)param_3);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is wa_open"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\ndouble [MASK](long param_1)\n\n{\n  int iVar1;\n  double dVar2;\n  \n  iVar1 = dxf_cvt_lweight(*(undefined *)(param_1 + 0x92));\n  dVar2 = DAT_000067b8;\n  if (-1 < iVar1) {\n    dVar2 = (double)iVar1 * DAT_000067b0;\n  }\n  return dVar2;\n}\n\n",
        "output": "The predicted function name is entity_lweight"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined4 param_2)\n\n{\n  *(undefined4 *)(param_1 + 4) = param_2;\n  return;\n}\n\n",
        "output": "The predicted function name is ping_set_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](char *param_1,char *param_2)\n\n{\n  int iVar1;\n  char *local_18;\n  char *local_10;\n  \n  local_18 = param_1;\n  for (local_10 = param_2; (*local_18 != '\\0' && (*local_10 != '\\0')); local_10 = local_10 + 1) {\n    if ((*local_10 == '-') || (*local_10 == '_')) {\n      if ((*local_18 == '-') || (*local_18 == '_')) {\n        local_18 = local_18 + 1;\n      }\n      local_10 = local_10 + 1;\n    }\n    if ((*local_18 == '\\0') || (*local_10 == '\\0')) break;\n    iVar1 = FUN_0002857d((int)*local_18);\n    if (iVar1 != *local_10) break;\n    local_18 = local_18 + 1;\n  }\n  return *local_18 != *local_10;\n}\n\n",
        "output": "The predicted function name is opt_compare_config_linear"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,char *param_2)\n\n{\n  int iVar1;\n  char *__s;\n  char *pcVar2;\n  int local_14;\n  \n  local_14 = 0;\n  do {\n    iVar1 = wget_vector_size(param_1);\n    if (iVar1 <= local_14) {\n      return 0;\n    }\n    __s = (char *)wget_vector_get(param_1,local_14);\n    wget_debug_printf(\"pattern[%d] \\'%s\\' - %s\\n\",local_14,__s,param_2);\n    pcVar2 = strpbrk(__s,\"*?[]\");\n    if (pcVar2 == (char *)0x0) {\n      if (DAT_002533e1 == '\\0') {\n        iVar1 = wget_match_tail(param_2);\n        if (iVar1 != 0) {\n          return 1;\n        }\n      }\n      else {\n        iVar1 = wget_match_tail_nocase(param_2);\n        if (iVar1 != 0) {\n          return 1;\n        }\n      }\n    }\n    else {\n      if (DAT_002533e1 == '\\0') {\n        iVar1 = 0;\n      }\n      else {\n        iVar1 = 0x10;\n      }\n      iVar1 = fnmatch(__s,param_2,iVar1);\n      if (iVar1 == 0) {\n        return 1;\n      }\n    }\n    local_14 = local_14 + 1;\n  } while( true );\n}\n\n",
        "output": "The predicted function name is in_pattern_list"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  if (*(long *)(param_1 + 8) != 0) {\n    (*wget_free)(*(undefined8 *)(param_1 + 8));\n    *(undefined8 *)(param_1 + 8) = 0;\n  }\n  wget_iri_free(param_1);\n  if (param_1 != 0) {\n    (*wget_free)(param_1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is free_value"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined2 param_2)\n\n{\n  long in_FS_OFFSET;\n  undefined local_16 [6];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  wget_snprintf(local_16,6,&DAT_00042abb,param_2);\n  FUN_0001c524(param_1,local_16);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is check_status_code_list"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *param_1,char *param_2,int param_3)\n\n{\n  int iVar1;\n  size_t __size;\n  \n  if (((param_1 == (char *)0x0) || (param_2 == (char *)0x0)) || (param_3 < 0)) {\n    iVar1 = -1;\n  }\n  else {\n    __size = strlen(param_2);\n    iVar1 = fsetxattr(param_3,param_1,param_2,__size,0);\n    if (iVar1 < 0) {\n      iVar1 = -1;\n    }\n    else {\n      iVar1 = 0;\n    }\n    if (iVar1 != 0) {\n      wget_debug_printf(\"Failed to set xattr %s.\\n\",param_1);\n    }\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is write_xattr_metadata"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SSL **param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  int local_14;\n  \n  local_14 = 1;\n  iVar1 = FUN_00012c68(\"test/helpers/handshake.c\",0x321,\"peer->status\",\"PEER_RETRY\",\n                       *(undefined4 *)((long)param_1 + 0x2c),1);\n  if (iVar1 == 0) {\n    *(undefined4 *)((long)param_1 + 0x2c) = 4;\n  }\n  else {\n    do {\n      while( true ) {\n        if ((local_14 < 1) || (*(int *)(param_1 + 5) == 0)) {\n          iVar1 = *(int *)((long)param_1 + 0x24);\n          if (*(int *)(param_1 + 2) <= *(int *)((long)param_1 + 0x24)) {\n            iVar1 = *(int *)(param_1 + 2);\n          }\n          if (iVar1 != 0) {\n            iVar2 = SSL_write(*param_1,param_1[1],iVar1);\n            if (iVar2 < 1) {\n              *(undefined4 *)((long)param_1 + 0x2c) = 2;\n              return;\n            }\n            iVar1 = FUN_00012c68(\"test/helpers/handshake.c\",0x342,&DAT_00017f88,\"write_bytes\",iVar2,\n                                 iVar1);\n            if (iVar1 == 0) {\n              *(undefined4 *)((long)param_1 + 0x2c) = 4;\n              return;\n            }\n            *(int *)((long)param_1 + 0x24) = *(int *)((long)param_1 + 0x24) - iVar2;\n          }\n          if (*(int *)((long)param_1 + 0x24) != 0) {\n            return;\n          }\n          if (*(int *)(param_1 + 5) != 0) {\n            return;\n          }\n          *(undefined4 *)((long)param_1 + 0x2c) = 0;\n          return;\n        }\n        local_14 = SSL_read(*param_1,param_1[3],*(int *)(param_1 + 4));\n        if (local_14 < 1) break;\n        iVar1 = FUN_00012de5(\"test/helpers/handshake.c\",0x32a,&DAT_00017f88,\"peer->bytes_to_read\",\n                             local_14,*(undefined4 *)(param_1 + 5));\n        if (iVar1 == 0) {\n          *(undefined4 *)((long)param_1 + 0x2c) = 4;\n          return;\n        }\n        *(int *)(param_1 + 5) = *(int *)(param_1 + 5) - local_14;\n      }\n      if (local_14 == 0) {\n        *(undefined4 *)((long)param_1 + 0x2c) = 2;\n        return;\n      }\n      iVar1 = SSL_get_error(*param_1,local_14);\n    } while (iVar1 == 2);\n    *(undefined4 *)((long)param_1 + 0x2c) = 2;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is do_app_data_step"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00010a72(stderr,param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is write_error_stderr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_000036d5(0x30,2,1);\n  return;\n}\n\n",
        "output": "The predicted function name is test_http_keep_alive_0_require_yes"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  undefined8 local_18;\n  \n  local_18 = 0;\n  ptr = (void *)FUN_000037e4(&DAT_00013c6c,\"secret\",6,&DAT_00013cf5,\"label\");\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x136,\"params\",ptr);\n  if (iVar1 != 0) {\n    local_18 = FUN_00002d68(&DAT_00013d1b);\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x137,\"kctx = get_kdfbyname(OSSL_KDF_NAME_HKDF)\",\n                         local_18);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_18,ptr);\n      iVar1 = FUN_0000e3f6(\"test/evp_kdf_test.c\",0x138,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        uVar2 = 1;\n        goto LAB_00004108;\n      }\n    }\n  }\n  uVar2 = 0;\nLAB_00004108:\n  EVP_KDF_CTX_free(local_18);\n  CRYPTO_free(ptr);\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_hkdf_invalid_digest"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  size_t sVar1;\n  long in_FS_OFFSET;\n  long local_30;\n  long local_20;\n  char *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = param_1;\n  while (*(char *)(local_30 + DAT_00215a50) != '\\0') {\n    local_18 = (char *)gcide_grk_to_utf8(DAT_00215a50 + local_30,&local_20);\n    if (local_18 == (char *)0x0) {\n      FUN_0000ca59((int)*(char *)(local_30 + DAT_00215a50));\n      local_30 = local_30 + 1;\n    }\n    else {\n      sVar1 = strlen(local_18);\n      FUN_0000c999(local_18,sVar1);\n      local_30 = local_30 + local_20;\n    }\n  }\n  FUN_0000caa1();\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is greek_translit"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  FUN_0000b30f(param_1 + 0x18);\n  FUN_0000b30f(param_1 + 0xe0);\n  return;\n}\n\n",
        "output": "The predicted function name is ssl_test_ctx_free_extra_data"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong [MASK](char *param_1,void **param_2,undefined8 *param_3)\n\n{\n  int iVar1;\n  ulong uVar2;\n  void *pvVar3;\n  long in_FS_OFFSET;\n  undefined8 local_20;\n  size_t local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = strcmp(param_1,\"NULL\");\n  if (iVar1 == 0) {\n    *param_2 = (void *)0x0;\n    *param_3 = 0;\n    uVar2 = 1;\n  }\n  else if (*param_1 == '\\0') {\n    pvVar3 = CRYPTO_malloc(1,\"test/evp_test.c\",0x125);\n    *param_2 = pvVar3;\n    if (*param_2 == (void *)0x0) {\n      uVar2 = 0;\n    }\n    else {\n      *(undefined *)*param_2 = 0;\n      *param_3 = 0;\n      uVar2 = 1;\n    }\n  }\n  else if (*param_1 == '\\\"') {\n    param_1 = param_1 + 1;\n    local_18 = strlen(param_1);\n    if ((local_18 == 0) || (param_1[local_18 - 1] != '\\\"')) {\n      uVar2 = 0;\n    }\n    else {\n      local_18 = local_18 - 1;\n      pvVar3 = (void *)FUN_00006572(param_1,local_18,param_3);\n      *param_2 = pvVar3;\n      uVar2 = (ulong)(*param_2 != (void *)0x0);\n    }\n  }\n  else {\n    pvVar3 = (void *)OPENSSL_hexstr2buf(param_1,&local_20);\n    *param_2 = pvVar3;\n    iVar1 = FUN_00018f92(\"test/evp_test.c\",0x139,\"*buf = OPENSSL_hexstr2buf(value, &len)\",*param_2);\n    if (iVar1 == 0) {\n      FUN_00016f06(\"test/evp_test.c\",0x13a,\"Can\\'t convert %s\",param_1);\n      FUN_00017533();\n      uVar2 = 0xffffffff;\n    }\n    else {\n      *param_3 = local_20;\n      uVar2 = 1;\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is parse_bin"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  *(undefined8 *)(param_1 + 0x38) = param_2;\n  return;\n}\n\n",
        "output": "The predicted function name is impl_register_post_processor"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined ** [MASK](undefined4 param_1)\n\n{\n  _DAT_002130c8 = param_1;\n  return &PTR_DAT_002124e0;\n}\n\n",
        "output": "The predicted function name is fake_rsa_keymgmt_imptypes"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  long lVar4;\n  undefined8 *puVar5;\n  long in_FS_OFFSET;\n  byte bVar6;\n  long local_f8;\n  long local_f0;\n  long local_e8;\n  undefined8 *local_e0;\n  undefined8 local_d8 [3];\n  long local_c0;\n  long local_20;\n  \n  bVar6 = 0;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_e8 = wget_read_file(param_1,0);\n  if (local_e8 != 0) {\n    local_f8 = wget_metalink_parse(local_e8);\n    if (*(long *)(local_f8 + 0x20) < 1) {\n      uVar3 = *(undefined8 *)(local_f8 + 0x20);\n      uVar2 = gettext(\"Invalid file length %llu\\n\");\n      wget_error_printf(uVar2,uVar3);\n      wget_metalink_free(&local_f8);\n    }\n    else if (*(long *)(local_f8 + 8) == 0) {\n      uVar3 = gettext(\"No download mirrors found\\n\");\n      wget_error_printf(uVar3);\n      wget_metalink_free(&local_f8);\n    }\n    else {\n      puVar5 = local_d8;\n      for (lVar4 = 0x16; lVar4 != 0; lVar4 = lVar4 + -1) {\n        *puVar5 = 0;\n        puVar5 = puVar5 + (ulong)bVar6 * -2 + 1;\n      }\n      local_c0 = local_f8;\n      iVar1 = FUN_0000fea0(local_d8);\n      if (iVar1 == 0) {\n        wget_metalink_sort_mirrors(local_f8);\n        local_e0 = (undefined8 *)wget_vector_get(*(undefined8 *)(local_f8 + 8),0);\n        local_f0 = FUN_0000e8bf(*local_e0);\n        if (local_f0 == 0) {\n          local_f0 = FUN_0000e9fe(*local_e0);\n        }\n        FUN_0000f20f(local_f0,local_d8);\n      }\n      else {\n        wget_metalink_free(&local_f8);\n      }\n    }\n    if (local_e8 != 0) {\n      (*wget_free)(local_e8);\n      local_e8 = 0;\n    }\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is metalink_parse_localfile"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00009ddc(&PTR_s_UnknownCA_0021ee80,7,param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is parse_alert"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](BIO *param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  int local_3c;\n  undefined8 local_38;\n  long local_30;\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = BIO_ctrl(param_1,3,0,&local_38);\n  if (local_30 < 0) {\n    uVar2 = 0;\n  }\n  else {\n    iVar1 = FUN_00003567(local_28,local_38,local_30);\n    if (iVar1 == 0) {\n      uVar2 = 0;\n    }\n    else {\n      iVar1 = FUN_000036e5(local_28,&local_3c);\n      if ((iVar1 == 0) || (local_3c != 0x14)) {\n        uVar2 = 0;\n      }\n      else {\n        iVar1 = FUN_0000365d(local_28,&local_3c);\n        if ((iVar1 == 0) || (local_3c != 0x100)) {\n          uVar2 = 0;\n        }\n        else {\n          iVar1 = FUN_0000385b(local_28,10);\n          if (iVar1 == 0) {\n            uVar2 = 0;\n          }\n          else {\n            iVar1 = FUN_000036e5(local_28,&local_3c);\n            if ((iVar1 == 0) || (local_3c != 1)) {\n              uVar2 = 0;\n            }\n            else {\n              iVar1 = FUN_0000365d(local_28,&local_3c);\n              if ((iVar1 == 0) || (local_3c != 2)) {\n                uVar2 = 0;\n              }\n              else {\n                iVar1 = FUN_000036e5(local_28,&local_3c);\n                if ((iVar1 == 0) || (local_3c != 0x16)) {\n                  uVar2 = 0;\n                }\n                else {\n                  iVar1 = FUN_0000365d(local_28,&local_3c);\n                  if ((iVar1 == 0) || (local_3c != 0x100)) {\n                    uVar2 = 0;\n                  }\n                  else {\n                    iVar1 = FUN_0000365d(local_28,&local_3c);\n                    if ((iVar1 == 0) || (local_3c != 1)) {\n                      uVar2 = 0;\n                    }\n                    else {\n                      uVar2 = 1;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is validate_ccs"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2,char *param_3)\n\n{\n  long lVar1;\n  int iVar2;\n  undefined8 uVar3;\n  \n  lVar1 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  iVar2 = strcmp(param_2,\"id\");\n  if (iVar2 == 0) {\n    iVar2 = atoi(param_3);\n    *(int *)(lVar1 + 0x28) = iVar2;\n    if (*(int *)(lVar1 + 0x28) < 1) {\n      uVar3 = 0xffffffff;\n    }\n    else {\n      uVar3 = 1;\n    }\n  }\n  else {\n    uVar3 = FUN_0000c67a(param_1,param_2,param_3);\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is pkcs12_test_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Type propagation algorithm not settling */\n\nvoid [MASK](undefined8 param_1)\n\n{\n  int iVar1;\n  char *pcVar2;\n  \n  FUN_000061e7(DAT_00214a50,0xd);\n  FUN_00006846(DAT_00214a50,FUN_00005d18,0);\n  FUN_00006871(DAT_00214a50,0x14);\n  iVar1 = FUN_0000688c(DAT_00214a50,param_1);\n  if (iVar1 != 0) {\n    error(1,0,\"unknown host\");\n  }\n  pcVar2 = inet_ntoa((in_addr)((in_addr *)(DAT_00214a50 + 0x2c))->s_addr);\n  printf(\"PING %s (%s): sending timestamp requests\\n\",*(undefined8 *)(DAT_00214a50 + 0x48),pcVar2);\n  FUN_0000349f(DAT_00214a50,FUN_00005f58);\n  return;\n}\n\n",
        "output": "The predicted function name is ping_timestamp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  void *__ptr;\n  undefined8 uVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  char local_2c [12];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  __ptr = (void *)FUN_000029a3(param_1);\n  sprintf(local_2c,\"%ld\",(long)*(int *)(param_1 + 4));\n  uVar1 = FUN_00002192(param_1);\n  uVar2 = gettext(\"LOGIN\");\n  FUN_00002228(0xffffffff,uVar2,0x20,0x20,param_1 + 8,uVar1,&DAT_000073d6,local_2c,__ptr,\n               &DAT_000073d6);\n  free(__ptr);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is print_login"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0001c422(param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is check_statuscode_list"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  FUN_0000ae56(param_1 + 0x200,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is parse_expected_client_sign_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (DAT_002053b8 == (code *)0x0) {\n    EVP_PKEY_meth_get_decrypt(DAT_00205350,&DAT_002053b8,0);\n  }\n  if (DAT_002053b8 == (code *)0x0) {\n    uVar1 = 1;\n  }\n  else {\n    uVar1 = (*DAT_002053b8)(param_1);\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is dasync_rsa_decrypt_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  ASN1_ITEM *it;\n  \n  it = (ASN1_ITEM *)FUN_00002e02();\n  ASN1_item_new(it);\n  return;\n}\n\n",
        "output": "The predicted function name is ASN1_UINT64_DATA_new"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void **param_1)\n\n{\n  free(*param_1);\n  FUN_0000cc1e(param_1[2],0);\n  free(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_parse_tree_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  \n  uVar1 = EVP_KDF_fetch(param_1,param_2,0);\n  uVar2 = EVP_KDF_CTX_new(uVar1);\n  EVP_KDF_free(uVar1);\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is get_kdfbyname_libctx"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ASN1_VALUE **param_1,uchar **param_2,long param_3)\n\n{\n  ASN1_ITEM *it;\n  \n  it = (ASN1_ITEM *)FUN_00002ac0();\n  ASN1_item_d2i(param_1,param_2,param_3,it);\n  return;\n}\n\n",
        "output": "The predicted function name is d2i_ASN1_INT32_DATA"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  long in_FS_OFFSET;\n  code *pcStack168;\n  ulong uStack16;\n  \n  uStack16 = *(ulong *)(in_FS_OFFSET + 0x28);\n  wget_global_init(0);\n  FUN_0000dbc9();\n  FUN_0000e742();\n  wget_thread_mutex_init(&DAT_00253d08);\n  wget_thread_mutex_init(&DAT_00253d10);\n  wget_thread_mutex_init(&DAT_00253d18);\n  wget_thread_mutex_init(&DAT_00253d20);\n  wget_thread_mutex_init(&DAT_00253d28);\n  wget_thread_mutex_init(&DAT_00253d30);\n  wget_thread_mutex_init(&DAT_00253d38);\n  wget_thread_mutex_init(&DAT_00253cd8);\n  wget_thread_cond_init(&DAT_00253d40);\n  wget_thread_cond_init(&DAT_00253d48);\n  setlocale(6,\"\");\n  bindtextdomain(&DAT_000419fc,\n                 \"/home/xin/Downloads/gnu_projects/compilation/x86_64/O0/compile_projects_copy/wget2-2.0.1/build/share/locale\"\n                );\n  textdomain(&DAT_000419fc);\n  memset(&stack0xffffffffffffff58,0,0x98);\n  pcStack168 = (code *)0x1;\n  sigaction(0xd,(sigaction *)&stack0xffffffffffffff58,(sigaction *)0x0);\n  pcStack168 = FUN_00012eeb;\n  sigaction(0xf,(sigaction *)&stack0xffffffffffffff58,(sigaction *)0x0);\n  sigaction(2,(sigaction *)&stack0xffffffffffffff58,(sigaction *)0x0);\n  sigaction(0x1c,(sigaction *)&stack0xffffffffffffff58,(sigaction *)0x0);\n  DAT_00253cc8 = wget_hashmap_create(0x80,FUN_00019fb3,PTR_strcmp_00252ff0);\n  FUN_00011d0c();\n  FUN_00010ea5(\"/home/xin/Downloads/gnu_projects/compilation/x86_64/O0/compile_projects_copy/wget2-2.0.1/build/lib/wget2/plugins\"\n               ,0);\n  if (uStack16 != *(ulong *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is program_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8\n[MASK](long param_1,undefined8 param_2,int param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  int local_24;\n  EVP_PKEY *local_20;\n  undefined8 *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = (EVP_PKEY *)0x0;\n  local_24 = 0;\n  if (param_3 != 0) {\n    local_24 = FUN_00010ea5(&local_20,param_2,DAT_002241b8);\n  }\n  if (local_24 == 0) {\n    local_24 = FUN_00010ea5(&local_20,param_2,DAT_002241b0);\n  }\n  if ((local_24 == 0) || (local_20 == (EVP_PKEY *)0x0)) {\n    FUN_00016f06(\"test/evp_test.c\",0x6a0,\"skipping, key \\'%s\\' is disabled\",param_2);\n    *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n    uVar2 = 1;\n  }\n  else {\n    local_18 = (undefined8 *)CRYPTO_zalloc(0x30,\"test/evp_test.c\",0x6a5);\n    iVar1 = FUN_00018f92(\"test/evp_test.c\",0x6a5,\"kdata = OPENSSL_zalloc(sizeof(*kdata))\",local_18);\n    if (iVar1 == 0) {\n      EVP_PKEY_free(local_20);\n      uVar2 = 0;\n    }\n    else {\n      local_18[1] = param_5;\n      uVar2 = EVP_PKEY_CTX_new_from_pkey(DAT_002241a8,local_20,0);\n      *local_18 = uVar2;\n      iVar1 = FUN_00018f92(\"test/evp_test.c\",0x6aa,\n                           \"kdata->ctx = EVP_PKEY_CTX_new_from_pkey(libctx, pkey, NULL)\",*local_18);\n      if (iVar1 == 0) {\n        EVP_PKEY_free(local_20);\n        CRYPTO_free(local_18);\n        uVar2 = 0;\n      }\n      else {\n        iVar1 = (*param_4)(*local_18);\n        if (iVar1 < 1) {\n          *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KEYOP_INIT_ERROR\";\n        }\n        *(undefined8 **)(\"EVP_PKEY_verify_recover_init\" + param_1) = local_18;\n        uVar2 = 1;\n      }\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is pkey_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  wget_hashmap_free(&DAT_00253c48);\n  wget_thread_mutex_destroy(&DAT_00253c50);\n  return;\n}\n\n",
        "output": "The predicted function name is server_stats_exit"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](EVP_MD_CTX *param_1,void *param_2,size_t param_3)\n\n{\n  EVP_DigestUpdate(param_1,param_2,param_3);\n  return;\n}\n\n",
        "output": "The predicted function name is digest_update_fn"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *param_1,char param_2,undefined8 param_3)\n\n{\n  char *local_18;\n  char *local_10;\n  \n  local_18 = param_1;\n  local_10 = param_1;\n  while (*local_18 != '\\0') {\n    local_18 = strchrnul(local_10,(int)param_2);\n    if (local_10 < local_18) {\n      wget_strmemdup(local_10,(long)local_18 - (long)local_10);\n      wget_vector_add(param_3);\n    }\n    local_10 = local_18 + 1;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is split_string"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  FUN_0000e18b(*(undefined8 *)(param_1 + 0x18));\n  (*wget_free)(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is plugin_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](undefined8 param_1,undefined8 *param_2)\n\n{\n  size_t sVar1;\n  bool bVar2;\n  char cVar3;\n  int iVar4;\n  undefined4 uVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  ulong uVar10;\n  long in_FS_OFFSET;\n  undefined local_4b4 [4];\n  int local_4b0;\n  undefined4 local_4ac;\n  size_t local_4a8;\n  int local_4a0;\n  int local_49c;\n  undefined8 local_498;\n  undefined8 local_490;\n  undefined8 local_488;\n  undefined local_478 [79];\n  char acStack1065 [1033];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_4ac = 0xffffffff;\n  bVar2 = false;\n  local_4a8 = 0;\n  local_498 = DAT_00253250;\n  local_488 = 0;\n  local_490 = param_1;\n  iVar4 = pipe(&local_4a0);\n  if (iVar4 == -1) {\n    uVar6 = gettext(\"Cannot create pipe\");\n    wget_error_printf(uVar6);\n    uVar5 = 0xffffffff;\n  }\n  else {\n    local_4b0 = FUN_00028ad2(local_478);\n    if (local_4b0 == 0) {\n      bVar2 = true;\n      local_4b0 = FUN_00028890(local_478,local_4a0);\n      if (local_4b0 == 0) {\n        local_4b0 = FUN_0002892c(local_478,local_49c,1);\n      }\n      if (local_4b0 == 0) {\n        local_4b0 = FUN_00028890(local_478,local_49c);\n      }\n      if (local_4b0 == 0) {\n        cVar3 = FUN_000279a5();\n        if ((cVar3 == '\\x01') ||\n           (local_4b0 = FUN_00028afb(local_4b4,DAT_00253250,local_478,0,&local_498,environ),\n           uVar6 = DAT_00253250, local_4b0 == 0)) {\n          close(local_49c);\n          local_49c = -1;\n          cVar3 = FUN_000279a5();\n          if (cVar3 == '\\x01') {\n            iVar4 = rand();\n            uVar10 = (ulong)iVar4;\n            local_4a8 = uVar10 + ((uVar10 - uVar10 / 0x3ff >> 1) + uVar10 / 0x3ff >> 9) * -0x3ff;\n            memset(acStack1065 + 1,0x78,local_4a8);\n          }\n          else {\n            local_4a8 = read(local_4a0,acStack1065 + 1,0x3ff);\n          }\n          if ((long)local_4a8 < 1) {\n            piVar8 = __errno_location();\n            pcVar9 = strerror(*piVar8);\n            uVar6 = DAT_00253250;\n            uVar7 = gettext(\"Error reading response from command \\\"%s %s\\\": %s\\n\");\n            wget_error_printf(uVar7,uVar6,param_1,pcVar9);\n          }\n          else {\n            acStack1065[local_4a8 + 1] = '\\0';\n            sVar1 = local_4a8;\n            while ((local_4a8 = sVar1 - 1, -1 < (long)local_4a8 &&\n                   ((acStack1065[sVar1] == '\\n' || (acStack1065[sVar1] == '\\r'))))) {\n              acStack1065[sVar1] = '\\0';\n              sVar1 = local_4a8;\n            }\n            uVar6 = wget_strdup();\n            *param_2 = uVar6;\n            local_4ac = 0;\n          }\n        }\n        else {\n          uVar7 = gettext(\"Error spawning %s: %d\");\n          wget_error_printf(uVar7,uVar6,local_4b0);\n        }\n      }\n      else {\n        uVar6 = gettext(\"Error setting spawn file actions for use-askpass: %d\");\n        wget_error_printf(uVar6,local_4b0);\n      }\n    }\n    else {\n      uVar6 = gettext(\"Error initializing spawn file actions for use-askpass: %d\");\n      wget_error_printf(uVar6,local_4b0);\n    }\n    if (local_49c != -1) {\n      close(local_49c);\n    }\n    if (local_4a0 != -1) {\n      close(local_4a0);\n    }\n    uVar5 = local_4ac;\n    if (bVar2) {\n      FUN_000289e3(local_478);\n      uVar5 = local_4ac;\n    }\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar5;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is run_use_askpass"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](double *param_1)\n\n{\n  double dVar1;\n  double in_stack_00000008;\n  double in_stack_00000010;\n  double in_stack_00000018;\n  \n  dVar1 = sqrt(in_stack_00000018 * in_stack_00000018 +\n               in_stack_00000008 * in_stack_00000008 + in_stack_00000010 * in_stack_00000010);\n  *param_1 = in_stack_00000008;\n  param_1[1] = in_stack_00000010;\n  param_1[2] = in_stack_00000018;\n  if ((DAT_000067f0 != dVar1) && (dVar1 != 0.0)) {\n    *param_1 = in_stack_00000008 / dVar1;\n    param_1[1] = in_stack_00000010 / dVar1;\n    param_1[2] = in_stack_00000018 / dVar1;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is normalize"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](undefined8 param_1,char *param_2,long param_3)\n\n{\n  bool bVar1;\n  int iVar2;\n  int iVar3;\n  size_t sVar4;\n  void *__dest;\n  char *pcVar5;\n  bool bVar6;\n  undefined4 local_2c;\n  undefined **local_20;\n  \n  local_20 = &PTR_DAT_002125a0;\n  bVar1 = false;\n  while( true ) {\n    if (*local_20 == (char *)0x0) {\n      return !bVar1;\n    }\n    iVar2 = OPENSSL_strcasecmp(param_2,*local_20);\n    bVar6 = iVar2 == 0;\n    sVar4 = strlen(*local_20);\n    __dest = CRYPTO_malloc((int)sVar4 + 1,\"test/v3nametest.c\",0x120);\n    iVar2 = FUN_000085b0(\"test/v3nametest.c\",0x123,&DAT_0000eb45,__dest);\n    if (iVar2 == 0) break;\n    memcpy(__dest,*local_20,sVar4 + 1);\n    local_2c = 0xffffffff;\n    iVar2 = X509_check_host(param_1,__dest,sVar4,0,0);\n    iVar3 = FUN_00006dec(\"test/v3nametest.c\",0x129,\n                         \"ret = X509_check_host(crt, name, namelen, 0, NULL)\",&DAT_0000eb4a,iVar2,0)\n    ;\n    if (iVar3 == 0) {\n      bVar1 = true;\n    }\n    else if (*(int *)(param_3 + 0x10) == 0) {\n      if (iVar2 == 1) {\n        local_2c = 1;\n      }\n    }\n    else {\n      if ((iVar2 == 1) && (!bVar6)) {\n        local_2c = 1;\n      }\n      if ((iVar2 == 0) && (bVar6)) {\n        local_2c = 0;\n      }\n    }\n    iVar2 = FUN_00003e1d(param_3,&DAT_0000eb83,param_2,local_2c,*local_20);\n    iVar2 = FUN_00008625(\"test/v3nametest.c\",0x132,\n                         \"check_message(fn, \\\"host\\\", nameincert, match, *pname)\",iVar2 != 0);\n    if (iVar2 == 0) {\n      bVar1 = true;\n    }\n    local_2c = 0xffffffff;\n    iVar2 = X509_check_host(param_1,__dest,sVar4,2,0);\n    iVar3 = FUN_00006dec(\"test/v3nametest.c\",0x138,\n                         \"ret = X509_check_host(crt, name, namelen, X509_CHECK_FLAG_NO_WILDCARDS, NULL)\"\n                         ,&DAT_0000eb4a,iVar2,0);\n    if (iVar3 == 0) {\n      bVar1 = true;\n    }\n    else if (*(int *)(param_3 + 0x10) == 0) {\n      if (iVar2 == 1) {\n        local_2c = 1;\n      }\n    }\n    else {\n      if ((iVar2 == 1) && (!bVar6)) {\n        local_2c = 1;\n      }\n      if ((iVar2 == 0) && (bVar6)) {\n        local_2c = 0;\n      }\n    }\n    iVar2 = FUN_00003e1d(param_3,\"host-no-wildcards\",param_2,local_2c,*local_20);\n    iVar2 = FUN_00008625(\"test/v3nametest.c\",0x142,\n                         \"check_message(fn, \\\"host-no-wildcards\\\", nameincert, match, *pname)\",\n                         iVar2 != 0);\n    if (iVar2 == 0) {\n      bVar1 = true;\n    }\n    local_2c = 0xffffffff;\n    iVar2 = X509_check_email(param_1,__dest,sVar4,0);\n    if (*(int *)(param_3 + 0x14) == 0) {\n      if (iVar2 != 0) {\n        local_2c = 1;\n      }\n    }\n    else {\n      if ((iVar2 != 0) && (!bVar6)) {\n        local_2c = 1;\n      }\n      if (((iVar2 == 0) && (bVar6)) && (pcVar5 = strchr(param_2,0x40), pcVar5 != (char *)0x0)) {\n        local_2c = 0;\n      }\n    }\n    iVar2 = FUN_00003e1d(param_3,\"email\",param_2,local_2c,*local_20);\n    iVar2 = FUN_00008625(\"test/v3nametest.c\",0x14e,\n                         \"check_message(fn, \\\"email\\\", nameincert, match, *pname)\",iVar2 != 0);\n    if (iVar2 == 0) {\n      bVar1 = true;\n    }\n    CRYPTO_free(__dest);\n    local_20 = local_20 + 1;\n  }\n  return false;\n}\n\n",
        "output": "The predicted function name is run_cert"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](void)\n\n{\n  byte bVar1;\n  int iVar2;\n  bool local_9;\n  \n  local_9 = true;\n  if (PTR_s__home_xin_Downloads_gnu_projects_00253208 != (undefined *)0x0) {\n    iVar2 = FUN_00022d4b(PTR_s__home_xin_Downloads_gnu_projects_00253208,1);\n    local_9 = iVar2 != 0;\n  }\n  if (DAT_00253210 != 0) {\n    bVar1 = FUN_00022d4b(DAT_00253210,1);\n    local_9 = (local_9 & bVar1) != 0;\n  }\n  return local_9;\n}\n\n",
        "output": "The predicted function name is read_config"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,int param_2)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  int local_18;\n  \n  lVar1 = *(long *)(*(long *)(param_1 + 0x50) + (long)param_2 * 8);\n  *(int *)(lVar1 + 8) = *(int *)(lVar1 + 8) + 1;\n  if (param_2 != 0) {\n    local_18 = param_2 + -1;\n    while ((-1 < local_18 &&\n           (*(uint *)(*(long *)(*(long *)(param_1 + 0x50) + (long)local_18 * 8) + 8) <\n            *(uint *)(lVar1 + 8)))) {\n      local_18 = local_18 + -1;\n    }\n    local_18 = local_18 + 1;\n    if (local_18 != param_2) {\n      uVar2 = *(undefined8 *)(*(long *)(param_1 + 0x50) + (long)param_2 * 8);\n      *(undefined8 *)((long)param_2 * 8 + *(long *)(param_1 + 0x50)) =\n           *(undefined8 *)(*(long *)(param_1 + 0x50) + (long)local_18 * 8);\n      *(undefined8 *)((long)local_18 * 8 + *(long *)(param_1 + 0x50)) = uVar2;\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _cache_promote"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,long param_2,undefined8 param_3,long param_4)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  int iVar3;\n  undefined8 uVar4;\n  int *piVar5;\n  long local_28;\n  \n  if ((*(long *)(param_2 + 0x18) == 0) && (DAT_00253402 != '\\0')) {\n    uVar1 = **(undefined8 **)(param_1 + 0x58);\n    uVar2 = *(undefined8 *)(*(long *)(param_1 + 0x58) + 8);\n    uVar4 = gettext(\"# got header %zu bytes:\\n%s\\n\");\n    wget_info_printf(uVar4,uVar2,uVar1);\n  }\n  *(long *)(param_2 + 0x18) = *(long *)(param_2 + 0x18) + param_4;\n  if (-1 < *(int *)(param_2 + 0x20)) {\n    local_28 = FUN_0003f903(*(undefined4 *)(param_2 + 0x20),param_3,param_4);\n    if ((((local_28 == -1) && (piVar5 = __errno_location(), *piVar5 == 0xb)) &&\n        (DAT_00253cf0 != '\\x01')) &&\n       (iVar3 = wget_ready_2_write(*(undefined4 *)(param_2 + 0x20),1000), 0 < iVar3)) {\n      local_28 = FUN_0003f903(*(undefined4 *)(param_2 + 0x20),param_3,param_4);\n    }\n    if (local_28 == -1) {\n      if (DAT_00253cf0 != '\\x01') {\n        piVar5 = __errno_location();\n        wget_debug_printf(\"Failed to write errno=%d\\n\",*piVar5);\n      }\n      FUN_0001fa1d(3);\n      return 0xffffffff;\n    }\n  }\n  if ((*(long *)(param_2 + 0x10) == 0) || (*(ulong *)(param_2 + 0x18) < *(ulong *)(param_2 + 0x10)))\n  {\n    wget_buffer_memcat(*(undefined8 *)(param_2 + 8),param_3,param_4);\n  }\n  if (DAT_002533d2 != '\\0') {\n    FUN_0000d49c(*(undefined4 *)(param_2 + 0x24),\n                 *(long *)(param_1 + 0x78) - *(long *)(param_1 + 0x80));\n    *(undefined8 *)(param_1 + 0x80) = *(undefined8 *)(param_1 + 0x78);\n  }\n  if (DAT_00253378 != 0) {\n    FUN_0001de03(param_2,param_4);\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is get_body"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_14;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_00009ddc(&PTR_DAT_0021f220,5,&local_14,param_2);\n  if (iVar1 != 0) {\n    *(undefined4 *)(param_1 + 8) = local_14;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1 != 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is parse_max_fragment_len_mode"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  wget_hashmap_get(param_1,param_2,param_3);\n  return;\n}\n\n",
        "output": "The predicted function name is wget_stringmap_get"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2,char param_3)\n\n{\n  long **pplVar1;\n  int iVar2;\n  undefined8 uVar3;\n  long *plVar4;\n  long lVar5;\n  char *local_48;\n  undefined4 local_2c;\n  \n  pplVar1 = *(long ***)(param_1 + 0x18);\n  if ((*pplVar1 != (long *)0x0) && (**pplVar1 != 0)) {\n    (*wget_free)(**pplVar1);\n    **pplVar1 = 0;\n  }\n  if (param_3 == '\\0') {\n    if ((param_2 == (char *)0x0) || (local_48 = strchr(param_2,0x3a), local_48 == (char *)0x0)) {\n      local_2c = 0;\n      local_48 = param_2;\n    }\n    else {\n      iVar2 = wget_strncasecmp_ascii(\"human\",param_2,(long)local_48 - (long)param_2);\n      if ((iVar2 == 0) ||\n         (iVar2 = wget_strncasecmp_ascii(&DAT_000436d9,param_2,(long)local_48 - (long)param_2),\n         iVar2 == 0)) {\n        local_2c = 0;\n      }\n      else {\n        iVar2 = wget_strncasecmp_ascii(&DAT_000436db,param_2,(long)local_48 - (long)param_2);\n        if (iVar2 != 0) {\n          uVar3 = gettext(\"Unknown stats format \\'%s\\'\\n\");\n          wget_error_printf(uVar3,param_2);\n          return 0xffffffff;\n        }\n        local_2c = 1;\n      }\n      local_48 = local_48 + 1;\n    }\n    if (*pplVar1 == (long *)0x0) {\n      plVar4 = (long *)FUN_0001f985(1,0x18);\n      *pplVar1 = plVar4;\n    }\n    plVar4 = *pplVar1;\n    lVar5 = FUN_00027e53(local_48);\n    *plVar4 = lVar5;\n    *(undefined4 *)(*pplVar1 + 2) = local_2c;\n    return 0;\n  }\n  if (*pplVar1 != (long *)0x0) {\n    (*wget_free)(*pplVar1);\n    *pplVar1 = (long *)0x0;\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is parse_stats"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  long in_FS_OFFSET;\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  __gmpz_init_set_ui(local_28,param_2);\n  FUN_00002cd7(param_1,local_28);\n  __gmpz_clear(local_28);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is mp_factor_insert_ui"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_000036d5(0x30,1,1);\n  return;\n}\n\n",
        "output": "The predicted function name is test_http_keep_alive_0_prefer_yes"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,code *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  ulong *puVar2;\n  int local_1c;\n  ulong local_18;\n  \n  local_18 = 0;\n  while( true ) {\n    if (*(ulong *)(param_1 + 0x28) <= local_18) {\n      return 0;\n    }\n    puVar2 = (ulong *)_idx_get_page(param_1,local_18);\n    if (puVar2 == (ulong *)0x0) break;\n    local_1c = 0;\n    while (((ulong)(long)local_1c < *puVar2 &&\n           (iVar1 = (*param_2)(puVar2 + (long)local_1c * 7 + 7,param_3), iVar1 == 0))) {\n      local_1c = local_1c + 1;\n    }\n    local_18 = local_18 + 1;\n  }\n  return 0xffffffff;\n}\n\n",
        "output": "The predicted function name is gcide_idx_enumerate"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *param_1,char *param_2,char *param_3)\n\n{\n  char cVar1;\n  bool bVar2;\n  int iVar3;\n  size_t sVar4;\n  size_t sVar5;\n  char *__dest;\n  char *pcVar6;\n  ulong uVar7;\n  byte bVar8;\n  \n  bVar8 = 0;\n  sVar4 = strlen(param_2);\n  sVar5 = strlen(param_3);\n  __dest = (char *)FUN_0000fbd8(sVar5 + sVar4 + 0xd);\n  *__dest = '\\0';\n  iVar3 = FUN_0000c086(&PTR_s_whois_ripe_net_0021a020,param_1);\n  if ((iVar3 == 0) && (iVar3 = FUN_0000c086(&PTR_s_whois_ra_net_0021a0a0,param_1), iVar3 == 0)) {\n    bVar2 = false;\n  }\n  else {\n    bVar2 = true;\n  }\n  if (bVar2) {\n    uVar7 = 0xffffffffffffffff;\n    pcVar6 = __dest;\n    do {\n      if (uVar7 == 0) break;\n      uVar7 = uVar7 - 1;\n      cVar1 = *pcVar6;\n      pcVar6 = pcVar6 + (ulong)bVar8 * -2 + 1;\n    } while (cVar1 != '\\0');\n    *(undefined8 *)(__dest + (~uVar7 - 1)) = 0x20352e34644d562d;\n    *(undefined *)((long)(__dest + (~uVar7 - 1)) + 8) = 0;\n  }\n  if (*param_2 != '\\0') {\n    if ((bVar2) || (iVar3 = strcmp(param_1,\"whois.corenic.net\"), iVar3 == 0)) {\n      strcat(__dest,param_2);\n    }\n    else {\n      puts(\"Warning: RIPE flags ignored for a traditional server.\");\n    }\n  }\n  if (((!bVar2) &&\n      (((iVar3 = strcmp(param_1,\"whois.arin.net\"), iVar3 == 0 ||\n        (iVar3 = strcmp(param_1,\"whois.nic.mil\"), iVar3 == 0)) &&\n       (iVar3 = strncasecmp(param_3,\"AS\",2), iVar3 == 0)))) &&\n     (('/' < param_3[2] && (param_3[2] < ':')))) {\n    sprintf(__dest,\"a %s\",param_3 + 2);\n    return __dest;\n  }\n  if ((!bVar2) && (iVar3 = strcmp(param_1,\"whois.corenic.net\"), iVar3 == 0)) {\n    sprintf(__dest,\"--machine %s\",param_3);\n    return __dest;\n  }\n  if (((!bVar2) && (iVar3 = strcmp(param_1,\"whois.ncst.ernet.in\"), iVar3 == 0)) &&\n     (pcVar6 = strchr(param_3,0x20), pcVar6 == (char *)0x0)) {\n    sprintf(__dest,\"domain %s\",param_3);\n    return __dest;\n  }\n  if ((bVar2) || (iVar3 = strcmp(param_1,\"whois.nic.ad.jp\"), iVar3 != 0)) {\n    strcat(__dest,param_3);\n    return __dest;\n  }\n  pcVar6 = getenv(\"LANG\");\n  if ((pcVar6 != (char *)0x0) && (iVar3 = strncmp(pcVar6,\"ja\",2), iVar3 == 0)) {\n    strcat(__dest,param_3);\n    return __dest;\n  }\n  sprintf(__dest,\"%s/e\",param_3);\n  return __dest;\n}\n\n",
        "output": "The predicted function name is queryformat"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void **param_1)\n\n{\n  void **ppvVar1;\n  void **local_20;\n  \n  local_20 = param_1;\n  while (local_20 != (void **)0x0) {\n    ppvVar1 = (void **)local_20[2];\n    EVP_PKEY_free((EVP_PKEY *)local_20[1]);\n    CRYPTO_free(*local_20);\n    CRYPTO_free(local_20);\n    local_20 = ppvVar1;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is free_key_list"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_000036d5(0x31,0,0);\n  return;\n}\n\n",
        "output": "The predicted function name is test_http_keep_alive_1_no_no"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long *param_1)\n\n{\n  if (*param_1 != 0) {\n    wget_iri_free(param_1);\n  }\n  if (param_1[1] != 0) {\n    (*wget_free)(param_1[1]);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is plugin_db_forward_url_verdict_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void *param_1)\n\n{\n  if (param_1 != (void *)0x0) {\n    free(*(void **)((long)param_1 + 8));\n    free(param_1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_iterator_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,char *param_2)\n\n{\n  int iVar1;\n  char *__s;\n  char *pcVar2;\n  int local_14;\n  \n  local_14 = 0;\n  do {\n    iVar1 = wget_vector_size(param_1);\n    if (iVar1 <= local_14) {\n      return 0;\n    }\n    __s = (char *)wget_vector_get(param_1,local_14);\n    wget_debug_printf(\"host_pattern[%d] \\'%s\\' - %s\\n\",local_14,__s,param_2);\n    pcVar2 = strpbrk(__s,\"*?[]\");\n    if (pcVar2 == (char *)0x0) {\n      iVar1 = wget_match_tail(__s);\n      if (iVar1 != 0) {\n        return 1;\n      }\n    }\n    else {\n      iVar1 = fnmatch(__s,param_2,0);\n      if (iVar1 == 0) {\n        return 1;\n      }\n    }\n    local_14 = local_14 + 1;\n  } while( true );\n}\n\n",
        "output": "The predicted function name is in_host_pattern_list"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  if (DAT_00253c20 == 0) {\n    DAT_00253c28 = wget_vector_create(0x10,0);\n    DAT_00253c30 = wget_vector_create(0x10,0);\n    wget_vector_set_destructor(DAT_00253c30,FUN_00011260);\n    DAT_00253c38 = wget_stringmap_create(0x10);\n    FUN_00010d9f(DAT_00253c38,0);\n    FUN_00010dc5(DAT_00253c38,0);\n    DAT_00253c40 = 0;\n    DAT_00253c20 = 1;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is plugin_db_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ASN1_VALUE *param_1)\n\n{\n  ASN1_ITEM *it;\n  \n  it = (ASN1_ITEM *)FUN_00002ac0();\n  ASN1_item_free(param_1,it);\n  return;\n}\n\n",
        "output": "The predicted function name is ASN1_INT32_DATA_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  wget_thread_mutex_lock(DAT_00253c08);\n  wget_list_browse(*(undefined8 *)(param_1 + 0x18),FUN_0000f9d8,0);\n  wget_list_free(param_1 + 0x18);\n  if (*(long *)(param_1 + 8) != 0) {\n    FUN_0000fb27(*(undefined8 *)(param_1 + 8));\n    if (*(long *)(param_1 + 8) != 0) {\n      (*wget_free)(*(undefined8 *)(param_1 + 8));\n      *(undefined8 *)(param_1 + 8) = 0;\n    }\n  }\n  if ((*(byte *)(param_1 + 0x36) & 1) != 1) {\n    DAT_00253c10 = DAT_00253c10 - *(int *)(param_1 + 0x28);\n  }\n  *(undefined4 *)(param_1 + 0x28) = 0;\n  wget_thread_mutex_unlock(DAT_00253c08);\n  return;\n}\n\n",
        "output": "The predicted function name is host_queue_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 uVar1;\n  long lVar2;\n  \n  uVar1 = dlsym(*param_1,param_2);\n  lVar2 = dlerror();\n  if (lVar2 != 0) {\n    FUN_0000defe(param_3,lVar2);\n    uVar1 = 0;\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is dl_file_lookup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](undefined8 param_1,uint param_2)\n\n{\n  int in_stack_00000008;\n  \n  if ((param_2 & 0x82) != 0) {\n    DAT_002110c4 = 1;\n    in_stack_00000008 = 0;\n  }\n  return (long)in_stack_00000008;\n}\n\n",
        "output": "The predicted function name is BIO_error_callback"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  uchar local_68 [72];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  FUN_00003950(\"key expansion\",0xd,&DAT_002134c0,0x20,&DAT_002134a0,0x20,&DAT_00213560,0x68,param_2,\n               param_1);\n  iVar1 = EVP_DigestFinal_ex(DAT_002135c8,local_68,(uint *)0x0);\n  if (iVar1 == 0) {\n    uVar3 = 0;\n  }\n  else {\n    uVar3 = EVP_MD_CTX_get0_md(DAT_002135c8);\n    uVar2 = EVP_MD_get_size(uVar3);\n    FUN_00003950(\"server finished\",0xf,local_68,uVar2,0,0,&DAT_002133ac,0xc,param_2,param_1);\n    uVar3 = FUN_00003f99(param_2,0x16,0,&DAT_002133a0,0x18);\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is send_finished"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](int *param_1,undefined4 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  uint uVar1;\n  bool bVar2;\n  int iVar3;\n  undefined8 uVar4;\n  ssize_t sVar5;\n  int *piVar6;\n  long in_FS_OFFSET;\n  uint local_64;\n  undefined8 *local_58;\n  long local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined local_38 [16];\n  long local_28;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_64 = 0;\n  bVar2 = false;\n  local_50 = 0;\n  local_48 = 0;\n  local_40 = 0;\n  if ((param_1[1] == 0) && (iVar3 = FUN_00001c02(param_1), iVar3 == 0)) {\n    uVar4 = 0;\n  }\n  else {\n    local_58 = (undefined8 *)(param_1 + 0xc);\n    memset(local_58,0,0x40);\n    *(undefined4 *)((long)local_58 + 0x14) = param_2;\n    *(undefined2 *)(local_58 + 2) = 0;\n    local_58[3] = param_3;\n    local_58[5] = 0;\n    *local_58 = 0;\n    local_58[4] = param_4;\n    *(undefined4 *)(local_58 + 7) = 1;\n    *(int *)((long)local_58 + 0x3c) = *param_1;\n    iVar3 = FUN_00001b60(*(undefined8 *)(param_1 + 2),1,&local_58);\n    if (iVar3 < 0) {\n      fprintf(*(FILE **)PTR_stderr_00203ff8,\"ALG_PERR: %s(%d): io_read failed : \",\n              \"engines/e_afalg.c\",0x132);\n      perror((char *)0x0);\n      uVar4 = 0;\n    }\n    else {\n      do {\n        ASYNC_pause_job();\n        sVar5 = read(*param_1,&local_50,8);\n        if ((int)sVar5 < 0) {\n          piVar6 = __errno_location();\n          if ((*piVar6 != 0xb) && (piVar6 = __errno_location(), *piVar6 != 0xb)) {\n            fprintf(*(FILE **)PTR_stderr_00203ff8,\"ALG_PERR: %s(%d): read failed for event fd : \",\n                    \"engines/e_afalg.c\",0x13f);\n            perror((char *)0x0);\n            uVar4 = 0;\n            goto LAB_000021d5;\n          }\n        }\n        else if (local_50 != 0) {\n          iVar3 = FUN_00001b94(*(undefined8 *)(param_1 + 2),1,1,local_38,&local_48);\n          if (iVar3 < 1) {\n            if (iVar3 < 0) {\n              fprintf(*(FILE **)PTR_stderr_00203ff8,\"ALG_PERR: %s(%d): io_getevents failed : \",\n                      \"engines/e_afalg.c\",0x173);\n              perror((char *)0x0);\n              uVar4 = 0;\n              goto LAB_000021d5;\n            }\n          }\n          else if (local_28 < 0) {\n            if ((local_28 != -0x10) || (uVar1 = local_64 + 1, 2 < (int)local_64)) {\n              uVar4 = 0;\n              goto LAB_000021d5;\n            }\n            iVar3 = FUN_00001b60(*(undefined8 *)(param_1 + 2),1,&local_58);\n            local_64 = uVar1;\n            if (iVar3 < 0) {\n              fprintf(*(FILE **)PTR_stderr_00203ff8,\n                      \"ALG_PERR: %s(%d): retry %d for io_read failed : \",\"engines/e_afalg.c\",0x161,\n                      (ulong)uVar1);\n              perror((char *)0x0);\n              uVar4 = 0;\n              goto LAB_000021d5;\n            }\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      } while (!bVar2);\n      uVar4 = 1;\n    }\n  }\nLAB_000021d5:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is afalg_fin_cipher_aio"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,long param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  if (param_1 == param_2) {\n    uVar2 = 1;\n  }\n  else {\n    uVar2 = EVP_KDF_get0_provider(param_2);\n    uVar3 = EVP_KDF_get0_provider(param_1);\n    iVar1 = FUN_0000e1a2(\"test/evp_kdf_test.c\",0x5e6,\"EVP_KDF_get0_provider(kdf1)\",\n                         \"EVP_KDF_get0_provider(kdf2)\",uVar3,uVar2);\n    if (iVar1 != 0) {\n      uVar2 = EVP_KDF_get0_name(param_2);\n      uVar3 = EVP_KDF_get0_name(param_1);\n      iVar1 = FUN_0000e462(\"test/evp_kdf_test.c\",0x5e7,\"EVP_KDF_get0_name(kdf1)\",\n                           \"EVP_KDF_get0_name(kdf2)\",uVar3,uVar2);\n      if (iVar1 != 0) {\n        return 1;\n      }\n    }\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdfs_same"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return 1;\n}\n\n",
        "output": "The predicted function name is afalg_finish"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  undefined8 uVar1;\n  \n  if (DAT_00205390 == (code *)0x0) {\n    EVP_PKEY_meth_get_paramgen(DAT_00205350,0,&DAT_00205390);\n  }\n  if (DAT_00205390 == (code *)0x0) {\n    uVar1 = 1;\n  }\n  else {\n    uVar1 = (*DAT_00205390)(param_1,param_2);\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is dasync_rsa_paramgen"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_20;\n  undefined4 local_1c;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = 0xffffffff;\n  local_18 = 0;\n  local_1c = 0;\n  ERR_new();\n  ERR_set_debug(\"test/errtest.c\",0x129,\"test_clear_error\");\n  ERR_set_error(0,0,\"hello %s\",\"world\");\n  ERR_peek_error_data(&local_18,&local_20);\n  iVar1 = FUN_00007c13(\"test/errtest.c\",299,&DAT_0000d434,\"\\\"hello world\\\"\",local_18,\"hello world\");\n  if (iVar1 != 0) {\n    iVar1 = FUN_00006087(\"test/errtest.c\",300,\"flags\",\"ERR_TXT_STRING | ERR_TXT_MALLOCED\",local_20,3\n                        );\n    if (iVar1 != 0) {\n      ERR_clear_error();\n      ERR_new();\n      ERR_set_debug(\"test/errtest.c\",0x131,\"test_clear_error\");\n      ERR_set_error(0,0,0);\n      ERR_peek_error_data(&local_18,&local_20);\n      iVar1 = FUN_00007c13(\"test/errtest.c\",0x133,&DAT_0000d434,&DAT_0000d569,local_18,&DAT_0000d568\n                          );\n      if (iVar1 != 0) {\n        iVar1 = FUN_00006087(\"test/errtest.c\",0x134,\"flags\",\"ERR_TXT_MALLOCED\",local_20,1);\n        if (iVar1 != 0) {\n          ERR_clear_error();\n          ERR_new();\n          ERR_set_debug(\"test/errtest.c\",0x139,\"test_clear_error\");\n          ERR_set_error(0,0,\"goodbye %s world\",\"cruel\");\n          ERR_peek_error_data(&local_18,&local_20);\n          iVar1 = FUN_00007c13(\"test/errtest.c\",0x13b,&DAT_0000d434,\"\\\"goodbye cruel world\\\"\",\n                               local_18,\"goodbye cruel world\");\n          if (iVar1 != 0) {\n            iVar1 = FUN_00006087(\"test/errtest.c\",0x13c,\"flags\",\"ERR_TXT_STRING | ERR_TXT_MALLOCED\",\n                                 local_20,3);\n            if (iVar1 != 0) {\n              ERR_clear_error();\n              ERR_new();\n              ERR_set_debug(\"test/errtest.c\",0x144,\"test_clear_error\");\n              ERR_set_error(0,0,0);\n              ERR_peek_error_data(&local_18,&local_20);\n              iVar1 = FUN_00007c13(\"test/errtest.c\",0x146,&DAT_0000d434,&DAT_0000d569,local_18,\n                                   &DAT_0000d568);\n              if (iVar1 != 0) {\n                iVar1 = FUN_00006087(\"test/errtest.c\",0x147,\"flags\",\"ERR_TXT_MALLOCED\",local_20,1);\n                if (iVar1 != 0) {\n                  ERR_clear_error();\n                  local_1c = 1;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  ERR_clear_error();\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_1c;\n}\n\n",
        "output": "The predicted function name is test_clear_error"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong [MASK](long param_1,char *param_2,char *param_3)\n\n{\n  long lVar1;\n  int iVar2;\n  ulong uVar3;\n  \n  lVar1 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  iVar2 = strcmp(param_2,\"Input\");\n  if (iVar2 == 0) {\n    uVar3 = FUN_000061e9(param_3,lVar1 + 0x10);\n  }\n  else {\n    iVar2 = strcmp(param_2,\"Output\");\n    if (iVar2 == 0) {\n      uVar3 = FUN_000066e2(param_3,lVar1 + 0x18,lVar1 + 0x20);\n    }\n    else {\n      iVar2 = strcmp(param_2,\"Count\");\n      if (iVar2 == 0) {\n        uVar3 = FUN_00006443(param_3,*(undefined8 *)(lVar1 + 0x10));\n      }\n      else {\n        iVar2 = strcmp(param_2,\"Ncopy\");\n        if (iVar2 == 0) {\n          uVar3 = FUN_000062f7(param_3,*(undefined8 *)(lVar1 + 0x10));\n        }\n        else {\n          iVar2 = strcmp(param_2,\"Padding\");\n          if (iVar2 == 0) {\n            iVar2 = atoi(param_3);\n            *(int *)(lVar1 + 0x28) = iVar2;\n            uVar3 = (ulong)(0 < *(int *)(lVar1 + 0x28));\n          }\n          else {\n            uVar3 = 0;\n          }\n        }\n      }\n    }\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is digest_test_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,char *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  iVar1 = strncmp(param_2,\"fake_rsa:\",9);\n  if (iVar1 == 0) {\n    uVar2 = CRYPTO_zalloc(1,\"test/fake_rsaprov.c\",0x106);\n    iVar1 = FUN_0000879a(\"test/fake_rsaprov.c\",0x107,\"storectx\",uVar2);\n    if (iVar1 == 0) {\n      uVar2 = 0;\n    }\n    else {\n      FUN_0000670e(\"test/fake_rsaprov.c\",0x10a,\"fake_rsa_open called\");\n    }\n  }\n  else {\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is fake_rsa_st_open"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  ulong uVar2;\n  long in_FS_OFFSET;\n  undefined4 local_3c;\n  undefined local_38 [8];\n  BIO *local_30;\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_3c = 0;\n  local_30 = BIO_new_mem_buf(\"Hello World\\n\",0xc);\n  iVar1 = FUN_000078e9(\"test/bio_memleak_test.c\",0x4f,&DAT_0000d168,local_30);\n  if (iVar1 != 0) {\n    iVar1 = BIO_read(local_30,local_28,5);\n    iVar1 = FUN_00005eaa(\"test/bio_memleak_test.c\",0x51,\"BIO_read(bio, data, 5)\",&DAT_0000d22d,iVar1\n                         ,5);\n    if ((iVar1 != 0) &&\n       (iVar1 = FUN_00007e1c(\"test/bio_memleak_test.c\",0x53,&DAT_0000d24e,\"\\\"Hello\\\"\",local_28,5,\n                             \"Hello\",5), iVar1 != 0)) {\n      uVar2 = BIO_ctrl(local_30,0x73,0,local_38);\n      iVar1 = FUN_000060a6(\"test/bio_memleak_test.c\",0x55,\"BIO_get_mem_ptr(bio, &bufmem)\",\n                           &DAT_0000d1ee,uVar2 & 0xffffffff,0);\n      if (iVar1 != 0) {\n        iVar1 = BIO_write(local_30,&DAT_0000d277,4);\n        iVar1 = FUN_00005fa8(\"test/bio_memleak_test.c\",0x57,\"BIO_write(bio, \\\"test\\\", 4)\",\n                             &DAT_0000d1ee,iVar1,0);\n        if (iVar1 != 0) {\n          iVar1 = BIO_read(local_30,local_28,0x10);\n          iVar1 = FUN_00005eaa(\"test/bio_memleak_test.c\",0x59,\"BIO_read(bio, data, 16)\",\n                               &DAT_0000d296,iVar1,7);\n          if ((iVar1 != 0) &&\n             (iVar1 = FUN_00007e1c(\"test/bio_memleak_test.c\",0x5b,&DAT_0000d24e,\"\\\" World\\\\n\\\"\",\n                                   local_28,7,\" World\\n\",7), iVar1 != 0)) {\n            uVar2 = BIO_ctrl(local_30,1,0,(void *)0x0);\n            iVar1 = FUN_000060a6(\"test/bio_memleak_test.c\",0x5d,\"BIO_reset(bio)\",&DAT_0000d1ee,\n                                 uVar2 & 0xffffffff,0);\n            if (iVar1 != 0) {\n              iVar1 = BIO_read(local_30,local_28,0x10);\n              iVar1 = FUN_00005eaa(\"test/bio_memleak_test.c\",0x5f,\"BIO_read(bio, data, 16)\",\n                                   &DAT_0000d1c5,iVar1,0xc);\n              if ((iVar1 != 0) &&\n                 (iVar1 = FUN_00007e1c(\"test/bio_memleak_test.c\",0x61,&DAT_0000d24e,\n                                       \"\\\"Hello World\\\\n\\\"\",local_28,0xc,\"Hello World\\n\",0xc),\n                 iVar1 != 0)) {\n                local_3c = 1;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  BIO_free(local_30);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_3c;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_bio_new_mem_buf"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return *(undefined8 *)PTR_gcide_markup_yyleng_00212fd0;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyget_leng"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong [MASK](ulong *param_1,ulong param_2,ulong param_3,undefined8 param_4)\n\n{\n  long lVar1;\n  byte bVar2;\n  long lVar3;\n  ulong uVar4;\n  ulong local_60;\n  ulong local_58;\n  int iStack72;\n  uint local_44;\n  ulong local_40;\n  \n  local_60 = param_3;\n  local_58 = param_2;\n  if ((param_3 & 1) == 0) {\n    if (param_3 == 0) {\n      lVar3 = 0;\n      if (param_2 != 0) {\n        for (; (param_2 >> lVar3 & 1) == 0; lVar3 = lVar3 + 1) {\n        }\n      }\n      local_60 = param_2 >> ((byte)lVar3 & 0x3f);\n      local_58 = 0;\n      iStack72 = (int)lVar3 + 0x40;\n    }\n    else {\n      lVar3 = 0;\n      if (param_3 != 0) {\n        for (; (param_3 >> lVar3 & 1) == 0; lVar3 = lVar3 + 1) {\n        }\n      }\n      iStack72 = (int)lVar3;\n      bVar2 = (byte)lVar3;\n      local_60 = param_3 >> (bVar2 & 0x3f) | param_2 << (0x40 - bVar2 & 0x3f);\n      local_58 = param_2 >> (bVar2 & 0x3f);\n    }\n    FUN_00002a58(param_4,2,iStack72);\n  }\n  local_40 = 3;\n  for (local_44 = 0; (local_58 != 0 && (local_44 < 0x29c)); local_44 = local_44 + 1) {\n    while( true ) {\n      lVar3 = *(long *)(&DAT_0000e7c0 + (ulong)local_44 * 0x10);\n      uVar4 = SUB168(ZEXT816(lVar3 * local_60) * ZEXT816(local_40) >> 0x40,0);\n      if ((local_58 < uVar4) ||\n         (uVar4 = *(long *)(&DAT_0000e7c0 + (ulong)local_44 * 0x10) * (local_58 - uVar4),\n         *(ulong *)(&DAT_0000e7c8 + (ulong)local_44 * 0x10) < uVar4)) break;\n      FUN_00002a58(param_4,local_40,1);\n      local_60 = lVar3 * local_60;\n      local_58 = uVar4;\n    }\n    local_40 = local_40 + (byte)(&DAT_0000e240)[local_44 + 1];\n  }\n  if (param_1 != (ulong *)0x0) {\n    *param_1 = local_58;\n  }\n  while( true ) {\n    if (0x29b < local_44) {\n      return local_60;\n    }\n    lVar3 = (ulong)local_44 * 0x10;\n    while (lVar1 = *(long *)(&DAT_0000e7c0 + lVar3),\n          lVar1 * local_60 <= *(ulong *)(&DAT_0000e7c8 + lVar3)) {\n      FUN_00002f62(param_4,local_40,local_44 + 1,0);\n      local_60 = lVar1 * local_60;\n    }\n    while (lVar1 = *(long *)(&UNK_0000e7d0 + lVar3),\n          lVar1 * local_60 <= *(ulong *)(&UNK_0000e7d8 + lVar3)) {\n      FUN_00002f62(param_4,local_40,local_44 + 1,1);\n      local_60 = lVar1 * local_60;\n    }\n    while (lVar1 = *(long *)(&UNK_0000e7e0 + lVar3),\n          lVar1 * local_60 <= *(ulong *)(&UNK_0000e7e8 + lVar3)) {\n      FUN_00002f62(param_4,local_40,local_44 + 1,2);\n      local_60 = lVar1 * local_60;\n    }\n    while (lVar1 = *(long *)(&UNK_0000e7f0 + lVar3),\n          lVar1 * local_60 <= *(ulong *)(&UNK_0000e7f8 + lVar3)) {\n      FUN_00002f62(param_4,local_40,local_44 + 1,3);\n      local_60 = lVar1 * local_60;\n    }\n    while (lVar1 = *(long *)(&UNK_0000e800 + lVar3),\n          lVar1 * local_60 <= *(ulong *)(&UNK_0000e808 + lVar3)) {\n      FUN_00002f62(param_4,local_40,local_44 + 1,4);\n      local_60 = lVar1 * local_60;\n    }\n    while (lVar1 = *(long *)(&UNK_0000e810 + lVar3),\n          lVar1 * local_60 <= *(ulong *)(&UNK_0000e818 + lVar3)) {\n      FUN_00002f62(param_4,local_40,local_44 + 1,5);\n      local_60 = lVar1 * local_60;\n    }\n    while (lVar1 = *(long *)(&UNK_0000e820 + lVar3),\n          lVar1 * local_60 <= *(ulong *)(&UNK_0000e828 + lVar3)) {\n      FUN_00002f62(param_4,local_40,local_44 + 1,6);\n      local_60 = lVar1 * local_60;\n    }\n    while (lVar1 = *(long *)(&UNK_0000e830 + lVar3),\n          lVar1 * local_60 <= *(ulong *)(&UNK_0000e838 + lVar3)) {\n      FUN_00002f62(param_4,local_40,local_44 + 1,7);\n      local_60 = lVar1 * local_60;\n    }\n    local_40 = local_40 + (byte)(&DAT_0000e500)[local_44];\n    if (local_60 < local_40 * local_40) break;\n    local_44 = local_44 + 8;\n  }\n  return local_60;\n}\n\n",
        "output": "The predicted function name is factor_using_division"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return 0;\n}\n\n",
        "output": "The predicted function name is broken_session_ticket_cb"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](char *param_1)\n\n{\n  return *param_1 != '\\0';\n}\n\n",
        "output": "The predicted function name is fake_rsa_st_eof"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  int local_40;\n  undefined4 local_3c;\n  EVP_PKEY *local_38;\n  size_t local_30;\n  EVP_PKEY_CTX *local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = 0;\n  local_18 = 0;\n  local_3c = 0;\n  local_38 = (EVP_PKEY *)0x0;\n  local_28 = (EVP_PKEY_CTX *)0x0;\n  local_18 = FUN_00003dc0(DAT_002130d0);\n  iVar1 = FUN_0000879a(\"test/provider_pkey_test.c\",0x3a,\"fake_rsa = fake_rsa_start(libctx)\",local_18\n                      );\n  if (iVar1 == 0) {\n    local_3c = 0;\n  }\n  else {\n    local_20 = OSSL_PROVIDER_load(DAT_002130d0,\"default\");\n    iVar1 = FUN_0000879a(\"test/provider_pkey_test.c\",0x3d,\n                         \"deflt = OSSL_PROVIDER_load(libctx, \\\"default\\\")\",local_20);\n    if (iVar1 != 0) {\n      iVar1 = FUN_00003e73(DAT_002130d0,&DAT_0000e368,\"provider=fake-rsa\",local_18);\n      iVar1 = FUN_0000880f(\"test/provider_pkey_test.c\",0x41,\n                           \"fetch_sig(libctx, \\\"RSA\\\", \\\"provider=fake-rsa\\\", fake_rsa)\",iVar1 != 0)\n      ;\n      if (iVar1 != 0) {\n        iVar1 = FUN_00003e73(DAT_002130d0,&DAT_0000e368,\"?provider=fake-rsa\",local_18);\n        iVar1 = FUN_0000880f(\"test/provider_pkey_test.c\",0x42,\n                             \"fetch_sig(libctx, \\\"RSA\\\", \\\"?provider=fake-rsa\\\", fake_rsa)\",\n                             iVar1 != 0);\n        if (iVar1 != 0) {\n          local_28 = (EVP_PKEY_CTX *)\n                     EVP_PKEY_CTX_new_from_name(DAT_002130d0,&DAT_0000e368,\"provider=fake-rsa\");\n          iVar1 = FUN_0000879a(\"test/provider_pkey_test.c\",0x47,\n                               \"ctx = EVP_PKEY_CTX_new_from_name(libctx, \\\"RSA\\\", \\\"provider=fake-rsa\\\")\"\n                               ,local_28);\n          if (iVar1 != 0) {\n            iVar1 = EVP_PKEY_fromdata_init(local_28);\n            iVar1 = FUN_0000880f(\"test/provider_pkey_test.c\",0x48,\"EVP_PKEY_fromdata_init(ctx)\",\n                                 iVar1 != 0);\n            if (iVar1 != 0) {\n              iVar1 = EVP_PKEY_fromdata(local_28,&local_38,0x87,0);\n              iVar1 = FUN_0000880f(\"test/provider_pkey_test.c\",0x49,\n                                   \"EVP_PKEY_fromdata(ctx, &pkey, EVP_PKEY_KEYPAIR, NULL)\",\n                                   iVar1 != 0);\n              if ((iVar1 != 0) &&\n                 (iVar1 = FUN_0000879a(\"test/provider_pkey_test.c\",0x4a,&DAT_0000e59e,local_38),\n                 iVar1 != 0)) {\n                EVP_PKEY_CTX_free(local_28);\n                for (local_40 = 0; local_28 = (EVP_PKEY_CTX *)0x0, local_40 < 3;\n                    local_40 = local_40 + 1) {\n                  local_28 = (EVP_PKEY_CTX *)\n                             EVP_PKEY_CTX_new_from_pkey(DAT_002130d0,local_38,\"?provider=default\");\n                  iVar1 = FUN_0000879a(\"test/provider_pkey_test.c\",0x5a,\n                                       \"ctx = EVP_PKEY_CTX_new_from_pkey(libctx, pkey, \\\"?provider=default\\\")\"\n                                       ,local_28);\n                  if (iVar1 == 0) goto LAB_00004338;\n                  iVar1 = EVP_PKEY_sign_init(local_28);\n                  iVar1 = FUN_00006d5b(\"test/provider_pkey_test.c\",0x62,\"EVP_PKEY_sign_init(ctx)\",\n                                       &DAT_0000e5fc,iVar1,1);\n                  if (iVar1 == 0) goto LAB_00004338;\n                  iVar1 = EVP_PKEY_sign(local_28,(uchar *)0x0,&local_30,(uchar *)0x0,0);\n                  iVar1 = FUN_00006d5b(\"test/provider_pkey_test.c\",0x65,\n                                       \"EVP_PKEY_sign(ctx, NULL, &siglen, NULL, 0)\",&DAT_0000e5fc,\n                                       iVar1,1);\n                  if ((iVar1 == 0) ||\n                     (iVar1 = FUN_00007fa3(\"test/provider_pkey_test.c\",0x66,\"siglen\",&DAT_0000e643,\n                                           local_30,0x100), iVar1 == 0)) goto LAB_00004338;\n                  EVP_PKEY_CTX_free(local_28);\n                }\n                local_3c = 1;\n              }\n            }\n          }\n        }\n      }\n    }\nLAB_00004338:\n    FUN_00003e58(local_18);\n    OSSL_PROVIDER_unload(local_20);\n    EVP_PKEY_CTX_free(local_28);\n    EVP_PKEY_free(local_38);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_3c;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_pkey_sig"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](undefined4 param_1)\n\n{\n  char *pcVar1;\n  \n  switch(param_1) {\n  default:\n    pcVar1 = \"?\";\n    break;\n  case 1:\n    pcVar1 = \"SSL3\";\n    break;\n  case 2:\n    pcVar1 = \"TLS1.0\";\n    break;\n  case 3:\n    pcVar1 = \"TLS1.1\";\n    break;\n  case 4:\n    pcVar1 = \"TLS1.2\";\n    break;\n  case 5:\n    pcVar1 = \"TLS1.3\";\n  }\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is tlsversion_string"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nsize_t [MASK](char *param_1)\n\n{\n  ushort **ppuVar1;\n  size_t local_10;\n  \n  local_10 = strlen(param_1);\n  while( true ) {\n    if (local_10 == 0) {\n      return 0;\n    }\n    ppuVar1 = __ctype_b_loc();\n    if (((*ppuVar1)[param_1[local_10 - 1]] & 0x2000) == 0) break;\n    local_10 = local_10 - 1;\n    param_1[local_10] = '\\0';\n  }\n  return local_10;\n}\n\n",
        "output": "The predicted function name is trimws"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = FUN_00003cce(\"http://usr@host:1/p?q=x#frag\",\"/p?q=x\");\n  if (((iVar1 != 0) && (iVar1 = FUN_00003cce(\"http://host?query#frag\",\"/?query\"), iVar1 != 0)) &&\n     (iVar1 = FUN_00003cce(\"http://host:9999#frag\",&DAT_0000e2c5), iVar1 != 0)) {\n    return 1;\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is test_http_url_path_query"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Removing unreachable block (ram,0x000046b9) */\n/* WARNING: Removing unreachable block (ram,0x000046d2) */\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid [MASK](long param_1)\n\n{\n  long lVar1;\n  ushort local_26;\n  int local_24;\n  \n  local_24 = 0;\n  DAT_002091f8 = (char *)dwg_model_x_min(param_1);\n  DAT_00209200 = (double)dwg_model_y_min(param_1);\n  DAT_00209208 = (double)dwg_model_x_max(param_1);\n  DAT_00209210 = (double)dwg_model_y_max(param_1);\n  DAT_00209218 = DAT_00209208 - (double)DAT_002091f8;\n  DAT_00209220 = DAT_00209210 - DAT_00209200;\n  _DAT_00209228 = DAT_000067d8;\n  printf(DAT_002091f8,DAT_00209200,DAT_00209218,DAT_00209220,\n         \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\\n<svg\\n   xmlns:svg=\\\"http://www.w3.org/2000/svg\\\"\\n   xmlns=\\\"http://www.w3.org/2000/svg\\\"\\n   xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\"\\n   version=\\\"1.1\\\" baseProfile=\\\"basic\\\"\\n   width=\\\"100%%\\\" height=\\\"100%%\\\"\\n   viewBox=\\\"%f %f %f %f\\\">\\n\"\n        );\n  if ((DAT_00209234 == 0) && (lVar1 = dwg_paper_space_ref(param_1), lVar1 != 0)) {\n    local_24 = FUN_00004363(lVar1);\n  }\n  if ((local_24 == 0) && (lVar1 = dwg_model_space_ref(param_1), lVar1 != 0)) {\n    FUN_00004363(lVar1);\n  }\n  puts(\"\\t<defs>\");\n  for (local_26 = 0; local_26 < *(ushort *)(param_1 + 3000); local_26 = local_26 + 1) {\n    lVar1 = *(long *)(*(long *)(param_1 + 0xbc0) + (ulong)local_26 * 8);\n    if (lVar1 != 0) {\n      FUN_00004363(lVar1);\n    }\n  }\n  puts(\"\\t</defs>\");\n  puts(\"</svg>\");\n  return;\n}\n\n",
        "output": "The predicted function name is output_SVG"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](byte *param_1,uint param_2)\n\n{\n  byte *local_10;\n  \n  local_10 = param_1;\n  while (*local_10 != 0) {\n    FUN_00008236(DAT_002448b0,*local_10 | param_2);\n    local_10 = local_10 + 1;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is attr_addstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long lVar3;\n  long in_FS_OFFSET;\n  undefined8 local_c8;\n  undefined8 local_c0;\n  undefined8 local_b8;\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_98;\n  long local_90;\n  undefined4 local_7c;\n  long *local_78;\n  long local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_68 = 0;\n  local_60 = 0;\n  local_58 = 0;\n  local_50 = 0;\n  local_48 = 0;\n  local_40 = 0;\n  local_38 = 0;\n  local_30 = 0;\n  local_28 = 0;\n  local_20 = 0;\n  local_7c = 0x100;\n  local_98 = param_2;\n  local_90 = param_1;\n  local_78 = (long *)CRYPTO_zalloc(0x990,\"test/evp_test.c\",0x97d);\n  iVar1 = FUN_00018f92(\"test/evp_test.c\",0x97d,\"rdata = OPENSSL_zalloc(sizeof(*rdata))\",local_78);\n  if (iVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    local_70 = EVP_RAND_fetch(DAT_002241a8,\"TEST-RAND\",\"-fips\");\n    if (local_70 != 0) {\n      lVar3 = EVP_RAND_CTX_new(local_70,0);\n      local_78[1] = lVar3;\n      EVP_RAND_free(local_70);\n      if (local_78[1] != 0) {\n        OSSL_PARAM_construct_uint(&local_c8,\"strength\",&local_7c);\n        local_68 = local_c8;\n        local_60 = local_c0;\n        local_58 = local_b8;\n        local_50 = local_b0;\n        local_48 = local_a8;\n        iVar1 = EVP_RAND_CTX_set_params(local_78[1],&local_68);\n        if ((iVar1 != 0) && (local_70 = EVP_RAND_fetch(DAT_002241a8,local_98,0), local_70 != 0)) {\n          lVar3 = EVP_RAND_CTX_new(local_70,local_78[1]);\n          *local_78 = lVar3;\n          EVP_RAND_free(local_70);\n          if (*local_78 != 0) {\n            *(undefined4 *)(local_78 + 2) = 0xffffffff;\n            *(long **)(\"EVP_PKEY_verify_recover_init\" + local_90) = local_78;\n            uVar2 = 1;\n            goto LAB_0000d668;\n          }\n        }\n      }\n    }\n    EVP_RAND_CTX_free(local_78[1]);\n    CRYPTO_free(local_78);\n    uVar2 = 0;\n  }\nLAB_0000d668:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is rand_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](int *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  lVar1 = FUN_0000aaab(param_1);\n  if (lVar1 == 0) {\n    uVar2 = 1;\n  }\n  else {\n    if (*param_1 == 0) {\n      dico_stream_write(param_3,*(undefined8 *)(lVar1 + 0x30),*(long *)(lVar1 + 0x10) + -1);\n    }\n    else if (*param_1 == 1) {\n      uVar2 = FUN_0000af8d(param_3,*(undefined8 *)(param_1 + 2),lVar1);\n      return uVar2;\n    }\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is gcide_output_result"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  while (DAT_00253be8 != '\\x01') {\n    wget_bar_update(DAT_00253bd8);\n    wget_millisleep(0x7d);\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is bar_update_thread"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined4 param_1)\n\n{\n  FUN_00009e5e(&PTR_DAT_0021f220,5,param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is ssl_max_fragment_len_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long *param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long *plVar3;\n  long local_20;\n  long local_18;\n  \n  if (param_1 == (long *)0x0) {\n    uVar2 = 0xffffffff;\n  }\n  else if ((param_1[9] == 0) || (param_1[10] != param_1[9] + -1)) {\n    if ((ulong)param_1[6] < param_1[7] - 1U) {\n      local_20 = param_1[5];\n      local_18 = param_1[6] + 1;\n    }\n    else {\n      if (param_1[5] == *(long *)(*param_1 + 0x28)) {\n        if (param_1[9] == 0) {\n          param_1[9] = param_1[10] + 1;\n        }\n        return 0xffffffff;\n      }\n      local_20 = param_1[5] + 1;\n      local_18 = 0;\n    }\n    plVar3 = (long *)_idx_get_page(*param_1,local_20);\n    if (plVar3 == (long *)0x0) {\n      uVar2 = 0xffffffff;\n    }\n    else {\n      if ((param_1[9] == 0) &&\n         (iVar1 = FUN_0000bf2c(*param_1,param_1[1],plVar3 + local_18 * 7 + 7,param_1[2]), iVar1 != 0\n         )) {\n        if (param_1[9] == 0) {\n          param_1[9] = param_1[10] + 1;\n        }\n        return 0xffffffff;\n      }\n      param_1[7] = *plVar3;\n      param_1[5] = local_20;\n      param_1[6] = local_18;\n      param_1[10] = param_1[10] + 1;\n      uVar2 = 0;\n    }\n  }\n  else {\n    uVar2 = 0xffffffff;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is gcide_iterator_next"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 *param_1,void *param_2,size_t param_3)\n\n{\n  undefined8 uVar1;\n  ssize_t sVar2;\n  int *piVar3;\n  undefined8 uVar4;\n  size_t local_40;\n  void *local_28;\n  \n  local_40 = param_3;\n  local_28 = param_2;\n  do {\n    while( true ) {\n      if (local_40 == 0) {\n        return 0;\n      }\n      sVar2 = read(*(int *)(param_1 + 1),local_28,local_40);\n      if (sVar2 == -1) break;\n      if (sVar2 == 0) {\n        uVar1 = *param_1;\n        uVar4 = gettext(\"short read while reading from `%s\\'\");\n        piVar3 = __errno_location();\n        dico_log(4,*piVar3,uVar4,uVar1);\n        return 0xffffffff;\n      }\n      local_28 = (void *)((long)local_28 + sVar2);\n      local_40 = local_40 - sVar2;\n    }\n    piVar3 = __errno_location();\n  } while (*piVar3 == 0xb);\n  uVar1 = *param_1;\n  uVar4 = gettext(\"error reading from `%s\\'\");\n  piVar3 = __errno_location();\n  dico_log(4,*piVar3,uVar4,uVar1);\n  return 0xffffffff;\n}\n\n",
        "output": "The predicted function name is _idx_full_read"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined4 param_1)\n\n{\n  FUN_00009e5e(&PTR_s_UnknownCA_0021ee80,7,param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is ssl_alert_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  long in_FS_OFFSET;\n  undefined8 local_30;\n  undefined local_1a [10];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = 0;\n  ptr = (void *)FUN_000037e4(\"sha256\",\"secret\",6,&DAT_00013cc3,\"label\");\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x1d3,\"params\",ptr);\n  if (iVar1 != 0) {\n    local_30 = FUN_00002d68(&DAT_00013d1b);\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x1d4,\"kctx = get_kdfbyname(OSSL_KDF_NAME_HKDF)\",\n                         local_30);\n    if (iVar1 != 0) {\n      uVar2 = EVP_KDF_derive(local_30,local_1a,10,ptr);\n      iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x1d5,\n                           \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar2,0);\n      if (iVar1 != 0) {\n        uVar2 = 1;\n        goto LAB_00004bbd;\n      }\n    }\n  }\n  uVar2 = 0;\nLAB_00004bbd:\n  EVP_KDF_CTX_free(local_30);\n  CRYPTO_free(ptr);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_hkdf_empty_salt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 *param_1,undefined4 param_2)\n\n{\n  *(undefined4 *)(param_1 + 1) = 0x117;\n  *(undefined4 *)((long)param_1 + 0xc) = 3;\n  *param_1 = 0x14;\n  *(undefined4 *)(param_1 + 2) = param_2;\n  return;\n}\n\n",
        "output": "The predicted function name is afalg_set_op_sk"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](SSL *param_1,SSL_CTX *param_2,int param_3)\n\n{\n  byte *pbVar1;\n  byte *pbVar2;\n  int iVar3;\n  undefined8 uVar4;\n  ulong uVar5;\n  long in_FS_OFFSET;\n  byte *local_40;\n  ulong local_38;\n  void *local_30;\n  ulong local_28;\n  byte *local_20;\n  SSL_CTX *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = SSL_get_ex_data(param_1,DAT_002200e4);\n  iVar3 = SSL_client_hello_get0_ext(param_1,0,&local_40,&local_38);\n  uVar5 = local_38;\n  if ((iVar3 == 0) || (local_38 < 3)) {\n    uVar4 = 0;\n  }\n  else {\n    pbVar1 = local_40 + 2;\n    local_28 = (long)(int)((uint)*local_40 << 8) + (ulong)local_40[1];\n    if (local_28 + 2 == local_38) {\n      pbVar2 = pbVar1;\n      if ((local_28 == 0) || (pbVar2 = local_40 + 3, *pbVar1 != 0)) {\n        local_40 = pbVar2;\n        uVar4 = 0;\n        uVar5 = local_28;\n      }\n      else {\n        uVar5 = local_28 - 1;\n        if (uVar5 < 3) {\n          uVar4 = 0;\n          local_40 = pbVar2;\n        }\n        else {\n          pbVar1 = local_40 + 4;\n          local_40 = local_40 + 5;\n          local_38 = (long)(int)((uint)*pbVar2 << 8) + (ulong)*pbVar1;\n          local_28 = local_38;\n          if (uVar5 < local_38 + 2) {\n            uVar4 = 0;\n          }\n          else {\n            local_20 = local_40;\n            if (local_38 == 7) {\n              iVar3 = strncmp((char *)local_40,\"server2\",7);\n              if (iVar3 == 0) {\n                local_18 = param_2;\n                SSL_set_SSL_CTX(param_1,param_2);\n                SSL_clear_options(param_1,0xffffffff);\n                uVar4 = SSL_CTX_get_options(local_18);\n                SSL_set_options(param_1,uVar4);\n                *(undefined4 *)((long)local_30 + 0x10) = 2;\n                uVar4 = 1;\n                uVar5 = local_38;\n                goto LAB_00006785;\n              }\n            }\n            if (local_28 == 7) {\n              iVar3 = strncmp((char *)local_20,\"server1\",7);\n              if (iVar3 == 0) {\n                *(undefined4 *)((long)local_30 + 0x10) = 1;\n                uVar4 = 1;\n                uVar5 = local_38;\n                goto LAB_00006785;\n              }\n            }\n            uVar5 = local_38;\n            if (param_3 == 0) {\n              uVar4 = 0;\n            }\n            else {\n              *(undefined4 *)((long)local_30 + 0x10) = 1;\n              uVar4 = 1;\n            }\n          }\n        }\n      }\n    }\n    else {\n      uVar4 = 0;\n      local_40 = pbVar1;\n    }\n  }\nLAB_00006785:\n  local_38 = uVar5;\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar4;\n}\n\n",
        "output": "The predicted function name is client_hello_select_server_ctx"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  BIO_METHOD *type;\n  BIO *bp;\n  ulong uVar2;\n  long in_FS_OFFSET;\n  undefined4 local_34;\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_34 = 0;\n  type = BIO_s_mem();\n  bp = BIO_new(type);\n  iVar1 = FUN_000078e9(\"test/bio_memleak_test.c\",0xbf,&DAT_0000d168,bp);\n  if (iVar1 != 0) {\n    iVar1 = BIO_puts(bp,\"Hello World\\n\");\n    iVar1 = FUN_00005eaa(\"test/bio_memleak_test.c\",0xc1,\"BIO_puts(bio, \\\"Hello World\\\\n\\\")\",\n                         &DAT_0000d1c5,iVar1,0xc);\n    if (iVar1 != 0) {\n      BIO_set_flags(bp,0x400);\n      iVar1 = BIO_read(bp,local_28,0x10);\n      iVar1 = FUN_00005eaa(\"test/bio_memleak_test.c\",0xc6,\"BIO_read(bio, data, 16)\",&DAT_0000d1c5,\n                           iVar1,0xc);\n      if ((iVar1 != 0) &&\n         (iVar1 = FUN_00007e1c(\"test/bio_memleak_test.c\",200,&DAT_0000d24e,\"\\\"Hello World\\\\n\\\"\",\n                               local_28,0xc,\"Hello World\\n\",0xc), iVar1 != 0)) {\n        uVar2 = BIO_ctrl(bp,1,0,(void *)0x0);\n        iVar1 = FUN_000060a6(\"test/bio_memleak_test.c\",0xca,\"BIO_reset(bio)\",&DAT_0000d1ee,\n                             uVar2 & 0xffffffff,0);\n        if (iVar1 != 0) {\n          iVar1 = BIO_read(bp,local_28,0x10);\n          iVar1 = FUN_00005eaa(\"test/bio_memleak_test.c\",0xcd,\"BIO_read(bio, data, 16)\",\n                               &DAT_0000d1c5,iVar1,0xc);\n          if ((iVar1 != 0) &&\n             (iVar1 = FUN_00007e1c(\"test/bio_memleak_test.c\",0xcf,&DAT_0000d24e,\"\\\"Hello World\\\\n\\\"\"\n                                   ,local_28,0xc,\"Hello World\\n\",0xc), iVar1 != 0)) {\n            BIO_clear_flags(bp,0x400);\n            uVar2 = BIO_ctrl(bp,1,0,(void *)0x0);\n            iVar1 = FUN_000060a6(\"test/bio_memleak_test.c\",0xd3,\"BIO_reset(bio)\",&DAT_0000d1ee,\n                                 uVar2 & 0xffffffff,0);\n            if (iVar1 != 0) {\n              iVar1 = BIO_read(bp,local_28,0x10);\n              iVar1 = FUN_00005fa8(\"test/bio_memleak_test.c\",0xd6,\"BIO_read(bio, data, 16)\",\n                                   &DAT_0000d347,iVar1,1);\n              if (iVar1 != 0) {\n                local_34 = 1;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  BIO_free(bp);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_34;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_bio_nonclear_rst"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](undefined param_1,int param_2,int param_3)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  BIO_METHOD *pBVar3;\n  long in_FS_OFFSET;\n  int local_70;\n  int local_68;\n  int local_64;\n  undefined8 local_60;\n  BIO *local_58;\n  BIO *local_50;\n  char *local_48;\n  BIO *local_40;\n  BIO *local_38;\n  undefined local_30;\n  int local_2c;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  pBVar3 = BIO_s_mem();\n  local_58 = BIO_new(pBVar3);\n  pBVar3 = BIO_s_mem();\n  local_50 = BIO_new(pBVar3);\n  local_38 = (BIO *)0x0;\n  local_30 = 0x30;\n  local_2c = 0;\n  local_48 = \"application/x-x509-ca-cert\";\n  local_60 = 0;\n  local_64 = 0;\n  if ((local_58 != (BIO *)0x0) && (local_50 != (BIO *)0x0)) {\n    local_38 = local_50;\n    local_30 = param_1;\n    local_2c = param_3;\n    BIO_set_callback_ex(local_58,FUN_00003386);\n    BIO_set_callback_arg(local_58,(char *)&local_38);\n    local_64 = 1;\n    local_70 = param_2;\n    for (local_68 = 1; (local_64 != 0 && (local_68 < 3)); local_68 = local_68 + 1) {\n      local_40 = (BIO *)OSSL_HTTP_transfer(&local_60,0,0,\"/path/result.crt\",0,0,0,local_58,local_50,\n                                           0,0,0,0,0,0,local_48,0,0,0,local_70);\n      if ((local_70 == 2) && (param_3 == 0)) {\n        if ((local_64 != 0) &&\n           (iVar1 = FUN_0000a8ff(\"test/http_test.c\",0xba,&DAT_0000e0e6,local_40), iVar1 != 0)) {\n          uVar2 = OSSL_HTTP_is_alive(local_60);\n          iVar1 = FUN_00008f35(\"test/http_test.c\",0xbb,\"OSSL_HTTP_is_alive(rctx)\",&DAT_0000e0b3,\n                               uVar2,0);\n          if (iVar1 != 0) {\n            local_64 = 1;\n            goto LAB_000038f2;\n          }\n        }\n        local_64 = 0;\n      }\n      else {\n        if ((local_64 != 0) &&\n           (iVar1 = FUN_0000a974(\"test/http_test.c\",0xbd,&DAT_0000e0e6,local_40), iVar1 != 0)) {\n          uVar2 = OSSL_HTTP_is_alive(local_60);\n          iVar1 = FUN_00008f35(\"test/http_test.c\",0xbe,\"OSSL_HTTP_is_alive(rctx)\",\"keep_alive > 0\",\n                               uVar2,0 < local_70);\n          if (iVar1 != 0) {\n            local_64 = 1;\n            goto LAB_000038f2;\n          }\n        }\n        local_64 = 0;\n      }\nLAB_000038f2:\n      BIO_free(local_40);\n      BIO_ctrl(local_50,1,0,(void *)0x0);\n      local_70 = 0;\n    }\n    OSSL_HTTP_close(local_60,local_64);\n  }\n  BIO_free(local_58);\n  BIO_free(local_50);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_64;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_http_keep_alive"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,char **param_4)\n\n{\n  ulong uVar1;\n  undefined4 uVar2;\n  int iVar3;\n  undefined8 uVar4;\n  undefined8 *puVar5;\n  undefined8 uVar6;\n  char *pcVar7;\n  int local_34;\n  char *local_30;\n  \n  local_30 = (char *)0x0;\n  if (param_4 != (char **)0x0) {\n    local_30 = strrchr(*param_4,0x2f);\n    if (local_30 == (char *)0x0) {\n      local_30 = (char *)strlen(*param_4);\n    }\n    else {\n      local_30 = local_30 + (1 - (long)*param_4);\n    }\n  }\n  if (param_4 == (char **)0x0) {\n    pcVar7 = (char *)0x0;\n  }\n  else {\n    pcVar7 = *param_4;\n  }\n  uVar2 = wget_vector_size(param_2);\n  uVar4 = gettext(\"found %d url(s) (base=%s)\\n\");\n  wget_info_printf(uVar4,uVar2,pcVar7);\n  wget_thread_mutex_lock(DAT_00253d18);\n  local_34 = 0;\n  do {\n    iVar3 = wget_vector_size(param_2);\n    if (iVar3 <= local_34) {\n      wget_thread_mutex_unlock(DAT_00253d18);\n      return;\n    }\n    puVar5 = (undefined8 *)wget_vector_get(param_2,local_34);\n    if (local_30 == (char *)0x0) {\nLAB_0001b69b:\n      uVar4 = wget_strmemdup(*puVar5,puVar5[1]);\n      iVar3 = wget_hashmap_put(DAT_00253cc8,uVar4,0);\n      if (iVar3 == 0) {\n        FUN_00014525(param_1,param_3,uVar4,0,0);\n      }\n      else {\n        uVar4 = *puVar5;\n        uVar1 = puVar5[1];\n        uVar6 = gettext(\"URL \\'%.*s\\' not followed (already known)\\n\");\n        wget_info_printf(uVar6,uVar1 & 0xffffffff,uVar4);\n      }\n    }\n    else {\n      if (local_30 < (char *)puVar5[1]) {\n        iVar3 = wget_strncasecmp(*puVar5,*param_4,local_30);\n        if (iVar3 == 0) goto LAB_0001b69b;\n      }\n      uVar4 = *puVar5;\n      uVar1 = puVar5[1];\n      uVar6 = gettext(\"URL \\'%.*s\\' not followed (not matching base)\\n\");\n      wget_info_printf(uVar6,uVar1 & 0xffffffff,uVar4);\n    }\n    local_34 = local_34 + 1;\n  } while( true );\n}\n\n",
        "output": "The predicted function name is add_urls"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long in_FS_OFFSET;\n  undefined8 local_d8;\n  undefined8 local_d0;\n  undefined8 local_c8;\n  undefined8 local_c0;\n  undefined8 local_b8;\n  undefined4 local_a4;\n  undefined4 local_a0;\n  undefined4 local_9c;\n  undefined8 local_98;\n  void *local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  undefined8 local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined local_38 [40];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_9c = 0;\n  local_98 = 0;\n  local_a4 = 0x1000;\n  local_a0 = 1;\n  local_90 = (void *)FUN_0000511d(\"passwordPASSWORDpassword\",\"sha256\",\"saltSALT\",&local_a4,&local_a0\n                                 );\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x2d3,\"params\",local_90);\n  if (iVar1 != 0) {\n    local_98 = FUN_00002d68(\"PBKDF2\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x2d4,\"kctx = get_kdfbyname(OSSL_KDF_NAME_PBKDF2)\",\n                         local_98);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_98,local_90);\n      iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0x2d6,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        uVar2 = EVP_KDF_derive(local_98,local_38,0x19,0);\n        iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x2d7,\n                             \"EVP_KDF_derive(kctx, out, sizeof(out), NULL)\",&DAT_00013c2d,uVar2,0);\n        if (iVar1 != 0) {\n          local_a0 = 0;\n          OSSL_PARAM_construct_int(&local_d8,\"pkcs5\",&local_a0);\n          local_88 = local_d8;\n          local_80 = local_d0;\n          local_78 = local_c8;\n          local_70 = local_c0;\n          local_68 = local_b8;\n          OSSL_PARAM_construct_end(&local_d8);\n          local_60 = local_d8;\n          local_58 = local_d0;\n          local_50 = local_c8;\n          local_48 = local_c0;\n          local_40 = local_b8;\n          iVar1 = EVP_KDF_CTX_set_params(local_98,&local_88);\n          iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0x2df,\n                               \"EVP_KDF_CTX_set_params(kctx, mode_params)\",iVar1 != 0);\n          if (iVar1 != 0) {\n            uVar2 = EVP_KDF_derive(local_98,local_38,0x19,0);\n            iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x2e0,\n                                 \"EVP_KDF_derive(kctx, out, sizeof(out), NULL)\",&DAT_00013c2d,uVar2,\n                                 0);\n            if (iVar1 != 0) {\n              local_9c = 1;\n            }\n          }\n        }\n      }\n    }\n  }\n  EVP_KDF_CTX_free(local_98);\n  CRYPTO_free(local_90);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_9c;\n}\n\n",
        "output": "The predicted function name is test_kdf_pbkdf2_small_salt_pkcs5"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  char **ptr;\n  char *pcVar4;\n  undefined4 local_24;\n  size_t local_20;\n  \n  local_24 = 0;\n  iVar1 = FUN_00011e59(param_2);\n  if (iVar1 == 0) {\n    pcVar3 = (char *)EVP_MAC_fetch(DAT_002241a8,param_2,0);\n    if (pcVar3 == (char *)0x0) {\n      local_20 = strlen(param_2);\n      if ((0xc < local_20) &&\n         (iVar1 = strcmp(param_2 + (local_20 - 0xc),\" by EVP_PKEY\"), iVar1 == 0)) {\n        local_20 = local_20 - 0xc;\n      }\n      iVar1 = strncmp(param_2,\"HMAC\",local_20);\n      if (iVar1 == 0) {\n        local_24 = 0x357;\n      }\n      else {\n        iVar1 = strncmp(param_2,\"CMAC\",local_20);\n        if (iVar1 == 0) {\n          local_24 = 0x37e;\n        }\n        else {\n          iVar1 = strncmp(param_2,\"Poly1305\",local_20);\n          if (iVar1 == 0) {\n            local_24 = 0x425;\n          }\n          else {\n            iVar1 = strncmp(param_2,\"SipHash\",local_20);\n            if (iVar1 != 0) {\n              return 0;\n            }\n            local_24 = 0x426;\n          }\n        }\n      }\n    }\n    ptr = (char **)CRYPTO_zalloc(0x98,\"test/evp_test.c\",0x49d);\n    iVar1 = FUN_00018f92(\"test/evp_test.c\",0x49d,\"mdat = OPENSSL_zalloc(sizeof(*mdat))\",ptr);\n    if (iVar1 == 0) {\n      uVar2 = 0;\n    }\n    else {\n      *(undefined4 *)(ptr + 2) = local_24;\n      pcVar4 = CRYPTO_strdup(param_2,\"test/evp_test.c\",0x4a1);\n      *ptr = pcVar4;\n      iVar1 = FUN_00018f92(\"test/evp_test.c\",0x4a1,\"mdat->mac_name = OPENSSL_strdup(alg)\",*ptr);\n      if (iVar1 == 0) {\n        CRYPTO_free(ptr);\n        uVar2 = 0;\n      }\n      else {\n        ptr[1] = pcVar3;\n        pcVar3 = (char *)OPENSSL_sk_new_null();\n        ptr[0x11] = pcVar3;\n        iVar1 = FUN_00018f92(\"test/evp_test.c\",0x4a7,\"mdat->controls = sk_OPENSSL_STRING_new_null()\"\n                             ,ptr[0x11]);\n        if (iVar1 == 0) {\n          CRYPTO_free(*ptr);\n          CRYPTO_free(ptr);\n          uVar2 = 0;\n        }\n        else {\n          *(undefined4 *)((long)ptr + 0x94) = 0xffffffff;\n          *(undefined4 *)(ptr + 0x12) = *(undefined4 *)((long)ptr + 0x94);\n          *(char ***)(\"EVP_PKEY_verify_recover_init\" + param_1) = ptr;\n          uVar2 = 1;\n        }\n      }\n    }\n  }\n  else {\n    FUN_00016f06(\"test/evp_test.c\",0x480,\"skipping, \\'%s\\' is disabled\",param_2);\n    *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is mac_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined8 local_30;\n  void *local_28;\n  EVP_PKEY_CTX *local_20;\n  EVP_PKEY_CTX **local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = *(EVP_PKEY_CTX ***)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  local_28 = (void *)0x0;\n  local_20 = (EVP_PKEY_CTX *)0x0;\n  iVar1 = (*(code *)local_18[1])(*local_18,0,&local_30,local_18[2],local_18[3]);\n  if (0 < iVar1) {\n    local_28 = CRYPTO_malloc((int)local_30,\"test/evp_test.c\",0x6f2);\n    iVar1 = FUN_00018f92(\"test/evp_test.c\",0x6f2,\"got = OPENSSL_malloc(got_len)\",local_28);\n    if (iVar1 != 0) {\n      iVar1 = (*(code *)local_18[1])(*local_18,local_28,&local_30,local_18[2],local_18[3]);\n      if (iVar1 < 1) {\n        *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KEYOP_ERROR\";\n      }\n      else {\n        iVar1 = FUN_000060ba(param_1,\"KEYOP_MISMATCH\",local_18[4],local_18[5],local_28,local_30);\n        if (iVar1 != 0) {\n          *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n          CRYPTO_free(local_28);\n          local_28 = (void *)0x0;\n          local_20 = EVP_PKEY_CTX_dup(*local_18);\n          iVar1 = FUN_00018f92(\"test/evp_test.c\",0x705,\"copy = EVP_PKEY_CTX_dup(expected->ctx)\",\n                               local_20);\n          if (iVar1 == 0) {\n            *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"INTERNAL_ERROR\";\n          }\n          else {\n            iVar1 = (*(code *)local_18[1])(local_20,0,&local_30,local_18[2],local_18[3]);\n            if (0 < iVar1) {\n              local_28 = CRYPTO_malloc((int)local_30,\"test/evp_test.c\",0x70b);\n              iVar1 = FUN_00018f92(\"test/evp_test.c\",0x70b,\"got = OPENSSL_malloc(got_len)\",local_28)\n              ;\n              if (iVar1 != 0) {\n                iVar1 = (*(code *)local_18[1])(local_20,local_28,&local_30,local_18[2],local_18[3]);\n                if (iVar1 < 1) {\n                  *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KEYOP_ERROR\";\n                }\n                else {\n                  FUN_000060ba(param_1,\"KEYOP_MISMATCH\",local_18[4],local_18[5],local_28,local_30);\n                }\n                goto LAB_0000bacc;\n              }\n            }\n            *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KEYOP_LENGTH_ERROR\";\n          }\n        }\n      }\n      goto LAB_0000bacc;\n    }\n  }\n  *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KEYOP_LENGTH_ERROR\";\nLAB_0000bacc:\n  CRYPTO_free(local_28);\n  EVP_PKEY_CTX_free(local_20);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is pkey_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  mu_sieve_register_action\n            (param_1,\"vacation\",PTR_sieve_action_vacation_00204fd0,&DAT_002052a8,\n             &PTR_PTR_DAT_002053c0,1);\n  return 0;\n}\n\n",
        "output": "The predicted function name is vacation_LTX_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4\n[MASK](BIO *param_1,undefined param_2,undefined8 param_3,void *param_4,size_t param_5)\n\n{\n  ulong uVar1;\n  int iVar2;\n  undefined4 uVar3;\n  EVP_CIPHER *cipher;\n  long in_FS_OFFSET;\n  undefined8 local_128;\n  undefined8 local_120;\n  undefined8 local_118;\n  undefined8 local_110;\n  undefined8 local_108;\n  size_t local_f0;\n  void *local_e8;\n  undefined8 local_e0;\n  undefined local_d4 [4];\n  BIO *local_d0;\n  byte local_bd;\n  undefined4 local_bc;\n  undefined8 local_b8;\n  EVP_CIPHER_CTX *local_b0;\n  undefined8 local_a8;\n  uchar *local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  undefined8 local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined local_3a;\n  char local_39;\n  uchar local_38 [24];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_a8 = 0;\n  local_b8 = 0;\n  local_b0 = (EVP_CIPHER_CTX *)0x0;\n  local_bc = 0;\n  DAT_002135d0 = (undefined)((ulong)param_3 >> 0x28);\n  DAT_002135d1 = (undefined)((ulong)param_3 >> 0x20);\n  DAT_002135d2 = (undefined)((ulong)param_3 >> 0x18);\n  DAT_002135d3 = (undefined)((ulong)param_3 >> 0x10);\n  DAT_002135d4 = (undefined)((ulong)param_3 >> 8);\n  DAT_002135d5 = (undefined)param_3;\n  local_bd = ~((char)param_5 + 0x14U) & 0xf;\n  local_f0 = param_5;\n  local_e8 = param_4;\n  local_e0 = param_3;\n  local_d4[0] = param_2;\n  local_d0 = param_1;\n  local_a0 = (uchar *)CRYPTO_malloc((int)param_5 + (uint)local_bd + 0x15,\"test/bad_dtls_test.c\",\n                                    0x12d);\n  if (local_a0 == (uchar *)0x0) {\n    uVar3 = 0;\n  }\n  else {\n    memcpy(local_a0,local_e8,local_f0);\n    local_a8 = EVP_MAC_fetch(0,&DAT_0000e94d,0);\n    iVar2 = FUN_000090bd(\"test/bad_dtls_test.c\",0x135,\"hmac = EVP_MAC_fetch(NULL, \\\"HMAC\\\", NULL)\",\n                         local_a8);\n    if (iVar2 != 0) {\n      local_b8 = EVP_MAC_CTX_new(local_a8);\n      iVar2 = FUN_000090bd(\"test/bad_dtls_test.c\",0x136,\"ctx = EVP_MAC_CTX_new(hmac)\",local_b8);\n      if (iVar2 != 0) {\n        OSSL_PARAM_construct_utf8_string(&local_128,\"digest\",&DAT_0000e99d,0);\n        local_98 = local_128;\n        local_90 = local_120;\n        local_88 = local_118;\n        local_80 = local_110;\n        local_78 = local_108;\n        OSSL_PARAM_construct_end(&local_128);\n        local_70 = local_128;\n        local_68 = local_120;\n        local_60 = local_118;\n        local_58 = local_110;\n        local_50 = local_108;\n        local_3a = (undefined)(local_f0 >> 8);\n        local_39 = (char)local_f0;\n        iVar2 = EVP_MAC_init(local_b8,&DAT_00213574,0x14,&local_98);\n        if (iVar2 != 0) {\n          iVar2 = EVP_MAC_update(local_b8,&DAT_00213390,2);\n          if (iVar2 != 0) {\n            iVar2 = EVP_MAC_update(local_b8,&DAT_002135d0,6);\n            if (iVar2 != 0) {\n              iVar2 = EVP_MAC_update(local_b8,local_d4,1);\n              if (iVar2 != 0) {\n                iVar2 = EVP_MAC_update(local_b8,&DAT_00213392,2);\n                if (iVar2 != 0) {\n                  iVar2 = EVP_MAC_update(local_b8,&local_3a,2);\n                  if (iVar2 != 0) {\n                    iVar2 = EVP_MAC_update(local_b8,local_a0,local_f0);\n                    if (iVar2 != 0) {\n                      iVar2 = EVP_MAC_final(local_b8,local_a0 + local_f0,0,0x14);\n                      if (iVar2 != 0) {\n                        local_f0 = local_f0 + 0x14;\n                        do {\n                          uVar1 = local_f0 + 1;\n                          local_a0[local_f0] = local_bd;\n                          local_f0 = uVar1;\n                        } while ((uVar1 & 0xf) != 0);\n                        iVar2 = RAND_bytes(local_38,0x10);\n                        iVar2 = FUN_0000787a(\"test/bad_dtls_test.c\",0x14e,\n                                             \"RAND_bytes(iv, sizeof(iv))\",&DAT_0000e9a9,iVar2,0);\n                        if (iVar2 != 0) {\n                          local_b0 = EVP_CIPHER_CTX_new();\n                          iVar2 = FUN_000090bd(\"test/bad_dtls_test.c\",0x14f,\n                                               \"enc_ctx = EVP_CIPHER_CTX_new()\",local_b0);\n                          if (iVar2 != 0) {\n                            cipher = EVP_aes_128_cbc();\n                            EVP_CipherInit_ex(local_b0,cipher,(ENGINE *)0x0,&DAT_00213598,local_38,1\n                                             );\n                            iVar2 = FUN_00009132(\"test/bad_dtls_test.c\",0x151,\n                                                 \"EVP_CipherInit_ex(enc_ctx, EVP_aes_128_cbc(), NULL, enc_key, iv, 1)\"\n                                                );\n                            if (iVar2 != 0) {\n                              iVar2 = EVP_Cipher(local_b0,local_a0,local_a0,(uint)local_f0);\n                              iVar2 = FUN_000078f9(\"test/bad_dtls_test.c\",0x152,\n                                                   \"EVP_Cipher(enc_ctx, enc, enc, len)\",\n                                                   &DAT_0000e9a9,iVar2,0);\n                              if (iVar2 != 0) {\n                                BIO_write(local_d0,local_d4,1);\n                                BIO_write(local_d0,&DAT_00213392,2);\n                                BIO_write(local_d0,&DAT_00213390,2);\n                                BIO_write(local_d0,&DAT_002135d0,6);\n                                local_3a = (undefined)(local_f0 + 0x10 >> 8);\n                                local_39 = (char)local_f0 + '\\x10';\n                                BIO_write(local_d0,&local_3a,2);\n                                BIO_write(local_d0,local_38,0x10);\n                                BIO_write(local_d0,local_a0,(int)local_f0);\n                                local_bc = 1;\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    EVP_MAC_free(local_a8);\n    EVP_MAC_CTX_free(local_b8);\n    EVP_CIPHER_CTX_free(local_b0);\n    CRYPTO_free(local_a0);\n    uVar3 = local_bc;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is send_record"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return 0;\n}\n\n",
        "output": "The predicted function name is is_pkey_disabled"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  FUN_0000a186(param_1,0);\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_info"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = atoi(param_2);\n  *(int *)(param_1 + 8) = iVar1;\n  return 1;\n}\n\n",
        "output": "The predicted function name is parse_test_app_data_size"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](BIO *param_1)\n\n{\n  int iVar1;\n  \n  DAT_0021333b = DAT_002134c0;\n  DAT_00213343 = DAT_002134c8;\n  DAT_0021334b = DAT_002134d0;\n  DAT_00213353 = DAT_002134d8;\n  DAT_0021335c = DAT_002134e0;\n  DAT_00213364 = DAT_002134e8;\n  DAT_0021336c = DAT_002134f0;\n  DAT_00213374 = DAT_002134f8;\n  iVar1 = EVP_DigestUpdate(DAT_002135c8,&DAT_00213339,0x46);\n  if (iVar1 != 0) {\n    BIO_write(param_1,&DAT_00213320,0x5f);\n    BIO_write(param_1,&DAT_00213380,0x10);\n  }\n  return iVar1 != 0;\n}\n\n",
        "output": "The predicted function name is send_server_hello"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](char *param_1,char **param_2,char **param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  char cVar3;\n  undefined8 uVar4;\n  char *local_30;\n  char *local_18;\n  char *local_10;\n  \n  local_30 = param_1;\n  while (cVar3 = FUN_000284f3((int)*local_30), cVar3 != '\\0') {\n    local_30 = local_30 + 1;\n  }\n  *param_2 = local_30;\n  for (; ((cVar3 = FUN_0002836d((int)*local_30), cVar3 != '\\0' || (*local_30 == '-')) ||\n         (*local_30 == '_')); local_30 = local_30 + 1) {\n  }\n  if (**param_2 == '\\0') {\n    uVar4 = gettext(\"Failed to parse: \\'%s\\'\\n\");\n    wget_error_printf(uVar4,local_30);\n    uVar4 = 0;\n  }\n  else {\n    cVar3 = FUN_000284f3((int)*local_30);\n    if (cVar3 != '\\0') {\n      *local_30 = '\\0';\n      do {\n        local_30 = local_30 + 1;\n        cVar3 = FUN_000284f3((int)*local_30);\n      } while (cVar3 != '\\0');\n    }\n    if (*local_30 == '=') {\n      *local_30 = '\\0';\n      do {\n        pcVar2 = local_30;\n        local_30 = pcVar2 + 1;\n        cVar3 = FUN_000284f3((int)*local_30);\n      } while (cVar3 != '\\0');\n      *param_3 = local_30;\n      cVar3 = *local_30;\n      if ((cVar3 == '\\\"') || (cVar3 == '\\'')) {\n        local_10 = local_30;\n        local_18 = pcVar2 + 2;\n        while ((cVar1 = *local_18, cVar3 != cVar1 && (cVar1 != '\\0'))) {\n          if ((cVar1 == '\\\\') && (local_18[1] != '\\0')) {\n            *local_10 = local_18[1];\n            local_18 = local_18 + 2;\n            local_10 = local_10 + 1;\n          }\n          else {\n            *local_10 = *local_18;\n            local_18 = local_18 + 1;\n            local_10 = local_10 + 1;\n          }\n        }\n        *local_10 = '\\0';\n      }\n      uVar4 = 1;\n    }\n    else {\n      if (*local_30 != '\\0') {\n        *local_30 = '\\0';\n        local_30 = local_30 + 1;\n      }\n      while (cVar3 = FUN_000284f3((int)*local_30), cVar3 != '\\0') {\n        local_30 = local_30 + 1;\n      }\n      *param_3 = local_30;\n      uVar4 = 2;\n    }\n  }\n  return uVar4;\n}\n\n",
        "output": "The predicted function name is parse_option"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_14;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_00009ddc(&PTR_s_Success_0021ee20,5,&local_14,param_2);\n  if (iVar1 != 0) {\n    *(undefined4 *)(param_1 + 0x1a8) = local_14;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1 != 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is parse_expected_result"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  wget_buffer_memcat(param_1,param_2,param_3);\n  return 0;\n}\n\n",
        "output": "The predicted function name is get_unzipped"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long *param_1)\n\n{\n  undefined8 *puVar1;\n  char cVar2;\n  byte bVar3;\n  int iVar4;\n  long lVar5;\n  long lVar6;\n  undefined8 uVar7;\n  undefined8 uVar8;\n  undefined8 *puVar9;\n  long lVar10;\n  ulong uVar11;\n  ulong uVar12;\n  char *pcVar13;\n  long lVar14;\n  long in_FS_OFFSET;\n  int local_118;\n  undefined8 local_e8;\n  undefined4 local_e0;\n  undefined4 uStack220;\n  undefined4 local_d8;\n  undefined4 uStack212;\n  undefined8 local_c8 [19];\n  long local_30;\n  ulong local_28;\n  long local_20;\n  \n  bVar3 = 0;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  puVar1 = *(undefined8 **)(*param_1 + 0x20);\n  lVar10 = *(long *)(puVar1[9] + 8);\n  *(byte *)(puVar1 + 0x15) = *(byte *)(puVar1 + 0x15) & 0xdf;\n  if (lVar10 == 0) {\n    lVar5 = -1;\n  }\n  else {\n    lVar5 = FUN_0001bfe4(lVar10);\n  }\n  if ((((DAT_002533ff == '\\0') || (DAT_0025341e == '\\x01')) || (*(short *)(param_1 + 0x18) != 200))\n     || ((lVar5 != param_1[0xe] ||\n         (lVar14 = param_1[0x11], lVar6 = FUN_0001c0a4(lVar10), lVar6 < lVar14)))) {\n    if ((DAT_00253407 == '\\0') &&\n       ((DAT_00253423 == '\\0' ||\n        ((DAT_002532c0 == 0 && ((*(byte *)((long)puVar1 + 0xa9) & 2) == 0)))))) {\n      if ((DAT_00253368 == 0) || ((ulong)param_1[0xe] <= DAT_00253368)) {\n        if (DAT_00253368 != 0) {\n          *(byte *)(puVar1 + 0x15) = *(byte *)(puVar1 + 0x15) & 0xfb;\n        }\n      }\n      else {\n        puVar9 = local_c8;\n        for (lVar14 = 0x15; lVar14 != 0; lVar14 = lVar14 + -1) {\n          *puVar9 = 0;\n          puVar9 = puVar9 + (ulong)bVar3 * -2 + 1;\n        }\n        local_28 = DAT_00253368;\n        local_e0 = 0;\n        uStack212 = 0;\n        local_e8 = *puVar1;\n        uStack220 = 0x2d;\n        local_d8 = 0;\n        puVar9 = (undefined8 *)FUN_00012d61(1,0x28);\n        puVar9[4] = param_1[0xe];\n        if (DAT_002531a0 != 0) {\n          lVar10 = DAT_002531a0;\n        }\n        uVar7 = wget_strdup(lVar10);\n        *puVar9 = uVar7;\n        uVar11 = (DAT_00253368 + param_1[0xe]) - 1;\n        uVar12 = uVar11 / DAT_00253368;\n        uVar7 = wget_vector_create(uVar12 & 0xffffffff,0,uVar11 % DAT_00253368);\n        puVar9[3] = uVar7;\n        for (local_118 = 0; (long)local_118 < (long)uVar12; local_118 = local_118 + 1) {\n          local_30 = DAT_00253368 * (long)local_118;\n          wget_vector_add_memdup(puVar9[3],local_c8,0xa8);\n        }\n        uVar7 = wget_vector_create(1,0);\n        puVar9[1] = uVar7;\n        wget_vector_add_memdup(puVar9[1],&local_e8,0x18);\n        puVar1[3] = puVar9;\n        iVar4 = FUN_0000fea0(puVar1);\n        if (iVar4 == 0) {\n          wget_thread_cond_signal(DAT_00253d48);\n          *(byte *)(puVar1 + 0x15) = *(byte *)(puVar1 + 0x15) & 0xfb;\n        }\n      }\n      if (DAT_002532c0 == 0) {\n        if ((((DAT_002533ff != '\\0') && (DAT_0025341e != '\\x01')) && (DAT_00253368 == 0)) &&\n           (((*(byte *)(puVar1 + 0x15) = *(byte *)(puVar1 + 0x15) & 0xfb, DAT_002533ff != '\\0' &&\n             (DAT_0025341e != '\\x01')) && ((-1 < lVar5 && (lVar5 != param_1[0xe])))))) {\n          lVar10 = param_1[0xe];\n          uVar7 = gettext(\"The sizes do not match (local %lld, remote %zu) -- retrieving\");\n          wget_info_printf(uVar7,lVar5,lVar10);\n        }\n      }\n      else {\n        if (param_1[6] == 0) {\n          pcVar13 = \"application/octet-stream\";\n        }\n        else {\n          pcVar13 = (char *)param_1[6];\n        }\n        bVar3 = FUN_0001c422(DAT_002532c0,pcVar13);\n        *(byte *)(puVar1 + 0x15) = *(byte *)(puVar1 + 0x15) & 0xfb | ((bVar3 ^ 1) & 1) * '\\x04';\n      }\n    }\n    else if (((*(short *)(param_1 + 0x18) == 200) && (param_1[6] != 0)) &&\n            (((((iVar4 = wget_strcasecmp_ascii(param_1[6],\"text/html\"), iVar4 == 0 ||\n                (((iVar4 = wget_strcasecmp_ascii(param_1[6],\"text/css\"), iVar4 == 0 ||\n                  (iVar4 = wget_strcasecmp_ascii(param_1[6],\"application/xhtml+xml\"), iVar4 == 0))\n                 || (iVar4 = wget_strcasecmp_ascii(param_1[6],\"application/atom+xml\"), iVar4 == 0)))\n                ) || (iVar4 = wget_strcasecmp_ascii(param_1[6],\"application/rss+xml\"), iVar4 == 0))\n              || ((((*(byte *)(puVar1 + 0x15) >> 3 & 1) == 1 &&\n                   (iVar4 = wget_strcasecmp_ascii(param_1[6],\"application/xml\"), iVar4 != 0)) ||\n                  (((*(byte *)(puVar1 + 0x15) >> 3 & 1) == 1 &&\n                   (iVar4 = wget_strcasecmp_ascii(param_1[6],\"application/x-gzip\"), iVar4 != 0))))))\n             || ((((*(byte *)(puVar1 + 0x15) >> 3 & 1) == 1 &&\n                  (iVar4 = wget_strcasecmp_ascii(param_1[6],\"text/plain\"), iVar4 != 0)) ||\n                 ((DAT_002532c0 != 0 &&\n                  (cVar2 = FUN_0001c422(DAT_002532c0,param_1[6]), cVar2 == '\\x01')))))))) {\n      if (param_1[10] != 0) {\n        wget_thread_mutex_lock(DAT_00253d20);\n        if (DAT_00253cc0 == 0) {\n          DAT_00253cc0 = wget_stringmap_create(0x80);\n        }\n        iVar4 = FUN_00012db3(DAT_00253cc0,param_1[10],0);\n        param_1[10] = 0;\n        wget_thread_mutex_unlock(DAT_00253d20);\n        if (iVar4 != 0) {\n          uVar7 = *(undefined8 *)*puVar1;\n          uVar8 = gettext(\"Not scanning \\'%s\\' (known ETag)\\n\");\n          wget_info_printf(uVar8,uVar7);\n          goto LAB_0001860e;\n        }\n      }\n      if ((DAT_00253407 == '\\0') || (DAT_00253423 == '\\x01')) {\n        *(byte *)(puVar1 + 0x15) = *(byte *)(puVar1 + 0x15) & 0xfb;\n      }\n    }\n  }\n  else {\n    uVar7 = gettext(\"File \\'%s\\' not modified on server. Omitting download\");\n    wget_info_printf(uVar7,lVar10);\n    if ((DAT_00253423 != '\\0') &&\n       ((DAT_002533a0 == 0 || (*(int *)(puVar1 + 0x12) < (int)((uint)DAT_002533ec + DAT_002533a0))))\n       ) {\n      FUN_00013810(puVar1,lVar10,param_1[7],param_1[6],*puVar1);\n    }\n  }\nLAB_0001860e:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is process_head_response"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  undefined8 local_18;\n  \n  local_18 = 0;\n  ptr = (void *)FUN_00002d87(&DAT_00013c6c,\"secret\",&DAT_00013be2);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x5a,\"params\",ptr);\n  if (iVar1 != 0) {\n    local_18 = FUN_00002d68(\"TLS1-PRF\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x5b,\"kctx = get_kdfbyname(OSSL_KDF_NAME_TLS1_PRF)\",\n                         local_18);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_18,ptr);\n      iVar1 = FUN_0000e3f6(\"test/evp_kdf_test.c\",0x5c,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        uVar2 = 1;\n        goto LAB_0000316b;\n      }\n    }\n  }\n  uVar2 = 0;\nLAB_0000316b:\n  EVP_KDF_CTX_free(local_18);\n  CRYPTO_free(ptr);\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_tls1_prf_invalid_digest"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined4 param_1)\n\n{\n  *(undefined4 *)PTR_gcide_markup_yylineno_00212fc8 = param_1;\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyset_lineno"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined4 param_2,undefined4 param_3,undefined8 param_4)\n\n{\n  EVP_CIPHER *pEVar1;\n  \n  pEVar1 = EVP_aes_128_cbc_hmac_sha1();\n  FUN_00003068(param_1,param_2,param_3,param_4,1,pEVar1);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_aes128_cbc_hmac_sha1_ctrl"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined4 param_4)\n\n{\n  EVP_CIPHER *pEVar1;\n  \n  pEVar1 = EVP_aes_128_cbc_hmac_sha1();\n  FUN_0000333c(param_1,param_2,param_3,param_4,pEVar1);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_aes128_cbc_hmac_sha1_init_key"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2,undefined8 param_3)\n\n{\n  int *piVar1;\n  int iVar2;\n  undefined8 uVar3;\n  \n  piVar1 = *(int **)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  iVar2 = strcmp(param_2,\"Password\");\n  if (iVar2 == 0) {\n    uVar3 = FUN_000066e2(param_3,piVar1 + 0xe,piVar1 + 0x10);\n  }\n  else {\n    iVar2 = strcmp(param_2,\"Salt\");\n    if (iVar2 == 0) {\n      uVar3 = FUN_000066e2(param_3,piVar1 + 0x12,piVar1 + 0x14);\n    }\n    else {\n      iVar2 = strcmp(param_2,\"Key\");\n      if (iVar2 == 0) {\n        uVar3 = FUN_000066e2(param_3,piVar1 + 0x16,piVar1 + 0x18);\n      }\n      else if (*piVar1 == 2) {\n        uVar3 = FUN_0000c67a(param_1,param_2,param_3);\n      }\n      else if (*piVar1 == 3) {\n        uVar3 = FUN_0000c732(param_1,param_2,param_3);\n      }\n      else if (*piVar1 == 1) {\n        uVar3 = FUN_0000c58d(param_1,param_2,param_3);\n      }\n      else {\n        uVar3 = 0;\n      }\n    }\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is pbe_test_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  if (*(int *)(DAT_00253348 + 0x10) == 0) {\n    FUN_00012c6d();\n  }\n  else {\n    FUN_00012ce3();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is site_stats_print"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,int param_2)\n\n{\n  undefined8 uVar1;\n  long in_FS_OFFSET;\n  undefined local_38 [40];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 < 0) {\n    uVar1 = 0xffffffff;\n  }\n  else {\n    wget_snprintf(local_38,0x20,&DAT_0004301d,param_1);\n    uVar1 = FUN_0001f423(\"user.last_modified\",local_38,param_2);\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is write_xattr_last_modified"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  if (param_1 != 0) {\n    close(*(int *)(param_1 + 8));\n    FUN_0000b454(param_1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_idx_file_close"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  lVar1 = SSL_get0_peer_certificate(param_1);\n  if (lVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = X509_get0_pubkey(lVar1);\n    uVar2 = FUN_000087b6(uVar2);\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is peer_pkey_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,ulong param_2,undefined4 *param_3,char *param_4)\n\n{\n  int iVar1;\n  ulong local_10;\n  \n  local_10 = 0;\n  while( true ) {\n    if (param_2 <= local_10) {\n      return 0;\n    }\n    iVar1 = strcmp(*(char **)(param_1 + local_10 * 0x10),param_4);\n    if (iVar1 == 0) break;\n    local_10 = local_10 + 1;\n  }\n  *param_3 = *(undefined4 *)(param_1 + local_10 * 0x10 + 8);\n  return 1;\n}\n\n",
        "output": "The predicted function name is parse_enum"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  if (param_1 != 0) {\n    FUN_0000f9fb(param_1);\n    wget_robots_free(param_1 + 0x10);\n    if (param_1 != 0) {\n      (*wget_free)(param_1);\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _free_host_entry"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long in_FS_OFFSET;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined8 local_88;\n  undefined4 local_78;\n  undefined4 local_74;\n  undefined8 local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_74 = 0;\n  local_78 = 100;\n  local_70 = 0;\n  local_70 = FUN_00002d68(&DAT_00013d1b);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x15c,\"kctx = get_kdfbyname(OSSL_KDF_NAME_HKDF)\",\n                       local_70);\n  if (iVar1 != 0) {\n    OSSL_PARAM_construct_utf8_string(&local_a8,&DAT_00013d10,\"BADMODE\",0);\n    local_68 = local_a8;\n    local_60 = local_a0;\n    local_58 = local_98;\n    local_50 = local_90;\n    local_48 = local_88;\n    OSSL_PARAM_construct_end(&local_a8);\n    local_40 = local_a8;\n    local_38 = local_a0;\n    local_30 = local_98;\n    local_28 = local_90;\n    local_20 = local_88;\n    uVar2 = EVP_KDF_CTX_set_params(local_70,&local_68);\n    iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x161,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                         &DAT_00013c2d,uVar2,0);\n    if (iVar1 != 0) {\n      OSSL_PARAM_construct_int(&local_a8,&DAT_00013d10,&local_78);\n      local_68 = local_a8;\n      local_60 = local_a0;\n      local_58 = local_98;\n      local_50 = local_90;\n      local_48 = local_88;\n      uVar2 = EVP_KDF_CTX_set_params(local_70,&local_68);\n      iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x165,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           &DAT_00013c2d,uVar2,0);\n      if (iVar1 != 0) {\n        local_74 = 1;\n      }\n    }\n  }\n  EVP_KDF_CTX_free(local_70);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_74;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_kdf_hkdf_set_invalid_mode"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char param_1,char *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  undefined8 uVar3;\n  \n  sVar2 = strlen(param_2);\n  if (sVar2 < 0x13) {\n    if (param_1 == '\\0') {\n      uVar1 = 0x20;\n      uVar3 = 0x20;\n    }\n    else {\n      uVar1 = (uint)param_1;\n      uVar3 = 0x2d;\n    }\n    printf(\"  %c%-2c --%-18.18s  %s\",uVar3,(ulong)uVar1,param_2,param_3);\n  }\n  else {\n    if (param_1 == '\\0') {\n      uVar1 = 0x20;\n      uVar3 = 0x20;\n    }\n    else {\n      uVar1 = (uint)param_1;\n      uVar3 = 0x2d;\n    }\n    printf(\"  %c%-2c --%s\\n\",uVar3,(ulong)uVar1,param_2);\n    printf(\"%28s%s\",&DAT_00046466,param_3);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is print_first"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,long param_2,long param_3,long param_4)\n\n{\n  long lVar1;\n  int iVar2;\n  undefined4 uVar3;\n  undefined8 uVar4;\n  int *piVar5;\n  undefined8 *puVar6;\n  undefined8 *puVar7;\n  long in_FS_OFFSET;\n  undefined8 local_38;\n  undefined8 local_30;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = 0;\n  local_30 = 0;\n  if (((param_1 == 0) || (param_2 == 0)) || (param_3 == 0)) {\n    uVar4 = 0;\n  }\n  else {\n    piVar5 = (int *)EVP_CIPHER_CTX_get_cipher_data(param_1);\n    if ((piVar5 == (int *)0x0) || (*piVar5 != 0x1890671)) {\n      uVar4 = 0;\n    }\n    else {\n      iVar2 = EVP_CIPHER_CTX_is_encrypting(param_1);\n      if (iVar2 == 0) {\n        puVar6 = (undefined8 *)(param_3 + param_4 + -0x10);\n        local_30 = puVar6[1];\n        local_38 = *puVar6;\n      }\n      uVar3 = EVP_CIPHER_CTX_is_encrypting(param_1);\n      uVar4 = EVP_CIPHER_CTX_iv(param_1);\n      iVar2 = FUN_000025b2(piVar5,param_3,param_4,uVar4,uVar3);\n      if (iVar2 < 1) {\n        uVar4 = 0;\n      }\n      else {\n        iVar2 = FUN_00001ec7(piVar5 + 4,piVar5[1],param_2,param_4);\n        if (iVar2 < 1) {\n          uVar4 = 0;\n        }\n        else {\n          iVar2 = EVP_CIPHER_CTX_is_encrypting(param_1);\n          if (iVar2 == 0) {\n            puVar6 = (undefined8 *)EVP_CIPHER_CTX_iv_noconst(param_1);\n            *puVar6 = local_38;\n            puVar6[1] = local_30;\n          }\n          else {\n            puVar6 = (undefined8 *)(param_4 + -0x10 + param_2);\n            puVar7 = (undefined8 *)EVP_CIPHER_CTX_iv_noconst(param_1);\n            uVar4 = puVar6[1];\n            *puVar7 = *puVar6;\n            puVar7[1] = uVar4;\n          }\n          uVar4 = 1;\n        }\n      }\n    }\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar4;\n}\n\n",
        "output": "The predicted function name is afalg_do_cipher"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  EVP_MD *pEVar1;\n  code *pcVar2;\n  \n  FUN_00002e1a();\n  pEVar1 = EVP_sha1();\n  pcVar2 = (code *)EVP_MD_meth_get_update(pEVar1);\n  (*pcVar2)(param_1,param_2,param_3);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_sha1_update"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](uint param_1,undefined *param_2,undefined param_3,uint param_4,undefined8 param_5,\n                 undefined8 param_6,char *param_7,char *param_8,undefined8 param_9,char *param_10)\n\n{\n  char *pcVar1;\n  int iVar2;\n  size_t sVar3;\n  long lVar4;\n  undefined *puVar5;\n  long in_FS_OFFSET;\n  undefined8 uVar6;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  char local_35 [8];\n  char local_2d [13];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  DAT_0020a019 = param_3;\n  if (((DAT_0020a103 == '\\0') || (DAT_0020a102 == '\\x01')) || (sVar3 = strlen(param_7), 6 < sVar3))\n  {\n    local_35[0] = '\\0';\n  }\n  else {\n    sprintf(local_35,\" %-6s\",param_7);\n  }\n  if ((DAT_0020a102 == '\\x01') || (sVar3 = strlen(param_8), 0xb < sVar3)) {\n    local_2d[0] = '\\0';\n  }\n  else {\n    sprintf(local_2d,\" %10s\",param_8);\n  }\n  if (DAT_0020a106 == '\\0') {\n    lVar4 = 1;\n  }\n  else {\n    sVar3 = strlen(param_10);\n    if (sVar3 < 0xc) {\n      lVar4 = 0xe;\n    }\n    else {\n      sVar3 = strlen(param_10);\n      lVar4 = sVar3 + 2;\n    }\n  }\n  uVar6 = 0x236b;\n  local_40 = (char *)FUN_000069b0(lVar4);\n  if (DAT_0020a106 == '\\0') {\n    *local_40 = '\\0';\n  }\n  else {\n    uVar6 = 0x2399;\n    sprintf(local_40,\" %-12s\",param_10);\n  }\n  if (DAT_0020a105 == '\\0') {\n    puVar5 = &DAT_000073d6;\n  }\n  else {\n    puVar5 = &DAT_0020a018;\n  }\n  if (param_2 == (undefined *)0x0) {\n    param_2 = &DAT_000074ca;\n  }\n  iVar2 = asprintf(&local_50,\"%-8.*s%s %-12.*s %-*s%s%s %-8s%s\",(ulong)param_1,param_2,puVar5,\n                   (ulong)param_4,param_5,(ulong)DAT_0020a118,param_6,local_35,local_2d,param_9,\n                   local_40,uVar6);\n  if (iVar2 == -1) {\n    FUN_00006b51();\n  }\n  pcVar1 = local_50;\n  sVar3 = strlen(local_50);\n  pcVar1 = pcVar1 + sVar3;\n  do {\n    local_48 = pcVar1;\n    pcVar1 = local_48 + -1;\n  } while (*pcVar1 == ' ');\n  *local_48 = '\\0';\n  local_48 = pcVar1;\n  puts(local_50);\n  free(local_50);\n  free(local_40);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is print_line"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void **param_1)\n\n{\n  void *local_10;\n  \n  free(*param_1);\n  for (local_10 = (void *)0x0; local_10 < param_1[9]; local_10 = (void *)((long)local_10 + 1)) {\n    free(*(void **)(*(long *)((long)param_1[10] + (long)local_10 * 8) + 0x10));\n    free(*(void **)((long)param_1[10] + (long)local_10 * 8));\n  }\n  free(param_1[10]);\n  free(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is _free_index"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  undefined8 uVar3;\n  \n  ptr = (void *)FUN_000076f4(\"sha256\",&DAT_00013c6c,&DAT_00219201,1,&DAT_00014265,&DAT_00014260);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x467,\"params\",ptr);\n  if (iVar1 == 0) {\n    return 0;\n  }\n  uVar3 = FUN_00002d68(\"KBKDF\");\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x46c,&DAT_000141f4,uVar3);\n  if (iVar1 != 0) {\n    iVar1 = EVP_KDF_CTX_set_params(uVar3,ptr);\n    iVar1 = FUN_0000e3f6(\"test/evp_kdf_test.c\",0x46d,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                         iVar1 != 0);\n    if (iVar1 != 0) {\n      uVar2 = 1;\n      goto LAB_00007bca;\n    }\n  }\n  uVar2 = 0;\nLAB_00007bca:\n  EVP_KDF_CTX_free(uVar3);\n  CRYPTO_free(ptr);\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_kbkdf_invalid_mac"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nuint [MASK](undefined8 param_1,FILE *param_2,char param_3)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined8 uVar3;\n  size_t sVar4;\n  undefined8 uVar5;\n  char *__s;\n  void *__ptr;\n  char *__filename;\n  FILE *__stream;\n  long in_FS_OFFSET;\n  uint local_21c;\n  undefined local_1e8 [48];\n  undefined8 local_1b8;\n  undefined8 local_158;\n  undefined8 local_150;\n  undefined8 local_140;\n  undefined8 local_138;\n  undefined8 local_128;\n  long local_118;\n  long local_110;\n  undefined local_100 [48];\n  char acStack208 [10];\n  undefined auStack198 [14];\n  undefined8 local_b8;\n  FILE *local_b0;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_88;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_158 = 0;\n  local_150 = 0;\n  local_140 = 0;\n  local_138 = 0;\n  local_128 = 0;\n  local_b8 = 0;\n  local_b0 = (FILE *)0x0;\n  local_a0 = 0;\n  local_98 = 0;\n  local_88 = 0;\n  iVar1 = fileno(param_2);\n  iVar1 = FUN_000073a0(iVar1,local_1e8);\n  if (-1 < iVar1) {\n    iVar1 = FUN_00005240(&local_158,param_1,param_2,local_1b8,param_3,0);\n    if (iVar1 == 0) {\n      local_21c = 0;\n      while( true ) {\n        iVar1 = fseek(param_2,local_110,0);\n        if (iVar1 != 0) break;\n        sVar4 = fread(local_100,1,0x3c,param_2);\n        if (sVar4 != 0x3c) {\n          if (sVar4 != 0) {\n            uVar3 = gettext(\"%s: failed to read archive header\\n\");\n            error(uVar3,param_1);\n            local_21c = 1;\n          }\n          goto LAB_000034e2;\n        }\n        iVar1 = memcmp(auStack198,&DAT_00007673,2);\n        uVar3 = local_158;\n        if (iVar1 != 0) {\n          uVar5 = gettext(\"%s: did not find a valid archive header\\n\");\n          error(uVar5,uVar3);\n          local_21c = 1;\n          goto LAB_000034e2;\n        }\n        local_110 = local_110 + 0x3c;\n        DAT_0020a268 = strtoul(acStack208,(char **)0x0,10);\n        if ((DAT_0020a268 & 1) != 0) {\n          DAT_0020a268 = DAT_0020a268 + 1;\n        }\n        __s = (char *)FUN_00005833(&local_158,&local_b8);\n        if (__s == (char *)0x0) {\n          uVar3 = gettext(\"%s: bad archive file name\\n\");\n          error(uVar3,param_1);\n          local_21c = 1;\n          goto LAB_000034e2;\n        }\n        sVar4 = strlen(__s);\n        __ptr = (void *)FUN_00005cdd(&local_158,&local_b8,__s);\n        if (__ptr == (void *)0x0) {\n          uVar3 = gettext(\"%s: bad archive file name\\n\");\n          error(uVar3,param_1);\n          free(__s);\n          local_21c = 1;\n          goto LAB_000034e2;\n        }\n        if ((param_3 == '\\0') || (local_118 != 0)) {\n          if (param_3 == '\\0') {\n            free(__s);\n            DAT_0020a260 = local_110;\n            local_110 = DAT_0020a268 + local_110;\n            uVar2 = FUN_00002e4a(__ptr,param_2);\n            local_21c = local_21c | uVar2;\n          }\n          else {\n            free(__s);\n            DAT_0020a260 = local_118 + 0x3c;\n            iVar1 = fseek(local_b0,DAT_0020a260,0);\n            uVar3 = local_b8;\n            if (iVar1 != 0) {\n              uVar5 = gettext(\"%s: failed to seek to archive member\\n\");\n              error(uVar5,uVar3);\n              free(__ptr);\n              local_21c = 1;\n              goto LAB_000034e2;\n            }\n            uVar2 = FUN_00002e4a(__ptr,local_b0);\n            local_21c = local_21c | uVar2;\n          }\n        }\n        else {\n          __filename = (char *)FUN_00004b4d(param_1,__s,sVar4);\n          free(__s);\n          if (__filename == (char *)0x0) {\n            free(__ptr);\n            local_21c = 1;\n            goto LAB_000034e2;\n          }\n          __stream = fopen(__filename,\"r+b\");\n          if (__stream == (FILE *)0x0) {\n            uVar3 = gettext(\"Input file \\'%s\\' is not readable\\n\");\n            error(uVar3,__filename);\n            free(__filename);\n            free(__ptr);\n            local_21c = 1;\n            goto LAB_000034e2;\n          }\n          DAT_0020a260 = local_118;\n          uVar2 = FUN_00002e4a(__ptr,__stream);\n          local_21c = local_21c | uVar2;\n          fclose(__stream);\n          free(__filename);\n        }\n        free(__ptr);\n      }\n      uVar3 = gettext(\"%s: failed to seek to next archive header\\n\");\n      error(uVar3,param_1);\n      local_21c = 1;\n      goto LAB_00003521;\n    }\n  }\n  local_21c = 1;\nLAB_000034e2:\n  if (local_b0 != (FILE *)0x0) {\n    fclose(local_b0);\n  }\n  FUN_000057b6(&local_b8);\n  FUN_000057b6(&local_158);\nLAB_00003521:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_21c;\n}\n\n",
        "output": "The predicted function name is process_archive"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *__name;\n  undefined8 uVar3;\n  \n  pcVar2 = getenv(\"SYSTEM_WGET2RC\");\n  if ((pcVar2 == (char *)0x0) || (*pcVar2 == '\\0')) {\n    if ((PTR_s__home_xin_Downloads_gnu_projects_00253208 != (undefined *)0x0) &&\n       ((iVar1 = access(PTR_s__home_xin_Downloads_gnu_projects_00253208,4), iVar1 != 0 &&\n        (PTR_s__home_xin_Downloads_gnu_projects_00253208 != (undefined *)0x0)))) {\n      (*wget_free)(PTR_s__home_xin_Downloads_gnu_projects_00253208);\n      PTR_s__home_xin_Downloads_gnu_projects_00253208 = (undefined *)0x0;\n    }\n  }\n  else {\n    PTR_s__home_xin_Downloads_gnu_projects_00253208 = (undefined *)wget_strdup(pcVar2);\n  }\n  pcVar2 = getenv(\"WGET2RC\");\n  if ((pcVar2 == (char *)0x0) || (*pcVar2 == '\\0')) {\n    __name = (char *)wget_aprintf(\"%s/wget2rc\",param_1);\n    iVar1 = access(__name,4);\n    pcVar2 = __name;\n    if ((iVar1 != 0) && (pcVar2 = DAT_00253210, __name != (char *)0x0)) {\n      (*wget_free)(__name);\n      pcVar2 = DAT_00253210;\n    }\n  }\n  else {\n    pcVar2 = (char *)wget_strdup(pcVar2);\n  }\n  DAT_00253210 = pcVar2;\n  if (DAT_00253210 == (char *)0x0) {\n    pcVar2 = (char *)wget_aprintf(\"%s/.wget2rc\",param_2);\n    iVar1 = access(pcVar2,4);\n    if (iVar1 == 0) {\n      DAT_00253210 = pcVar2;\n      uVar3 = gettext(\"~/.wget2rc is deprecated. Please move it to %s/wget2rc\\n\");\n      wget_error_printf(uVar3,param_1);\n    }\n    else if (pcVar2 != (char *)0x0) {\n      (*wget_free)(pcVar2);\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is get_config_files"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbyte [MASK](int *param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  byte bVar2;\n  byte bVar3;\n  byte bVar4;\n  byte bVar5;\n  byte bVar6;\n  byte bVar7;\n  byte bVar8;\n  byte bVar9;\n  byte bVar10;\n  byte bVar11;\n  byte bVar12;\n  byte bVar13;\n  byte bVar14;\n  byte bVar15;\n  byte bVar16;\n  byte bVar17;\n  byte bVar18;\n  byte bVar19;\n  byte bVar20;\n  byte bVar21;\n  \n  bVar2 = FUN_0000bd47(param_1,param_2);\n  bVar3 = FUN_0000bdea(param_1,param_2);\n  bVar3 = bVar2 & 1 & bVar3;\n  if (*param_1 == 0) {\n    bVar2 = FUN_0000c054(param_1,param_2);\n    bVar4 = FUN_0000c18c(param_1,param_2);\n    bVar5 = FUN_0000c231(param_1,param_2);\n    bVar6 = FUN_0000c3b1(param_1,param_2);\n    bVar7 = FUN_0000c2ee(param_1,param_2);\n    iVar1 = param_1[0xc];\n    bVar8 = FUN_0000c409(param_1,param_2);\n    bVar9 = FUN_0000cb86(param_1,param_2);\n    bVar10 = FUN_0000c4a8(param_1,param_2);\n    bVar11 = FUN_0000c547(param_1,param_2);\n    bVar12 = FUN_0000c617(param_1,param_2);\n    bVar13 = FUN_0000c9c1(param_1,param_2);\n    bVar14 = FUN_0000c9f2(param_1,param_2);\n    bVar15 = FUN_0000ca23(param_1,param_2);\n    bVar16 = FUN_0000ca54(param_1,param_2);\n    bVar17 = FUN_0000ca85(param_1,param_2);\n    bVar18 = FUN_0000cab9(param_1,param_2);\n    bVar19 = FUN_0000caea(param_1,param_2);\n    bVar20 = FUN_0000cb1b(param_1,param_2);\n    bVar21 = FUN_0000cb4f(param_1,param_2);\n    bVar3 = bVar3 & bVar2 & bVar4 & bVar5 & bVar6 & bVar7 & iVar1 == 0 & bVar8 & bVar9 & bVar10 &\n            bVar11 & bVar12 & bVar13 & bVar14 & bVar15 & bVar16 & bVar17 & bVar18 & bVar19 & bVar20\n            & bVar21;\n  }\n  return bVar3;\n}\n\n",
        "output": "The predicted function name is check_test"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](char *param_1)\n\n{\n  char *pcVar1;\n  long local_18;\n  \n  local_18 = 0;\n  if (*param_1 == '~') {\n    pcVar1 = strchrnul(param_1,0x2f);\n    local_18 = wget_strnglob(param_1,(long)pcVar1 - (long)param_1,\"t_iri_get_connection_part\");\n  }\n  if (local_18 == 0) {\n    local_18 = wget_strdup(param_1);\n  }\n  return local_18;\n}\n\n",
        "output": "The predicted function name is shell_expand"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  GENERAL_NAME **ppGVar1;\n  int iVar2;\n  GENERAL_NAME *pGVar3;\n  long in_FS_OFFSET;\n  undefined4 local_4c;\n  uchar *local_48;\n  ulong local_40;\n  ulong local_38;\n  void *local_30;\n  void *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = CRYPTO_malloc(0xd0,\"test/v3nametest.c\",0x28e);\n  local_28 = CRYPTO_malloc(0xd0,\"test/v3nametest.c\",0x290);\n  local_4c = 0;\n  iVar2 = FUN_000085b0(\"test/v3nametest.c\",0x293,\"namesa\",local_30);\n  if ((iVar2 != 0) &&\n     (iVar2 = FUN_000085b0(\"test/v3nametest.c\",0x293,\"namesb\",local_28), iVar2 != 0)) {\n    for (local_40 = 0; local_40 < 0x1a; local_40 = local_40 + 1) {\n      local_48 = &DAT_00213020 + local_40 * 0x20;\n      ppGVar1 = (GENERAL_NAME **)(local_40 * 8 + (long)local_30);\n      pGVar3 = d2i_GENERAL_NAME((GENERAL_NAME **)0x0,&local_48,\n                                *(long *)(&DAT_00213038 + local_40 * 0x20));\n      *ppGVar1 = pGVar3;\n      local_48 = &DAT_00213020 + local_40 * 0x20;\n      ppGVar1 = (GENERAL_NAME **)(local_40 * 8 + (long)local_28);\n      pGVar3 = d2i_GENERAL_NAME((GENERAL_NAME **)0x0,&local_48,\n                                *(long *)(&DAT_00213038 + local_40 * 0x20));\n      *ppGVar1 = pGVar3;\n      iVar2 = FUN_000085b0(\"test/v3nametest.c\",0x2a0,\"namesa[i]\",\n                           *(undefined8 *)((long)local_30 + local_40 * 8));\n      if ((iVar2 == 0) ||\n         (iVar2 = FUN_000085b0(\"test/v3nametest.c\",0x2a0,\"namesb[i]\",\n                               *(undefined8 *)((long)local_28 + local_40 * 8)), iVar2 == 0))\n      goto LAB_0000470b;\n    }\n    for (local_40 = 0; local_40 < 0x1a; local_40 = local_40 + 1) {\n      for (local_38 = 0; local_38 < 0x1a; local_38 = local_38 + 1) {\n        if (local_40 == local_38) {\n          iVar2 = GENERAL_NAME_cmp(*(GENERAL_NAME **)((long)local_30 + local_40 * 8),\n                                   *(GENERAL_NAME **)((long)local_28 + local_38 * 8));\n          iVar2 = FUN_00006b71(\"test/v3nametest.c\",0x2a8,\"GENERAL_NAME_cmp(namesa[i], namesb[j])\",\n                               &DAT_0000eb4a,iVar2,0);\n        }\n        else {\n          iVar2 = GENERAL_NAME_cmp(*(GENERAL_NAME **)((long)local_30 + local_40 * 8),\n                                   *(GENERAL_NAME **)((long)local_28 + local_38 * 8));\n          iVar2 = FUN_00006bf0(\"test/v3nametest.c\",0x2ab,\"GENERAL_NAME_cmp(namesa[i], namesb[j])\",\n                               &DAT_0000eb4a,iVar2,0);\n        }\n        if (iVar2 == 0) goto LAB_0000470b;\n      }\n    }\n    local_4c = 1;\n  }\nLAB_0000470b:\n  for (local_40 = 0; local_40 < 0x1a; local_40 = local_40 + 1) {\n    if (local_30 != (void *)0x0) {\n      GENERAL_NAME_free(*(GENERAL_NAME **)((long)local_30 + local_40 * 8));\n    }\n    if (local_28 != (void *)0x0) {\n      GENERAL_NAME_free(*(GENERAL_NAME **)((long)local_28 + local_40 * 8));\n    }\n  }\n  CRYPTO_free(local_30);\n  CRYPTO_free(local_28);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_4c;\n}\n\n",
        "output": "The predicted function name is test_GENERAL_NAME_cmp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar ** [MASK](undefined8 param_1,int param_2,long param_3)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  int *piVar4;\n  char *pcVar5;\n  char **ppcVar6;\n  long in_FS_OFFSET;\n  int local_60;\n  int local_5c;\n  long local_58;\n  undefined8 local_50;\n  char **local_48;\n  long local_40;\n  FILE *local_38;\n  char **local_30;\n  char *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 == 2) {\n    local_38 = fopen(*(char **)(param_3 + 8),\"r\");\n    if (local_38 == (FILE *)0x0) {\n      uVar2 = *(undefined8 *)(param_3 + 8);\n      uVar3 = gettext(\"cannot open file %s\");\n      piVar4 = __errno_location();\n      dico_log(4,*piVar4,uVar3,uVar2);\n      ppcVar6 = (char **)0x0;\n    }\n    else {\n      local_30 = (char **)malloc(0x48);\n      if (local_30 == (char **)0x0) {\n        dico_log(4,0,\"not enough memory\");\n        fclose(local_38);\n        ppcVar6 = (char **)0x0;\n      }\n      else {\n        memset(local_30,0,0x48);\n        pcVar5 = strdup(*(char **)(param_3 + 8));\n        *local_30 = pcVar5;\n        local_30[1] = (char *)local_38;\n        local_58 = dico_list_create();\n        if (local_58 == 0) {\n          dico_log(4,0,\"not enough memory\");\n          fclose(local_38);\n          free(local_30);\n          ppcVar6 = (char **)0x0;\n        }\n        else {\n          local_5c = 0;\nLAB_0000294f:\n          local_48 = (char **)FUN_0000191a(local_30,&local_60);\n          if (local_48 != (char **)0x0) {\n            if (local_5c != 0) goto code_r0x00002826;\n            goto LAB_00002872;\n          }\n          local_28 = (char *)dico_list_count(local_58);\n          local_30[2] = local_28;\n          pcVar5 = (char *)calloc((size_t)local_28,0x30);\n          local_30[3] = pcVar5;\n          if (local_30[3] == (char *)0x0) {\n            dico_log(4,0,\"not enough memory\");\n            FUN_00002562(local_30);\n            ppcVar6 = (char **)0x0;\n          }\n          else {\n            local_50 = dico_list_iterator(local_58);\n            local_40 = 0;\n            local_48 = (char **)dico_iterator_first(local_50);\n            while (local_48 != (char **)0x0) {\n              ppcVar6 = (char **)(local_30[3] + local_40 * 0x30);\n              pcVar5 = local_48[1];\n              *ppcVar6 = *local_48;\n              ppcVar6[1] = pcVar5;\n              pcVar5 = local_48[3];\n              ppcVar6[2] = local_48[2];\n              ppcVar6[3] = pcVar5;\n              pcVar5 = local_48[5];\n              ppcVar6[4] = local_48[4];\n              ppcVar6[5] = pcVar5;\n              free(local_48);\n              local_40 = local_40 + 1;\n              local_48 = (char **)dico_iterator_next(local_50);\n            }\n            dico_iterator_destroy(&local_50);\n            dico_list_destroy(&local_58);\n            qsort(local_30[3],(size_t)local_28,0x30,FUN_00001bd2);\n            ppcVar6 = local_30;\n          }\n        }\n      }\n    }\n  }\n  else {\n    uVar2 = gettext(\"outline_open: wrong number of arguments\");\n    dico_log(4,0,uVar2);\n    ppcVar6 = (char **)0x0;\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return ppcVar6;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\ncode_r0x00002826:\n  if (local_5c == 1) {\n    if (local_60 == 2) {\n      dico_list_append(local_58,local_48);\n    }\n    else {\n      if (local_60 == 1) {\n        local_5c = 0;\nLAB_00002872:\n        if (local_60 == 1) {\n          iVar1 = strcasecmp(*local_48,\"info\");\n          if (iVar1 == 0) {\n            local_30[5] = (char *)local_48;\n            goto LAB_0000294f;\n          }\n          iVar1 = strcasecmp(*local_48,\"description\");\n          if (iVar1 == 0) {\n            local_30[6] = (char *)local_48;\n            goto LAB_0000294f;\n          }\n          iVar1 = strcasecmp(*local_48,\"languages\");\n          if (iVar1 == 0) {\n            local_30[7] = (char *)local_48;\n            goto LAB_0000294f;\n          }\n          iVar1 = strcasecmp(*local_48,\"mime\");\n          if (iVar1 == 0) {\n            local_30[8] = (char *)local_48;\n            goto LAB_0000294f;\n          }\n          iVar1 = strcasecmp(*local_48,\"dictionary\");\n          if (iVar1 == 0) {\n            local_5c = 1;\n          }\n        }\n        free(local_48);\n        goto LAB_0000294f;\n      }\n      free(local_48);\n    }\n  }\n  goto LAB_0000294f;\n}\n\n",
        "output": "The predicted function name is outline_init_db"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,long param_2)\n\n{\n  FUN_0000c7e8(\"Client CA names\",*(undefined8 *)(param_2 + 0x208),*(undefined8 *)(param_1 + 0x88));\n  return;\n}\n\n",
        "output": "The predicted function name is check_client_ca_names"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  undefined local_58 [72];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_0002e233(local_58,param_2,9);\n  if (iVar1 == 0) {\n    iVar1 = FUN_000357e9(local_58,param_1,0,0,0);\n    FUN_0002e6f2(local_58);\n    if (iVar1 == 0) {\n      uVar2 = 1;\n    }\n    else {\n      uVar2 = 0;\n    }\n  }\n  else {\n    uVar2 = 0;\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is regex_match_posix"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](long *param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  bool bVar3;\n  int iVar4;\n  char *pcVar5;\n  int local_34;\n  long local_30;\n  char *local_28;\n  \n  bVar3 = false;\n  local_34 = 0;\n  if (param_1 == (long *)0x0) {\n    local_34 = 0;\n  }\n  else if (*param_1 == 0) {\n    local_34 = 0;\n  }\n  else {\n    lVar1 = *param_1;\n    if (*(int *)(lVar1 + 0x10) == 0x31) {\n      if (*(long *)(lVar1 + 0x38) == 0) {\n        fwrite(\"Found null obj->tio.object\\n\",1,0x1b,stderr);\n        local_34 = 0;\n      }\n      else if (*(long *)(*(long *)(lVar1 + 0x38) + 8) == 0) {\n        fwrite(\"Found null obj->tio.object->tio.BLOCK_HEADER\\n\",1,0x2d,stderr);\n        local_34 = 0;\n      }\n      else {\n        lVar2 = *(long *)(*(long *)(lVar1 + 0x38) + 8);\n        if (*(long *)(lVar2 + 0x10) != 0) {\n          if (**(uint **)(lVar1 + 0x58) < 0x1a) {\n            local_28 = (char *)FUN_00004ca4(*(undefined8 *)(lVar2 + 0x10),\n                                            *(undefined2 *)((long)*(uint **)(lVar1 + 0x58) + 0x1e));\n          }\n          else {\n            local_28 = (char *)FUN_00005071(*(undefined8 *)(lVar2 + 0x10));\n          }\n          if ((local_28 != (char *)0x0) && (pcVar5 = strstr(local_28,\"--\"), pcVar5 != (char *)0x0))\n          {\n            while (pcVar5 = strstr(local_28,\"--\"), pcVar5 != (char *)0x0) {\n              *pcVar5 = '_';\n              pcVar5[1] = '_';\n            }\n          }\n          if ((local_28 == (char *)0x0) || (iVar4 = strcmp(local_28,\"*Model_Space\"), iVar4 != 0)) {\n            bVar3 = true;\n            pcVar5 = local_28;\n            if (local_28 == (char *)0x0) {\n              pcVar5 = \"\";\n            }\n            printf(\"\\t<g id=\\\"symbol-%lX\\\" >\\n\\t\\t<!-- %s -->\\n\",param_1[4],pcVar5);\n          }\n          else {\n            printf(\"\\t<!-- %s -->\\n\",local_28);\n          }\n          if (local_28 != (char *)0x0) {\n            free(local_28);\n          }\n        }\n        for (local_30 = get_first_owned_entity(*param_1); local_30 != 0;\n            local_30 = get_next_owned_entity(*param_1,local_30)) {\n          iVar4 = FUN_000041de(local_30);\n          local_34 = local_34 + iVar4;\n        }\n        if (bVar3) {\n          puts(\"\\t</g>\");\n        }\n      }\n    }\n    else {\n      fwrite(\"Argument not a BLOCK_HEADER reference\\n\",1,0x26,stderr);\n      local_34 = 0;\n    }\n  }\n  return local_34;\n}\n\n",
        "output": "The predicted function name is output_BLOCK_HEADER"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8\n[MASK](int param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,undefined8 param_5\n            ,undefined8 param_6,undefined4 param_7)\n\n{\n  if (-1 < param_1) {\n    if (param_1 < 2) {\n      FUN_00005d9b(param_1 == 1,param_2,param_3,param_4,param_5,param_6,param_7);\n    }\n    else if (param_1 == 2) {\n      FUN_000051cd(param_4,param_5,param_6,param_7);\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is recv_timestamp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,ulong param_2,long param_3)\n\n{\n  char cVar1;\n  ulong uVar2;\n  long local_10;\n  \n  *(undefined *)(param_3 + 0xfa) = 0;\n  *(undefined8 *)(param_3 + 8) = 0;\n  if (((param_1 != 0) || (1 < param_2)) &&\n     ((local_10 = param_1, uVar2 = FUN_00002fc4(&local_10,param_1,param_2,param_3), local_10 != 0 ||\n      (1 < uVar2)))) {\n    cVar1 = FUN_000044d6(local_10,uVar2);\n    if (cVar1 == '\\0') {\n      if (local_10 == 0) {\n        FUN_00005227(uVar2,1,param_3);\n      }\n      else {\n        FUN_000058a7(local_10,uVar2,1,param_3);\n      }\n    }\n    else {\n      FUN_00002bca(param_3,local_10,uVar2);\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is factor"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](long param_1,char *param_2)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_3c;\n  long local_38;\n  long local_30;\n  char *local_28;\n  char *local_20;\n  long *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_3c = 0;\n  local_38 = 0;\n  local_30 = 0;\n  local_28 = (char *)0x0;\n  local_28 = CRYPTO_strdup(param_2,\"test/evp_test.c\",0xb87);\n  iVar1 = FUN_00018f92(\"test/evp_test.c\",0xb87,\"priv = OPENSSL_strdup(pair)\",local_28);\n  if (iVar1 != 0) {\n    local_20 = strchr(local_28,0x3a);\n    iVar1 = FUN_00018f92(\"test/evp_test.c\",0xb88,\"pub = strchr(priv, \\':\\')\",local_20);\n    if (iVar1 != 0) {\n      *local_20 = '\\0';\n      local_20 = local_20 + 1;\n      iVar1 = FUN_00010ea5(&local_38,local_28,DAT_002241b0);\n      iVar1 = FUN_00019007(\"test/evp_test.c\",0xb8e,\"find_key(&pk, priv, private_keys)\",iVar1 != 0);\n      if (iVar1 == 0) {\n        FUN_00016f06(\"test/evp_test.c\",0xb8f,\"Can\\'t find private key: %s\",local_28);\n        *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"MISSING_PRIVATE_KEY\";\n      }\n      else {\n        iVar1 = FUN_00010ea5(&local_30,local_20,DAT_002241b8);\n        iVar1 = FUN_00019007(\"test/evp_test.c\",0xb93,\"find_key(&pubk, pub, public_keys)\",iVar1 != 0)\n        ;\n        if (iVar1 == 0) {\n          FUN_00016f06(\"test/evp_test.c\",0xb94,\"Can\\'t find public key: %s\",local_20);\n          *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"MISSING_PUBLIC_KEY\";\n        }\n        else if ((local_38 == 0) && (local_30 == 0)) {\n          *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n          local_3c = 1;\n        }\n        else {\n          local_18 = (long *)CRYPTO_malloc(0x10,\"test/evp_test.c\",0xba0);\n          iVar1 = FUN_00018f92(\"test/evp_test.c\",0xba0,\"data = OPENSSL_malloc(sizeof(*data))\",\n                               local_18);\n          if (iVar1 != 0) {\n            *local_18 = local_38;\n            local_18[1] = local_30;\n            *(long **)(\"EVP_PKEY_verify_recover_init\" + param_1) = local_18;\n            local_3c = 1;\n            *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n          }\n        }\n      }\n      goto LAB_0000f85e;\n    }\n  }\n  *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"PARSING_ERROR\";\nLAB_0000f85e:\n  CRYPTO_free(local_28);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_3c;\n}\n\n",
        "output": "The predicted function name is keypair_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  long in_FS_OFFSET;\n  undefined8 local_38;\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = 0;\n  ptr = (void *)FUN_00002d87(\"sha256\",&DAT_00013cc4,&DAT_00013be2);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x92,\"params\",ptr);\n  if (iVar1 != 0) {\n    local_38 = FUN_00002d68(\"TLS1-PRF\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x93,\"kctx = get_kdfbyname(OSSL_KDF_NAME_TLS1_PRF)\",\n                         local_38);\n    if (iVar1 != 0) {\n      uVar2 = EVP_KDF_derive(local_38,local_28,0x10,ptr);\n      iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x94,\n                           \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar2,0);\n      if (iVar1 != 0) {\n        uVar2 = 1;\n        goto LAB_00003513;\n      }\n    }\n  }\n  uVar2 = 0;\nLAB_00003513:\n  EVP_KDF_CTX_free(local_38);\n  CRYPTO_free(ptr);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_tls1_prf_1byte_secret"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  *(undefined8 *)(param_1 + 0x28) = param_2;\n  return;\n}\n\n",
        "output": "The predicted function name is impl_register_argp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,long param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  if (*(int *)(param_2 + 0x1bc) == 0) {\n    uVar2 = 1;\n  }\n  else {\n    iVar1 = FUN_00012c68(\"test/ssl_test.c\",0x8c,\"result->session_ticket\",\n                         \"test_ctx->session_ticket_expected\",*(undefined4 *)(param_1 + 0x28),\n                         *(undefined4 *)(param_2 + 0x1bc));\n    if (iVar1 == 0) {\n      uVar2 = FUN_0000a2f7(*(undefined4 *)(param_1 + 0x28));\n      uVar3 = FUN_0000a2f7(*(undefined4 *)(param_2 + 0x1bc));\n      FUN_0001261b(\"test/ssl_test.c\",0x8f,\n                   \"Client SessionTicketExpected mismatch, expected %s, got %s.\",uVar3,uVar2);\n      uVar2 = 0;\n    }\n    else {\n      uVar2 = 1;\n    }\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is check_session_ticket"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong [MASK](long param_1,undefined4 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  int iVar1;\n  ulong uVar2;\n  long in_FS_OFFSET;\n  undefined local_98 [136];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = wget_hash_file_fd(param_1,param_2,local_98,0x81,param_3,param_4);\n  if (iVar1 == -1) {\n    uVar2 = 0xffffffff;\n  }\n  else {\n    iVar1 = wget_strcasecmp_ascii(local_98,param_1 + 0x10);\n    uVar2 = (ulong)(iVar1 == 0);\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is check_piece_hash"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,char *param_2)\n\n{\n  char *pcVar1;\n  \n  CRYPTO_free(*(void **)(param_1 + 0x220));\n  pcVar1 = CRYPTO_strdup(param_2,\"test/helpers/ssl_test_ctx.c\",0x27a);\n  *(char **)(param_1 + 0x220) = pcVar1;\n  FUN_000146a7(\"test/helpers/ssl_test_ctx.c\",0x27a,\"ctx->expected_cipher\",\n               *(undefined8 *)(param_1 + 0x220));\n  return;\n}\n\n",
        "output": "The predicted function name is parse_test_expected_cipher"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  wget_thread_mutex_init(&DAT_00253bf8);\n  DAT_00253bf0 = wget_hashmap_create(0x80,FUN_0000da39,PTR_wget_iri_compare_00252fd8);\n  wget_hashmap_set_key_destructor(DAT_00253bf0,0);\n  wget_hashmap_set_value_destructor(DAT_00253bf0,FUN_0000db5a);\n  return;\n}\n\n",
        "output": "The predicted function name is blacklist_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00003658(param_1,0xd,param_2,0xd,\"dummy value\",0);\n  return;\n}\n\n",
        "output": "The predicted function name is set_cn3"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  dico_log(4,0xc,&DAT_000107ae,param_1);\n                    /* WARNING: Subroutine does not return */\n  longjmp((__jmp_buf_tag *)&DAT_00215a80,1);\n}\n\n",
        "output": "The predicted function name is memerr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  EVP_CIPHER_meth_free(DAT_00205358);\n  EVP_CIPHER_meth_free(DAT_00205360);\n  DAT_00205358 = 0;\n  DAT_00205360 = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is destroy_ciphers"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](int param_1)\n\n{\n  char *pcVar1;\n  \n  if (param_1 == 0) {\n    pcVar1 = \"no alert\";\n  }\n  else {\n    pcVar1 = SSL_alert_desc_string_long(param_1);\n  }\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is print_alert"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](undefined8 *param_1)\n\n{\n  long lVar1;\n  \n  if (param_1 == (undefined8 *)0x0) {\n    lVar1 = 0;\n  }\n  else {\n    lVar1 = _idx_get_page(*param_1,param_1[5]);\n    if (lVar1 == 0) {\n      lVar1 = 0;\n    }\n    else {\n      lVar1 = lVar1 + param_1[6] * 0x38 + 0x38;\n    }\n  }\n  return lVar1;\n}\n\n",
        "output": "The predicted function name is gcide_iterator_ref"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](long param_1,char *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  long in_FS_OFFSET;\n  undefined4 local_bc;\n  undefined local_b8 [88];\n  long local_60;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_bc = 1;\n  iVar1 = access(param_2,4);\n  if (iVar1 == 0) {\n    iVar1 = FUN_0000f6f0(param_2,local_b8);\n    if (iVar1 == 0) {\n      if (local_60 < *(long *)(param_1 + 0x30)) {\n        uVar2 = gettext(\"gcide: index file older than database, reindexing\");\n        dico_log(2,0,uVar2);\n      }\n      else {\n        local_bc = 0;\n      }\n    }\n    else {\n      uVar2 = gettext(\"gcide: can\\'t stat `%s\\'\");\n      piVar3 = __errno_location();\n      dico_log(4,*piVar3,uVar2,param_2);\n    }\n  }\n  else {\n    piVar3 = __errno_location();\n    if (*piVar3 != 2) {\n      uVar2 = gettext(\"gcide_open_idx: cannot access %s\");\n      piVar3 = __errno_location();\n      dico_log(4,*piVar3,uVar2,param_2);\n      local_bc = 0xffffffff;\n    }\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_bc;\n}\n\n",
        "output": "The predicted function name is gcide_access_idx"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  dico_strategy_add(&PTR_s_substr_002020a0);\n  return 0;\n}\n\n",
        "output": "The predicted function name is substr_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SSL **param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = FUN_00012c68(\"test/helpers/handshake.c\",0x300,\"peer->status\",\"PEER_RETRY\",\n                       *(undefined4 *)((long)param_1 + 0x2c),1);\n  if (iVar1 == 0) {\n    *(undefined4 *)((long)param_1 + 0x2c) = 4;\n  }\n  else {\n    iVar1 = SSL_do_handshake(*param_1);\n    if (iVar1 == 1) {\n      *(undefined4 *)((long)param_1 + 0x2c) = 0;\n    }\n    else if (iVar1 == 0) {\n      *(undefined4 *)((long)param_1 + 0x2c) = 2;\n    }\n    else {\n      iVar1 = SSL_get_error(*param_1,iVar1);\n      if ((iVar1 != 2) && (iVar1 != 0xc)) {\n        *(undefined4 *)((long)param_1 + 0x2c) = 2;\n      }\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is do_handshake_step"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](int param_1,long param_2)\n\n{\n  code *pcVar1;\n  int *piVar2;\n  void *__buf;\n  ssize_t sVar3;\n  \n  if ((*(uint *)(param_2 + 0x18) & 0xf000) == 0x8000) {\n    __buf = (void *)(**(code **)(DAT_00202118 + 0x118))();\n    if (__buf == (void *)0x0) {\n      (**(code **)(DAT_00202118 + 0x60))\n                (DAT_00202120,\"%s: malloc of %d bytes failed\",\"do_readfile\",\n                 *(long *)(param_2 + 0x30) + 1);\n    }\n    sVar3 = read(param_1,__buf,*(size_t *)(param_2 + 0x30));\n    if (sVar3 == *(long *)(param_2 + 0x30)) {\n      *(undefined *)((long)__buf + *(long *)(param_2 + 0x30)) = 0;\n    }\n    else {\n      pcVar1 = *(code **)(DAT_00202118 + 0x80);\n      piVar2 = __errno_location();\n      (*pcVar1)(DAT_00202120,*piVar2);\n      (**(code **)(DAT_00202118 + 0x130))(__buf);\n      __buf = (void *)0x0;\n    }\n  }\n  else {\n    piVar2 = __errno_location();\n    *piVar2 = 0x16;\n    pcVar1 = *(code **)(DAT_00202118 + 0x80);\n    piVar2 = __errno_location();\n    (*pcVar1)(DAT_00202120,*piVar2);\n    __buf = (void *)0x0;\n  }\n  return __buf;\n}\n\n",
        "output": "The predicted function name is read_file_to_buffer"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  void *__ptr;\n  undefined8 uVar1;\n  long in_FS_OFFSET;\n  char local_1c [12];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  __ptr = (void *)FUN_000029a3(param_1);\n  sprintf(local_1c,\"%ld\",(long)*(int *)(param_1 + 4));\n  uVar1 = FUN_00002192(param_1);\n  FUN_00002228(0xffffffff,&DAT_000073d6,0x20,0x20,param_1 + 8,uVar1,&DAT_000073d6,local_1c,__ptr,\n               &DAT_000073d6);\n  free(__ptr);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is print_initspawn"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long *param_1)\n\n{\n  char cVar1;\n  char cVar2;\n  char cVar3;\n  undefined4 uVar4;\n  undefined8 uVar5;\n  undefined *puVar6;\n  undefined *puVar7;\n  undefined8 uVar8;\n  \n  if (*(int *)(DAT_00253340 + 0x10) == 0) {\n    if (*param_1 == 0) {\n      puVar6 = &DAT_0004179d;\n    }\n    else {\n      puVar6 = (undefined *)*param_1;\n    }\n    wget_fprintf(DAT_00253c58,\"  %s:\\n\",puVar6);\n    if (param_1[1] == 0) {\n      puVar6 = &DAT_0004179d;\n    }\n    else {\n      puVar6 = (undefined *)param_1[1];\n    }\n    wget_fprintf(DAT_00253c58,\"    IP             : %s\\n\",puVar6);\n    uVar5 = wget_iri_scheme_get_name(*(undefined4 *)((long)param_1 + 0x14));\n    wget_fprintf(DAT_00253c58,\"    Scheme         : %s\\n\",uVar5);\n    uVar5 = FUN_0001200e(*(undefined4 *)(param_1 + 2));\n    wget_fprintf(DAT_00253c58,\"    HPKP           : %s\\n\",uVar5);\n    if (*(char *)((long)param_1 + 0x1a) == '\\0') {\n      puVar6 = &DAT_000417f4;\n    }\n    else if (*(char *)((long)param_1 + 0x1a) == '\\x01') {\n      puVar6 = &DAT_000417f1;\n    }\n    else {\n      puVar6 = &DAT_0004179d;\n    }\n    wget_fprintf(DAT_00253c58,\"    HPKP New Entry : %s\\n\",puVar6);\n    if (*(char *)(param_1 + 3) == '\\0') {\n      puVar6 = &DAT_000417f4;\n    }\n    else if (*(char *)(param_1 + 3) == '\\x01') {\n      puVar6 = &DAT_000417f1;\n    }\n    else {\n      puVar6 = &DAT_0004179d;\n    }\n    wget_fprintf(DAT_00253c58,\"    HSTS           : %s\\n\",puVar6);\n    if (*(char *)((long)param_1 + 0x19) == '\\0') {\n      puVar6 = &DAT_000417f4;\n    }\n    else if (*(char *)((long)param_1 + 0x19) == '\\x01') {\n      puVar6 = &DAT_000417f1;\n    }\n    else {\n      puVar6 = &DAT_0004179d;\n    }\n    wget_fprintf(DAT_00253c58,\"    CSP            : %s\\n\\n\",puVar6);\n  }\n  else {\n    cVar1 = *(char *)((long)param_1 + 0x19);\n    cVar2 = *(char *)(param_1 + 3);\n    cVar3 = *(char *)((long)param_1 + 0x1a);\n    uVar4 = *(undefined4 *)(param_1 + 2);\n    uVar8 = 0x1227b;\n    uVar5 = wget_iri_scheme_get_name(*(undefined4 *)((long)param_1 + 0x14));\n    if (param_1[1] == 0) {\n      puVar6 = &DAT_00041844;\n    }\n    else {\n      puVar6 = (undefined *)param_1[1];\n    }\n    if (*param_1 == 0) {\n      puVar7 = &DAT_00041844;\n    }\n    else {\n      puVar7 = (undefined *)*param_1;\n    }\n    wget_fprintf(DAT_00253c58,\"%s,%s,%s,%d,%d,%d,%d\\n\",puVar7,puVar6,uVar5,uVar4,(int)cVar3,\n                 (int)cVar2,(int)cVar1,uVar8);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is server_stats_print"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 *param_1,undefined8 *param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  undefined8 uVar1;\n  long lVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  undefined8 local_48 [5];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  wget_buffer_init(local_48,0,param_2[1] * 10);\n  lVar2 = wget_decompress_open(1,FUN_0001b06a,local_48);\n  if (lVar2 == 0) {\n    uVar1 = *(undefined8 *)*param_1;\n    uVar3 = gettext(\"Can\\'t scan \\'%s\\' because no libz support enabled at compile time\\n\");\n    wget_error_printf(uVar3,uVar1);\n  }\n  else {\n    wget_decompress(lVar2,*param_2,param_2[1]);\n    wget_decompress_close(lVar2);\n    FUN_0001acf5(param_1,local_48[0],param_3,param_4);\n  }\n  wget_buffer_deinit(local_48);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is sitemap_parse_xml_gz"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8\n[MASK](undefined8 *param_1,undefined8 *param_2,ulong *param_3,undefined8 *param_4,\n            undefined8 param_5,undefined8 *param_6)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  int local_44;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  ulong local_20;\n  \n  local_28 = *param_2;\n  local_30 = param_2[1];\n  uVar1 = *param_4;\n  uVar2 = param_4[1];\n  local_38 = *param_6;\n  local_40 = param_6[1];\n  local_20 = *param_3;\n  for (local_44 = 0x40; local_44 != 0; local_44 = local_44 + -1) {\n    if ((local_20 & 1) != 0) {\n      local_38 = FUN_00003660(param_1,local_40,local_38,local_30,local_28,uVar2,uVar1,param_5);\n      local_40 = *param_1;\n    }\n    local_28 = FUN_00003660(param_1,local_30,local_28,local_30,local_28,uVar2,uVar1,param_5);\n    local_30 = *param_1;\n    local_20 = local_20 >> 1;\n  }\n  for (local_20 = param_3[1]; local_20 != 0; local_20 = local_20 >> 1) {\n    if ((local_20 & 1) != 0) {\n      local_38 = FUN_00003660(param_1,local_40,local_38,local_30,local_28,uVar2,uVar1,param_5);\n      local_40 = *param_1;\n    }\n    local_28 = FUN_00003660(param_1,local_30,local_28,local_30,local_28,uVar2,uVar1,param_5);\n    local_30 = *param_1;\n  }\n  *param_1 = local_40;\n  return local_38;\n}\n\n",
        "output": "The predicted function name is powm2"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ASN1_VALUE *param_1)\n\n{\n  ASN1_ITEM *it;\n  \n  it = (ASN1_ITEM *)FUN_000029aa();\n  ASN1_item_free(param_1,it);\n  return;\n}\n\n",
        "output": "The predicted function name is ASN1_LONG_DATA_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](char *param_1,undefined4 param_2)\n\n{\n  char cVar1;\n  \n  if ((*param_1 != '\\0') && (cVar1 = FUN_00004daf(param_2), cVar1 != '\\0')) {\n    return 1;\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is ignorable_missing"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ASN1_VALUE *param_1)\n\n{\n  ASN1_ITEM *it;\n  \n  it = (ASN1_ITEM *)FUN_00002bd6();\n  ASN1_item_free(param_1,it);\n  return;\n}\n\n",
        "output": "The predicted function name is ASN1_UINT32_DATA_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 * [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  undefined8 *local_18;\n  \n  DAT_00204310 = 0;\n  local_18 = (undefined8 *)malloc(0x28);\n  if (local_18 == (undefined8 *)0x0) {\n    local_18 = (undefined8 *)0x0;\n  }\n  else {\n    *local_18 = param_1;\n    iVar1 = FUN_00001f25(param_1,param_2,local_18);\n    if (iVar1 == 0) {\n      *(undefined4 *)(local_18 + 1) = 2;\n      local_18[3] = DAT_00204310;\n    }\n    else {\n      free(local_18);\n      local_18 = (undefined8 *)0x0;\n    }\n  }\n  return local_18;\n}\n\n",
        "output": "The predicted function name is outline_define"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  wget_hashmap_browse(DAT_00253bf0,FUN_0000db1c,0);\n  return;\n}\n\n",
        "output": "The predicted function name is blacklist_print"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](long param_1,long param_2)\n\n{\n  long lVar1;\n  short sVar2;\n  int iVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  \n  lVar1 = *(long *)(param_1 + 0x10);\n  if (lVar1 != 0) {\n    uVar5 = *(undefined8 *)(param_2 + 0x20);\n    uVar4 = wget_http_get_host(lVar1);\n    iVar3 = wget_strcmp(uVar4,uVar5);\n    if (((iVar3 == 0) && (iVar3 = wget_http_get_scheme(lVar1), iVar3 == *(int *)(param_2 + 0x5c)))\n       && (sVar2 = wget_http_get_port(lVar1), sVar2 == *(short *)(param_2 + 0x58))) {\n      uVar5 = wget_http_get_host(lVar1);\n      wget_debug_printf(\"reuse connection %s\\n\",uVar5);\n      return 0;\n    }\n    uVar5 = wget_http_get_host(lVar1);\n    wget_debug_printf(\"close connection %s\\n\",uVar5);\n    wget_http_close(param_1 + 0x10);\n  }\n  iVar3 = wget_http_open(param_1 + 0x10,param_2);\n  if (iVar3 == 0) {\n    uVar5 = wget_http_get_host(*(undefined8 *)(param_1 + 0x10));\n    wget_debug_printf(\"established connection %s\\n\",uVar5);\n  }\n  else {\n    uVar5 = wget_strerror(iVar3);\n    uVar4 = gettext(\"Failed to connect: %s\\n\");\n    wget_info_printf(uVar4,uVar5);\n  }\n  return iVar3;\n}\n\n",
        "output": "The predicted function name is try_connection"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  undefined8 uVar1;\n  int in_R8D;\n  \n  if (in_R8D == 5) {\n    uVar1 = 3;\n  }\n  else {\n    if (in_R8D < 6) {\n      if (2 < in_R8D) {\n        return 2;\n      }\n    }\n    else if (in_R8D == 6) {\n      return 4;\n    }\n    uVar1 = 0;\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is decrypt_session_ticket_cb"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  EVP_PKEY_CTX **ppEVar1;\n  \n  ppEVar1 = *(EVP_PKEY_CTX ***)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  CRYPTO_free(ppEVar1[2]);\n  CRYPTO_free(ppEVar1[4]);\n  EVP_PKEY_CTX_free(*ppEVar1);\n  return;\n}\n\n",
        "output": "The predicted function name is pkey_test_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](undefined4 *param_1,long param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  iVar1 = FUN_00012c68(\"test/ssl_test.c\",0x24,\"result->result\",\"test_ctx->expected_result\",*param_1,\n                       *(undefined4 *)(param_2 + 0x1a8));\n  if (iVar1 == 0) {\n    uVar2 = FUN_00009f33(*param_1);\n    uVar3 = FUN_00009f33(*(undefined4 *)(param_2 + 0x1a8));\n    FUN_0001261b(\"test/ssl_test.c\",0x27,\"ExpectedResult mismatch: expected %s, got %s.\",uVar3,uVar2)\n    ;\n  }\n  return iVar1 != 0;\n}\n\n",
        "output": "The predicted function name is check_result"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8\n[MASK](undefined *param_1,ulong param_2,undefined param_3,uint16_t param_4,uint16_t param_5)\n\n{\n  uint16_t uVar1;\n  undefined2 uVar2;\n  undefined8 uVar3;\n  \n  if (param_2 < 8) {\n    uVar3 = 0xffffffff;\n  }\n  else {\n    *param_1 = param_3;\n    param_1[1] = 0;\n    *(undefined2 *)(param_1 + 2) = 0;\n    uVar1 = htons(param_5);\n    *(uint16_t *)(param_1 + 6) = uVar1;\n    uVar1 = htons(param_4);\n    *(uint16_t *)(param_1 + 4) = uVar1;\n    uVar2 = FUN_00006cfc(param_1,param_2 & 0xffffffff);\n    *(undefined2 *)(param_1 + 2) = uVar2;\n    uVar3 = 0;\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is icmp_generic_encode"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined local_a8 [48];\n  undefined8 local_78;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_000410c0(param_1,local_a8);\n  if (iVar1 != 0) {\n    local_78 = 0xffffffffffffffff;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_78;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is get_file_size"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](int param_1,char *param_2)\n\n{\n  char *pcVar1;\n  int iVar2;\n  char *local_18;\n  undefined *local_10;\n  \n  pcVar1 = DAT_00220fc0;\n  if (param_1 == 0x56) {\n    DAT_00220fb0 = 1;\n  }\n  else if (param_1 < 0x57) {\n    if (param_1 != 0x48) {\n      return 7;\n    }\n    DAT_0021a010 = 0;\n  }\n  else if (param_1 == 0x68) {\n    strlen(param_2);\n    DAT_00220fb8 = (undefined *)FUN_0000fbd8();\n    local_18 = param_2;\n    local_10 = DAT_00220fb8;\n    while ((*local_18 != '\\0' && (*local_18 != ':'))) {\n      iVar2 = tolower((int)*local_18);\n      *local_10 = (char)iVar2;\n      local_18 = local_18 + 1;\n      local_10 = local_10 + 1;\n    }\n    if (*local_18 == ':') {\n      DAT_00220fc0 = local_18 + 1;\n    }\n    *local_10 = 0;\n    pcVar1 = DAT_00220fc0;\n  }\n  else {\n    pcVar1 = param_2;\n    if (param_1 != 0x70) {\n      return 7;\n    }\n  }\n  DAT_00220fc0 = pcVar1;\n  return 0;\n}\n\n",
        "output": "The predicted function name is gwhois_argp_parser"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 *param_1,undefined8 param_2)\n\n{\n  undefined8 uVar1;\n  undefined *puVar2;\n  char *pcVar3;\n  \n  if (*(int *)(DAT_00253350 + 0x10) == 0) {\n    wget_fprintf(param_2,\"  %s:\\n\",*param_1);\n    uVar1 = FUN_0002459c(*(undefined4 *)(param_1 + 3));\n    wget_fprintf(param_2,\"    Version         : %s\\n\",uVar1);\n    if (*(char *)((long)param_1 + 0x21) == '\\0') {\n      puVar2 = &DAT_00046b4d;\n    }\n    else if (*(char *)((long)param_1 + 0x21) == '\\0') {\n      puVar2 = &DAT_00046950;\n    }\n    else {\n      puVar2 = &DAT_00046b4a;\n    }\n    wget_fprintf(param_2,\"    False Start     : %s\\n\",puVar2);\n    if (*(char *)((long)param_1 + 0x22) == '\\0') {\n      puVar2 = &DAT_00046b4d;\n    }\n    else if (*(char *)((long)param_1 + 0x22) == '\\0') {\n      puVar2 = &DAT_00046950;\n    }\n    else {\n      puVar2 = &DAT_00046b4a;\n    }\n    wget_fprintf(param_2,\"    TFO             : %s\\n\",puVar2);\n    if (param_1[1] == 0) {\n      puVar2 = &DAT_00046950;\n    }\n    else {\n      puVar2 = (undefined *)param_1[1];\n    }\n    wget_fprintf(param_2,\"    ALPN Protocol   : %s\\n\",puVar2);\n    if (*(char *)((long)param_1 + 0x24) == '\\0') {\n      puVar2 = &DAT_00046ba3;\n    }\n    else {\n      puVar2 = &DAT_00046b9f;\n    }\n    wget_fprintf(param_2,\"    Resumed         : %s\\n\",puVar2);\n    if (*(char *)(param_1 + 4) == '\\0') {\n      pcVar3 = \"HTTP/1.1\";\n    }\n    else if (*(char *)(param_1 + 4) == '\\x01') {\n      pcVar3 = \"HTTP/2\";\n    }\n    else {\n      pcVar3 = \"-\";\n    }\n    wget_fprintf(param_2,\"    TCP Protocol    : %s\\n\",pcVar3);\n    wget_fprintf(param_2,\"    Cert Chain Size : %d\\n\",*(undefined4 *)((long)param_1 + 0x1c));\n    wget_fprintf(param_2,\"    TLS negotiation\\n\");\n    wget_fprintf(param_2,\"    duration (ms)   : %lld\\n\\n\",param_1[2]);\n  }\n  else {\n    if (param_1[1] == 0) {\n      puVar2 = &DAT_00046466;\n    }\n    else {\n      puVar2 = (undefined *)param_1[1];\n    }\n    wget_fprintf(param_2,\"%s,%d,%d,%d,%d,%s,%d,%d,%lld\\n\",*param_1,*(undefined4 *)(param_1 + 3),\n                 *(undefined *)((long)param_1 + 0x21),*(undefined *)((long)param_1 + 0x22),\n                 *(undefined *)((long)param_1 + 0x24),puVar2,(int)*(char *)(param_1 + 4),\n                 *(undefined4 *)((long)param_1 + 0x1c),param_1[2]);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is stats_callback_tls"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00010aaf(stdout,param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is write_info_stdout"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  \n  if ((DAT_00215a00 == 0) || (*(long *)(DAT_00215a00 + DAT_002159f0 * 8) == 0)) {\n    FUN_0000ea24();\n    puVar1 = (undefined8 *)(DAT_00215a00 + DAT_002159f0 * 8);\n    uVar2 = gcide_markup_yy_create_buffer(*(undefined8 *)PTR_gcide_markup_yyin_00212fc0,0x4000);\n    *puVar1 = uVar2;\n  }\n  if (DAT_00215a00 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = *(undefined8 *)(DAT_00215a00 + DAT_002159f0 * 8);\n  }\n  FUN_0000e6dd(uVar2,param_1);\n  FUN_0000e524();\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyrestart"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1)\n\n{\n  return *(int *)(param_1 + 4) - 4U < 3;\n}\n\n",
        "output": "The predicted function name is post_handshake_op"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,undefined8 *param_2,undefined8 *param_3)\n\n{\n  undefined8 uVar1;\n  long in_FS_OFFSET;\n  undefined local_20 [8];\n  long local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = param_1;\n  if ((*(long *)(param_1 + 0x20) == 0) && (*(long *)(param_1 + 0x10) != 0)) {\n    uVar1 = wget_read_file(*(undefined8 *)(param_1 + 0x10),local_20);\n    *(undefined8 *)(local_18 + 0x28) = uVar1;\n    if (*(long *)(local_18 + 0x28) == 0) {\n      uVar1 = 0xffffffff;\n      goto LAB_0001114b;\n    }\n    *(undefined8 *)(local_18 + 0x20) = *(undefined8 *)(local_18 + 0x28);\n  }\n  *param_2 = *(undefined8 *)(local_18 + 0x20);\n  *param_3 = *(undefined8 *)(local_18 + 0x18);\n  uVar1 = 0;\nLAB_0001114b:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is impl_file_get_contents"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  DAT_00205348 = 0;\n  DAT_00205350 = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is destroy_pkey"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,char *param_2)\n\n{\n  char *pcVar1;\n  \n  CRYPTO_free(*(void **)(param_1 + 0x28));\n  pcVar1 = CRYPTO_strdup(param_2,\"test/helpers/ssl_test_ctx.c\",0x16a);\n  *(char **)(param_1 + 0x28) = pcVar1;\n  FUN_000146a7(\"test/helpers/ssl_test_ctx.c\",0x16a,\"ctx->srp_password\",\n               *(undefined8 *)(param_1 + 0x28));\n  return;\n}\n\n",
        "output": "The predicted function name is parse_server_srp_password"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  wget_thread_mutex_init(&DAT_00253c08);\n  return;\n}\n\n",
        "output": "The predicted function name is host_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong [MASK](long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  ulong uVar2;\n  long *plVar3;\n  ulong local_28;\n  ulong local_20;\n  \n  local_28 = 0;\n  uVar2 = *(ulong *)(param_1 + 0x28);\n  while( true ) {\n    do {\n      local_20 = uVar2;\n      if (local_20 <= local_28) {\n        return 0xffffffffffffffff;\n      }\n      uVar2 = local_20 + local_28 >> 1;\n      plVar3 = (long *)_idx_get_page(param_1,uVar2);\n      if (plVar3 == (long *)0x0) {\n        return 0xffffffffffffffff;\n      }\n      iVar1 = FUN_0000bf2c(param_1,param_2,plVar3 + 7,param_3);\n    } while (iVar1 < 0);\n    if (iVar1 == 0) {\n      return uVar2;\n    }\n    iVar1 = FUN_0000bf2c(param_1,param_2,plVar3 + (*plVar3 + -1) * 7 + 7,param_3);\n    if (iVar1 < 1) break;\n    local_28 = uVar2 + 1;\n    uVar2 = local_20;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is _idx_page_locate"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined4 param_3,undefined8 param_4,\n                 undefined8 param_5)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined4 local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 *local_10;\n  \n  local_40 = param_5;\n  local_38 = param_4;\n  local_2c = param_3;\n  local_28 = param_2;\n  local_20 = param_1;\n  wget_thread_mutex_lock(DAT_00253d38);\n  wget_debug_printf(\"conversion: remember %s\\n\",local_20);\n  if (DAT_00253c80 == 0) {\n    DAT_00253c80 = wget_stringmap_create_nocase(0x80);\n    FUN_00012e28(DAT_00253c80,0);\n    FUN_00012e4e(DAT_00253c80,FUN_00019db5);\n  }\n  iVar1 = FUN_00012de0(DAT_00253c80,local_20,0);\n  if (iVar1 == 0) {\n    local_10 = (undefined8 *)FUN_00012d43(0x28);\n    uVar2 = wget_strdup(local_20);\n    *local_10 = uVar2;\n    uVar2 = wget_strdup(local_38);\n    local_10[1] = uVar2;\n    uVar2 = wget_iri_clone(local_28);\n    local_10[2] = uVar2;\n    *(undefined4 *)(local_10 + 4) = local_2c;\n    local_10[3] = local_40;\n    FUN_00012db3(DAT_00253c80,*local_10,local_10);\n  }\n  else {\n    wget_html_free_urls_inline(&local_40);\n  }\n  wget_thread_mutex_unlock(DAT_00253d38);\n  return;\n}\n\n",
        "output": "The predicted function name is remember_for_conversion"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  \n  uVar1 = FUN_00002192(param_1);\n  uVar2 = gettext(\"clock change\");\n  FUN_00002228(0xffffffff,&DAT_000073d6,0x20,0xffffffff,uVar2,uVar1,&DAT_000073d6,&DAT_000073d6,\n               &DAT_000073d6,&DAT_000073d6);\n  return;\n}\n\n",
        "output": "The predicted function name is print_clockchange"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,int param_3)\n\n{\n  close(param_3);\n  return;\n}\n\n",
        "output": "The predicted function name is afalg_waitfd_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void *param_1)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  \n  if (param_1 != (void *)0x0) {\n    CRYPTO_free(*(void **)((long)param_1 + 0x38));\n    CRYPTO_free(*(void **)((long)param_1 + 0x40));\n    CRYPTO_free(*(void **)((long)param_1 + 0x48));\n    CRYPTO_free(*(void **)((long)param_1 + 0x50));\n    CRYPTO_free(*(void **)((long)param_1 + 0xa0));\n    uVar1 = FUN_00006128(PTR_X509_NAME_free_0021ffc8);\n    uVar2 = FUN_0000611a(*(undefined8 *)((long)param_1 + 0x70));\n    OPENSSL_sk_pop_free(uVar2,uVar1);\n    uVar1 = FUN_00006128(PTR_X509_NAME_free_0021ffc8);\n    uVar2 = FUN_0000611a(*(undefined8 *)((long)param_1 + 0x88));\n    OPENSSL_sk_pop_free(uVar2,uVar1);\n    CRYPTO_free(*(void **)((long)param_1 + 0x98));\n    CRYPTO_free(param_1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is HANDSHAKE_RESULT_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00003658(param_1,0xd,param_2,0);\n  return;\n}\n\n",
        "output": "The predicted function name is set_cn1"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  FUN_000106cd(param_1,param_2,param_3,1,&DAT_0004156d,5);\n  return;\n}\n\n",
        "output": "The predicted function name is write_debug"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  SSL_METHOD *meth;\n  long lVar2;\n  long in_FS_OFFSET;\n  undefined4 local_2c;\n  SSL *local_28;\n  SSL *local_20;\n  SSL_CTX *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = (SSL_CTX *)0x0;\n  local_28 = (SSL *)0x0;\n  local_20 = (SSL *)0x0;\n  local_2c = 0;\n  meth = (SSL_METHOD *)DTLS_method();\n  local_18 = SSL_CTX_new(meth);\n  iVar1 = FUN_0000a946(\"test/dtls_mtu_test.c\",0xc5,\"ctx = SSL_CTX_new(DTLS_method())\",local_18);\n  if (iVar1 != 0) {\n    SSL_CTX_set_psk_server_callback(local_18,FUN_00003adb);\n    SSL_CTX_set_psk_client_callback(local_18,FUN_00003a78);\n    lVar2 = SSL_CTX_ctrl(local_18,0x76,1,(void *)0x0);\n    iVar1 = FUN_0000a9bb(\"test/dtls_mtu_test.c\",0xcc,\"SSL_CTX_set_dh_auto(ctx, 1)\",lVar2 != 0);\n    if (iVar1 != 0) {\n      iVar1 = FUN_000063cf(local_18,local_18,&local_28,&local_20,0,0);\n      iVar1 = FUN_0000a9bb(\"test/dtls_mtu_test.c\",0xd1,\n                           \"create_ssl_objects(ctx, ctx, &srvr_ssl, &clnt_ssl, NULL, NULL)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        SSL_set_options(local_28,0x1000);\n        lVar2 = SSL_ctrl(local_28,0x78,0x5dc,(void *)0x0);\n        iVar1 = FUN_0000a9bb(\"test/dtls_mtu_test.c\",0xd5,\"DTLS_set_link_mtu(srvr_ssl, 1500)\",\n                             lVar2 != 0);\n        if (iVar1 != 0) {\n          SSL_set_tlsext_max_fragment_length(local_20,1);\n          iVar1 = FUN_00006a36(local_28,local_20,0);\n          iVar1 = FUN_0000a9bb(\"test/dtls_mtu_test.c\",0xdc,\n                               \"create_ssl_connection(srvr_ssl, clnt_ssl, SSL_ERROR_NONE)\",\n                               iVar1 != 0);\n          if (iVar1 != 0) {\n            local_2c = 1;\n          }\n        }\n      }\n    }\n  }\n  SSL_free(local_20);\n  SSL_free(local_28);\n  SSL_CTX_free(local_18);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_2c;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_server_mtu_larger_than_max_fragment_length"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](undefined8 *param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long lVar3;\n  \n  if (DAT_00205368 == 0) {\n    lVar3 = FUN_0000248d();\n    iVar1 = DAT_0020536c;\n    if (lVar3 != 0) {\n      DAT_0020536c = DAT_0020536c + 1;\n      uVar2 = EVP_MD_get_type(lVar3);\n      *(undefined4 *)(&DAT_00205370 + (long)iVar1 * 4) = uVar2;\n    }\n    *(undefined4 *)(&DAT_00205370 + (long)DAT_0020536c * 4) = 0;\n    DAT_00205368 = 1;\n  }\n  *param_1 = &DAT_00205370;\n  return DAT_0020536c;\n}\n\n",
        "output": "The predicted function name is dasync_digest_nids"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 * [MASK](undefined8 param_1,char *param_2,char *param_3)\n\n{\n  undefined8 *puVar1;\n  size_t sVar2;\n  undefined8 *puVar3;\n  long in_FS_OFFSET;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  undefined8 local_70;\n  undefined8 local_68;\n  char *local_50;\n  char *local_48;\n  undefined8 local_40;\n  undefined8 *local_30;\n  undefined8 *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_50 = param_3;\n  local_48 = param_2;\n  local_40 = param_1;\n  puVar1 = (undefined8 *)CRYPTO_malloc(0xa0,\"test/evp_kdf_test.c\",0x28);\n  local_30 = puVar1;\n  if (puVar1 == (undefined8 *)0x0) {\n    puVar3 = (undefined8 *)0x0;\n    local_28 = puVar1;\n  }\n  else {\n    local_28 = puVar1 + 5;\n    OSSL_PARAM_construct_utf8_string(&local_88,\"digest\",local_40,0);\n    *puVar1 = local_88;\n    puVar1[1] = local_80;\n    puVar1[2] = local_78;\n    puVar1[3] = local_70;\n    puVar1[4] = local_68;\n    sVar2 = strlen(local_48);\n    puVar1 = local_28;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_octet_string(&local_88,\"secret\",local_48,sVar2);\n    *puVar1 = local_88;\n    puVar1[1] = local_80;\n    puVar1[2] = local_78;\n    puVar1[3] = local_70;\n    puVar1[4] = local_68;\n    sVar2 = strlen(local_50);\n    puVar1 = local_28;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_octet_string(&local_88,&DAT_00013be2,local_50,sVar2);\n    puVar3 = local_28;\n    *puVar1 = local_88;\n    puVar1[1] = local_80;\n    puVar1[2] = local_78;\n    puVar1[3] = local_70;\n    puVar1[4] = local_68;\n    OSSL_PARAM_construct_end(&local_88);\n    *puVar3 = local_88;\n    puVar3[1] = local_80;\n    puVar3[2] = local_78;\n    puVar3[3] = local_70;\n    puVar3[4] = local_68;\n    puVar3 = local_30;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar3;\n}\n\n",
        "output": "The predicted function name is construct_tls1_prf_params"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](char *param_1)\n\n{\n  int iVar1;\n  long lVar2;\n  long in_FS_OFFSET;\n  int local_20;\n  int local_1c;\n  int local_18;\n  int local_14;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == (char *)0x0) {\n    lVar2 = 0;\n  }\n  else {\n    iVar1 = sscanf(param_1,\"%d.%d.%d.%d\",&local_20,&local_1c,&local_18,&local_14);\n    if (iVar1 == 4) {\n      lVar2 = (long)(local_14 + local_20 * 0x1000000 + local_1c * 0x10000 + local_18 * 0x100);\n    }\n    else {\n      lVar2 = 0;\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return lVar2;\n}\n\n",
        "output": "The predicted function name is myinet_aton"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2,char *param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  char *pcVar3;\n  undefined8 uVar4;\n  \n  puVar1 = *(undefined8 **)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  iVar2 = strcmp(param_2,\"KeyName\");\n  if (iVar2 == 0) {\n    pcVar3 = CRYPTO_strdup(param_3,\"test/evp_test.c\",0xc28);\n    puVar1[1] = pcVar3;\n    uVar4 = FUN_00018f92(\"test/evp_test.c\",0xc28,\"keygen->keyname = OPENSSL_strdup(value)\",puVar1[1]\n                        );\n  }\n  else {\n    iVar2 = strcmp(param_2,\"Ctrl\");\n    if (iVar2 == 0) {\n      uVar4 = FUN_0000b5de(param_1,*puVar1,param_3);\n    }\n    else {\n      uVar4 = 0;\n    }\n  }\n  return uVar4;\n}\n\n",
        "output": "The predicted function name is keygen_test_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](int *param_1,int param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined4 *puVar3;\n  \n  iVar1 = getdtablesize();\n  if ((param_2 < 0) || (iVar1 <= param_2)) {\n    uVar2 = 9;\n  }\n  else {\n    if ((param_1[1] == *param_1) && (iVar1 = FUN_00028a6d(param_1), iVar1 != 0)) {\n      return 0xc;\n    }\n    puVar3 = (undefined4 *)((long)param_1[1] * 0x20 + *(long *)(param_1 + 2));\n    *puVar3 = 0;\n    puVar3[2] = param_2;\n    param_1[1] = param_1[1] + 1;\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is rpl_posix_spawn_file_actions_addclose"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  FUN_0000b01a(param_1 + 0x1e4,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is parse_expected_server_sign_hash"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  EVP_CIPHER *pEVar1;\n  \n  pEVar1 = EVP_aes_128_cbc_hmac_sha1();\n  FUN_00003665(param_1,pEVar1);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_aes128_cbc_hmac_sha1_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return 0;\n}\n\n",
        "output": "The predicted function name is is_mac_disabled"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined * [MASK](char *param_1,ulong *param_2)\n\n{\n  undefined *puVar1;\n  int local_24;\n  undefined **local_20;\n  undefined **local_18;\n  ulong local_10;\n  \n  local_18 = (undefined **)0x0;\n  local_10 = 0;\n  if ((*param_1 == 's') && (param_1[1] == '\\0')) {\n    *param_2 = 1;\n    puVar1 = &DAT_000112b2;\n  }\n  else {\n    for (local_20 = &PTR_DAT_002146e0; *local_20 != (undefined *)0x0; local_20 = local_20 + 2) {\n      for (local_24 = 0; (param_1[local_24] != '\\0' && (param_1[local_24] == (*local_20)[local_24]))\n          ; local_24 = local_24 + 1) {\n      }\n      if ((*local_20)[local_24] == '\\0') {\n        if (local_10 < (ulong)(long)local_24) {\n          local_10 = (ulong)local_24;\n          local_18 = local_20;\n        }\n      }\n      else if ((local_10 != 0) && (local_24 == 0)) break;\n    }\n    if (local_10 == 0) {\n      puVar1 = (undefined *)0x0;\n    }\n    else {\n      *param_2 = local_10;\n      puVar1 = local_18[1];\n    }\n  }\n  return puVar1;\n}\n\n",
        "output": "The predicted function name is gcide_grk_to_utf8"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,char *param_2)\n\n{\n  char *pcVar1;\n  \n  CRYPTO_free(*(void **)(param_1 + 0x228));\n  pcVar1 = CRYPTO_strdup(param_2,\"test/helpers/ssl_test_ctx.c\",0x16d);\n  *(char **)(param_1 + 0x228) = pcVar1;\n  FUN_000146a7(\"test/helpers/ssl_test_ctx.c\",0x16d,\"ctx->expected_session_ticket_app_data\",\n               *(undefined8 *)(param_1 + 0x228));\n  return;\n}\n\n",
        "output": "The predicted function name is parse_test_expected_session_ticket_app_data"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long *param_1)\n\n{\n  long *plVar1;\n  undefined8 *puVar2;\n  long lVar3;\n  undefined8 uVar4;\n  long in_FS_OFFSET;\n  undefined8 local_438;\n  long local_430;\n  undefined local_418 [1032];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  plVar1 = *(long **)(*param_1 + 0x20);\n  lVar3 = plVar1[0xd];\n  puVar2 = (undefined8 *)*plVar1;\n  if ((*(short *)(param_1 + 0x18) < 400) || (599 < *(short *)(param_1 + 0x18))) {\n    FUN_000160f4(lVar3,\"HTTP response %d %s [%s]\\n\",(int)*(short *)(param_1 + 0x18),param_1 + 0x13,\n                 *puVar2);\n  }\n  else {\n    FUN_000160f4(lVar3,\"HTTP ERROR response %d %s [%s]\\n\",(int)*(short *)(param_1 + 0x18),\n                 param_1 + 0x13,*puVar2);\n  }\n  if (((*(byte *)((long)param_1 + 0xcb) & 2) == 0) || (*(short *)(param_1 + 0x18) != 200)) {\n    if (((ushort)(*(short *)(param_1 + 0x18) - 400U) < 100) && (*(short *)(param_1 + 0x18) != 0x1a0)\n       ) {\n      if ((*(byte *)(plVar1 + 0x15) & 0x20) == 0) {\n        if ((*(short *)(param_1 + 0x18) == 0x194) && ((*(byte *)(plVar1 + 0x15) >> 4 & 1) != 1)) {\n          FUN_0001fa1d(8);\n        }\n      }\n      else {\n        FUN_0001fa1d(8);\n      }\n    }\n    wget_debug_printf(\"keep_alive=%d\\n\",*(undefined *)((long)param_1 + 0xca));\n    if (*(char *)((long)param_1 + 0xca) != '\\x01') {\n      wget_http_close(lVar3 + 0x10);\n    }\n    FUN_00017507(param_1);\n    wget_cookie_normalize_cookies(*plVar1,param_1[3]);\n    wget_cookie_store_cookies(DAT_00253328,param_1[3]);\n    if ((((DAT_002533e3 != '\\0') && (*(int *)((long)puVar2 + 0x5c) == 1)) &&\n        ((*(byte *)(puVar2 + 0xc) >> 6 & 1) != 1)) && ((*(byte *)((long)param_1 + 0xcb) & 4) != 0))\n    {\n      wget_hsts_db_add(DAT_00253300,puVar2[4],*(undefined2 *)(puVar2 + 0xb),param_1[0x12],\n                       *(undefined *)((long)param_1 + 0xc9));\n      DAT_00253ce8 = 1;\n    }\n    if (((DAT_002533e5 != '\\0') && (*(int *)((long)puVar2 + 0x5c) == 1)) &&\n       (((*(byte *)(puVar2 + 0xc) >> 6 & 1) != 1 && (param_1[5] != 0)))) {\n      wget_hpkp_set_host(param_1[5],puVar2[4]);\n      wget_hpkp_db_add(DAT_00253308,param_1 + 5);\n      DAT_00253cec = 1;\n    }\n    if (((*(short *)(param_1 + 0x18) == 0x12e) && (param_1[1] != 0)) && (param_1[2] != 0)) {\n      uVar4 = 0;\n    }\n    else if (*(short *)(param_1 + 0x18) == 0x191) {\n      *(int *)(plVar1 + 0x13) = *(int *)(plVar1 + 0x13) + 1;\n      if ((*(int *)(plVar1 + 0x13) < 2) && (param_1[4] != 0)) {\n        plVar1[4] = param_1[4];\n        *(byte *)(plVar1 + 0x15) = *(byte *)(plVar1 + 0x15) | 1;\n        param_1[4] = 0;\n        *(byte *)(plVar1 + 0x15) = *(byte *)(plVar1 + 0x15) & 0xfb;\n        uVar4 = 1;\n      }\n      else {\n        FUN_0001fa1d(6);\n        uVar4 = 1;\n      }\n    }\n    else if (*(short *)(param_1 + 0x18) == 0x197) {\n      if ((plVar1[5] == 0) && (param_1[4] != 0)) {\n        plVar1[5] = param_1[4];\n        param_1[4] = 0;\n        *(byte *)(plVar1 + 0x15) = *(byte *)(plVar1 + 0x15) & 0xfb;\n        uVar4 = 1;\n      }\n      else {\n        FUN_0001fa1d(6);\n        uVar4 = 1;\n      }\n    }\n    else {\n      if ((*(short *)(param_1 + 0x18) == 0x1a0) && (param_1[0xf] == 0)) {\n        uVar4 = gettext(\"The file is already fully retrieved; nothing to do.\\n\");\n        wget_info_printf(uVar4);\n      }\n      if ((((ushort)(*(short *)(param_1 + 0x18) - 200U) < 100) || (399 < *(short *)(param_1 + 0x18))\n          ) || (*(short *)(param_1 + 0x18) == 0x130)) {\n        uVar4 = 0;\n      }\n      else {\n        if (param_1[9] != 0) {\n          if (((ushort)(*(short *)(param_1 + 0x18) - 300U) < 100) &&\n             (*(short *)(param_1 + 0x18) != 0x133)) {\n            *(byte *)((long)plVar1 + 0xa9) = *(byte *)((long)plVar1 + 0xa9) | 4;\n          }\n          wget_cookie_normalize_cookies(*plVar1,param_1[3]);\n          wget_cookie_store_cookies(DAT_00253328,param_1[3]);\n          wget_buffer_init(&local_438,local_418,0x400);\n          wget_iri_relative_to_abs(puVar2,param_1[9],0xffffffffffffffff,&local_438);\n          if (local_430 != 0) {\n            FUN_00014525(plVar1,\"utf-8\",local_438,1,0);\n          }\n          wget_buffer_deinit(&local_438);\n        }\n        uVar4 = 0;\n      }\n    }\n  }\n  else {\n    FUN_000160f4(lVar3,\"Unexpected body length %zu.\",param_1[0xe]);\n    if (DAT_00253390 != 0) {\n      *(int *)((long)plVar1 + 0xa4) = *(int *)((long)plVar1 + 0xa4) + 1;\n      if (*(int *)((long)plVar1 + 0xa4) < DAT_00253390) {\n        if (*(long *)(plVar1[9] + 8) != 0) {\n          wget_debug_printf(\"Removing %s\\n\",*(undefined8 *)(plVar1[9] + 8));\n          unlink(*(char **)(plVar1[9] + 8));\n        }\n        *(byte *)(plVar1 + 0x15) = *(byte *)(plVar1 + 0x15) & 0xfb;\n        lVar3 = wget_get_timemillis();\n        plVar1[0x11] = lVar3 + *(int *)((long)plVar1 + 0xa4) * 1000;\n      }\n    }\n    uVar4 = 1;\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar4;\n}\n\n",
        "output": "The predicted function name is process_response_header"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  int iVar1;\n  int *piVar2;\n  long in_FS_OFFSET;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = utf8_mbstr_to_wc(param_1,&local_18,0);\n  if (iVar1 != 0) {\n    piVar2 = __errno_location();\n    dico_log(4,*piVar2,0xcbb,param_1);\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_18;\n}\n\n",
        "output": "The predicted function name is strtowc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_0000397d(\"https://1.2.3.4/p/q\",1,\"1.2.3.4\",&DAT_0000e2fe,&DAT_0000e2f9);\n  return;\n}\n\n",
        "output": "The predicted function name is test_http_url_ipv4"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_14;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_00009ddc(&PTR_DAT_0021efc0,4,&local_14,param_2);\n  if (iVar1 != 0) {\n    *(undefined4 *)(param_1 + 0x1b8) = local_14;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1 != 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is parse_expected_servername"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](long param_1)\n\n{\n  long *plVar1;\n  int iVar2;\n  \n  plVar1 = *(long **)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  if ((*plVar1 == 0) || (plVar1[1] == 0)) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KEYPAIR_TYPE_MISMATCH\";\n  }\n  else {\n    iVar2 = EVP_PKEY_eq(*plVar1,plVar1[1]);\n    if (iVar2 == 1) {\n      *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n    }\n    else if (iVar2 == 0) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KEYPAIR_MISMATCH\";\n    }\n    else if (iVar2 == -1) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KEYPAIR_TYPE_MISMATCH\";\n    }\n    else {\n      if (iVar2 != -2) {\n        FUN_000170fc(\"test/evp_test.c\",0xbd3,\"Unexpected error in key comparison\");\n        return 0;\n      }\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"UNSUPPORTED_KEY_COMPARISON\";\n    }\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is keypair_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,ulong param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  uint32_t uVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  timeval local_28;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 < 0x14) {\n    uVar2 = 0xffffffff;\n  }\n  else {\n    gettimeofday(&local_28,(__timezone_ptr_t)0x0);\n    uVar1 = htonl((int)(local_28.tv_usec / 1000) +\n                  (int)local_28.tv_sec * 1000 + (int)(local_28.tv_sec / 0x15180) * -86400000);\n    *(uint32_t *)(param_1 + 8) = uVar1;\n    *(uint32_t *)(param_1 + 0xc) = uVar1;\n    *(uint32_t *)(param_1 + 0x10) = uVar1;\n    FUN_000069ac(param_1,param_2,0xd,param_3,param_4);\n    uVar2 = 0;\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is icmp_timestamp_encode"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (DAT_00205388 == (code *)0x0) {\n    EVP_PKEY_meth_get_paramgen(DAT_00205350,&DAT_00205388,0);\n  }\n  if (DAT_00205388 == (code *)0x0) {\n    uVar1 = 1;\n  }\n  else {\n    uVar1 = (*DAT_00205388)(param_1);\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is dasync_rsa_paramgen_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](SSL *param_1,long param_2)\n\n{\n  char *__s;\n  SSL_SESSION *pSVar1;\n  undefined8 uVar2;\n  size_t sVar3;\n  \n  pSVar1 = SSL_get_session(param_1);\n  __s = *(char **)(param_2 + 0x30);\n  if ((pSVar1 == (SSL_SESSION *)0x0) || (__s == (char *)0x0)) {\n    uVar2 = 0;\n  }\n  else {\n    sVar3 = strlen(__s);\n    uVar2 = SSL_SESSION_set1_ticket_appdata(pSVar1,__s,sVar3);\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is generate_session_ticket_cb"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 *param_2)\n\n{\n  wget_debug_printf(\"blacklist %s\\n\",*param_2);\n  return 0;\n}\n\n",
        "output": "The predicted function name is blacklist_print_entry"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined4 param_1,undefined8 param_2)\n\n{\n  wget_bar_slot_downloaded(DAT_00253bd8,param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is bar_set_downloaded"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](double param_1,double param_2,double *param_3)\n\n{\n  long in_FS_OFFSET;\n  double in_stack_00000008;\n  double in_stack_00000010;\n  double in_stack_00000018;\n  double local_88;\n  double local_80;\n  ulong local_68;\n  ulong local_60;\n  double local_48;\n  double local_40;\n  double local_38;\n  double local_28;\n  double local_20;\n  double local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (((in_stack_00000008 == 0.0) && (in_stack_00000010 == 0.0)) &&\n     (in_stack_00000018 == DAT_000067f0)) {\n    *param_3 = param_1;\n    param_3[1] = param_2;\n  }\n  else if (((in_stack_00000008 == 0.0) && (in_stack_00000010 == 0.0)) &&\n          (in_stack_00000018 == DAT_000067f8)) {\n    *param_3 = param_1;\n    param_3[1] = param_2;\n    *param_3 = (double)(DAT_00006800 ^ (ulong)*param_3);\n  }\n  else {\n    local_48 = in_stack_00000008;\n    local_40 = in_stack_00000010;\n    local_38 = in_stack_00000018;\n    FUN_0000542c(&local_68);\n    if ((DAT_00006820 <= (double)(DAT_00006810 & local_68)) ||\n       (DAT_00006820 <= (double)(DAT_00006810 & local_60))) {\n      local_28 = 0.0;\n      local_20 = 0.0;\n      local_18 = DAT_000067f0;\n      FUN_00005506(&local_28);\n      FUN_0000542c(&local_88);\n    }\n    else {\n      local_28 = 0.0;\n      local_20 = DAT_000067f0;\n      local_18 = 0.0;\n      FUN_00005506(0,&local_28);\n      FUN_0000542c(&local_88);\n    }\n    FUN_00005506(&local_28);\n    FUN_0000542c(&local_28);\n    *param_3 = local_80 * param_2 + param_1 * local_88;\n    param_3[1] = local_20 * param_2 + param_1 * local_28;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is transform_OCS_2d"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  int iVar1;\n  int extraout_EAX;\n  long in_FS_OFFSET;\n  int local_40;\n  int local_3c;\n  uchar *local_38;\n  uchar *local_30;\n  EVP_ENCODE_CTX *local_28;\n  uchar **local_20;\n  EVP_ENCODE_CTX *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = *(uchar ***)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  local_38 = (uchar *)0x0;\n  local_30 = (uchar *)0x0;\n  local_18 = (EVP_ENCODE_CTX *)0x0;\n  local_28 = (EVP_ENCODE_CTX *)0x0;\n  local_18 = (EVP_ENCODE_CTX *)EVP_ENCODE_CTX_new();\n  iVar1 = FUN_00018f92(\"test/evp_test.c\",0x90a,\"decode_ctx = EVP_ENCODE_CTX_new()\",local_18);\n  if (iVar1 == 0) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"INTERNAL_ERROR\";\n    goto LAB_0000d3aa;\n  }\n  if (*(int *)(local_20 + 4) == 0) {\n    local_28 = (EVP_ENCODE_CTX *)EVP_ENCODE_CTX_new();\n    iVar1 = FUN_00018f92(\"test/evp_test.c\",0x911,\"encode_ctx = EVP_ENCODE_CTX_new()\",local_28);\n    if (iVar1 == 0) goto LAB_0000d3aa;\n    local_38 = (uchar *)CRYPTO_malloc(((int)((ulong)local_20[1] / 0x30) +\n                                       (int)((ulong)(local_20[1] + 2) / 3) * 2 + 0x29) * 2,\n                                      \"test/evp_test.c\",0x913);\n    iVar1 = FUN_00018f92(\"test/evp_test.c\",0x913,\n                         \"encode_out = OPENSSL_malloc(EVP_ENCODE_LENGTH(expected->input_len))\",\n                         local_38);\n    if (iVar1 == 0) goto LAB_0000d3aa;\n    EVP_EncodeInit(local_28);\n    EVP_EncodeUpdate(local_28,local_38,&local_40,*local_20,(int)local_20[1]);\n    iVar1 = FUN_00019007(\"test/evp_test.c\",0x918,\n                         \"EVP_EncodeUpdate(encode_ctx, encode_out, &chunk_len, expected->input, expected->input_len)\"\n                         ,extraout_EAX != 0);\n    if (iVar1 == 0) goto LAB_0000d3aa;\n    local_3c = local_40;\n    EVP_EncodeFinal(local_28,local_38 + local_40,&local_40);\n    local_3c = local_3c + local_40;\n    iVar1 = FUN_000060ba(param_1,\"BAD_ENCODING\",local_20[2],local_20[3],local_38,(long)local_3c);\n    if (iVar1 == 0) goto LAB_0000d3aa;\n  }\n  local_30 = (uchar *)CRYPTO_malloc((int)((ulong)(local_20[3] + 3) >> 2) * 3 + 0x50,\n                                    \"test/evp_test.c\",0x927);\n  iVar1 = FUN_00018f92(\"test/evp_test.c\",0x927,\n                       \"decode_out = OPENSSL_malloc(EVP_DECODE_LENGTH(expected->output_len))\",\n                       local_30);\n  if (iVar1 != 0) {\n    EVP_DecodeInit(local_18);\n    iVar1 = EVP_DecodeUpdate(local_18,local_30,&local_40,local_20[2],(int)local_20[3]);\n    if (iVar1 < 0) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DECODE_ERROR\";\n    }\n    else {\n      local_3c = local_40;\n      iVar1 = EVP_DecodeFinal(local_18,local_30 + local_40,&local_40);\n      if (iVar1 == 1) {\n        local_3c = local_3c + local_40;\n        if ((*(int *)(local_20 + 4) == 2) ||\n           (iVar1 = FUN_000060ba(param_1,\"BAD_DECODING\",*local_20,local_20[1],local_30,\n                                 (long)local_3c), iVar1 != 0)) {\n          *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n        }\n        else {\n          *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"BAD_DECODING\";\n        }\n      }\n      else {\n        *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DECODE_ERROR\";\n      }\n    }\n  }\nLAB_0000d3aa:\n  CRYPTO_free(local_38);\n  CRYPTO_free(local_30);\n  EVP_ENCODE_CTX_free(local_18);\n  EVP_ENCODE_CTX_free(local_28);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is encode_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](long param_1)\n\n{\n  undefined4 uVar1;\n  \n  if (param_1 == 0) {\n    uVar1 = 0;\n  }\n  else {\n    uVar1 = *(undefined4 *)(param_1 + 0x68);\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is gcide_iterator_flags"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  \n  uVar1 = FUN_0000e3dc(param_1,0);\n  uVar2 = FUN_0001128f(uVar1,param_1,param_2);\n  (*wget_free)(uVar1);\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is plugin_db_load_from_path"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void *param_1)\n\n{\n  long lVar1;\n  void *__ptr;\n  \n  if (*(int *)(DAT_00215a78 + 0x10) == 1) {\n    __ptr = calloc(1,0x28);\n    if (__ptr == (void *)0x0) {\n      FUN_0000c95a(\"append_tag\");\n    }\n    *(undefined4 *)((long)__ptr + 0x10) = 1;\n    *(undefined8 *)((long)__ptr + 0x20) = *(undefined8 *)(DAT_00215a78 + 0x20);\n    lVar1 = dico_list_create();\n    if (lVar1 == 0) {\n      free(__ptr);\n      free(param_1);\n      FUN_0000c95a(\"append_tag\");\n    }\n    dico_list_set_free_item(lVar1,FUN_0000cc1e,0);\n    dico_list_append(lVar1,__ptr);\n    *(undefined4 *)(DAT_00215a78 + 0x10) = 2;\n    *(long *)(DAT_00215a78 + 0x20) = lVar1;\n  }\n  else if (*(int *)(DAT_00215a78 + 0x10) == 0) {\n    lVar1 = dico_list_create();\n    if (lVar1 == 0) {\n      free(param_1);\n      FUN_0000c95a(\"append_tag\");\n    }\n    dico_list_set_free_item(lVar1,FUN_0000cc1e,0);\n    *(undefined4 *)(DAT_00215a78 + 0x10) = 2;\n    *(long *)(DAT_00215a78 + 0x20) = lVar1;\n  }\n  dico_list_append(*(undefined8 *)(DAT_00215a78 + 0x20),param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is append_tag"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](void)\n\n{\n  long in_FS_OFFSET;\n  bool bVar1;\n  undefined *local_20;\n  long local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = &DAT_00211010;\n  local_18 = FUN_00002cf9(0,&local_20,4);\n  bVar1 = local_18 != 0;\n  if (bVar1) {\n    FUN_00002d6b(local_18);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return bVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_int64"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](char *param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  uint local_c;\n  \n  local_c = 0;\n  while( true ) {\n    if (0xf < local_c) {\n      uVar2 = gettext(\"Unknown OSABI: %s\\n\");\n      error(uVar2,param_1);\n      return 0xffffffff;\n    }\n    iVar1 = strcasecmp(param_1,(&PTR_DAT_00209b68)[(ulong)local_c * 2]);\n    if (iVar1 == 0) break;\n    local_c = local_c + 1;\n  }\n  return *(undefined4 *)(&DAT_00209b60 + (ulong)local_c * 0x10);\n}\n\n",
        "output": "The predicted function name is elf_osabi"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void **param_1)\n\n{\n  void *local_18;\n  \n  fclose((FILE *)param_1[1]);\n  free(*param_1);\n  free(param_1[5]);\n  free(param_1[6]);\n  free(param_1[7]);\n  free(param_1[8]);\n  for (local_18 = (void *)0x0; local_18 < param_1[2]; local_18 = (void *)((long)local_18 + 1)) {\n    free(*(void **)((long)local_18 * 0x30 + (long)param_1[3]));\n    if (param_1[4] != (void *)0x0) {\n      free(*(void **)((long)local_18 * 0x30 + (long)param_1[4]));\n    }\n  }\n  free(param_1[3]);\n  free(param_1[4]);\n  free(param_1);\n  return 0;\n}\n\n",
        "output": "The predicted function name is outline_free_db"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](BIO *param_1)\n\n{\n  int iVar1;\n  long lVar2;\n  long in_FS_OFFSET;\n  int local_50;\n  int local_4c;\n  long local_48;\n  long local_40;\n  undefined local_38 [16];\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_4c = 0;\n  local_50 = 0;\n  local_40 = BIO_ctrl(param_1,3,0,&local_48);\n  if (local_40 < 0) {\n    iVar1 = 0;\n  }\n  else {\n    iVar1 = FUN_00003567(local_38,local_48,local_40);\n    if (iVar1 == 0) {\n      iVar1 = 0;\n    }\n    else {\n      iVar1 = FUN_000036e5(local_38,&local_50);\n      if ((iVar1 == 0) || (local_50 != 0x16)) {\n        iVar1 = 0;\n      }\n      else {\n        iVar1 = FUN_0000365d(local_38,&local_50);\n        if ((iVar1 == 0) || (local_50 != 0x100)) {\n          iVar1 = 0;\n        }\n        else {\n          iVar1 = FUN_0000385b(local_38,10);\n          if (iVar1 == 0) {\n            iVar1 = 0;\n          }\n          else {\n            iVar1 = FUN_000036e5(local_38,&local_50);\n            if ((iVar1 == 0) || (local_50 != 1)) {\n              iVar1 = 0;\n            }\n            else {\n              iVar1 = FUN_0000385b(local_38,0xb);\n              if (iVar1 == 0) {\n                iVar1 = 0;\n              }\n              else {\n                iVar1 = FUN_0000365d(local_38,&local_50);\n                if ((iVar1 == 0) || (local_50 != 0x100)) {\n                  iVar1 = 0;\n                }\n                else {\n                  iVar1 = FUN_0000380b(local_38,&DAT_002134a0,0x20);\n                  if (iVar1 == 0) {\n                    iVar1 = 0;\n                  }\n                  else {\n                    iVar1 = FUN_0000389e(local_38,local_28);\n                    if (iVar1 != 0) {\n                      iVar1 = FUN_000035a5(local_28,&DAT_002134e0,0x20);\n                      if (iVar1 != 0) {\n                        iVar1 = FUN_0000389e(local_38,local_28);\n                        if (iVar1 == 0) {\n                          iVar1 = 0;\n                          goto LAB_00003e63;\n                        }\n                        lVar2 = FUN_00003555(local_28);\n                        if (lVar2 != 0) {\n                          iVar1 = FUN_000035a5(local_28,&DAT_00213530,0x14);\n                          if (iVar1 == 0) {\n                            iVar1 = 0;\n                            goto LAB_00003e63;\n                          }\n                          local_4c = 1;\n                        }\n                        iVar1 = FUN_0000365d(local_38,&local_50);\n                        if (iVar1 != 0) {\n                          iVar1 = FUN_0000385b(local_38,local_50);\n                          if (iVar1 != 0) {\n                            iVar1 = FUN_000036e5(local_38,&local_50);\n                            if (iVar1 != 0) {\n                              iVar1 = FUN_0000385b(local_38,local_50);\n                              if (iVar1 != 0) {\n                                iVar1 = FUN_0000365d(local_38,&local_50);\n                                if (iVar1 != 0) {\n                                  iVar1 = FUN_0000385b(local_38,local_50);\n                                  if (iVar1 != 0) {\n                                    lVar2 = FUN_00003555(local_38);\n                                    if (lVar2 == 0) {\n                                      if (local_4c != 0) {\n                                        iVar1 = EVP_DigestUpdate(DAT_002135c8,\n                                                                 (void *)(local_48 + 0x19),\n                                                                 local_40 - 0x19);\n                                        if (iVar1 == 0) {\n                                          iVar1 = 0;\n                                          goto LAB_00003e63;\n                                        }\n                                      }\n                                      BIO_ctrl(param_1,1,0,(void *)0x0);\n                                      iVar1 = local_4c + 1;\n                                    }\n                                    else {\n                                      iVar1 = 0;\n                                    }\n                                    goto LAB_00003e63;\n                                  }\n                                }\n                                iVar1 = 0;\n                                goto LAB_00003e63;\n                              }\n                            }\n                            iVar1 = 0;\n                            goto LAB_00003e63;\n                          }\n                        }\n                        iVar1 = 0;\n                        goto LAB_00003e63;\n                      }\n                    }\n                    iVar1 = 0;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_00003e63:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is validate_client_hello"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 [MASK](long param_1,long param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long lVar3;\n  long in_FS_OFFSET;\n  char local_1a;\n  char local_19;\n  double local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 != 0) {\n    local_1a = '\\0';\n    local_19 = '\\0';\n    local_18 = 0.0;\n    iVar1 = wget_strcasecmp_ascii(0,param_2,&DAT_000433e2);\n    if ((iVar1 == 0) || (iVar1 = wget_strcasecmp_ascii(param_2,\"INFINITY\"), iVar1 == 0)) {\n      **(undefined8 **)(param_1 + 0x18) = 0;\n      uVar2 = 0;\n      goto LAB_0001fefe;\n    }\n    iVar1 = FUN_0001fba6(param_2,&local_18,&local_1a);\n    if ((iVar1 < 1) || (local_18 < 0.0)) {\n      local_19 = '\\x01';\n    }\n    else if (local_1a != '\\0') {\n      iVar1 = FUN_0002857d((int)local_1a);\n      if (iVar1 == 0x6b) {\n        local_18 = DAT_000474b0 * local_18;\n      }\n      else if (iVar1 < 0x6c) {\n        if (iVar1 == 0x67) {\n          local_18 = DAT_000474c0 * local_18;\n        }\n        else {\nLAB_0001fe8c:\n          local_19 = '\\x01';\n        }\n      }\n      else if (iVar1 == 0x6d) {\n        local_18 = DAT_000474b8 * local_18;\n      }\n      else {\n        if (iVar1 != 0x74) goto LAB_0001fe8c;\n        local_18 = DAT_000474c8 * local_18;\n      }\n    }\n    if (local_19 != '\\0') {\n      uVar2 = gettext(\"Invalid byte specifier: %s\\n\");\n      wget_error_printf(uVar2,param_2);\n      uVar2 = 0xffffffff;\n      goto LAB_0001fefe;\n    }\n    if (local_18 <= _DAT_000474d0) {\n      lVar3 = (long)local_18;\n    }\n    else {\n      lVar3 = 0x7fffffffffffffff;\n    }\n    **(long **)(param_1 + 0x18) = lVar3;\n  }\n  uVar2 = 0;\nLAB_0001fefe:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is parse_numbytes"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  long in_FS_OFFSET;\n  uchar *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = &DAT_00213260;\n  DAT_0021326f = DAT_002134e0;\n  DAT_00213277 = DAT_002134e8;\n  DAT_0021327f = DAT_002134f0;\n  DAT_00213287 = DAT_002134f8;\n  DAT_00213291 = DAT_00213500;\n  DAT_00213299 = DAT_00213508;\n  DAT_002132a1 = DAT_00213510;\n  DAT_002132a9 = DAT_00213518;\n  DAT_002132b1 = DAT_00213520;\n  DAT_002132b9 = DAT_00213528;\n  d2i_SSL_SESSION((SSL_SESSION **)0x0,&local_18,0x61);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is client_session"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 [MASK](long param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  char local_19;\n  double local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = DAT_000474d8;\n  iVar1 = wget_strcasecmp_ascii(param_2,&DAT_000433e2);\n  if ((iVar1 != 0) && (iVar1 = wget_strcasecmp_ascii(param_2,\"INFINITY\"), iVar1 != 0)) {\n    local_19 = '\\0';\n    iVar1 = FUN_0001fba6(param_2,&local_18,&local_19);\n    if ((0 < iVar1) && (0.0 <= local_18)) {\n      if (local_19 == '\\0') {\n        local_18 = DAT_000474e0 * local_18;\n      }\n      else {\n        iVar1 = FUN_0002857d((int)local_19);\n        if (iVar1 == 0x68) {\n          local_18 = DAT_000474f0 * local_18;\n        }\n        else if (iVar1 < 0x69) {\n          if (iVar1 != 100) {\nLAB_00020f32:\n            uVar2 = gettext(\"Invalid time specifier in \\'%s\\'\\n\");\n            wget_error_printf(uVar2,param_2);\n            uVar2 = 0xffffffff;\n            goto LAB_0002100b;\n          }\n          local_18 = DAT_000474f8 * local_18;\n        }\n        else if (iVar1 == 0x6d) {\n          local_18 = DAT_000474e8 * local_18;\n        }\n        else {\n          if (iVar1 != 0x73) goto LAB_00020f32;\n          local_18 = DAT_000474e0 * local_18;\n        }\n      }\n    }\n  }\n  if (local_18 <= 0.0) {\n    local_18 = DAT_000474d8;\n  }\n  if (*(long *)(param_1 + 0x18) == 0) {\n    if (local_18 <= _DAT_00047500) {\n      DAT_002533ac = (int)local_18;\n      DAT_002533b0 = DAT_002533ac;\n      DAT_002533b4 = DAT_002533ac;\n    }\n    else {\n      DAT_002533ac = 0x7fffffff;\n      DAT_002533b0 = DAT_002533ac;\n      DAT_002533b4 = DAT_002533ac;\n    }\n  }\n  else {\n    if (local_18 <= _DAT_00047500) {\n      iVar1 = (int)local_18;\n    }\n    else {\n      iVar1 = 0x7fffffff;\n    }\n    **(int **)(param_1 + 0x18) = iVar1;\n  }\n  uVar2 = 0;\nLAB_0002100b:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is parse_timeout"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 *param_1)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  \n  if (param_1 == (undefined8 *)0x0) {\n    uVar1 = 0xffffffff;\n  }\n  else {\n    param_1[5] = param_1[3];\n    param_1[6] = param_1[4];\n    param_1[10] = 0;\n    puVar2 = (undefined8 *)_idx_get_page(*param_1,param_1[5]);\n    if (puVar2 == (undefined8 *)0x0) {\n      uVar1 = 0xffffffff;\n    }\n    else {\n      param_1[7] = *puVar2;\n      uVar1 = 0;\n    }\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is gcide_iterator_rewind"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  iVar1 = OSSL_PROVIDER_add_builtin(param_1,\"fake-rsa\",FUN_00003d57);\n  iVar1 = FUN_0000880f(\"test/fake_rsaprov.c\",0x194,\n                       \"OSSL_PROVIDER_add_builtin(libctx, \\\"fake-rsa\\\", fake_rsa_provider_init)\",\n                       iVar1 != 0);\n  if (iVar1 != 0) {\n    uVar2 = OSSL_PROVIDER_try_load(param_1,\"fake-rsa\",1);\n    iVar1 = FUN_0000879a(\"test/fake_rsaprov.c\",0x195,\n                         \"p = OSSL_PROVIDER_try_load(libctx, \\\"fake-rsa\\\", 1)\",uVar2);\n    if (iVar1 != 0) {\n      return uVar2;\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is fake_rsa_start"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  FUN_00002d1a(0,param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is get_kdfbyname"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void **param_1)\n\n{\n  uint local_c;\n  \n  for (local_c = 0; (void *)(ulong)local_c < param_1[2]; local_c = local_c + 1) {\n    __gmpz_clear((void *)((long)*param_1 + (ulong)local_c * 0x10));\n  }\n  free(*param_1);\n  free(param_1[1]);\n  return;\n}\n\n",
        "output": "The predicted function name is mp_factor_clear"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](char *param_1,undefined8 param_2)\n\n{\n  undefined4 uVar1;\n  size_t sVar2;\n  long in_FS_OFFSET;\n  undefined8 uVar3;\n  undefined local_34 [4];\n  undefined4 local_30;\n  int local_2c;\n  undefined local_28 [8];\n  long local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = 0;\n  local_20 = pcre2_compile_8(param_2,0xffffffffffffffff,0,local_34,local_28,0);\n  if (local_20 == 0) {\n    uVar1 = 0;\n  }\n  else {\n    local_18 = pcre2_match_data_create_from_pattern_8(local_20,0);\n    uVar3 = 0x13758;\n    sVar2 = strlen(param_1);\n    local_2c = pcre2_match_8(local_20,param_1,sVar2,0,0,local_18,0,uVar3);\n    if (-1 < local_2c) {\n      local_30 = 1;\n    }\n    pcre2_match_data_free_8(local_18);\n    pcre2_code_free_8(local_20);\n    uVar1 = local_30;\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is regex_match_pcre"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](undefined8 param_1,char *param_2)\n\n{\n  int iVar1;\n  \n  if ((param_2 != (char *)0x0) && (iVar1 = strcmp(param_2,PTR_s_dasync_00205320), iVar1 != 0)) {\n    return false;\n  }\n  iVar1 = FUN_000025ac(param_1);\n  return iVar1 != 0;\n}\n\n",
        "output": "The predicted function name is bind_helper"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,undefined8 *param_2)\n\n{\n  long in_FS_OFFSET;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_28 = 0;\n  local_20 = 0;\n  local_18 = 0;\n  local_20 = wget_get_timemillis();\n  if (param_1 == 0) {\n    wget_thread_mutex_lock(DAT_00253c08);\n    wget_hashmap_browse(DAT_00253c00,FUN_0000ecd9,&local_28);\n    wget_thread_mutex_unlock(DAT_00253c08);\n  }\n  else {\n    FUN_0000ecd9(&local_28,param_1,0);\n  }\n  if (param_2 != (undefined8 *)0x0) {\n    *param_2 = local_18;\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_28;\n}\n\n",
        "output": "The predicted function name is host_get_job"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong [MASK](long param_1)\n\n{\n  return *(ulong *)(param_1 + 0x30) & 0xffffffffffffff00 | (ulong)(*(ulong *)(param_1 + 0x30) != 0);\n}\n\n",
        "output": "The predicted function name is impl_file_get_recurse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](undefined8 param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  \n  iVar1 = FUN_00006555(param_1,param_3,0);\n  if (iVar1 == 0) {\n    *param_2 = 0x70;\n  }\n  return iVar1 != 0;\n}\n\n",
        "output": "The predicted function name is client_hello_reject_cb"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  *(undefined8 *)(param_1 + 0x30) = param_2;\n  return;\n}\n\n",
        "output": "The predicted function name is impl_register_url_filter"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int param_1,uint param_2,undefined8 param_3)\n\n{\n  int *local_10;\n  \n  local_10 = &DAT_002145c0;\n  while( true ) {\n    if ((int *)0x2146ff < local_10) {\n      printf(\"%s, Unknown Code: %d\\n\",param_3,(ulong)param_2);\n      return;\n    }\n    if ((param_1 == *local_10) && (param_2 == local_10[1])) break;\n    local_10 = local_10 + 4;\n  }\n  puts(*(char **)(local_10 + 2));\n  return;\n}\n\n",
        "output": "The predicted function name is print_icmp_code"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                 undefined8 param_5)\n\n{\n  syscall(0xd0,param_1,param_2,param_3,param_4,param_5);\n  return;\n}\n\n",
        "output": "The predicted function name is io_getevents"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  FUN_0000a186(param_1,1);\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_descr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return 1;\n}\n\n",
        "output": "The predicted function name is fake_rsa_st_set_ctx_params"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1,long param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  iVar1 = FUN_00012c68(\"test/ssl_test.c\",0x7e,\"result->servername\",\"test_ctx->expected_servername\",\n                       *(undefined4 *)(param_1 + 0x24),*(undefined4 *)(param_2 + 0x1b8));\n  if (iVar1 == 0) {\n    uVar2 = FUN_0000a1cf(*(undefined4 *)(param_1 + 0x24));\n    uVar3 = FUN_0000a1cf(*(undefined4 *)(param_2 + 0x1b8));\n    FUN_0001261b(\"test/ssl_test.c\",0x81,\"Client ServerName mismatch, expected %s, got %s.\",uVar3,\n                 uVar2);\n  }\n  return iVar1 != 0;\n}\n\n",
        "output": "The predicted function name is check_servername"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,char *param_2)\n\n{\n  char *pcVar1;\n  \n  CRYPTO_free(*(void **)(param_1 + 0x10));\n  pcVar1 = CRYPTO_strdup(param_2,\"test/helpers/ssl_test_ctx.c\",0x15f);\n  *(char **)(param_1 + 0x10) = pcVar1;\n  FUN_000146a7(\"test/helpers/ssl_test_ctx.c\",0x15f,\"ctx->npn_protocols\",\n               *(undefined8 *)(param_1 + 0x10));\n  return;\n}\n\n",
        "output": "The predicted function name is parse_client_npn_protocols"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong [MASK](char *param_1,undefined4 param_2,undefined4 param_3,int param_4,char *param_5,\n                  ulong param_6)\n\n{\n  ulong uVar1;\n  size_t sVar2;\n  int *piVar3;\n  undefined8 uVar4;\n  uint local_1c;\n  int local_18;\n  int local_14;\n  char *local_10;\n  \n  if ((param_6 == 0) || (*param_5 == '\\0')) {\n    local_1c = FUN_0001c1f5(param_1,param_2,param_3);\n    if ((int)local_1c < 0) {\n      if (DAT_00253404 == '\\0') {\n        local_14 = 1;\n        while (((local_14 < 99999 && ((int)local_1c < 0)) &&\n               (((param_4 != 0 && (piVar3 = __errno_location(), *piVar3 == 0x11)) ||\n                (piVar3 = __errno_location(), *piVar3 == 0x15))))) {\n          uVar1 = wget_snprintf(param_5,param_6,\"%s.%d\",param_1,local_14);\n          if (param_6 <= uVar1) {\n            return 0xffffffff;\n          }\n          local_1c = FUN_0001c1f5(param_5,param_2,param_3);\n          local_14 = local_14 + 1;\n        }\n      }\n      else {\n        local_10 = strrchr(param_1,0x2e);\n        if (local_10 == (char *)0x0) {\n          sVar2 = strlen(param_1);\n          local_10 = param_1 + sVar2;\n        }\n        local_18 = 1;\n        while ((local_18 < 99999 && ((int)local_1c < 0))) {\n          if (param_4 == 0) {\nLAB_0001c381:\n            uVar4 = 0x1c386;\n            piVar3 = __errno_location();\n            if (*piVar3 != 0x15) break;\n          }\n          else {\n            uVar4 = 0x1c376;\n            piVar3 = __errno_location();\n            if (*piVar3 != 0x11) goto LAB_0001c381;\n          }\n          uVar1 = wget_snprintf(param_5,param_6,\"%.*s_%d%s\",\n                                (long)local_10 - (long)param_1 & 0xffffffff,param_1,local_18,\n                                local_10,uVar4);\n          if (param_6 <= uVar1) {\n            return 0xffffffff;\n          }\n          local_1c = FUN_0001c1f5(param_5,param_2,param_3);\n          local_18 = local_18 + 1;\n        }\n      }\n      uVar1 = (ulong)local_1c;\n    }\n    else {\n      uVar1 = (ulong)local_1c;\n    }\n  }\n  else {\n    uVar1 = FUN_0001c1f5(param_5,param_2,param_3);\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is open_unique"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined *param_1)\n\n{\n  *param_1 = 1;\n  return 1;\n}\n\n",
        "output": "The predicted function name is fake_rsa_keymgmt_import"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](undefined8 param_1,int param_2)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  lVar1 = gcide_markup_yyalloc(0x48);\n  if (lVar1 == 0) {\n    FUN_0000ed51(\"out of dynamic memory in yy_create_buffer()\");\n  }\n  *(long *)(lVar1 + 0x18) = (long)param_2;\n  uVar2 = gcide_markup_yyalloc(*(long *)(lVar1 + 0x18) + 2);\n  *(undefined8 *)(lVar1 + 8) = uVar2;\n  if (*(long *)(lVar1 + 8) == 0) {\n    FUN_0000ed51(\"out of dynamic memory in yy_create_buffer()\");\n  }\n  *(undefined4 *)(lVar1 + 0x28) = 1;\n  FUN_0000e6dd(lVar1,param_1);\n  return lVar1;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yy_create_buffer"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](undefined8 param_1,undefined8 param_2,long param_3)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long in_FS_OFFSET;\n  void *local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = (void *)0x0;\n  local_18 = param_1;\n  iVar1 = (**(code **)(param_3 + 0x48))(param_1,&local_20);\n  if (iVar1 < 0) {\n    uVar2 = 0xffffffff;\n  }\n  else {\n    uVar2 = FUN_000039d3(local_20,(long)iVar1,param_1,param_2,param_3);\n    CRYPTO_free(local_20);\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is do_enc_dec"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  bool bVar1;\n  int iVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  long in_FS_OFFSET;\n  char *local_58;\n  char *local_50;\n  undefined8 local_48;\n  char *local_40;\n  undefined8 local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  bVar1 = false;\n  iVar2 = mu_sieve_get_tag(param_1,\"subject\",2,&local_50);\n  if (iVar2 == 0) {\n    iVar2 = mu_message_get_header(param_2,&local_48);\n    if (iVar2 == 0) {\n      iVar2 = mu_header_aget_value_unfold_n(local_48,\"Subject\",1,&local_58);\n      if (iVar2 == 0) {\n        iVar2 = mu_rfc2047_decode(\"UTF-8\",local_58,&local_40);\n        bVar1 = true;\n        if (iVar2 == 0) {\n          local_50 = local_40;\n        }\n        else {\n          local_50 = local_58;\n          local_58 = (char *)0x0;\n        }\n        iVar2 = mu_sieve_get_tag(param_1,\"reply_regex\",2,&local_40);\n        if (iVar2 != 0) {\n          local_38 = 0;\n          iVar2 = mu_unre_set_regex(local_40,0,&local_38);\n          if (iVar2 != 0) {\n            uVar3 = FUN_0000235a(local_38);\n            uVar4 = mu_strerror(iVar2);\n            uVar5 = mu_sieve_get_message_num(param_1);\n            uVar6 = dgettext(\"mailutils\",\"%lu: cannot compile reply prefix regexp: %s: %s\");\n            mu_sieve_error(param_1,uVar6,uVar5,uVar4,uVar3);\n          }\n        }\n        iVar2 = mu_unre_subject(local_50,0);\n        if (iVar2 != 0) {\n          FUN_0000309a(param_1,&local_50);\n        }\n        free(local_58);\n        goto LAB_000033ac;\n      }\n    }\n    local_50 = \"Re: Your mail\";\n  }\nLAB_000033ac:\n  iVar2 = mu_rfc2047_encode(\"UTF-8\",\"quoted-printable\",local_50,&local_58);\n  if (iVar2 == 0) {\n    mu_header_set_value(param_3,\"Subject\",local_58,1);\n    free(local_58);\n  }\n  else {\n    mu_header_set_value(param_3,\"Subject\",local_50,1);\n  }\n  if (bVar1) {\n    free(local_50);\n  }\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is vacation_subject"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](char *param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  long in_FS_OFFSET;\n  long local_48;\n  char *local_40;\n  char *local_38;\n  char *local_30;\n  char *local_28;\n  char *local_20;\n  long local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = (char *)wget_strdup(param_1);\n  local_30 = strchr(local_38,0x2e);\n  if (local_30 == (char *)0x0) {\n    FUN_0000df2f(param_2,\"\\'%s\\': \\'.\\' is missing (separates plugin name and option)\",param_1);\n    (*wget_free)(local_38);\n    uVar2 = 0xffffffff;\n  }\n  else if (local_30 == local_38) {\n    FUN_0000df2f(param_2,\"\\'%s\\': Plugin name is missing.\",param_1);\n    (*wget_free)(local_38);\n    uVar2 = 0xffffffff;\n  }\n  else {\n    *local_30 = '\\0';\n    local_28 = local_38;\n    local_20 = local_30 + 1;\n    local_30 = strchr(local_20,0x3d);\n    if (local_30 == (char *)0x0) {\n      local_40 = (char *)0x0;\n    }\n    else {\n      *local_30 = '\\0';\n      local_40 = local_30 + 1;\n    }\n    if (*local_20 == '\\0') {\n      FUN_0000df2f(param_2,\n                   \"\\'%s\\': An option is required (after \\'.\\', and before \\'=\\' if present)\",\n                   param_1);\n      (*wget_free)(local_38);\n      uVar2 = 0xffffffff;\n    }\n    else {\n      iVar1 = strcmp(local_20,\"help\");\n      if (iVar1 == 0) {\n        if (local_40 != (char *)0x0) {\n          FUN_0000df2f(param_2,\"\\'help\\' option does not accept arguments\\n\");\n          (*wget_free)(local_38);\n          uVar2 = 0xffffffff;\n          goto LAB_000119b3;\n        }\n        DAT_00253c40 = 1;\n      }\n      iVar1 = FUN_00010d57(DAT_00253c38,local_28,&local_48);\n      if (iVar1 == 0) {\n        FUN_0000df2f(param_2,\"Plugin \\'%s\\' is not loaded.\",local_28);\n        (*wget_free)(local_38);\n        uVar2 = 0xffffffff;\n      }\n      else {\n        local_18 = local_48;\n        if (*(long *)(local_48 + 0x28) == 0) {\n          FUN_0000df2f(param_2,\"Plugin \\'%s\\' does not accept options.\",\n                       *(undefined8 *)(local_48 + 0x10));\n          (*wget_free)(local_38);\n          uVar2 = 0xffffffff;\n        }\n        else {\n          iVar1 = (**(code **)(local_48 + 0x28))(local_48,local_20,local_40);\n          if (iVar1 < 0) {\n            pcVar3 = strchrnul(param_1,0x2e);\n            FUN_0000df2f(param_2,\"Plugin \\'%s\\' did not accept option \\'%s\\'\",\n                         *(undefined8 *)(local_48 + 0x10),pcVar3);\n            (*wget_free)(local_38);\n            uVar2 = 0xffffffff;\n          }\n          else {\n            (*wget_free)(local_38);\n            uVar2 = 0;\n          }\n        }\n      }\n    }\n  }\nLAB_000119b3:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is plugin_db_forward_option"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long in_FS_OFFSET;\n  void *local_20;\n  void *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = OSSL_HTTP_parse_url(param_1,0,0,&local_20,0,0,&local_18,0,0);\n  iVar1 = FUN_0000a9e9(\"test/http_test.c\",0xf0,\n                       \"OSSL_HTTP_parse_url(url, NULL, NULL, &host, NULL, NULL, &path, NULL, NULL)\",\n                       iVar1 != 0);\n  if (iVar1 != 0) {\n    iVar1 = FUN_0000aac1(\"test/http_test.c\",0xf1,&DAT_0000e199,\"\\\"host\\\"\",local_20,&DAT_0000e199);\n    if (iVar1 != 0) {\n      iVar1 = FUN_0000aac1(\"test/http_test.c\",0xf2,&DAT_0000e1c1,\"exp_path_qu\",local_18,param_2);\n      if (iVar1 != 0) {\n        uVar2 = 1;\n        goto LAB_00003dbb;\n      }\n    }\n  }\n  uVar2 = 0;\nLAB_00003dbb:\n  CRYPTO_free(local_20);\n  CRYPTO_free(local_18);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_http_url_path_query_ok"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,char **param_2)\n\n{\n  char cVar1;\n  size_t sVar2;\n  size_t sVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  ulong uVar6;\n  char *pcVar7;\n  long in_FS_OFFSET;\n  byte bVar8;\n  char *local_30;\n  char *local_28;\n  long local_20;\n  \n  bVar8 = 0;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = \"Re\";\n  mu_sieve_get_tag(param_1,\"reply_prefix\",2,&local_30);\n  sVar2 = strlen(*param_2);\n  sVar3 = strlen(local_30);\n  local_28 = (char *)malloc(sVar3 + sVar2 + 3);\n  if (local_28 == (char *)0x0) {\n    uVar4 = mu_sieve_get_message_num(param_1);\n    uVar5 = dgettext(\"mailutils\",\"%lu: not enough memory\");\n    mu_sieve_error(param_1,uVar5,uVar4);\n  }\n  else {\n    strcpy(local_28,local_30);\n    uVar6 = 0xffffffffffffffff;\n    pcVar7 = local_28;\n    do {\n      if (uVar6 == 0) break;\n      uVar6 = uVar6 - 1;\n      cVar1 = *pcVar7;\n      pcVar7 = pcVar7 + (ulong)bVar8 * -2 + 1;\n    } while (cVar1 != '\\0');\n    *(undefined2 *)(local_28 + (~uVar6 - 1)) = 0x203a;\n    *(undefined *)((long)(local_28 + (~uVar6 - 1)) + 2) = 0;\n    strcat(local_28,*param_2);\n    free(*param_2);\n    *param_2 = local_28;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is re_subject"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  wget_vector_clear(DAT_00253c28);\n  return;\n}\n\n",
        "output": "The predicted function name is plugin_db_clear_search_paths"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  if (((param_2 == (char *)0x0) || (*param_2 == '\\0')) ||\n     (iVar1 = wget_strcasecmp_ascii(param_2,&DAT_0004354a), iVar1 == 0)) {\n    **(undefined4 **)(param_1 + 0x18) = 0;\n  }\n  else {\n    iVar1 = wget_strcasecmp_ascii(param_2,&DAT_0004356f);\n    if (iVar1 == 0) {\n      **(undefined4 **)(param_1 + 0x18) = 1;\n    }\n    else {\n      iVar1 = wget_strcasecmp_ascii(param_2,\"windows\");\n      if (iVar1 == 0) {\n        **(undefined4 **)(param_1 + 0x18) = 2;\n      }\n      else {\n        iVar1 = wget_strcasecmp_ascii(param_2,\"nocontrol\");\n        if (iVar1 == 0) {\n          **(undefined4 **)(param_1 + 0x18) = 4;\n        }\n        else {\n          iVar1 = wget_strcasecmp_ascii(param_2,\"ascii\");\n          if (iVar1 == 0) {\n            **(undefined4 **)(param_1 + 0x18) = 8;\n          }\n          else {\n            iVar1 = wget_strcasecmp_ascii(param_2,\"uppercase\");\n            if (iVar1 == 0) {\n              **(undefined4 **)(param_1 + 0x18) = 0x10;\n            }\n            else {\n              iVar1 = wget_strcasecmp_ascii(param_2,\"lowercase\");\n              if (iVar1 != 0) {\n                uVar2 = gettext(\"Unknown restrict-file-name type \\'%s\\'\\n\");\n                wget_error_printf(uVar2,param_2);\n                return 0xffffffff;\n              }\n              **(undefined4 **)(param_1 + 0x18) = 0x20;\n            }\n          }\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is parse_restrict_names"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0000fe57(param_1,param_2,0,1);\n  return;\n}\n\n",
        "output": "The predicted function name is oneshot_digestsign_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_14;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_00009ddc(&PTR_s_Ignore_0021f060,3,&local_14,param_2);\n  if (iVar1 != 0) {\n    *(undefined4 *)(param_1 + 0x1bc) = local_14;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1 != 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is parse_session_ticket"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined * [MASK](int param_1)\n\n{\n  undefined *puVar1;\n  \n  if (param_1 == 0x1a7) {\n    puVar1 = &DAT_00204230;\n  }\n  else if (param_1 == 0x1ab) {\n    puVar1 = &DAT_00204240;\n  }\n  else if (param_1 == 0x1a3) {\n    puVar1 = &DAT_00204220;\n  }\n  else {\n    puVar1 = (undefined *)0x0;\n  }\n  return puVar1;\n}\n\n",
        "output": "The predicted function name is get_cipher_handle"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](long param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_2c;\n  EVP_PKEY *local_28;\n  EVP_PKEY_CTX **local_20;\n  EVP_PKEY_CTX **local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = *(EVP_PKEY_CTX ***)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  local_28 = (EVP_PKEY *)0x0;\n  local_2c = 1;\n  iVar1 = EVP_PKEY_keygen(*local_20,&local_28);\n  if (iVar1 < 1) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KEYGEN_GENERATE_ERROR\";\n  }\n  else if (*(long *)&local_28[1].save_parameters == 0) {\n    FUN_00016f06(\"test/evp_test.c\",0xc3a,\"Warning: legacy key generated %s\",local_20[1]);\n  }\n  else {\n    if (local_20[1] == (EVP_PKEY_CTX *)0x0) {\n      EVP_PKEY_free(local_28);\n    }\n    else {\n      local_2c = 0;\n      iVar1 = FUN_00010ea5(0,local_20[1],DAT_002241b0);\n      if (iVar1 != 0) {\n        FUN_00016f06(\"test/evp_test.c\",0xc42,\"Duplicate key %s\",local_20[1]);\n        goto LAB_0000fe3e;\n      }\n      local_18 = (EVP_PKEY_CTX **)CRYPTO_malloc(0x18,\"test/evp_test.c\",0xc46);\n      iVar1 = FUN_00018f92(\"test/evp_test.c\",0xc46,\"key = OPENSSL_malloc(sizeof(*key))\",local_18);\n      if (iVar1 == 0) goto LAB_0000fe3e;\n      *local_18 = local_20[1];\n      local_20[1] = (EVP_PKEY_CTX *)0x0;\n      local_18[1] = (EVP_PKEY_CTX *)local_28;\n      local_18[2] = (EVP_PKEY_CTX *)DAT_002241b0;\n      DAT_002241b0 = local_18;\n    }\n    local_2c = 1;\n    *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n  }\nLAB_0000fe3e:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_2c;\n}\n\n",
        "output": "The predicted function name is keygen_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  wget_fprintf(DAT_00253c78,\n               \"ID,ParentID,URL,Status,Link,Method,Size,SizeDecompressed,TransferTime,ResponseTime,Encoding,Verification,Last-Modified,Content-Type\\n\"\n              );\n  wget_vector_browse(DAT_00253c60,FUN_00012b79,DAT_00253c78);\n  return;\n}\n\n",
        "output": "The predicted function name is print_csv"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SSL **param_1)\n\n{\n  SSL_free(*param_1);\n  CRYPTO_free(param_1[1]);\n  CRYPTO_free(param_1[3]);\n  return;\n}\n\n",
        "output": "The predicted function name is peer_free_data"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  return param_1;\n}\n\n",
        "output": "The predicted function name is ossl_check_GENERAL_NAME_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  BIO_METHOD *type;\n  ulong uVar2;\n  long in_FS_OFFSET;\n  undefined4 local_24;\n  BUF_MEM *local_20;\n  BIO *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_24 = 0;\n  local_18 = (BIO *)0x0;\n  local_20 = (BUF_MEM *)0x0;\n  type = BIO_s_mem();\n  local_18 = BIO_new(type);\n  iVar1 = FUN_000078e9(\"test/bio_memleak_test.c\",0x32,&DAT_0000d168,local_18);\n  if (iVar1 != 0) {\n    iVar1 = BIO_puts(local_18,\"Hello World\\n\");\n    iVar1 = FUN_00005eaa(\"test/bio_memleak_test.c\",0x34,\"BIO_puts(bio, \\\"Hello World\\\\n\\\")\",\n                         &DAT_0000d1c5,iVar1,0xc);\n    if (iVar1 != 0) {\n      BIO_ctrl(local_18,0x73,0,&local_20);\n      iVar1 = FUN_000078e9(\"test/bio_memleak_test.c\",0x37,\"bufmem\",local_20);\n      if (iVar1 != 0) {\n        uVar2 = BIO_ctrl(local_18,9,0,(void *)0x0);\n        iVar1 = FUN_000060a6(\"test/bio_memleak_test.c\",0x39,\"BIO_set_close(bio, BIO_NOCLOSE)\",\n                             &DAT_0000d1ee,uVar2 & 0xffffffff,0);\n        if (iVar1 != 0) {\n          BIO_free(local_18);\n          local_18 = (BIO *)0x0;\n          iVar1 = FUN_00007e1c(\"test/bio_memleak_test.c\",0x3d,\"bufmem->data\",\"\\\"Hello World\\\\n\\\"\",\n                               local_20->data,local_20->length,\"Hello World\\n\",0xc);\n          if (iVar1 != 0) {\n            local_24 = 1;\n          }\n        }\n      }\n    }\n  }\n  BIO_free(local_18);\n  BUF_MEM_free(local_20);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_24;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_bio_get_mem"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nuint [MASK](undefined8 *param_1,undefined8 *param_2)\n\n{\n  uint uVar1;\n  \n  if (*(int *)(param_1 + 6) == *(int *)(param_2 + 6)) {\n    uVar1 = wget_strcmp(*param_1,*param_2);\n    if (uVar1 == 0) {\n      if (*(ushort *)((long)param_1 + 0x34) < *(ushort *)((long)param_2 + 0x34)) {\n        uVar1 = 0xffffffff;\n      }\n      else {\n        uVar1 = (uint)(*(ushort *)((long)param_2 + 0x34) < *(ushort *)((long)param_1 + 0x34));\n      }\n    }\n  }\n  else if (*(uint *)(param_1 + 6) < *(uint *)(param_2 + 6)) {\n    uVar1 = 0xffffffff;\n  }\n  else {\n    uVar1 = 1;\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is _host_compare"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Type propagation algorithm not settling */\n\nvoid [MASK](long param_1,undefined8 param_2,undefined8 param_3,int param_4)\n\n{\n  byte bVar1;\n  int iVar2;\n  int *piVar3;\n  long lVar4;\n  undefined8 *puVar5;\n  long in_FS_OFFSET;\n  int local_ec;\n  undefined local_e8 [4];\n  int local_e4;\n  int local_e0;\n  int local_dc;\n  int local_d8;\n  undefined4 local_d4;\n  undefined4 local_d0;\n  int local_cc;\n  int local_c8;\n  int local_c4;\n  double local_c0;\n  timeval local_b8;\n  timeval local_a8;\n  long lStack16;\n  \n  lStack16 = *(long *)(in_FS_OFFSET + 0x28);\n  local_e0 = 0;\n  local_c0 = 0.0;\n  local_dc = 0;\n  printf((char *)0x0,\" %2d  \");\n  local_e4 = 0;\n  do {\n    if (param_4 <= local_e4) {\n      putchar(10);\n      if (lStack16 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n      return;\n    }\n    local_d8 = FUN_00003816(param_1);\n    puVar5 = (undefined8 *)&stack0xffffffffffffff68;\n    for (lVar4 = 0x10; lVar4 != 0; lVar4 = lVar4 + -1) {\n      *puVar5 = 0;\n      puVar5 = puVar5 + 1;\n    }\n    local_d0 = SUB84(puVar5,0);\n    local_d4 = 0;\n    iVar2 = local_d8;\n    if (local_d8 < 0) {\n      iVar2 = local_d8 + 0x3f;\n    }\n    bVar1 = (byte)(local_d8 >> 0x37);\n    *(ulong *)(&stack0xffffffffffffff68 + (long)(iVar2 >> 6) * 8) =\n         *(ulong *)(&stack0xffffffffffffff68 + (long)(iVar2 >> 6) * 8) |\n         1 << (((char)local_d8 + (bVar1 >> 2) & 0x3f) - (bVar1 >> 2) & 0x3f);\n    memset(&local_a8,0,0x10);\n    local_a8.tv_sec = (__time_t)DAT_0020f024;\n    local_a8.tv_usec = 0;\n    if (local_e0 == 0) {\n      FUN_000035a7();\n    }\n    piVar3 = __errno_location();\n    *piVar3 = 0;\n    local_cc = select(local_d8 + 1,(fd_set *)&stack0xffffffffffffff68,(fd_set *)0x0,(fd_set *)0x0,\n                      &local_a8);\n    piVar3 = __errno_location();\n    local_c8 = *piVar3;\n    gettimeofday(&local_b8,(__timezone_ptr_t)0x0);\n    local_b8.tv_usec = local_b8.tv_usec - *(long *)(param_1 + 0x40);\n    local_b8.tv_sec = local_b8.tv_sec - *(long *)(param_1 + 0x38);\n    if (local_b8.tv_usec < 0) {\n      local_b8.tv_sec = local_b8.tv_sec + -1;\n      local_b8.tv_usec = local_b8.tv_usec + 1000000;\n    }\n    if (local_cc < 0) {\n      if (local_c8 != 4) {\n        piVar3 = __errno_location();\n        error(1,*piVar3,\"select failed\");\n      }\nLAB_00002da2:\n      local_e0 = 0;\n      fflush(stdout);\n    }\n    else {\n      if (local_cc == 0) {\n        printf(\" * \");\n        fflush(stdout);\n        goto LAB_00002da2;\n      }\n      iVar2 = local_d8;\n      if (local_d8 < 0) {\n        iVar2 = local_d8 + 0x3f;\n      }\n      bVar1 = (byte)(local_d8 >> 0x37);\n      if ((1 << (((char)local_d8 + (bVar1 >> 2) & 0x3f) - (bVar1 >> 2) & 0x3f) &\n          *(ulong *)(&stack0xffffffffffffff68 + (long)(iVar2 >> 6) * 8)) == 0) goto LAB_00002da2;\n      local_c0 = (double)local_b8.tv_usec / DAT_0000c6e8 + DAT_0000c6e8 * (double)local_b8.tv_sec;\n      local_c4 = FUN_000031d5(param_1,&local_ec,local_e8);\n      if (-1 < local_c4) {\n        if ((local_e4 == 0) || (local_dc != *(int *)(param_1 + 0x24))) {\n          inet_ntoa((in_addr)((in_addr *)(param_1 + 0x24))->s_addr);\n          printf(\" %s \");\n          if (DAT_0020f340 != 0) {\n            FUN_00002df5(param_1 + 0x24);\n            printf(\"(%s) \");\n          }\n        }\n        printf(\" %.3fms \");\n        if ((0 < local_c4) && (local_ec == 3)) {\n          printf(\"!%c \");\n        }\n        local_dc = *(int *)(param_1 + 0x24);\n        goto LAB_00002da2;\n      }\n      local_e4 = local_e4 + -1;\n      local_e0 = 1;\n    }\n    local_e4 = local_e4 + 1;\n  } while( true );\n}\n\n",
        "output": "The predicted function name is do_try"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](undefined8 param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined local_70 [8];\n  char local_68 [88];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = EVP_PKEY_is_a(param_1,&DAT_000181fe);\n  if (iVar1 == 0) {\n    iVar1 = EVP_PKEY_get_id(param_1);\n  }\n  else {\n    iVar1 = EVP_PKEY_get_group_name(param_1,local_68,0x50,local_70);\n    if (iVar1 == 0) {\n      iVar1 = 0;\n    }\n    else {\n      iVar1 = OBJ_txt2nid(local_68);\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is pkey_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,SSL **param_2)\n\n{\n  undefined uVar1;\n  int iVar2;\n  uint uVar3;\n  long in_FS_OFFSET;\n  bool bVar4;\n  undefined local_1d;\n  int local_1c;\n  uint local_18;\n  int local_14;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (*(int *)((long)param_2 + 0x2c) == 0) {\n    *(undefined4 *)((long)param_2 + 0x2c) = 1;\n    FUN_00007c46(param_2);\n    goto LAB_0000834f;\n  }\n  iVar2 = FUN_00012c68(\"test/helpers/handshake.c\",0x36c,\"peer->status\",\"PEER_RETRY\",\n                       *(undefined4 *)((long)param_2 + 0x2c),1);\n  if (iVar2 != 0) {\n    if ((((*(int *)(param_1 + 4) == 2) || (*(int *)(param_1 + 4) == 3)) ||\n        (*(int *)(param_1 + 4) == 4)) ||\n       ((*(int *)(param_1 + 4) == 5 || (*(int *)(param_1 + 4) == 6)))) {\n      uVar1 = 1;\n    }\n    else {\n      uVar1 = 0;\n    }\n    iVar2 = FUN_0001471c(\"test/helpers/handshake.c\",0x376,\n                         \"test_ctx->handshake_mode == SSL_TEST_HANDSHAKE_RENEG_SERVER || test_ctx->handshake_mode == SSL_TEST_HANDSHAKE_RENEG_CLIENT || test_ctx->handshake_mode == SSL_TEST_HANDSHAKE_KEY_UPDATE_SERVER || test_ctx->handshake_mode == SSL_TEST_HANDSHAKE_KEY_UPDATE_CLIENT || test_ctx->handshake_mode == SSL_TEST_HANDSHAKE_POST_HANDSHAKE_AUTH\"\n                         ,uVar1);\n    if (iVar2 != 0) {\n      *(undefined4 *)(param_2 + 5) = *(undefined4 *)(param_1 + 8);\n      *(undefined4 *)((long)param_2 + 0x24) = *(undefined4 *)(param_2 + 5);\n      if (((*(int *)(param_1 + 4) == 2) && (iVar2 = SSL_is_server(*param_2), iVar2 != 0)) ||\n         ((*(int *)(param_1 + 4) == 3 && (iVar2 = SSL_is_server(*param_2), iVar2 == 0)))) {\n        iVar2 = SSL_renegotiate_pending(*param_2);\n        if (iVar2 == 0) {\n          iVar2 = SSL_is_server(*param_2);\n          if (iVar2 == 0) {\n            local_18 = 0;\n            bVar4 = *(int *)(param_1 + 0x5c) != 0;\n            if (bVar4) {\n              SSL_set_options(*param_2,1);\n            }\n            local_18 = (uint)bVar4;\n            if (*(long *)(param_1 + 0x40) != 0) {\n              iVar2 = SSL_set_cipher_list(*param_2,*(char **)(param_1 + 0x40));\n              if (iVar2 == 0) {\n                *(undefined4 *)((long)param_2 + 0x2c) = 2;\n                goto LAB_0000834f;\n              }\n              local_18 = 1;\n            }\n            if (local_18 == 0) {\n              local_1c = SSL_renegotiate_abbreviated(*param_2);\n            }\n            else {\n              local_1c = SSL_renegotiate(*param_2);\n            }\n          }\n          else {\n            local_1c = SSL_renegotiate(*param_2);\n          }\n          if (local_1c == 0) {\n            *(undefined4 *)((long)param_2 + 0x2c) = 2;\n          }\n          else {\n            FUN_00007c46(param_2);\n            if (*(int *)((long)param_2 + 0x2c) == 1) {\n              *(undefined4 *)((long)param_2 + 0x2c) = 0;\n            }\n            else if (*(int *)((long)param_2 + 0x2c) == 0) {\n              *(undefined4 *)((long)param_2 + 0x2c) = 1;\n            }\n          }\n          goto LAB_0000834f;\n        }\n      }\n      else {\n        if ((*(int *)(param_1 + 4) == 4) || (*(int *)(param_1 + 4) == 5)) {\n          uVar3 = SSL_is_server(*param_2);\n          if (uVar3 == (*(int *)(param_1 + 4) == 4)) {\n            local_1c = SSL_key_update(*param_2,*(undefined4 *)(param_1 + 0x10));\n            if (local_1c == 0) {\n              *(undefined4 *)((long)param_2 + 0x2c) = 2;\n            }\n            else {\n              FUN_00007c46(param_2);\n              if (*(int *)((long)param_2 + 0x2c) != 0) {\n                *(undefined4 *)((long)param_2 + 0x2c) = 2;\n              }\n            }\n          }\n          else {\n            *(undefined4 *)((long)param_2 + 0x2c) = 0;\n          }\n          goto LAB_0000834f;\n        }\n        if (*(int *)(param_1 + 4) == 6) {\n          iVar2 = SSL_is_server(*param_2);\n          if (iVar2 != 0) {\n            if (*(int *)(param_1 + 0x90) != 0) {\n              *(undefined4 *)&(*param_2)[4].enc_write_ctx = 2;\n            }\n            local_1c = SSL_verify_client_post_handshake(*param_2);\n            if (local_1c == 0) {\n              *(undefined4 *)((long)param_2 + 0x2c) = 2;\n              goto LAB_0000834f;\n            }\n          }\n          FUN_00007c46(param_2);\n          if (*(int *)((long)param_2 + 0x2c) != 0) {\n            *(undefined4 *)((long)param_2 + 0x2c) = 2;\n          }\n          goto LAB_0000834f;\n        }\n      }\n      local_1c = SSL_read(*param_2,&local_1d,1);\n      if (local_1c < 0) {\n        local_14 = SSL_get_error(*param_2,local_1c);\n        if (local_14 == 2) {\n          iVar2 = SSL_in_init(*param_2);\n          if (iVar2 != 0) {\n            *(undefined4 *)((long)param_2 + 0x2c) = 0;\n          }\n        }\n        else {\n          *(undefined4 *)((long)param_2 + 0x2c) = 2;\n        }\n      }\n      else {\n        *(undefined4 *)((long)param_2 + 0x2c) = 2;\n      }\n      goto LAB_0000834f;\n    }\n  }\n  *(undefined4 *)((long)param_2 + 0x2c) = 4;\nLAB_0000834f:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is do_reneg_setup_step"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](byte *param_1,ulong *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  ushort **ppuVar3;\n  byte *local_10;\n  \n  iVar1 = FUN_00019007(\"test/evp_test.c\",0x7fb,&DAT_0001d41a,*param_1 != 0);\n  if (iVar1 == 0) {\n    FUN_00016f06(\"test/evp_test.c\",0x7fc,\"Invalid empty integer value\");\n    uVar2 = 0xffffffff;\n  }\n  else {\n    *param_2 = 0;\n    for (local_10 = param_1; *local_10 != 0; local_10 = local_10 + 1) {\n      if (0x1999999999999999 < *param_2) {\n        FUN_000170fc(\"test/evp_test.c\",0x801,\"Integer overflow in string %s\",param_1);\n        return 0xffffffff;\n      }\n      *param_2 = *param_2 * 10;\n      ppuVar3 = __ctype_b_loc();\n      iVar1 = FUN_00019007(\"test/evp_test.c\",0x805,\"isdigit((unsigned char)*p)\",\n                           ((*ppuVar3)[*local_10] & 0x800) != 0);\n      if (iVar1 == 0) {\n        FUN_000170fc(\"test/evp_test.c\",0x806,\"Invalid character in string %s\",param_1);\n        return 0xffffffff;\n      }\n      *param_2 = *param_2 + (long)((char)*local_10 + -0x30);\n    }\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is parse_uint64"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](double *param_1)\n\n{\n  long in_FS_OFFSET;\n  double in_stack_00000008;\n  double in_stack_00000010;\n  double in_stack_00000018;\n  double in_stack_00000020;\n  double in_stack_00000028;\n  double in_stack_00000030;\n  double local_88;\n  double local_80;\n  double local_78;\n  double local_68;\n  double local_60;\n  double local_58;\n  double local_48;\n  double local_40;\n  double local_38;\n  double local_28;\n  double local_20;\n  double local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (((in_stack_00000020 == 0.0) && (in_stack_00000028 == 0.0)) &&\n     (in_stack_00000030 == DAT_000067f0)) {\n    *param_1 = in_stack_00000008;\n    param_1[1] = in_stack_00000010;\n    param_1[2] = in_stack_00000018;\n  }\n  else if (((in_stack_00000020 == 0.0) && (in_stack_00000028 == 0.0)) &&\n          (in_stack_00000030 == DAT_000067f8)) {\n    *param_1 = in_stack_00000008;\n    param_1[1] = in_stack_00000010;\n    param_1[2] = in_stack_00000018;\n    *param_1 = (double)(DAT_00006800 ^ (ulong)*param_1);\n  }\n  else {\n    local_48 = in_stack_00000020;\n    local_40 = in_stack_00000028;\n    local_38 = in_stack_00000030;\n    FUN_0000542c(&local_68);\n    if ((DAT_00006820 <= (double)(DAT_00006810 & (ulong)local_68)) ||\n       (DAT_00006820 <= (double)(DAT_00006810 & (ulong)local_60))) {\n      local_28 = 0.0;\n      local_20 = 0.0;\n      local_18 = DAT_000067f0;\n      FUN_00005506(&local_28);\n      FUN_0000542c(&local_88);\n    }\n    else {\n      local_28 = 0.0;\n      local_20 = DAT_000067f0;\n      local_18 = 0.0;\n      FUN_00005506(0,&local_28);\n      FUN_0000542c(&local_88);\n    }\n    FUN_00005506(&local_28);\n    FUN_0000542c(&local_28);\n    *param_1 = local_78 * in_stack_00000018 +\n               in_stack_00000008 * local_88 + local_80 * in_stack_00000010;\n    param_1[1] = local_18 * in_stack_00000018 +\n                 in_stack_00000008 * local_28 + local_20 * in_stack_00000010;\n    param_1[2] = local_58 * in_stack_00000018 +\n                 in_stack_00000008 * local_68 + local_60 * in_stack_00000010;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is transform_OCS"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 *param_1,undefined8 param_2)\n\n{\n  if (*(int *)(DAT_00253338 + 0x10) == 0) {\n    wget_fprintf(param_2,\"  %s:\\n\",*param_1);\n    wget_fprintf(param_2,\"    Stapling       : %d\\n\",*(undefined4 *)((long)param_1 + 0x14));\n    wget_fprintf(param_2,\"    Valid          : %d\\n\",*(undefined4 *)(param_1 + 1));\n    wget_fprintf(param_2,\"    Revoked        : %d\\n\",*(undefined4 *)((long)param_1 + 0xc));\n    wget_fprintf(param_2,\"    Ignored        : %d\\n\\n\",*(undefined4 *)(param_1 + 2));\n  }\n  else {\n    wget_fprintf(param_2,\"%s,%d,%d,%d,%d\\n\",*param_1,*(undefined4 *)((long)param_1 + 0x14),\n                 *(undefined4 *)(param_1 + 1),*(undefined4 *)((long)param_1 + 0xc),\n                 *(undefined4 *)(param_1 + 2));\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is stats_callback_ocsp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  int *piVar1;\n  int local_14;\n  \n  for (local_14 = 0; local_14 < *(int *)(param_1 + 4); local_14 = local_14 + 1) {\n    piVar1 = (int *)(*(long *)(param_1 + 8) + (long)local_14 * 0x20);\n    if (*piVar1 == 2) {\n      FUN_000286f2(*(undefined8 *)(piVar1 + 4));\n    }\n    else if (*piVar1 == 3) {\n      FUN_000286f2(*(undefined8 *)(piVar1 + 2));\n    }\n  }\n  FUN_000286f2(*(undefined8 *)(param_1 + 8));\n  return 0;\n}\n\n",
        "output": "The predicted function name is rpl_posix_spawn_file_actions_destroy"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return 1;\n}\n\n",
        "output": "The predicted function name is dl_supported"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  long lVar1;\n  \n  lVar1 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  FUN_00006094(*(undefined8 *)(lVar1 + 0x10),FUN_000061a0);\n  CRYPTO_free(*(void **)(lVar1 + 0x18));\n  EVP_MD_free(*(undefined8 *)(lVar1 + 8));\n  return;\n}\n\n",
        "output": "The predicted function name is digest_test_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8\n[MASK](int param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,undefined8 param_5\n            ,undefined8 param_6,undefined4 param_7)\n\n{\n  if (-1 < param_1) {\n    if (param_1 < 2) {\n      FUN_000049e7(param_1 == 1,param_2,param_3,param_4,param_5,param_6,param_7);\n    }\n    else if (param_1 == 2) {\n      FUN_000051cd(param_4,param_5,param_6,param_7);\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is handler"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  char *pcVar3;\n  undefined8 uVar4;\n  int local_30;\n  int local_2c;\n  int local_28;\n  \n  iVar1 = wget_vector_size(param_2);\n  local_30 = 0;\n  do {\n    if (iVar1 <= local_30) {\n      return 0;\n    }\n    pcVar3 = (char *)wget_vector_get(param_2,local_30);\n    if ((pcVar3 == (char *)0x0) || (*pcVar3 == '\\0')) {\n      local_28 = 0;\n      while ((&PTR_DAT_0024e200)[(long)local_28 * 2] != (undefined *)0x0) {\n        uVar4 = wget_aprintf(\"%s%s%s\",(&PTR_DAT_0024e200)[(long)local_28 * 2],param_1,\n                             (&PTR_DAT_0024e208)[(long)local_28 * 2]);\n        iVar2 = FUN_0000e363(uVar4);\n        if (iVar2 != 0) {\n          return uVar4;\n        }\n        (*wget_free)(uVar4);\n        local_28 = local_28 + 1;\n      }\n    }\n    else {\n      local_2c = 0;\n      while ((&PTR_DAT_0024e200)[(long)local_2c * 2] != (undefined *)0x0) {\n        uVar4 = wget_aprintf(\"%s/%s%s%s\",pcVar3,(&PTR_DAT_0024e200)[(long)local_2c * 2],param_1,\n                             (&PTR_DAT_0024e208)[(long)local_2c * 2]);\n        iVar2 = FUN_0000e363(uVar4);\n        if (iVar2 != 0) {\n          return uVar4;\n        }\n        (*wget_free)(uVar4);\n        local_2c = local_2c + 1;\n      }\n    }\n    local_30 = local_30 + 1;\n  } while( true );\n}\n\n",
        "output": "The predicted function name is dl_search"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  byte bVar3;\n  byte bVar4;\n  long lVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  char cVar8;\n  long in_FS_OFFSET;\n  undefined8 uVar9;\n  char *__format;\n  double dVar10;\n  undefined8 local_48;\n  undefined8 local_40;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar5 = *(long *)(*(long *)(param_1 + 0x38) + 8);\n  cVar8 = FUN_00001c1d(param_1);\n  if (cVar8 == '\\0') {\n    if ((*(long *)(lVar5 + 0x68) == 0) || (*(long *)(*(long *)(lVar5 + 0x68) + 0x10) == 0)) {\n      printf(\"\\n\\n<!-- WRONG INSERT(%u.%u.%lX) -->\\n\",(ulong)*(byte *)(param_1 + 0x40),\n             (ulong)*(byte *)(param_1 + 0x41),*(undefined8 *)(param_1 + 0x48));\n    }\n    else {\n      cVar8 = FUN_00001be7();\n      if (((cVar8 == '\\0') && (cVar8 = FUN_00001be7(), cVar8 == '\\0')) &&\n         (cVar8 = FUN_00001be7(), cVar8 == '\\0')) {\n        FUN_000058cd(&local_48);\n        printf(\"\\t<!-- insert-%d -->\\n\",(ulong)*(uint *)(param_1 + 0x14));\n        uVar6 = *(undefined8 *)(*(long *)(lVar5 + 0x68) + 0x10);\n        bVar3 = *(byte *)(*(long *)(lVar5 + 0x68) + 9);\n        bVar4 = *(byte *)(*(long *)(lVar5 + 0x68) + 8);\n        uVar7 = *(undefined8 *)(*(long *)(lVar5 + 0x68) + 0x20);\n        uVar1 = *(undefined8 *)(lVar5 + 0x30);\n        uVar2 = *(undefined8 *)(lVar5 + 0x28);\n        dVar10 = *(double *)(lVar5 + 0x40) * DAT_000067d0;\n        uVar9 = FUN_00001b1f(local_40);\n        __format = (char *)FUN_00001b03(local_48);\n        printf(__format,uVar9,dVar10,uVar2,uVar1,\n               \"\\t<use id=\\\"dwg-object-%d\\\" transform=\\\"translate(%f %f) rotate(%f) scale(%f %f)\\\" xlink:href=\\\"#symbol-%lX\\\" /><!-- block_header->handleref: %u.%u.%lX -->\\n\"\n               ,(ulong)*(uint *)(param_1 + 0x14),uVar7,(ulong)bVar4,(ulong)bVar3,uVar6);\n      }\n    }\n  }\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is output_INSERT"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  \n  uVar1 = FUN_00002192(param_1);\n  uVar2 = gettext(\"system boot\");\n  FUN_00002228(0xffffffff,&DAT_000073d6,0x20,0xffffffff,uVar2,uVar1,&DAT_000073d6,&DAT_000073d6,\n               &DAT_000073d6,&DAT_000073d6);\n  return;\n}\n\n",
        "output": "The predicted function name is print_boottime"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8\n[MASK](undefined8 param_1,uchar **param_2,uchar *param_3,uchar *param_4,uint param_5,\n            uchar **param_6)\n\n{\n  undefined uVar1;\n  int iVar2;\n  undefined8 uVar3;\n  \n  iVar2 = SSL_select_next_proto(param_2,param_3,param_4,param_5,*param_6,(uint)param_6[1]);\n  if ((iVar2 == 1) || (iVar2 == 2)) {\n    uVar1 = 1;\n  }\n  else {\n    uVar1 = 0;\n  }\n  iVar2 = FUN_0001471c(\"test/helpers/handshake.c\",0x194,\n                       \"ret == OPENSSL_NPN_NEGOTIATED || ret == OPENSSL_NPN_NO_OVERLAP\",uVar1);\n  if (iVar2 == 0) {\n    uVar3 = 2;\n  }\n  else {\n    uVar3 = 0;\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is client_npn_cb"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](undefined8 param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_1c;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_1c = 0;\n  iVar1 = mu_header_sget_value_n(param_1,\"Precedence\",1,&local_18);\n  if (iVar1 == 0) {\n    iVar1 = mu_c_strcasecmp(local_18,&DAT_0000424f);\n    if ((iVar1 == 0) || (iVar1 = mu_c_strcasecmp(local_18,&DAT_00004254), iVar1 == 0)) {\n      local_1c = 1;\n    }\n    else {\n      local_1c = 0;\n    }\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_1c;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is bulk_precedence_p"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  EVP_CIPHER *pEVar1;\n  \n  pEVar1 = EVP_aes_128_cbc_hmac_sha1();\n  FUN_0000344b(param_1,param_2,param_3,param_4,pEVar1);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_aes128_cbc_hmac_sha1_cipher"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ASN1_VALUE *param_1,uchar **param_2)\n\n{\n  ASN1_ITEM *it;\n  \n  it = (ASN1_ITEM *)FUN_00002ac0();\n  ASN1_item_i2d(param_1,param_2,it);\n  return;\n}\n\n",
        "output": "The predicted function name is i2d_ASN1_INT32_DATA"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long *param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  bool bVar3;\n  int iVar4;\n  long lVar5;\n  int local_2c;\n  \n  lVar1 = *(long *)(*param_1 + 0x20);\n  lVar2 = *(long *)(lVar1 + 0x68);\n  lVar5 = *(long *)(lVar1 + 0x60);\n  if (param_1[0xc] != 0) {\n    FUN_00012eca(param_1[0xf]);\n  }\n  if ((*(short *)(param_1 + 0x18) == 200) || (*(short *)(param_1 + 0x18) == 0xce)) {\n    if (param_1[0xc] == 0) {\n      FUN_000160f4(lVar2,\"part %d download error \\'empty body\\'\\n\",*(undefined4 *)(lVar5 + 0x10));\n    }\n    else if (*(long *)(param_1[0xc] + 8) == *(long *)(lVar5 + 8)) {\n      FUN_000160f4(lVar2,\"part %d downloaded\\n\",*(undefined4 *)(lVar5 + 0x10));\n      *(byte *)(lVar5 + 0x20) = *(byte *)(lVar5 + 0x20) | 2;\n    }\n    else {\n      FUN_000160f4(lVar2,\"part %d download error \\'%zu bytes of %lld expected\\'\\n\",\n                   *(undefined4 *)(lVar5 + 0x10),*(undefined8 *)(param_1[0xc] + 8),\n                   *(undefined8 *)(lVar5 + 8));\n    }\n  }\n  else {\n    FUN_000160f4(lVar2,\"part %d download error %d\\n\",*(undefined4 *)(lVar5 + 0x10),\n                 (int)*(short *)(param_1 + 0x18));\n  }\n  if ((*(byte *)(lVar5 + 0x20) & 2) == 0) {\n    FUN_000160f4(lVar2,\"part %d failed\\n\",*(undefined4 *)(lVar5 + 0x10));\n    *(byte *)(lVar5 + 0x20) = *(byte *)(lVar5 + 0x20) & 0xfe;\n  }\n  else {\n    bVar3 = true;\n    wget_thread_mutex_lock(DAT_00253d08);\n    local_2c = 0;\n    while( true ) {\n      iVar4 = wget_vector_size(*(undefined8 *)(lVar1 + 0x30));\n      if (iVar4 <= local_2c) break;\n      lVar5 = wget_vector_get(*(undefined8 *)(lVar1 + 0x30),local_2c);\n      if ((*(byte *)(lVar5 + 0x20) >> 1 & 1) != 1) {\n        bVar3 = false;\n        break;\n      }\n      local_2c = local_2c + 1;\n    }\n    wget_thread_mutex_unlock(DAT_00253d08);\n    if (bVar3) {\n      if (DAT_002533d2 == '\\0') {\n        if (*(long *)(lVar1 + 0x18) == 0) {\n          FUN_000160f4(lVar2,\"%s checking...\\n\",*(undefined8 *)(*(long *)(lVar1 + 0x48) + 8));\n        }\n        else {\n          FUN_000160f4(lVar2,\"%s checking...\\n\",**(undefined8 **)(lVar1 + 0x18));\n        }\n      }\n      else {\n        FUN_0000d33a(*(undefined4 *)(lVar2 + 0x28),\"Checksumming...\");\n      }\n      iVar4 = FUN_0000fea0(lVar1);\n      if (iVar4 == 0) {\n        if (DAT_002533d2 == '\\0') {\n          wget_debug_printf(\"checksum failed\\n\");\n        }\n        else {\n          FUN_0000d33a(*(undefined4 *)(lVar2 + 0x28),\"Checksum FAILED\");\n        }\n      }\n      else {\n        if (DAT_002533d2 == '\\0') {\n          wget_debug_printf(\"checksum ok\\n\");\n        }\n        else {\n          FUN_0000d33a(*(undefined4 *)(lVar2 + 0x28),\"Checksum OK\");\n        }\n        *(byte *)(lVar1 + 0xa8) = *(byte *)(lVar1 + 0xa8) | 4;\n      }\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is process_response_part"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return 1;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yywrap"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  long lVar1;\n  int iVar2;\n  \n  lVar1 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  iVar2 = FUN_000064e0(*(undefined8 *)(lVar1 + 0x20),FUN_0001059c,*(undefined8 *)(lVar1 + 0x10));\n  if (iVar2 == 0) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DIGESTUPDATE_ERROR\";\n  }\n  else {\n    iVar2 = EVP_DigestVerifyFinal\n                      (*(EVP_MD_CTX **)(lVar1 + 0x10),*(uchar **)(lVar1 + 0x38),\n                       *(size_t *)(lVar1 + 0x40));\n    if (iVar2 < 1) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"VERIFY_ERROR\";\n    }\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is digestverify_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_0000e755();\n  FUN_0000dc28();\n  wget_thread_mutex_destroy(&DAT_00253d08);\n  wget_thread_mutex_destroy(&DAT_00253d10);\n  wget_thread_mutex_destroy(&DAT_00253d18);\n  wget_thread_mutex_destroy(&DAT_00253d20);\n  wget_thread_mutex_destroy(&DAT_00253d28);\n  wget_thread_mutex_destroy(&DAT_00253d30);\n  wget_thread_mutex_destroy(&DAT_00253d38);\n  wget_thread_mutex_destroy(&DAT_00253cd8);\n  wget_thread_cond_destroy(&DAT_00253d40);\n  wget_thread_cond_destroy(&DAT_00253d48);\n  return;\n}\n\n",
        "output": "The predicted function name is program_deinit"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](ENGINE *param_1)\n\n{\n  int iVar1;\n  long lVar2;\n  ushort local_a;\n  \n  FUN_000019fa();\n  iVar1 = ENGINE_set_id(param_1,PTR_s_afalg_00204330);\n  if ((((iVar1 == 0) ||\n       (iVar1 = ENGINE_set_name(param_1,PTR_s_AFALG_engine_support_00204338), iVar1 == 0)) ||\n      (iVar1 = ENGINE_set_destroy_function(param_1,FUN_000031fd), iVar1 == 0)) ||\n     ((iVar1 = ENGINE_set_init_function(param_1,FUN_0000317a), iVar1 == 0 ||\n      (iVar1 = ENGINE_set_finish_function(param_1,FUN_00003189), iVar1 == 0)))) {\n    FUN_00001a71(0,100,\"engines/e_afalg.c\",0x30d);\n    return 0;\n  }\n  for (local_a = 0; local_a < 3; local_a = local_a + 1) {\n    lVar2 = FUN_00002b5d(*(undefined4 *)(&DAT_00204200 + (long)(int)(uint)local_a * 4));\n    if (lVar2 == 0) {\n      FUN_00001a71(0,100,\"engines/e_afalg.c\",0x318);\n      return 0;\n    }\n  }\n  iVar1 = ENGINE_set_ciphers(param_1,FUN_00002c8f);\n  if (iVar1 == 0) {\n    FUN_00001a71(0,100,\"engines/e_afalg.c\",0x31e);\n    return 0;\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is bind_afalg"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,CONF *param_2,char *param_3)\n\n{\n  bool bVar1;\n  int iVar2;\n  stack_st_CONF_VALUE *psVar3;\n  undefined8 uVar4;\n  long lVar5;\n  int local_28;\n  ulong local_20;\n  \n  psVar3 = NCONF_get_section(param_2,param_3);\n  iVar2 = FUN_000146a7(\"test/helpers/ssl_test_ctx.c\",0x32d,\n                       \"sk_conf = NCONF_get_section(conf, server_section)\",psVar3);\n  if (iVar2 == 0) {\n    uVar4 = 0;\n  }\n  else {\n    local_28 = 0;\n    while( true ) {\n      uVar4 = FUN_00009d27(psVar3);\n      iVar2 = OPENSSL_sk_num(uVar4);\n      if (iVar2 <= local_28) break;\n      bVar1 = false;\n      uVar4 = FUN_00009d27(psVar3);\n      lVar5 = OPENSSL_sk_value(uVar4,local_28);\n      for (local_20 = 0; local_20 < 9; local_20 = local_20 + 1) {\n        iVar2 = strcmp(*(char **)(lVar5 + 8),(&PTR_s_ServerNameCallback_0021f520)[local_20 * 2]);\n        if (iVar2 == 0) {\n          iVar2 = (*(code *)(&PTR_FUN_0021f528)[local_20 * 2])(param_1);\n          if (iVar2 == 0) {\n            FUN_0001261b(\"test/helpers/ssl_test_ctx.c\",0x337,\"Bad value %s for option %s\",\n                         *(undefined8 *)(lVar5 + 0x10),*(undefined8 *)(lVar5 + 8));\n            return 0;\n          }\n          bVar1 = true;\n          break;\n        }\n      }\n      if (!bVar1) {\n        FUN_0001261b(\"test/helpers/ssl_test_ctx.c\",0x33f,\"Unknown test option: %s\",\n                     *(undefined8 *)(lVar5 + 8));\n        return 0;\n      }\n      local_28 = local_28 + 1;\n    }\n    uVar4 = 1;\n  }\n  return uVar4;\n}\n\n",
        "output": "The predicted function name is parse_server_options"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined * [MASK](void)\n\n{\n  return &DAT_002107e0;\n}\n\n",
        "output": "The predicted function name is ASN1_UINT64_DATA_it"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 *\n[MASK](char *param_1,undefined8 param_2,char *param_3,undefined8 param_4,undefined8 param_5)\n\n{\n  undefined8 *puVar1;\n  size_t sVar2;\n  undefined8 *puVar3;\n  long in_FS_OFFSET;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  undefined8 local_60;\n  undefined8 local_58;\n  char *local_50;\n  undefined8 local_48;\n  char *local_40;\n  undefined8 *local_30;\n  undefined8 *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_60 = param_5;\n  local_58 = param_4;\n  local_50 = param_3;\n  local_48 = param_2;\n  local_40 = param_1;\n  local_30 = (undefined8 *)CRYPTO_malloc(0xf0,\"test/evp_kdf_test.c\",0x226);\n  local_28 = local_30;\n  if (local_30 == (undefined8 *)0x0) {\n    puVar3 = (undefined8 *)0x0;\n  }\n  else {\n    sVar2 = strlen(local_40);\n    puVar3 = local_28;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_octet_string(&local_98,&DAT_00013eb0,local_40,sVar2);\n    *puVar3 = local_98;\n    puVar3[1] = local_90;\n    puVar3[2] = local_88;\n    puVar3[3] = local_80;\n    puVar3[4] = local_78;\n    sVar2 = strlen(local_50);\n    puVar3 = local_28;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_octet_string(&local_98,&DAT_00013cf5,local_50,sVar2);\n    puVar1 = local_28;\n    *puVar3 = local_98;\n    puVar3[1] = local_90;\n    puVar3[2] = local_88;\n    puVar3[3] = local_80;\n    puVar3[4] = local_78;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_uint(&local_98,&DAT_00013eb5,local_58);\n    puVar3 = local_28;\n    *puVar1 = local_98;\n    puVar1[1] = local_90;\n    puVar1[2] = local_88;\n    puVar1[3] = local_80;\n    puVar1[4] = local_78;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_utf8_string(&local_98,\"digest\",local_48,0);\n    puVar1 = local_28;\n    *puVar3 = local_98;\n    puVar3[1] = local_90;\n    puVar3[2] = local_88;\n    puVar3[3] = local_80;\n    puVar3[4] = local_78;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_int(&local_98,\"pkcs5\",local_60);\n    puVar3 = local_28;\n    *puVar1 = local_98;\n    puVar1[1] = local_90;\n    puVar1[2] = local_88;\n    puVar1[3] = local_80;\n    puVar1[4] = local_78;\n    OSSL_PARAM_construct_end(&local_98);\n    *puVar3 = local_98;\n    puVar3[1] = local_90;\n    puVar3[2] = local_88;\n    puVar3[3] = local_80;\n    puVar3[4] = local_78;\n    puVar3 = local_30;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar3;\n}\n\n",
        "output": "The predicted function name is construct_pbkdf2_params"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  char cVar1;\n  long in_FS_OFFSET;\n  undefined8 uVar2;\n  char *pcVar3;\n  int local_54;\n  uint local_50;\n  uint local_4c;\n  long local_48;\n  undefined8 *local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48 = *(long *)(*(long *)(param_1 + 0x38) + 8);\n  cVar1 = FUN_00001c1d(param_1);\n  if ((((cVar1 == '\\0') &&\n       (local_4c = dwg_ent_lwpline_get_numpoints(local_48,&local_54), local_4c != 0)) &&\n      (local_54 == 0)) &&\n     (((local_40 = (undefined8 *)dwg_ent_lwpline_get_points(local_48,&local_54), local_54 == 0 &&\n       (cVar1 = FUN_00001b99(*local_40,local_40[1]), cVar1 == '\\0')) &&\n      (cVar1 = FUN_00001be7(), cVar1 == '\\0')))) {\n    local_28 = *local_40;\n    local_20 = local_40[1];\n    FUN_0000558b(local_28,local_20,&local_38);\n    printf(\"\\t<!-- lwpolyline-%d -->\\n\",(ulong)*(uint *)(param_1 + 0x14));\n    uVar2 = FUN_00001b1f(local_30);\n    pcVar3 = (char *)FUN_00001b03(local_38);\n    printf(pcVar3,uVar2,\"\\t<path id=\\\"dwg-object-%d\\\" d=\\\"M %f,%f\",(ulong)*(uint *)(param_1 + 0x14))\n    ;\n    for (local_50 = 1; local_50 < local_4c; local_50 = local_50 + 1) {\n      local_28 = local_40[(ulong)local_50 * 2];\n      local_20 = local_40[(ulong)local_50 * 2 + 1];\n      cVar1 = FUN_00001b4b(local_28,local_20);\n      if (cVar1 == '\\0') {\n        FUN_0000558b(local_28,local_20,&local_38);\n        uVar2 = FUN_00001b1f(local_30);\n        pcVar3 = (char *)FUN_00001b03(local_38);\n        printf(pcVar3,uVar2,\" L %f,%f\");\n      }\n    }\n    if ((*(ushort *)(local_48 + 8) & 0x200) != 0) {\n      printf(\" Z\");\n    }\n    printf(\"\\\"\\n\\t\");\n    FUN_00001e87(*(undefined8 *)(param_1 + 0x38));\n    free(local_40);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is output_LWPOLYLINE"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](long param_1)\n\n{\n  int local_1c;\n  byte *local_18;\n  \n  local_1c = *(int *)(param_1 + 0x5c) + (uint)*(ushort *)(param_1 + 0x58) * 0x65;\n  for (local_18 = *(byte **)(param_1 + 0x20); (local_18 != (byte *)0x0 && (*local_18 != 0));\n      local_18 = local_18 + 1) {\n    local_1c = (uint)*local_18 + local_1c * 0x65;\n  }\n  for (local_18 = *(byte **)(param_1 + 0x28); (local_18 != (byte *)0x0 && (*local_18 != 0));\n      local_18 = local_18 + 1) {\n    local_1c = (uint)*local_18 + local_1c * 0x65;\n  }\n  for (local_18 = *(byte **)(param_1 + 0x30); (local_18 != (byte *)0x0 && (*local_18 != 0));\n      local_18 = local_18 + 1) {\n    local_1c = (uint)*local_18 + local_1c * 0x65;\n  }\n  return local_1c;\n}\n\n",
        "output": "The predicted function name is hash_iri"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  if (((param_1 != 0) && (1 < *(uint *)(param_1 + 0x10))) && (*(uint *)(param_1 + 0x10) == 2)) {\n    dico_list_destroy(param_1 + 0x20);\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is free_tag"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_0000397d(\"http://[FF01::101]:6\",0,\"[FF01::101]\",&DAT_0000e31e,&DAT_0000e2c5);\n  return;\n}\n\n",
        "output": "The predicted function name is test_http_url_ipv6"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](undefined8 param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = OPENSSL_strcasecmp(param_1,&DAT_0001e546);\n  return iVar1 == 0;\n}\n\n",
        "output": "The predicted function name is is_digest_disabled"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,long *param_2,undefined8 param_3)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  \n  if (*(int *)(DAT_00253330 + 0x10) == 0) {\n    if (param_2[1] == 0) {\n      puVar2 = &DAT_00046950;\n    }\n    else {\n      puVar2 = (undefined *)param_2[1];\n    }\n    if (*param_2 == 0) {\n      puVar1 = &DAT_00046950;\n    }\n    else {\n      puVar1 = (undefined *)*param_2;\n    }\n    wget_fprintf(param_3,\"  %4lld %s:%hu (%s)\\n\",param_2[3],puVar1,*(undefined2 *)(param_2 + 2),\n                 puVar2);\n  }\n  else {\n    wget_fprintf(param_3,\"%s,%s,%hu,%lld\\n\",*param_2,param_2[1],*(undefined2 *)(param_2 + 2),\n                 param_2[3]);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is stats_callback_dns"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](ulong *param_1,ulong *param_2,char *param_3)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  ulong uVar3;\n  uint uVar4;\n  char *local_50;\n  int local_30;\n  ulong local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_20 = 0;\n  local_18 = 0;\n  local_30 = 4;\n  for (local_50 = param_3; *local_50 == ' '; local_50 = local_50 + 1) {\n  }\n  if (*local_50 == '+') {\n    local_50 = local_50 + 1;\n  }\n  local_10 = local_50;\n  while( true ) {\n    if (*local_10 == 0) break;\n    if (9 < (int)*local_10 - 0x30U) {\n      local_30 = 4;\n      break;\n    }\n    local_30 = 0;\n    local_10 = local_10 + 1;\n  }\n  do {\n    if (local_30 != 0) goto LAB_00006c42;\n    if (*local_50 == 0) goto LAB_00006c42;\n    uVar1 = (int)*local_50 - 0x30;\n    if (0x1999999999999999 < local_20) {\n      local_30 = 1;\n      goto LAB_00006c42;\n    }\n    uVar4 = (uint)(local_18 >> 0x20);\n    uVar2 = local_18 * 10;\n    uVar3 = local_18 * 2;\n    local_18 = local_18 * 10 + (ulong)uVar1;\n    uVar1 = ((uVar4 >> 0x1d) - ((int)uVar4 >> 0x1f)) + (uint)(uVar2 < uVar3) +\n            (uint)(local_18 < uVar1);\n    local_20 = local_20 * 10 + (ulong)uVar1;\n    local_50 = local_50 + 1;\n  } while (uVar1 <= local_20);\n  local_30 = 1;\nLAB_00006c42:\n  *param_1 = local_20;\n  *param_2 = local_18;\n  return local_30;\n}\n\n",
        "output": "The predicted function name is strto2uintmax"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  long lVar1;\n  \n  FUN_0000ea24();\n  if (DAT_00215a00 == 0) {\n    lVar1 = 0;\n  }\n  else {\n    lVar1 = *(long *)(DAT_00215a00 + DAT_002159f0 * 8);\n  }\n  if (lVar1 != param_1) {\n    if ((DAT_00215a00 != 0) && (*(long *)(DAT_00215a00 + DAT_002159f0 * 8) != 0)) {\n      *DAT_00215a18 = DAT_00215a08;\n      *(undefined **)(*(long *)(DAT_00215a00 + DAT_002159f0 * 8) + 0x10) = DAT_00215a18;\n      *(undefined8 *)(*(long *)(DAT_00215a00 + DAT_002159f0 * 8) + 0x20) = DAT_00215a10;\n    }\n    *(long *)(DAT_002159f0 * 8 + DAT_00215a00) = param_1;\n    FUN_0000e524();\n    DAT_00215a28 = 1;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yy_switch_to_buffer"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  int iVar1;\n  ssize_t sVar2;\n  long in_FS_OFFSET;\n  undefined local_41;\n  code *local_40;\n  undefined8 local_38;\n  int *local_30;\n  long local_28;\n  undefined8 local_20;\n  int local_18;\n  int local_14;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = 0;\n  local_14 = 0;\n  local_41 = 0x58;\n  local_28 = ASYNC_get_current_job();\n  if (local_28 != 0) {\n    local_20 = ASYNC_get_wait_ctx(local_28);\n    iVar1 = ASYNC_WAIT_CTX_get_callback(local_20,&local_40,&local_38);\n    if ((iVar1 == 0) || (local_40 == (code *)0x0)) {\n      iVar1 = ASYNC_WAIT_CTX_get_fd(local_20,PTR_s_dasync_00205320,&local_18,&local_30);\n      if (iVar1 == 0) {\n        local_30 = (int *)CRYPTO_malloc(4,\"engines/e_dasync.c\",0x1fe);\n        if (local_30 == (int *)0x0) goto LAB_00002faf;\n        iVar1 = pipe(&local_18);\n        if (iVar1 != 0) {\n          CRYPTO_free(local_30);\n          goto LAB_00002faf;\n        }\n        *local_30 = local_14;\n        iVar1 = ASYNC_WAIT_CTX_set_wait_fd\n                          (local_20,PTR_s_dasync_00205320,local_18,local_30,FUN_00002dc9);\n        if (iVar1 == 0) {\n          FUN_00002dc9(local_20,PTR_s_dasync_00205320,local_18,local_30);\n          goto LAB_00002faf;\n        }\n      }\n      else {\n        local_14 = *local_30;\n      }\n      sVar2 = write(local_14,&local_41,1);\n      if (-1 < sVar2) {\n        ASYNC_pause_job();\n        read(local_18,&local_41,1);\n      }\n    }\n    else {\n      (*local_40)(local_38);\n      ASYNC_pause_job();\n    }\n  }\nLAB_00002faf:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is dummy_pause_job"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int *param_1)\n\n{\n  LOCK();\n  *param_1 = *param_1 + 1;\n  return;\n}\n\n",
        "output": "The predicted function name is atomic_increment_int"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  *(undefined8 *)PTR_gcide_markup_yyout_00212fd8 = param_1;\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyset_out"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_0000397d(\"user:pass@host/p?q#fr\",0,&DAT_0000e199,&DAT_0000e2e0,&DAT_0000e2dd);\n  return;\n}\n\n",
        "output": "The predicted function name is test_http_url_userinfo_query_fragment"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  EVP_PKEY_CTX **ppEVar1;\n  int iVar2;\n  \n  ppEVar1 = *(EVP_PKEY_CTX ***)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  iVar2 = EVP_PKEY_verify(*ppEVar1,(uchar *)ppEVar1[4],(size_t)ppEVar1[5],(uchar *)ppEVar1[2],\n                          (size_t)ppEVar1[3]);\n  if (iVar2 < 1) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"VERIFY_ERROR\";\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is verify_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void *param_1)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  \n  if (param_1 != (void *)0x0) {\n    FUN_0000b4d4(param_1);\n    CRYPTO_free(*(void **)((long)param_1 + 0x1c8));\n    CRYPTO_free(*(void **)((long)param_1 + 0x1d0));\n    CRYPTO_free(*(void **)((long)param_1 + 0x228));\n    uVar1 = FUN_00009d43(PTR_X509_NAME_free_0021ffc8);\n    uVar2 = FUN_00009d35(*(undefined8 *)((long)param_1 + 0x1f0));\n    OPENSSL_sk_pop_free(uVar2,uVar1);\n    uVar1 = FUN_00009d43(PTR_X509_NAME_free_0021ffc8);\n    uVar2 = FUN_00009d35(*(undefined8 *)((long)param_1 + 0x208));\n    OPENSSL_sk_pop_free(uVar2,uVar1);\n    CRYPTO_free(*(void **)((long)param_1 + 0x220));\n    CRYPTO_free(param_1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is SSL_TEST_CTX_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  EVP_CIPHER *pEVar1;\n  \n  pEVar1 = EVP_aes_128_cbc();\n  FUN_0000344b(param_1,param_2,param_3,param_4,pEVar1);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_aes128_cbc_cipher"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  int *piVar1;\n  \n  piVar1 = __errno_location();\n  *piVar1 = 0x16;\n  ERR_get_error();\n  piVar1 = __errno_location();\n  FUN_00006087(\"test/errtest.c\",0x7e,\"errno\",\"EINVAL\",*piVar1,0x16);\n  return;\n}\n\n",
        "output": "The predicted function name is preserves_system_error"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined4 param_1)\n\n{\n  FUN_00009e5e(&PTR_DAT_0021f1e0,3,param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is ssl_certstatus_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,char *param_2)\n\n{\n  char *pcVar1;\n  \n  CRYPTO_free(*(void **)(param_1 + 0x30));\n  pcVar1 = CRYPTO_strdup(param_2,\"test/helpers/ssl_test_ctx.c\",0x167);\n  *(char **)(param_1 + 0x30) = pcVar1;\n  FUN_000146a7(\"test/helpers/ssl_test_ctx.c\",0x167,\"ctx->srp_user\",*(undefined8 *)(param_1 + 0x30));\n  return;\n}\n\n",
        "output": "The predicted function name is parse_client_srp_user"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2)\n\n{\n  long *plVar1;\n  long lVar2;\n  long local_30;\n  char *local_28;\n  char *local_20;\n  \n  if ((param_2 == (char *)0x0) || (*param_2 == '\\0')) {\n    wget_vector_free(*(undefined8 *)(param_1 + 0x18));\n  }\n  else {\n    local_30 = **(long **)(param_1 + 0x18);\n    local_28 = param_2;\n    local_20 = param_2;\n    if (local_30 == 0) {\n      plVar1 = *(long **)(param_1 + 0x18);\n      lVar2 = wget_vector_create(8,FUN_00020aa8);\n      *plVar1 = lVar2;\n      local_30 = *plVar1;\n      wget_vector_set_destructor(local_30,FUN_000208e1);\n    }\n    while (*local_20 != '\\0') {\n      local_20 = strchrnul(local_28,0x2c);\n      if (local_20 != local_28) {\n        FUN_00020975(local_30,local_28,local_20);\n      }\n      local_28 = local_20 + 1;\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is parse_taglist"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_00003f0e(\"https://[FF01::101]pkix\");\n  return;\n}\n\n",
        "output": "The predicted function name is test_http_url_invalid_path"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2,char *param_3)\n\n{\n  long lVar1;\n  int iVar2;\n  undefined8 uVar3;\n  EVP_MD *pEVar4;\n  \n  lVar1 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  iVar2 = strcmp(param_2,\"iter\");\n  if (iVar2 == 0) {\n    iVar2 = atoi(param_3);\n    *(int *)(lVar1 + 0x2c) = iVar2;\n    if (*(int *)(lVar1 + 0x2c) < 1) {\n      uVar3 = 0xffffffff;\n    }\n    else {\n      uVar3 = 1;\n    }\n  }\n  else {\n    iVar2 = strcmp(param_2,\"MD\");\n    if (iVar2 == 0) {\n      pEVar4 = EVP_get_digestbyname(param_3);\n      *(EVP_MD **)(lVar1 + 0x30) = pEVar4;\n      if (*(long *)(lVar1 + 0x30) == 0) {\n        uVar3 = 0xffffffff;\n      }\n      else {\n        uVar3 = 1;\n      }\n    }\n    else {\n      uVar3 = 0;\n    }\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is pbkdf2_test_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,long param_2,long param_3)\n\n{\n  if ((param_2 != 0) && (0 < param_3)) {\n    FUN_000106cd(param_1,param_2,param_3,0,0,1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is write_info"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8\n[MASK](undefined8 param_1,uchar **param_2,uchar *param_3,uchar *param_4,uint param_5,\n            long param_6)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  uchar *local_20;\n  long local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = param_6;\n  iVar1 = SSL_select_next_proto\n                    (&local_20,param_3,*(uchar **)(param_6 + 0x10),\n                     (uint)*(undefined8 *)(param_6 + 0x18),param_4,param_5);\n  *param_2 = local_20;\n  if (iVar1 == 1) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = 2;\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is server_alpn_cb"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,char *param_2)\n\n{\n  char *pcVar1;\n  \n  CRYPTO_free(*(void **)(param_1 + 0x38));\n  pcVar1 = CRYPTO_strdup(param_2,\"test/helpers/ssl_test_ctx.c\",0x169);\n  *(char **)(param_1 + 0x38) = pcVar1;\n  FUN_000146a7(\"test/helpers/ssl_test_ctx.c\",0x169,\"ctx->srp_password\",\n               *(undefined8 *)(param_1 + 0x38));\n  return;\n}\n\n",
        "output": "The predicted function name is parse_client_srp_password"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *param_1,int param_2)\n\n{\n  bool bVar1;\n  char cVar2;\n  int iVar3;\n  undefined8 uVar4;\n  size_t sVar5;\n  int *piVar6;\n  char *pcVar7;\n  long in_FS_OFFSET;\n  int local_4c4;\n  char *local_4b8;\n  char *local_4b0;\n  undefined8 local_4a8;\n  undefined8 local_4a0;\n  char *local_498;\n  long local_490;\n  char *local_488;\n  FILE *local_480;\n  undefined local_478 [32];\n  _func_4931 *local_458;\n  _func_4932 *local_450;\n  _func_4933 *local_448;\n  _func_4934 *local_440;\n  _func_4935 *local_438;\n  undefined local_428 [1032];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_4b8 = (char *)0x0;\n  bVar1 = false;\n  local_4c4 = 0;\n  local_4a0 = 0;\n  DAT_00253d78 = DAT_00253d78 + 1;\n  if (DAT_00253d78 < 0x15) {\n    if (param_2 == 0) {\n      local_480 = fopen(param_1,\"r\");\n      if (local_480 == (FILE *)0x0) {\n        piVar6 = __errno_location();\n        pcVar7 = strerror(*piVar6);\n        piVar6 = __errno_location();\n        iVar3 = *piVar6;\n        uVar4 = gettext(\"Failed to open %s (%d): %s\\n\");\n        wget_error_printf(uVar4,param_1,iVar3,pcVar7);\n        DAT_00253d78 = DAT_00253d78 + -1;\n        local_4c4 = -1;\n      }\n      else {\n        wget_debug_printf(\"Reading %s\\n\",param_1);\n        wget_buffer_init(local_478,local_428,0x400);\n        while ((local_4c4 == 0 &&\n               (local_490 = wget_getline(&local_4b8,&local_4a0,local_480), -1 < local_490))) {\n          if ((local_490 != 0) && ((*local_4b8 != '\\r' && (*local_4b8 != '\\n')))) {\n            local_498 = local_4b8;\n            if (!bVar1) {\n              while (cVar2 = FUN_000284f3((int)*local_498), cVar2 != '\\0') {\n                local_498 = local_498 + 1;\n                local_490 = local_490 + -1;\n              }\n            }\n            if (*local_498 != '#') {\n              while ((0 < local_490 &&\n                     (cVar2 = FUN_000284f3((int)local_498[local_490 + -1]), cVar2 != '\\0'))) {\n                local_490 = local_490 + -1;\n              }\n              local_498[local_490] = '\\0';\n              if ((local_490 < 1) || (local_498[local_490 + -1] != '\\\\')) {\n                if (bVar1) {\n                  wget_buffer_strcat(local_478,local_498);\n                  bVar1 = false;\n                  local_498 = local_478._0_8_;\n                }\n                iVar3 = FUN_00022b2d(local_498,&local_4b0,&local_4a8);\n                if (iVar3 == 1) {\n                  iVar3 = FUN_00022516(local_4b0,local_4a8,1);\n                  if (iVar3 < 0) {\n                    local_4c4 = iVar3;\n                  }\n                }\n                else if (iVar3 == 2) {\n                  iVar3 = strcmp(local_4b0,\"include\");\n                  if (iVar3 == 0) {\n                    local_4c4 = FUN_00022d4b(local_4a8,1);\n                  }\n                  else {\n                    iVar3 = FUN_00022516(local_4b0,0,0);\n                    if (iVar3 < 0) {\n                      local_4c4 = iVar3;\n                    }\n                  }\n                }\n              }\n              else if (bVar1) {\n                wget_buffer_memcat(local_478,local_498,local_490 + -1);\n              }\n              else {\n                wget_buffer_memcpy(local_478,local_498,local_490 + -1);\n                bVar1 = true;\n              }\n            }\n          }\n        }\n        wget_buffer_deinit(local_478);\n        if (local_4b8 != (char *)0x0) {\n          (*wget_free)(local_4b8);\n          local_4b8 = (char *)0x0;\n        }\n        FUN_000285bb(local_480);\n        if (bVar1) {\n          uVar4 = gettext(\"Failed to parse last line in \\'%s\\'\\n\");\n          wget_error_printf(uVar4,param_1);\n          local_4c4 = -4;\n        }\n        DAT_00253d78 = DAT_00253d78 + -1;\n      }\n    }\n    else {\n      local_478._0_8_ = (char *)0x0;\n      local_478._8_8_ = (char **)0x0;\n      local_478._16_8_ = 0;\n      local_478._24_8_ = 0;\n      local_458 = (_func_4931 *)0x0;\n      local_450 = (_func_4932 *)0x0;\n      local_448 = (_func_4933 *)0x0;\n      local_440 = (_func_4934 *)0x0;\n      local_438 = (_func_4935 *)0x0;\n      iVar3 = glob(param_1,0x1002,(__errfunc *)0x0,(glob_t *)local_478);\n      if (iVar3 == 0) {\n        local_488 = (char *)0x0;\n        while ((local_488 < local_478._0_8_ && (local_4c4 == 0))) {\n          pcVar7 = local_478._8_8_[(long)local_488];\n          sVar5 = strlen(local_478._8_8_[(long)local_488]);\n          if (pcVar7[sVar5 - 1] != '/') {\n            local_4c4 = FUN_00022d4b(local_478._8_8_[(long)local_488],0);\n          }\n          local_488 = local_488 + 1;\n        }\n        globfree((glob_t *)local_478);\n      }\n      else {\n        local_4c4 = FUN_00022d4b(param_1,0);\n      }\n      DAT_00253d78 = DAT_00253d78 + -1;\n    }\n  }\n  else {\n    uVar4 = gettext(\"Config file recursion detected in %s\\n\");\n    wget_error_printf(uVar4,param_1);\n    DAT_00253d78 = DAT_00253d78 + -1;\n    local_4c4 = -2;\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_4c4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is read_config_expand"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined * [MASK](undefined4 param_1)\n\n{\n  _DAT_002130cc = param_1;\n  return &DAT_0000e05c;\n}\n\n",
        "output": "The predicted function name is fake_rsa_keymgmt_query"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](undefined8 param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = OPENSSL_strncasecmp(&DAT_0001e54a,param_1,3);\n  return iVar1 == 0;\n}\n\n",
        "output": "The predicted function name is is_cipher_disabled"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *param_1,char *param_2)\n\n{\n  int iVar1;\n  char *__service;\n  long in_FS_OFFSET;\n  int local_60;\n  addrinfo *local_58;\n  addrinfo *local_50;\n  addrinfo local_48;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  memset(&local_48,0,0x30);\n  local_48.ai_family = 0;\n  local_48.ai_socktype = 1;\n  __service = param_2;\n  if (param_2 == (char *)0x0) {\n    __service = \"whois\";\n  }\n  iVar1 = getaddrinfo(param_1,__service,&local_48,&local_58);\n  if (iVar1 != 0) {\n    if (param_2 == (char *)0x0) {\n      param_2 = \"nicname\";\n    }\n    iVar1 = getaddrinfo(param_1,param_2,&local_48,&local_58);\n    if (iVar1 != 0) {\n      gai_strerror(iVar1);\n      FUN_0000ceeb();\n    }\n  }\n  local_50 = local_58;\n  for (; local_58 != (addrinfo *)0x0; local_58 = local_58->ai_next) {\n    local_60 = socket(local_58->ai_family,local_58->ai_socktype,local_58->ai_protocol);\n    if (-1 < local_60) {\n      iVar1 = connect(local_60,local_58->ai_addr,local_58->ai_addrlen);\n      if (iVar1 == 0) break;\n      close(local_60);\n    }\n  }\n  if (local_58 == (addrinfo *)0x0) {\n    FUN_0000cdfd(\"connect\");\n  }\n  freeaddrinfo(local_50);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_60;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is openconn"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  DAT_00215a10 = *(undefined8 *)(*(long *)(DAT_00215a00 + DAT_002159f0 * 8) + 0x20);\n  DAT_00215a18 = *(undefined **)(*(long *)(DAT_00215a00 + DAT_002159f0 * 8) + 0x10);\n  *(undefined **)PTR_gcide_markup_yytext_00212f90 = DAT_00215a18;\n  *(undefined8 *)PTR_gcide_markup_yyin_00212fc0 = **(undefined8 **)(DAT_00215a00 + DAT_002159f0 * 8)\n  ;\n  DAT_00215a08 = *DAT_00215a18;\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yy_load_buffer_state"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  uint local_34;\n  long local_30;\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_00215110 != '\\0') {\n    fwrite(\"[trial division] \",1,0x11,stderr);\n  }\n  __gmpz_init(local_28);\n  local_30 = __gmpz_scan1(param_1,0);\n  __gmpz_fdiv_q_2exp(param_1,param_1,local_30);\n  for (; local_30 != 0; local_30 = local_30 + -1) {\n    FUN_00002efa(param_2,2);\n  }\n  local_30 = 3;\n  local_34 = 1;\n  do {\n    while( true ) {\n      if (0x29c < local_34) goto LAB_000035d8;\n      iVar1 = __gmpz_divisible_ui_p(param_1,local_30);\n      if (iVar1 == 0) break;\n      __gmpz_tdiv_q_ui(param_1,param_1,local_30);\n      FUN_00002efa(param_2,local_30);\n    }\n    local_30 = local_30 + (ulong)(byte)(&DAT_0000e240)[local_34];\n    iVar1 = __gmpz_cmp_ui(param_1,local_30 * local_30);\n    local_34 = local_34 + 1;\n  } while (-1 < iVar1);\nLAB_000035d8:\n  __gmpz_clear(local_28);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is mp_factor_using_division"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  long in_FS_OFFSET;\n  int local_4c;\n  int local_48;\n  undefined8 local_40;\n  long local_38;\n  char *local_30;\n  undefined local_28 [8];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_4c = 0;\n  local_30 = getenv(PTR_s_WGET2_PLUGINS_00253020);\n  if (local_30 != (char *)0x0) {\n    FUN_00010deb(local_28);\n    local_40 = wget_vector_create(0x10,0);\n    FUN_00010e12(local_30,0x3a,local_40);\n    local_48 = 0;\n    while ((iVar1 = wget_vector_size(local_40), local_48 < iVar1 && (local_4c == 0))) {\n      local_30 = (char *)wget_vector_get(local_40,local_48);\n      pcVar2 = strchr(local_30,0x2f);\n      if (pcVar2 == (char *)0x0) {\n        local_38 = FUN_000114a6(local_30);\n      }\n      else {\n        local_38 = FUN_00011450(local_30);\n      }\n      if (local_38 == 0) {\n        uVar3 = FUN_00010e01(local_28);\n        uVar4 = gettext(\"Plugin \\'%s\\' failed to load: %s\");\n        wget_error_printf(uVar4,local_30,uVar3);\n        FUN_0000defe(local_28);\n        local_4c = -1;\n      }\n      local_48 = local_48 + 1;\n    }\n    wget_vector_free(&local_40);\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_4c;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is plugin_db_load_from_envvar"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  undefined8 uVar1;\n  int iVar2;\n  char *pcVar3;\n  long in_FS_OFFSET;\n  undefined8 uVar4;\n  int local_74;\n  undefined8 local_70;\n  size_t local_68;\n  EVP_MD_CTX *local_60;\n  EVP_PKEY *local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  uchar *local_40;\n  long local_38;\n  EVP_PKEY_CTX *local_30;\n  undefined8 local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  local_60 = (EVP_MD_CTX *)0x0;\n  local_70 = 0;\n  local_30 = (EVP_PKEY_CTX *)0x0;\n  local_58 = (EVP_PKEY *)0x0;\n  local_50 = 0;\n  local_48 = 0;\n  local_40 = (uchar *)0x0;\n  if (*(int *)(local_38 + 0x80) != 0) goto LAB_0000a182;\n  if (*(long *)(local_38 + 0x18) == 0) {\n    pcVar3 = OBJ_nid2sn(*(int *)(local_38 + 0x10));\n    FUN_00016f06(\"test/evp_test.c\",0x521,\"Trying the EVP_PKEY %s test\",pcVar3);\n  }\n  else {\n    uVar4 = *(undefined8 *)(local_38 + 0x18);\n    pcVar3 = OBJ_nid2sn(*(int *)(local_38 + 0x10));\n    FUN_00016f06(\"test/evp_test.c\",0x524,\"Trying the EVP_PKEY %s test with %s\",pcVar3,uVar4);\n  }\n  if (*(int *)(local_38 + 0x10) == 0x37e) {\n    if ((*(long *)(local_38 + 0x18) == 0) ||\n       (iVar2 = FUN_00011e77(*(undefined8 *)(local_38 + 0x18)), iVar2 == 0)) {\n      local_48 = EVP_CIPHER_fetch(DAT_002241a8,*(undefined8 *)(local_38 + 0x18),0);\n      iVar2 = FUN_00018f92(\"test/evp_test.c\",0x535,\n                           \"cipher = EVP_CIPHER_fetch(libctx, expected->alg, NULL)\",local_48);\n      if (iVar2 != 0) {\n        local_28 = OSSL_LIB_CTX_set0_default(DAT_002241a8);\n        local_58 = (EVP_PKEY *)\n                   EVP_PKEY_new_CMAC_key\n                             (0,*(undefined8 *)(local_38 + 0x20),*(undefined8 *)(local_38 + 0x28),\n                              local_48);\n        OSSL_LIB_CTX_set0_default(local_28);\n        goto LAB_00009e51;\n      }\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"MAC_KEY_CREATE_ERROR\";\n    }\n    else {\n      FUN_00016f06(\"test/evp_test.c\",0x530,\"skipping, PKEY CMAC \\'%s\\' is disabled\",\n                   *(undefined8 *)(local_38 + 0x18));\n      *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n      *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n    }\n  }\n  else {\n    uVar4 = *(undefined8 *)(local_38 + 0x28);\n    uVar1 = *(undefined8 *)(local_38 + 0x20);\n    pcVar3 = OBJ_nid2sn(*(int *)(local_38 + 0x10));\n    local_58 = (EVP_PKEY *)EVP_PKEY_new_raw_private_key_ex(DAT_002241a8,pcVar3,0,uVar1,uVar4);\nLAB_00009e51:\n    if (local_58 == (EVP_PKEY *)0x0) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"MAC_KEY_CREATE_ERROR\";\n    }\n    else {\n      if ((*(int *)(local_38 + 0x10) == 0x357) && (*(long *)(local_38 + 0x18) != 0)) {\n        iVar2 = FUN_00011e19(*(undefined8 *)(local_38 + 0x18));\n        if (iVar2 != 0) {\n          FUN_00016f06(\"test/evp_test.c\",0x54a,\"skipping, HMAC \\'%s\\' is disabled\",\n                       *(undefined8 *)(local_38 + 0x18));\n          *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n          *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n          goto LAB_0000a135;\n        }\n        local_50 = *(undefined8 *)(local_38 + 0x18);\n      }\n      local_60 = (EVP_MD_CTX *)EVP_MD_CTX_new();\n      uVar4 = 0x9f1c;\n      iVar2 = FUN_00018f92(\"test/evp_test.c\",0x551,\"mctx = EVP_MD_CTX_new()\",local_60);\n      if (iVar2 == 0) {\n        *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"INTERNAL_ERROR\";\n      }\n      else {\n        iVar2 = EVP_DigestSignInit_ex(local_60,&local_70,local_50,DAT_002241a8,0,local_58,0,uVar4);\n        if (iVar2 == 0) {\n          *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DIGESTSIGNINIT_ERROR\";\n        }\n        else {\n          local_74 = 0;\n          while( true ) {\n            uVar4 = FUN_00005fa8(*(undefined8 *)(local_38 + 0x88));\n            iVar2 = OPENSSL_sk_num(uVar4);\n            if (iVar2 <= local_74) break;\n            uVar4 = FUN_00005fa8(*(undefined8 *)(local_38 + 0x88));\n            uVar4 = OPENSSL_sk_value(uVar4,local_74);\n            iVar2 = FUN_00009af7(param_1,local_70,uVar4);\n            if (iVar2 == 0) {\n              *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"EVPPKEYCTXCTRL_ERROR\";\n              goto LAB_0000a135;\n            }\n            local_74 = local_74 + 1;\n          }\n          iVar2 = EVP_DigestSignUpdate\n                            (local_60,*(undefined8 *)(local_38 + 0x40),\n                             *(undefined8 *)(local_38 + 0x48));\n          if (iVar2 == 0) {\n            *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DIGESTSIGNUPDATE_ERROR\";\n          }\n          else {\n            iVar2 = EVP_DigestSignFinal(local_60,(uchar *)0x0,&local_68);\n            if (iVar2 == 0) {\n              *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) =\n                   \"DIGESTSIGNFINAL_LENGTH_ERROR\";\n            }\n            else {\n              local_40 = (uchar *)CRYPTO_malloc((int)local_68,\"test/evp_test.c\",0x568);\n              iVar2 = FUN_00018f92(\"test/evp_test.c\",0x568,\"got = OPENSSL_malloc(got_len)\",local_40)\n              ;\n              if (iVar2 == 0) {\n                *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"TEST_FAILURE\";\n              }\n              else {\n                iVar2 = EVP_DigestSignFinal(local_60,local_40,&local_68);\n                if ((iVar2 == 0) ||\n                   (iVar2 = FUN_000060ba(param_1,\"TEST_MAC_ERR\",*(undefined8 *)(local_38 + 0x50),\n                                         *(undefined8 *)(local_38 + 0x58),local_40,local_68),\n                   iVar2 == 0)) {\n                  *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"TEST_MAC_ERR\";\n                }\n                else {\n                  *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0000a135:\n  EVP_CIPHER_free(local_48);\n  EVP_MD_CTX_free(local_60);\n  CRYPTO_free(local_40);\n  EVP_PKEY_CTX_free(local_30);\n  EVP_PKEY_free(local_58);\nLAB_0000a182:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is mac_test_run_pkey"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  long in_FS_OFFSET;\n  undefined8 local_38;\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = 0;\n  ptr = (void *)FUN_00002d87(\"sha256\",\"secret\",&DAT_00013cc4);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0xb8,\"params\",ptr);\n  if (iVar1 != 0) {\n    local_38 = FUN_00002d68(\"TLS1-PRF\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0xb9,\"kctx = get_kdfbyname(OSSL_KDF_NAME_TLS1_PRF)\",\n                         local_38);\n    if (iVar1 != 0) {\n      uVar2 = EVP_KDF_derive(local_38,local_28,0x10,ptr);\n      iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0xba,\n                           \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar2,0);\n      if (iVar1 != 0) {\n        uVar2 = 1;\n        goto LAB_000037a4;\n      }\n    }\n  }\n  uVar2 = 0;\nLAB_000037a4:\n  EVP_KDF_CTX_free(local_38);\n  CRYPTO_free(ptr);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_tls1_prf_1byte_seed"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](undefined4 *param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_14;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_00009ddc(&PTR_DAT_0021f000,6,&local_14,param_2);\n  if (iVar1 != 0) {\n    *param_1 = local_14;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1 != 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is parse_servername_callback"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 *\n[MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n            char *param_5,char *param_6)\n\n{\n  undefined8 *puVar1;\n  size_t sVar2;\n  undefined8 *puVar3;\n  long in_FS_OFFSET;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  char *local_68;\n  char *local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 *local_30;\n  undefined8 *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_68 = param_6;\n  local_60 = param_5;\n  local_58 = param_4;\n  local_50 = param_3;\n  local_48 = param_2;\n  local_40 = param_1;\n  puVar1 = (undefined8 *)CRYPTO_malloc(0x118,\"test/evp_kdf_test.c\",0x431);\n  local_30 = puVar1;\n  if (puVar1 == (undefined8 *)0x0) {\n    puVar3 = (undefined8 *)0x0;\n    local_28 = puVar1;\n  }\n  else {\n    local_28 = puVar1 + 5;\n    OSSL_PARAM_construct_utf8_string(&local_98,\"digest\",local_40,0);\n    puVar3 = local_28;\n    *puVar1 = local_98;\n    puVar1[1] = local_90;\n    puVar1[2] = local_88;\n    puVar1[3] = local_80;\n    puVar1[4] = local_78;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_utf8_string(&local_98,&DAT_000141e1,local_48,0);\n    puVar1 = local_28;\n    *puVar3 = local_98;\n    puVar3[1] = local_90;\n    puVar3[2] = local_88;\n    puVar3[3] = local_80;\n    puVar3[4] = local_78;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_utf8_string(&local_98,&DAT_00013d10,\"COUNTER\",0);\n    puVar3 = local_28;\n    *puVar1 = local_98;\n    puVar1[1] = local_90;\n    puVar1[2] = local_88;\n    puVar1[3] = local_80;\n    puVar1[4] = local_78;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_octet_string(&local_98,&DAT_00013cfa,local_50,local_58);\n    *puVar3 = local_98;\n    puVar3[1] = local_90;\n    puVar3[2] = local_88;\n    puVar3[3] = local_80;\n    puVar3[4] = local_78;\n    sVar2 = strlen(local_60);\n    puVar1 = local_28;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_octet_string(&local_98,&DAT_00013cf5,local_60,sVar2);\n    *puVar1 = local_98;\n    puVar1[1] = local_90;\n    puVar1[2] = local_88;\n    puVar1[3] = local_80;\n    puVar1[4] = local_78;\n    sVar2 = strlen(local_68);\n    puVar1 = local_28;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_octet_string(&local_98,&DAT_00013cfe,local_68,sVar2);\n    puVar3 = local_28;\n    *puVar1 = local_98;\n    puVar1[1] = local_90;\n    puVar1[2] = local_88;\n    puVar1[3] = local_80;\n    puVar1[4] = local_78;\n    OSSL_PARAM_construct_end(&local_98);\n    *puVar3 = local_98;\n    puVar3[1] = local_90;\n    puVar3[2] = local_88;\n    puVar3[3] = local_80;\n    puVar3[4] = local_78;\n    puVar3 = local_30;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar3;\n}\n\n",
        "output": "The predicted function name is construct_kbkdf_params"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined4 uVar1;\n  long in_FS_OFFSET;\n  void *local_20;\n  long local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = (void *)0x0;\n  local_18 = FUN_00003d49(param_2,&local_20,0);\n  if (local_18 == 0) {\n    uVar1 = 0xffffffff;\n  }\n  else {\n    uVar1 = FUN_00003aa1(param_1,local_20,local_18,param_3);\n    CRYPTO_free(local_20);\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is do_encode_custom"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  long in_FS_OFFSET;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  wget_rss_get_urls_inline(param_2,&local_18);\n  FUN_0001b545(param_1,local_18,param_3,param_4);\n  wget_vector_free(&local_18);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is rss_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void *param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,long param_5\n                )\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  long in_FS_OFFSET;\n  int local_84;\n  undefined8 local_80;\n  undefined8 local_78;\n  undefined8 local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  long local_58;\n  long local_50;\n  void *local_48;\n  undefined8 local_40;\n  undefined8 local_38 [3];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_80 = 0;\n  local_70 = 0;\n  local_68 = 0;\n  iVar1 = mu_sieve_get_tag(param_1,&DAT_0000445f,0,0);\n  if (iVar1 == 0) {\n    iVar1 = FUN_00002378(param_1,&local_80,param_2,param_3);\n    if (iVar1 != 0) {\n      local_84 = -1;\n      goto LAB_00003d8c;\n    }\n    mu_mime_get_message(local_80,&local_78);\n    mu_message_unref(local_78);\n  }\n  else {\n    iVar1 = mu_mapfile_stream_create(&local_60,param_3,1);\n    if (iVar1 != 0) {\n      uVar2 = mu_strerror(iVar1);\n      uVar3 = mu_sieve_get_message_num(param_1);\n      uVar4 = dgettext(\"mailutils\",\"%lu: cannot open message file %s: %s\");\n      mu_sieve_error(param_1,uVar4,uVar3,param_3,uVar2);\n      local_84 = -1;\n      goto LAB_00003d8c;\n    }\n    iVar1 = mu_sieve_get_tag(param_1,\"rfc2822\",0,0);\n    if (iVar1 == 0) {\n      iVar1 = mu_memory_stream_create(&local_48,3);\n      if (iVar1 != 0) {\n        mu_stream_unref(local_60);\n        uVar2 = mu_strerror(iVar1);\n        uVar3 = mu_sieve_get_message_num(param_1);\n        uVar4 = dgettext(\"mailutils\",\"%lu: cannot create memory stream: %s\");\n        mu_sieve_error(param_1,uVar4,uVar3,uVar2);\n        local_84 = -1;\n        goto LAB_00003d8c;\n      }\n      local_84 = mu_stream_copy(local_48,local_60,0,0);\n      mu_stream_unref(local_60);\n      if (local_84 == 0) {\n        local_84 = mu_stream_write(local_48,&DAT_000040e0,1,0);\n      }\n      if (local_84 == 0) {\n        iVar1 = mu_stream_ioctl(local_48,0,0,local_38);\n        if (iVar1 == 0) {\n          iVar1 = FUN_00002378(param_1,&local_80,param_2,local_38[0]);\n          if (iVar1 == 0) {\n            mu_mime_get_message(local_80,&local_78);\n            mu_message_unref(local_78);\n            mu_stream_unref(local_48);\n            goto LAB_00003b4c;\n          }\n          mu_stream_unref(local_48);\n        }\n        else {\n          mu_stream_unref(local_48);\n          uVar2 = mu_strerror(iVar1);\n          uVar3 = mu_sieve_get_message_num(param_1);\n          mu_sieve_error(param_1,\"%lu: mu_stream_ioctl: %s\",uVar3,uVar2);\n        }\n      }\n      else {\n        uVar2 = mu_strerror(local_84);\n        uVar3 = mu_sieve_get_message_num(param_1);\n        uVar4 = dgettext(\"mailutils\",\"%lu: failed reading from %s: %s\");\n        mu_sieve_error(param_1,uVar4,uVar3,param_3,uVar2);\n      }\n      local_84 = -1;\n      goto LAB_00003d8c;\n    }\n    iVar1 = mu_stream_to_message(local_60,&local_78);\n    mu_stream_unref(local_60);\n    if (iVar1 != 0) {\n      uVar2 = mu_strerror(iVar1);\n      uVar3 = mu_sieve_get_message_num(param_1);\n      uVar4 = dgettext(\"mailutils\",\"%lu: cannot read message from file %s: %s\");\n      mu_sieve_error(param_1,uVar4,uVar3,param_3,uVar2);\n      local_84 = -1;\n      goto LAB_00003d8c;\n    }\n  }\nLAB_00003b4c:\n  mu_message_get_header(local_78,&local_60);\n  local_84 = mu_address_create(&local_70,param_4);\n  if (local_84 == 0) {\n    mu_header_set_value(local_60,&DAT_00004209,param_4,1);\n    local_58 = mu_sieve_get_tag_untyped(param_1,\"header\");\n    if (local_58 != 0) {\n      local_40 = local_60;\n      local_48 = param_1;\n      mu_sieve_vlist_do(param_1,local_58,FUN_000035c6,&local_48);\n    }\n    FUN_000031ea(param_1,param_2,local_60);\n    if (param_5 == 0) {\n      local_68 = 0;\n    }\n    else {\n      iVar1 = mu_address_create(&local_68,param_5);\n      if (iVar1 != 0) {\n        local_68 = 0;\n      }\n    }\n    iVar1 = mu_rfc2822_in_reply_to(param_2,&local_48);\n    if (iVar1 == 0) {\n      mu_header_set_value(local_60,\"In-Reply-To\",local_48,1);\n      free(local_48);\n    }\n    iVar1 = mu_rfc2822_references(param_2,&local_48);\n    if (iVar1 == 0) {\n      mu_header_set_value(local_60,\"References\",local_48,1);\n      free(local_48);\n    }\n    local_50 = mu_sieve_get_mailer(param_1);\n    if (local_50 == 0) {\n      local_84 = 0x1000;\n    }\n    else {\n      local_84 = mu_mailer_send_message(local_50,local_78,local_68,local_70);\n    }\n  }\n  else {\n    uVar2 = mu_strerror(local_84);\n    uVar3 = mu_sieve_get_message_num(param_1);\n    uVar4 = dgettext(\"mailutils\",\"%lu: cannot create recipient address <%s>: %s\");\n    mu_sieve_error(param_1,uVar4,uVar3,param_5,uVar2);\n  }\n  mu_address_destroy(&local_70);\n  mu_address_destroy(&local_68);\n  mu_mime_destroy(&local_80);\nLAB_00003d8c:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_84;\n}\n\n",
        "output": "The predicted function name is vacation_reply"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8\n[MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n            undefined8 param_5,undefined8 param_6)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = CRYPTO_zalloc(1,\"test/fake_rsaprov.c\",0xb2);\n  FUN_0000879a(\"test/fake_rsaprov.c\",0xb4,\"sigctx\",uVar1,param_5,param_6,param_2,param_1);\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is fake_rsa_sig_newctx"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ASN1_VALUE *param_1,uchar **param_2)\n\n{\n  ASN1_ITEM *it;\n  \n  it = (ASN1_ITEM *)FUN_00002cec();\n  ASN1_item_i2d(param_1,param_2,it);\n  return;\n}\n\n",
        "output": "The predicted function name is i2d_ASN1_INT64_DATA"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  uint local_c;\n  \n  for (local_c = 0; local_c < 2; local_c = local_c + 1) {\n    dico_strategy_add(&PTR_s_exact_002133c0 + (long)(int)local_c * 7);\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is gcide_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  if (DAT_00204348 != 0) {\n    ERR_unload_strings(DAT_00204344,(ERR_STRING_DATA *)&DAT_00204260);\n    DAT_00204348 = 0;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is ERR_unload_AFALG_strings"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                 char *param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n                 undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  int *piVar1;\n  char *pcVar2;\n  long in_FS_OFFSET;\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined *local_d0;\n  undefined *local_c8;\n  undefined8 local_c0;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = param_1;\n    local_78 = param_2;\n    local_68 = param_3;\n    local_58 = param_4;\n    local_48 = param_5;\n    local_38 = param_6;\n    local_28 = param_7;\n    local_18 = param_8;\n  }\n  local_c0 = *(undefined8 *)(in_FS_OFFSET + 0x28);\n  local_d8 = 8;\n  local_d4 = 0x30;\n  local_d0 = &stack0x00000008;\n  local_c8 = local_b8;\n  local_b0 = param_10;\n  local_a8 = param_11;\n  local_a0 = param_12;\n  local_98 = param_13;\n  local_90 = param_14;\n  vfprintf(stderr,param_9,&local_d8);\n  piVar1 = __errno_location();\n  pcVar2 = strerror(*piVar1);\n  fprintf(stderr,\": %s\\n\",pcVar2);\n                    /* WARNING: Subroutine does not return */\n  exit(1);\n}\n\n",
        "output": "The predicted function name is err_sys"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  size_t local_28;\n  uchar *local_20;\n  long local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  local_20 = (uchar *)0x0;\n  iVar1 = FUN_000064e0(*(undefined8 *)(local_18 + 0x20),FUN_00010395,\n                       *(undefined8 *)(local_18 + 0x10));\n  if (iVar1 == 0) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DIGESTUPDATE_ERROR\";\n  }\n  else {\n    iVar1 = EVP_DigestSignFinal(*(EVP_MD_CTX **)(local_18 + 0x10),(uchar *)0x0,&local_28);\n    if (iVar1 == 0) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DIGESTSIGNFINAL_LENGTH_ERROR\";\n    }\n    else {\n      local_20 = (uchar *)CRYPTO_malloc((int)local_28,\"test/evp_test.c\",0xce8);\n      iVar1 = FUN_00018f92(\"test/evp_test.c\",0xce8,\"got = OPENSSL_malloc(got_len)\",local_20);\n      if (iVar1 == 0) {\n        *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"MALLOC_FAILURE\";\n      }\n      else {\n        local_28 = local_28 * 2;\n        iVar1 = EVP_DigestSignFinal(*(EVP_MD_CTX **)(local_18 + 0x10),local_20,&local_28);\n        if (iVar1 == 0) {\n          *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DIGESTSIGNFINAL_ERROR\";\n        }\n        else {\n          iVar1 = FUN_000060ba(param_1,\"SIGNATURE_MISMATCH\",*(undefined8 *)(local_18 + 0x38),\n                               *(undefined8 *)(local_18 + 0x40),local_20,local_28);\n          if (iVar1 != 0) {\n            *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n          }\n        }\n      }\n    }\n  }\n  CRYPTO_free(local_20);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is digestsign_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int param_1)\n\n{\n  if (param_1 == 0xf) {\n                    /* WARNING: Subroutine does not return */\n    exit(1);\n  }\n  if (param_1 == 2) {\n    if (DAT_00253cf0 != '\\0') {\n                    /* WARNING: Subroutine does not return */\n      exit(1);\n    }\n    DAT_00253cf0 = '\\x01';\n    wget_http_abort_connection(0);\n  }\n  else if (param_1 == 0x1c) {\n    wget_bar_screen_resized();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is nop"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  wget_hashmap_set_value_destructor(param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is wget_stringmap_set_value_destructor"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  undefined8 uVar3;\n  \n  puVar1 = *(undefined8 **)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  iVar2 = strcmp(param_2,\"Input\");\n  if (iVar2 == 0) {\n    uVar3 = FUN_000066e2(param_3,puVar1 + 2,puVar1 + 3);\n  }\n  else {\n    iVar2 = strcmp(param_2,\"Output\");\n    if (iVar2 == 0) {\n      uVar3 = FUN_000066e2(param_3,puVar1 + 4,puVar1 + 5);\n    }\n    else {\n      iVar2 = strcmp(param_2,\"Ctrl\");\n      if (iVar2 == 0) {\n        uVar3 = FUN_0000b5de(param_1,*puVar1,param_3);\n      }\n      else {\n        uVar3 = 0;\n      }\n    }\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is pkey_test_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  FUN_00009d51(param_2,param_1 + 0x1d8);\n  return;\n}\n\n",
        "output": "The predicted function name is parse_test_resumption_expected"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_0000397d(\"host:65535/path\",0,&DAT_0000e199,\"65535\",\"/path\");\n  return;\n}\n\n",
        "output": "The predicted function name is test_http_url_dns"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                 char *param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n                 undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  long in_FS_OFFSET;\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined *local_d0;\n  undefined *local_c8;\n  undefined8 local_c0;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = param_1;\n    local_78 = param_2;\n    local_68 = param_3;\n    local_58 = param_4;\n    local_48 = param_5;\n    local_38 = param_6;\n    local_28 = param_7;\n    local_18 = param_8;\n  }\n  local_c0 = *(undefined8 *)(in_FS_OFFSET + 0x28);\n  local_d8 = 8;\n  local_d4 = 0x30;\n  local_d0 = &stack0x00000008;\n  local_c8 = local_b8;\n  local_b0 = param_10;\n  local_a8 = param_11;\n  local_a0 = param_12;\n  local_98 = param_13;\n  local_90 = param_14;\n  vfprintf(stderr,param_9,&local_d8);\n  fputc(10,stderr);\n                    /* WARNING: Subroutine does not return */\n  exit(1);\n}\n\n",
        "output": "The predicted function name is err_quit"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbyte * [MASK](byte *param_1,byte *param_2,undefined4 param_3)\n\n{\n  bool bVar1;\n  byte bVar2;\n  char *pcVar3;\n  byte *local_18;\n  byte *local_10;\n  \n  if ((param_1 != (byte *)0x0) && (param_2 != (byte *)0x0)) {\n    local_18 = param_1;\n    local_10 = param_2;\n    switch(param_3) {\n    default:\n      bVar1 = false;\n      for (; *local_18 != 0; local_18 = local_18 + 1) {\n        if (((char)*local_18 < '\\x01') || ('\\x1f' < (char)*local_18)) {\n          *local_10 = *local_18;\n          local_10 = local_10 + 1;\n        }\n        else {\n          *local_10 = 0x25;\n          bVar2 = *local_18 >> 4;\n          if (bVar2 < 10) {\n            bVar2 = bVar2 + 0x30;\n          }\n          else {\n            bVar2 = bVar2 + 0x37;\n          }\n          local_10[1] = bVar2;\n          bVar2 = *local_18 & 0xf;\n          if (bVar2 < 10) {\n            bVar2 = bVar2 + 0x30;\n          }\n          else {\n            bVar2 = bVar2 + 0x37;\n          }\n          local_10[2] = bVar2;\n          bVar1 = true;\n          local_10 = local_10 + 3;\n        }\n      }\n      *local_10 = 0;\n      if (bVar1) {\n        return param_2;\n      }\n      break;\n    case 2:\n      bVar1 = false;\n      for (; *local_18 != 0; local_18 = local_18 + 1) {\n        if (((char)*local_18 < ' ') ||\n           (pcVar3 = strchr(\"\\\\<>:\\\"|?*\",(int)(char)*local_18), pcVar3 != (char *)0x0)) {\n          *local_10 = 0x25;\n          bVar2 = *local_18 >> 4;\n          if (bVar2 < 10) {\n            bVar2 = bVar2 + 0x30;\n          }\n          else {\n            bVar2 = bVar2 + 0x37;\n          }\n          local_10[1] = bVar2;\n          bVar2 = *local_18 & 0xf;\n          if (bVar2 < 10) {\n            bVar2 = bVar2 + 0x30;\n          }\n          else {\n            bVar2 = bVar2 + 0x37;\n          }\n          local_10[2] = bVar2;\n          bVar1 = true;\n          local_10 = local_10 + 3;\n        }\n        else {\n          *local_10 = *local_18;\n          local_10 = local_10 + 1;\n        }\n      }\n      *local_10 = 0;\n      if (bVar1) {\n        return param_2;\n      }\n      break;\n    case 4:\n      break;\n    case 8:\n      bVar1 = false;\n      for (; *local_18 != 0; local_18 = local_18 + 1) {\n        if ((char)*local_18 < ' ') {\n          *local_10 = 0x25;\n          bVar2 = *local_18 >> 4;\n          if (bVar2 < 10) {\n            bVar2 = bVar2 + 0x30;\n          }\n          else {\n            bVar2 = bVar2 + 0x37;\n          }\n          local_10[1] = bVar2;\n          bVar2 = *local_18 & 0xf;\n          if (bVar2 < 10) {\n            bVar2 = bVar2 + 0x30;\n          }\n          else {\n            bVar2 = bVar2 + 0x37;\n          }\n          local_10[2] = bVar2;\n          bVar1 = true;\n          local_10 = local_10 + 3;\n        }\n        else {\n          *local_10 = *local_18;\n          local_10 = local_10 + 1;\n        }\n      }\n      *local_10 = 0;\n      if (bVar1) {\n        return param_2;\n      }\n      break;\n    case 0x10:\n      for (; *local_18 != 0; local_18 = local_18 + 1) {\n        if (('`' < (char)*local_18) && ((char)*local_18 < '{')) {\n          *local_18 = *local_18 & 0xdf;\n        }\n      }\n      break;\n    case 0x20:\n      for (; *local_18 != 0; local_18 = local_18 + 1) {\n        if (('@' < (char)*local_18) && ((char)*local_18 < '[')) {\n          *local_18 = *local_18 | 0x20;\n        }\n      }\n    }\n  }\n  return param_1;\n}\n\n",
        "output": "The predicted function name is wget_restrict_file_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  long local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 != 0) {\n    local_18 = wget_thread_self();\n    wget_thread_mutex_lock(DAT_00253c08);\n    if (((*(long *)(param_1 + 8) != 0) && ((*(byte *)(*(long *)(param_1 + 8) + 0xa8) & 2) != 0)) &&\n       (*(long *)(*(long *)(param_1 + 8) + 0x70) == local_18)) {\n      lVar1 = *(long *)(param_1 + 8);\n      *(byte *)(lVar1 + 0xa8) = *(byte *)(lVar1 + 0xa8) & 0xfb;\n      *(byte *)(*(long *)(param_1 + 8) + 0xa8) =\n           *(byte *)(*(long *)(param_1 + 8) + 0xa8) & 0xfd |\n           (*(byte *)(lVar1 + 0xa8) >> 2 & 1) * '\\x02';\n      *(undefined8 *)(*(long *)(param_1 + 8) + 0x70) = 0;\n      wget_debug_printf(\"released robots.txt job\\n\");\n    }\n    wget_list_browse(*(undefined8 *)(param_1 + 0x18),FUN_0000ef70,&local_18);\n    wget_thread_mutex_unlock(DAT_00253c08);\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is host_release_jobs"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Type propagation algorithm not settling */\n\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = inet_ntoa((in_addr)((in_addr *)(param_1 + 4))->s_addr);\n  printf(\"Parameter problem: IP address = %s\\n\",pcVar1);\n  FUN_00004f47(param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is print_parameterprob"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nundefined8 [MASK](long param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  ulong local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  wget_thread_mutex_lock(DAT_00253c08);\n  if (DAT_00253c00 == 0) {\n    DAT_00253c00 = wget_hashmap_create(0x10,FUN_0000e808,FUN_0000e768);\n    wget_hashmap_set_key_destructor(DAT_00253c00,FUN_0000e86e);\n  }\n  local_50 = 0;\n  local_40 = 0;\n  local_38 = 0;\n  local_30 = 0;\n  local_28 = 0;\n  local_20 = 0;\n  local_48 = *(undefined8 *)(param_1 + 0x20);\n  local_18 = (ulong)CONCAT24(*(undefined2 *)(param_1 + 0x58),*(undefined4 *)(param_1 + 0x5c));\n  iVar1 = wget_hashmap_contains(DAT_00253c00,&local_48);\n  if (iVar1 == 0) {\n    local_50 = wget_memdup(&local_48,0x38);\n    wget_hashmap_put(DAT_00253c00,local_50,local_50);\n  }\n  wget_thread_mutex_unlock(DAT_00253c08);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_50;\n}\n\n",
        "output": "The predicted function name is host_add"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  EVP_PKEY_CTX *local_28;\n  uchar *local_20;\n  EVP_PKEY_CTX **local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = *(EVP_PKEY_CTX ***)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  local_20 = (uchar *)0x0;\n  local_28 = (EVP_PKEY_CTX *)0x0;\n  iVar1 = FUN_00015d6d(DAT_002241a8,3,0,0);\n  if (iVar1 == 0) {\n    iVar1 = EVP_PKEY_derive(*local_18,(uchar *)0x0,(size_t *)&local_28);\n    if (iVar1 < 1) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"INTERNAL_ERROR\";\n      goto LAB_0000f5b5;\n    }\n    if ((local_28 == (EVP_PKEY_CTX *)0xffffffffffffffff) || (local_28 == (EVP_PKEY_CTX *)0x0)) {\n      local_28 = local_18[2];\n    }\n    else {\n      local_28 = (EVP_PKEY_CTX *)((long)local_18[2] * 2);\n    }\n  }\n  else {\n    local_28 = local_18[2];\n  }\n  if (local_28 == (EVP_PKEY_CTX *)0x0) {\n    iVar1 = 1;\n  }\n  else {\n    iVar1 = (int)local_28;\n  }\n  local_20 = (uchar *)CRYPTO_malloc(iVar1,\"test/evp_test.c\",0xb5b);\n  iVar1 = FUN_00018f92(\"test/evp_test.c\",0xb5b,\"got = OPENSSL_malloc(got_len == 0 ? 1 : got_len)\",\n                       local_20);\n  if (iVar1 == 0) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"INTERNAL_ERROR\";\n  }\n  else {\n    iVar1 = EVP_PKEY_derive(*local_18,local_20,(size_t *)&local_28);\n    if (iVar1 < 1) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KDF_DERIVE_ERROR\";\n    }\n    else {\n      iVar1 = FUN_000194c5(\"test/evp_test.c\",0xb63,\"expected->output\",&DAT_0001c568,local_18[1],\n                           local_18[2],local_20,local_28);\n      if (iVar1 == 0) {\n        *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KDF_MISMATCH\";\n      }\n      else {\n        *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n      }\n    }\n  }\nLAB_0000f5b5:\n  CRYPTO_free(local_20);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is pkey_kdf_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  void *ptr;\n  \n  ptr = *(void **)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  EVP_MD_CTX_free(*(undefined8 *)((long)ptr + 0x10));\n  FUN_00006094(*(undefined8 *)((long)ptr + 0x20),FUN_000061a0);\n  CRYPTO_free(*(void **)((long)ptr + 0x28));\n  CRYPTO_free(*(void **)((long)ptr + 0x38));\n  CRYPTO_free(ptr);\n  *(undefined8 *)(\"EVP_PKEY_verify_recover_init\" + param_1) = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is digestsigver_test_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  long in_FS_OFFSET;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  wget_atom_get_urls_inline(param_2,&local_18);\n  FUN_0001b545(param_1,local_18,param_3,param_4);\n  wget_vector_free(&local_18);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is atom_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4\n[MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined4 param_4,\n            undefined8 param_5)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long *plVar3;\n  long lVar4;\n  code *pcVar5;\n  \n  plVar3 = (long *)EVP_CIPHER_CTX_get_cipher_data(param_1);\n  if ((*plVar3 == 0) && (iVar1 = EVP_CIPHER_impl_ctx_size(param_5), iVar1 != 0)) {\n    iVar1 = EVP_CIPHER_impl_ctx_size(param_5);\n    lVar4 = CRYPTO_zalloc((long)iVar1,\"engines/e_dasync.c\",0x2aa);\n    *plVar3 = lVar4;\n    if (*plVar3 == 0) {\n      FUN_00002411(0,0xc0100,\"engines/e_dasync.c\",0x2ad);\n      return 0;\n    }\n  }\n  *(undefined4 *)(plVar3 + 1) = 0;\n  *(undefined4 *)(plVar3 + 0x39) = 0;\n  EVP_CIPHER_CTX_set_cipher_data(param_1,*plVar3);\n  pcVar5 = (code *)EVP_CIPHER_meth_get_init(param_5);\n  uVar2 = (*pcVar5)(param_1,param_2,param_3,param_4);\n  EVP_CIPHER_CTX_set_cipher_data(param_1,plVar3);\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is dasync_cipher_init_key_helper"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](ushort *param_1)\n\n{\n  char cVar1;\n  ushort uVar2;\n  int iVar3;\n  undefined4 *puVar4;\n  size_t sVar5;\n  ulong uVar6;\n  char *pcVar7;\n  byte bVar8;\n  ushort *local_40;\n  int local_28;\n  char *local_20;\n  char *local_18;\n  ushort *local_10;\n  \n  bVar8 = 0;\n  local_28 = 0;\n  local_10 = param_1;\n  if (param_1 == (ushort *)0x0) {\n    local_20 = (char *)0x0;\n  }\n  else {\n    while (*local_10 != 0) {\n      local_28 = local_28 + 1;\n      local_10 = local_10 + 1;\n    }\n    local_28 = local_28 + 0x10;\n    local_20 = (char *)calloc((long)local_28,1);\n    local_18 = local_20;\n    for (local_40 = param_1; *local_40 != 0; local_40 = local_40 + 1) {\n      iVar3 = (int)local_18 - (int)local_20;\n      if (local_28 + -8 <= iVar3) {\n        local_28 = local_28 + 0x10;\n        local_20 = (char *)realloc(local_20,(long)local_28);\n        local_18 = local_20 + iVar3;\n        *local_18 = '\\0';\n      }\n      uVar2 = *local_40;\n      if (uVar2 == 0x3c) {\n        uVar6 = 0xffffffffffffffff;\n        pcVar7 = local_18;\n        do {\n          if (uVar6 == 0) break;\n          uVar6 = uVar6 - 1;\n          cVar1 = *pcVar7;\n          pcVar7 = pcVar7 + (ulong)bVar8 * -2 + 1;\n        } while (cVar1 != '\\0');\n        *(undefined4 *)(local_18 + (~uVar6 - 1)) = 0x3b746c26;\n        *(undefined *)((long)(local_18 + (~uVar6 - 1)) + 4) = 0;\n        local_18 = local_18 + 4;\n      }\n      else if (uVar2 < 0x3d) {\n        if (uVar2 == 0x26) {\n          uVar6 = 0xffffffffffffffff;\n          pcVar7 = local_18;\n          do {\n            if (uVar6 == 0) break;\n            uVar6 = uVar6 - 1;\n            cVar1 = *pcVar7;\n            pcVar7 = pcVar7 + (ulong)bVar8 * -2 + 1;\n          } while (cVar1 != '\\0');\n          *(undefined4 *)(local_18 + (~uVar6 - 1)) = 0x706d6126;\n          *(undefined2 *)((long)(local_18 + (~uVar6 - 1)) + 4) = 0x3b;\n          local_18 = local_18 + 5;\n        }\n        else if (uVar2 == 0x27) {\n          uVar6 = 0xffffffffffffffff;\n          pcVar7 = local_18;\n          do {\n            if (uVar6 == 0) break;\n            uVar6 = uVar6 - 1;\n            cVar1 = *pcVar7;\n            pcVar7 = pcVar7 + (ulong)bVar8 * -2 + 1;\n          } while (cVar1 != '\\0');\n          *(undefined4 *)(local_18 + (~uVar6 - 1)) = 0x39332326;\n          *(undefined2 *)((long)(local_18 + (~uVar6 - 1)) + 4) = 0x3b;\n          local_18 = local_18 + 5;\n        }\n        else {\n          if (uVar2 != 0x22) goto LAB_00005397;\n          uVar6 = 0xffffffffffffffff;\n          pcVar7 = local_18;\n          do {\n            if (uVar6 == 0) break;\n            uVar6 = uVar6 - 1;\n            cVar1 = *pcVar7;\n            pcVar7 = pcVar7 + (ulong)bVar8 * -2 + 1;\n          } while (cVar1 != '\\0');\n          puVar4 = (undefined4 *)(local_18 + (~uVar6 - 1));\n          *puVar4 = 0x6f757126;\n          *(undefined2 *)(puVar4 + 1) = 0x3b74;\n          *(undefined *)((long)puVar4 + 6) = 0;\n          local_18 = local_18 + 6;\n        }\n      }\n      else if (uVar2 == 0x60) {\n        uVar6 = 0xffffffffffffffff;\n        pcVar7 = local_18;\n        do {\n          if (uVar6 == 0) break;\n          uVar6 = uVar6 - 1;\n          cVar1 = *pcVar7;\n          pcVar7 = pcVar7 + (ulong)bVar8 * -2 + 1;\n        } while (cVar1 != '\\0');\n        *(undefined4 *)(local_18 + (~uVar6 - 1)) = 0x36392326;\n        *(undefined2 *)((long)(local_18 + (~uVar6 - 1)) + 4) = 0x3b;\n        local_18 = local_18 + 5;\n      }\n      else if (uVar2 < 0x61) {\n        if (uVar2 == 0x3e) {\n          uVar6 = 0xffffffffffffffff;\n          pcVar7 = local_18;\n          do {\n            if (uVar6 == 0) break;\n            uVar6 = uVar6 - 1;\n            cVar1 = *pcVar7;\n            pcVar7 = pcVar7 + (ulong)bVar8 * -2 + 1;\n          } while (cVar1 != '\\0');\n          *(undefined4 *)(local_18 + (~uVar6 - 1)) = 0x3b746726;\n          *(undefined *)((long)(local_18 + (~uVar6 - 1)) + 4) = 0;\n          local_18 = local_18 + 4;\n        }\n        else {\nLAB_00005397:\n          if (*local_40 < 0x7f) {\n            if (0x13 < *local_40) {\n              *local_18 = (char)*local_40;\n              local_18[1] = '\\0';\n              local_18 = local_18 + 1;\n            }\n          }\n          else {\n            sprintf(local_18,\"&#x%X;\",(ulong)*local_40);\n            sVar5 = strlen(local_18);\n            local_18[sVar5] = '\\0';\n            local_18 = local_18 + sVar5;\n          }\n        }\n      }\n      else if (uVar2 == 0x7b) {\n        uVar6 = 0xffffffffffffffff;\n        pcVar7 = local_18;\n        do {\n          if (uVar6 == 0) break;\n          uVar6 = uVar6 - 1;\n          cVar1 = *pcVar7;\n          pcVar7 = pcVar7 + (ulong)bVar8 * -2 + 1;\n        } while (cVar1 != '\\0');\n        puVar4 = (undefined4 *)(local_18 + (~uVar6 - 1));\n        *puVar4 = 0x32312326;\n        *(undefined2 *)(puVar4 + 1) = 0x3b33;\n        *(undefined *)((long)puVar4 + 6) = 0;\n        local_18 = local_18 + 6;\n      }\n      else {\n        if (uVar2 != 0x7d) goto LAB_00005397;\n        uVar6 = 0xffffffffffffffff;\n        pcVar7 = local_18;\n        do {\n          if (uVar6 == 0) break;\n          uVar6 = uVar6 - 1;\n          cVar1 = *pcVar7;\n          pcVar7 = pcVar7 + (ulong)bVar8 * -2 + 1;\n        } while (cVar1 != '\\0');\n        puVar4 = (undefined4 *)(local_18 + (~uVar6 - 1));\n        *puVar4 = 0x32312326;\n        *(undefined2 *)(puVar4 + 1) = 0x3b35;\n        *(undefined *)((long)puVar4 + 6) = 0;\n        local_18 = local_18 + 6;\n      }\n    }\n    *local_18 = '\\0';\n  }\n  return local_20;\n}\n\n",
        "output": "The predicted function name is htmlwescape"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,char param_2)\n\n{\n  FUN_00010e12(param_1,(int)param_2,DAT_00253c28);\n  return;\n}\n\n",
        "output": "The predicted function name is plugin_db_add_search_paths"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (*(long *)(param_1 + 0x18) == 0) {\n    uVar1 = dico_list_iterator(*(undefined8 *)(param_1 + 0x20));\n    *(undefined8 *)(param_1 + 0x18) = uVar1;\n    if (*(long *)(param_1 + 0x18) == 0) {\n      uVar1 = 0;\n    }\n    else {\n      uVar1 = dico_iterator_first(*(undefined8 *)(param_1 + 0x18));\n    }\n  }\n  else {\n    uVar1 = dico_iterator_next(*(undefined8 *)(param_1 + 0x18));\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is gcide_result_ref"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  return param_1;\n}\n\n",
        "output": "The predicted function name is ossl_check_OPENSSL_STRING_sk_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  wget_strcasecmp_ascii(param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is opt_compare_config"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nFILE * [MASK](long param_1)\n\n{\n  FILE *pFVar1;\n  \n  if (*(long *)(param_1 + 0x20) == 0) {\n    if (*(long *)(param_1 + 0x10) == 0) {\n      pFVar1 = (FILE *)0x0;\n    }\n    else {\n      pFVar1 = fopen(*(char **)(param_1 + 0x10),\"rb\");\n    }\n  }\n  else {\n    pFVar1 = fmemopen(*(void **)(param_1 + 0x20),*(size_t *)(param_1 + 0x18),\"rb\");\n  }\n  return pFVar1;\n}\n\n",
        "output": "The predicted function name is impl_file_open_stream"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](uint param_1)\n\n{\n  syscall(0x122,(ulong)param_1,0);\n  return;\n}\n\n",
        "output": "The predicted function name is eventfd"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nuint [MASK](long param_1,char *param_2,undefined8 param_3,undefined8 param_4,\n                 undefined8 param_5,undefined8 param_6)\n\n{\n  int iVar1;\n  uint local_c;\n  \n  if (*(long *)(\"EVP_CIPHER_CTX_set_flags\" + param_1 + 9) != 0) {\n    iVar1 = strcmp(*(char **)(\"EVP_CIPHER_CTX_set_flags\" + param_1 + 9),param_2);\n    if (iVar1 == 0) {\n      iVar1 = FUN_0001957f(\"test/evp_test.c\",0x69,\"expected\",&DAT_0001c568,param_3,param_4,param_5,\n                           param_6);\n      local_c = (uint)(iVar1 == 0);\n      goto LAB_00006186;\n    }\n  }\n  local_c = FUN_000194c5(\"test/evp_test.c\",0x6b,\"expected\",&DAT_0001c568,param_3,param_4,param_5,\n                         param_6);\nLAB_00006186:\n  if (local_c == 0) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = param_2;\n  }\n  return local_c;\n}\n\n",
        "output": "The predicted function name is memory_err_compare"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ASN1_VALUE *param_1,uchar **param_2)\n\n{\n  ASN1_ITEM *it;\n  \n  it = (ASN1_ITEM *)FUN_000029aa();\n  ASN1_item_i2d(param_1,param_2,it);\n  return;\n}\n\n",
        "output": "The predicted function name is i2d_ASN1_LONG_DATA"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nENGINE * [MASK](void)\n\n{\n  int iVar1;\n  ENGINE *e;\n  \n  e = ENGINE_new();\n  if (e == (ENGINE *)0x0) {\n    e = (ENGINE *)0x0;\n  }\n  else {\n    iVar1 = FUN_000025ac(e);\n    if (iVar1 == 0) {\n      ENGINE_free(e);\n      e = (ENGINE *)0x0;\n    }\n  }\n  return e;\n}\n\n",
        "output": "The predicted function name is engine_dasync"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  undefined4 uVar1;\n  byte bVar2;\n  char cVar3;\n  int iVar4;\n  char *pcVar5;\n  size_t sVar6;\n  undefined8 uVar7;\n  ulong uVar8;\n  \n  iVar4 = *(int *)(param_1 + 4);\n  if (iVar4 < 0) {\n    iVar4 = iVar4 + 0xff;\n  }\n  bVar2 = (byte)((uint)iVar4 >> 8);\n  uVar1 = *(undefined4 *)(param_1 + 4);\n  if (DAT_0020a180 == (char *)0x0) {\n    pcVar5 = (char *)gettext(\"run-level\");\n    sVar6 = strlen(pcVar5);\n    DAT_0020a180 = (char *)FUN_000069b0(sVar6 + 3);\n  }\n  uVar7 = gettext(\"run-level\");\n  sprintf(DAT_0020a180,\"%s %c\",uVar7,(ulong)(byte)uVar1);\n  if (DAT_0020a188 == (char *)0x0) {\n    pcVar5 = (char *)gettext(\"last=\");\n    sVar6 = strlen(pcVar5);\n    DAT_0020a188 = (char *)FUN_000069b0(sVar6 + 2);\n  }\n  if (bVar2 == 0x4e) {\n    uVar8 = 0x53;\n  }\n  else {\n    uVar8 = (ulong)bVar2;\n  }\n  uVar7 = gettext(\"last=\");\n  sprintf(DAT_0020a188,\"%s%c\",uVar7,uVar8);\n  cVar3 = FUN_00003a71(bVar2);\n  pcVar5 = DAT_0020a188;\n  if (cVar3 == '\\0') {\n    pcVar5 = \"\";\n  }\n  uVar7 = FUN_00002192(param_1);\n  FUN_00002228(0xffffffff,&DAT_000073d6,0x20,0xffffffff,DAT_0020a180,uVar7,&DAT_000073d6,\n               &DAT_000073d6,pcVar5,&DAT_000073d6);\n  return;\n}\n\n",
        "output": "The predicted function name is print_runlevel"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  FUN_0000ae56(param_1 + 0x1e0,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is parse_expected_server_cert_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  OPENSSL_sk_pop_free(param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is sk_EVP_TEST_BUFFER_pop_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](void)\n\n{\n  long in_FS_OFFSET;\n  bool bVar1;\n  undefined *local_20;\n  long local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = &DAT_00211010;\n  local_18 = FUN_00002acd(0,&local_20,4);\n  bVar1 = local_18 != 0;\n  if (bVar1) {\n    FUN_00002b3f(local_18);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return bVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_int32"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  time_t tVar5;\n  long in_FS_OFFSET;\n  uint local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  char *local_38;\n  uint local_30 [2];\n  void *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = \"~/.vacation\";\n  iVar1 = mu_sieve_get_tag(param_1,&DAT_000042e5,1,local_30);\n  if (iVar1 == 0) {\n    local_58 = 7;\n  }\n  else {\n    local_58 = local_30[0];\n    if (0x3c < local_30[0]) {\n      local_58 = 0x3c;\n    }\n  }\n  mu_sieve_get_tag(param_1,\"database\",2,&local_38);\n  local_28 = (void *)mu_tilde_expansion(local_38,0x2f,0);\n  if (local_28 == (void *)0x0) {\n    uVar2 = mu_sieve_get_message_num(param_1);\n    uVar3 = dgettext(\"mailutils\",\"%lu: cannot build db file name\");\n    mu_sieve_error(param_1,uVar3,uVar2);\n    mu_sieve_abort(param_1);\n  }\n  iVar1 = mu_locker_create(&local_40,local_28,0);\n  if (iVar1 != 0) {\n    uVar2 = mu_strerror(iVar1);\n    uVar3 = mu_sieve_get_message_num(param_1);\n    uVar4 = dgettext(\"mailutils\",\"%lu: cannot lock %s: %s\");\n    mu_sieve_error(param_1,uVar4,uVar3,local_28,uVar2);\n    free(local_28);\n    mu_sieve_abort(param_1);\n  }\n  iVar1 = mu_file_stream_create(&local_48,local_28,0x13);\n  if (iVar1 != 0) {\n    uVar2 = mu_strerror(iVar1);\n    uVar3 = mu_sieve_get_message_num(param_1);\n    mu_sieve_error(param_1,\"%lu: mu_file_stream_create(%s): %s\",uVar3,local_28,uVar2);\n    mu_locker_destroy(&local_40);\n    free(local_28);\n    mu_sieve_abort(param_1);\n  }\n  free(local_28);\n  iVar1 = mu_property_create_init(&local_50,PTR_mu_assoc_property_init_00204ff0,local_48);\n  if (iVar1 != 0) {\n    uVar2 = mu_strerror(iVar1);\n    uVar3 = mu_sieve_get_message_num(param_1);\n    mu_sieve_error(param_1,\"%lu: mu_property_create_init: %s\",uVar3,uVar2);\n    mu_locker_destroy(&local_40);\n    mu_sieve_abort(param_1);\n  }\n  iVar1 = mu_locker_lock(local_40);\n  if (iVar1 != 0) {\n    uVar2 = mu_strerror(iVar1);\n    uVar3 = mu_sieve_get_message_num(param_1);\n    mu_sieve_error(param_1,\"%lu: cannot lock vacation database: %s\",uVar3,uVar2);\n    mu_property_destroy(&local_50);\n    mu_sieve_abort(param_1);\n  }\n  tVar5 = time((time_t *)0x0);\n  iVar1 = FUN_00002b00(local_50,param_2,tVar5,local_58,param_1);\n  mu_property_destroy(&local_50);\n  mu_locker_unlock(local_40);\n  mu_locker_destroy(&local_40);\n  if (iVar1 == -1) {\n    mu_sieve_abort(param_1);\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is check_db"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  lVar1 = FUN_0000e457(param_1,DAT_00253c28);\n  if (lVar1 == 0) {\n    FUN_0000df2f(param_2,\"Plugin \\'%s\\' not found in any of the plugin search paths.\",param_1);\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = FUN_0001128f(param_1,lVar1,param_2);\n    (*wget_free)(lVar1);\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is plugin_db_load_from_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  undefined8 uVar1;\n  uint *puVar2;\n  long lVar3;\n  char cVar4;\n  long lVar5;\n  long lVar6;\n  char *pcVar7;\n  undefined8 uVar8;\n  undefined *puVar9;\n  long in_FS_OFFSET;\n  undefined8 uVar10;\n  undefined *local_70;\n  char *local_68;\n  undefined8 local_38;\n  undefined8 local_30;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  puVar2 = *(uint **)(param_1 + 0x58);\n  lVar3 = *(long *)(*(long *)(param_1 + 0x38) + 8);\n  if (*(long *)(lVar3 + 0x88) == 0) {\n    lVar5 = 0;\n  }\n  else {\n    lVar5 = dwg_ref_object_silent(puVar2,*(long *)(lVar3 + 0x88));\n  }\n  if (lVar5 == 0) {\n    lVar6 = 0;\n  }\n  else {\n    lVar6 = *(long *)(*(long *)(lVar5 + 0x38) + 8);\n  }\n  if ((((*(long *)(lVar3 + 0x78) != 0) && (cVar4 = FUN_00001c1d(param_1), cVar4 == '\\0')) &&\n      (cVar4 = FUN_00001b4b(*(undefined8 *)(lVar3 + 0x18),*(undefined8 *)(lVar3 + 0x20)),\n      cVar4 == '\\0')) && (cVar4 = FUN_00001be7(), cVar4 == '\\0')) {\n    if (*puVar2 < 0x1a) {\n      local_70 = (undefined *)\n                 FUN_00004ca4(*(undefined8 *)(lVar3 + 0x78),*(undefined2 *)((long)puVar2 + 0x1e));\n    }\n    else {\n      local_70 = (undefined *)FUN_00005071(*(undefined8 *)(lVar3 + 0x78));\n    }\n    if (((lVar6 == 0) || (*(int *)(lVar5 + 0x18) != 0x35)) ||\n       ((*(long *)(lVar6 + 0x58) == 0 ||\n        ((**(char **)(lVar6 + 0x58) == '\\0' ||\n         (pcVar7 = strcasestr(*(char **)(lVar6 + 0x58),\".ttf\"), pcVar7 == (char *)0x0)))))) {\n      local_68 = \"Courier\";\n    }\n    else {\n      pcVar7 = strcasestr(*(char **)(lVar6 + 0x58),\"Arial\");\n      if (pcVar7 == (char *)0x0) {\n        local_68 = \"Verdana\";\n      }\n      else {\n        local_68 = \"Arial\";\n      }\n    }\n    FUN_0000558b(*(undefined8 *)(lVar3 + 0x18),*(undefined8 *)(lVar3 + 0x20),&local_38);\n    puVar9 = local_70;\n    if (local_70 == (undefined *)0x0) {\n      puVar9 = &DAT_00005cc8;\n    }\n    uVar8 = FUN_00001d07(*(undefined8 *)(param_1 + 0x38));\n    uVar1 = *(undefined8 *)(lVar3 + 0x68);\n    uVar10 = FUN_00001b1f(local_30);\n    pcVar7 = (char *)FUN_00001b03(local_38);\n    printf(pcVar7,uVar10,uVar1,\n           \"\\t<text id=\\\"dwg-object-%d\\\" x=\\\"%f\\\" y=\\\"%f\\\" font-family=\\\"%s\\\" font-size=\\\"%f\\\" fill=\\\"%s\\\">%s</text>\\n\"\n           ,(ulong)*(uint *)(param_1 + 0x14),local_68,uVar8,puVar9);\n    free(local_70);\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is output_TEXT"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](long param_1)\n\n{\n  long lVar1;\n  \n  if ((*(int *)(param_1 + 4) == 0xd) || (*(int *)(param_1 + 4) == 0xe)) {\n    lVar1 = 0x14;\n  }\n  else if ((*(int *)(param_1 + 4) == 0x11) || (*(int *)(param_1 + 4) == 0x12)) {\n    lVar1 = 0xc;\n  }\n  else {\n    lVar1 = *(long *)(param_1 + 0x50) + 8;\n  }\n  return lVar1;\n}\n\n",
        "output": "The predicted function name is _ping_packetsize"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Type propagation algorithm not settling */\n\nvoid [MASK](int param_1,undefined8 param_2,undefined8 param_3,long param_4,undefined8 param_5,\n                 long param_6,uint param_7)\n\n{\n  uint16_t uVar1;\n  char *pcVar2;\n  \n  uVar1 = ntohs(*(uint16_t *)(param_6 + 6));\n  pcVar2 = inet_ntoa((in_addr)((in_addr *)(param_4 + 4))->s_addr);\n  printf(\"%d bytes from %s: icmp_seq=%u\",(ulong)param_7,pcVar2,(ulong)uVar1);\n  if (param_1 != 0) {\n    printf(\" (DUP!)\");\n  }\n  putchar(10);\n  pcVar2 = inet_ntoa(SUB84(*(undefined8 *)(param_6 + 8),0));\n  printf(\"icmp_mask = %s\",pcVar2);\n  putchar(10);\n  return;\n}\n\n",
        "output": "The predicted function name is print_address"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](char *param_1,long param_2)\n\n{\n  void *pvVar1;\n  int iVar2;\n  int iVar3;\n  void **ppvVar4;\n  void *pvVar5;\n  int local_30;\n  void *local_28;\n  \n  iVar2 = atoi(param_1);\n  if (((0 < iVar2) && (param_2 != 0)) && (iVar3 = FUN_00006028(param_2), iVar3 != 0)) {\n    iVar3 = FUN_00006028(param_2);\n    ppvVar4 = (void **)FUN_00006042(param_2,iVar3 + -1);\n    pvVar1 = ppvVar4[1];\n    pvVar5 = CRYPTO_malloc((int)(void *)((long)iVar2 * (long)pvVar1),\"test/evp_test.c\",0xaf);\n    iVar3 = FUN_00018f92(\"test/evp_test.c\",0xaf,\"tbuf = OPENSSL_malloc(tbuflen)\",pvVar5);\n    if (iVar3 != 0) {\n      local_28 = pvVar5;\n      for (local_30 = 0; local_30 < iVar2; local_30 = local_30 + 1) {\n        memcpy(local_28,*ppvVar4,(size_t)ppvVar4[1]);\n        local_28 = (void *)((long)local_28 + (long)ppvVar4[1]);\n      }\n      CRYPTO_free(*ppvVar4);\n      *ppvVar4 = pvVar5;\n      ppvVar4[1] = (void *)((long)iVar2 * (long)pvVar1);\n      return 1;\n    }\n    return 0;\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is evp_test_buffer_ncopy"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](undefined8 param_1,undefined8 *param_2,undefined8 *param_3,int param_4)\n\n{\n  undefined8 uVar1;\n  undefined4 local_c;\n  \n  local_c = 1;\n  if (param_2 == (undefined8 *)0x0) {\n    *param_3 = &DAT_00204200;\n    local_c = 3;\n  }\n  else if (((param_4 == 0x1a7) || (param_4 == 0x1ab)) || (param_4 == 0x1a3)) {\n    uVar1 = FUN_00002b5d(param_4);\n    *param_2 = uVar1;\n  }\n  else {\n    *param_2 = 0;\n    local_c = 0;\n  }\n  return local_c;\n}\n\n",
        "output": "The predicted function name is afalg_ciphers"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](long param_1)\n\n{\n  char *pcVar1;\n  long lVar2;\n  \n  if (param_1 == 0) {\n    if (DAT_00253e90 != 0) {\n      (*wget_free)(DAT_00253e90);\n      DAT_00253e90 = 0;\n    }\n    lVar2 = 0;\n  }\n  else {\n    lVar2 = DAT_00253e90;\n    if (DAT_00253e90 == 0) {\n      pcVar1 = getenv(\"XDG_CONFIG_HOME\");\n      if ((pcVar1 == (char *)0x0) || (*pcVar1 == '\\0')) {\n        DAT_00253e90 = wget_aprintf(\"%s/.config/wget\",param_1);\n        lVar2 = DAT_00253e90;\n      }\n      else {\n        DAT_00253e90 = wget_aprintf(\"%s/wget\",pcVar1);\n        lVar2 = DAT_00253e90;\n      }\n    }\n  }\n  return lVar2;\n}\n\n",
        "output": "The predicted function name is get_xdg_config_home"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,char *param_2)\n\n{\n  char *pcVar1;\n  \n  CRYPTO_free(*(void **)(param_1 + 0x1c8));\n  pcVar1 = CRYPTO_strdup(param_2,\"test/helpers/ssl_test_ctx.c\",0x161);\n  *(char **)(param_1 + 0x1c8) = pcVar1;\n  FUN_000146a7(\"test/helpers/ssl_test_ctx.c\",0x161,\"ctx->expected_npn_protocol\",\n               *(undefined8 *)(param_1 + 0x1c8));\n  return;\n}\n\n",
        "output": "The predicted function name is parse_test_expected_npn_protocol"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,long param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  if ((param_2 == 0) || (iVar1 = wget_strcasecmp_ascii(param_2,&DAT_000434e8), iVar1 == 0)) {\n    **(undefined **)(param_1 + 0x18) = 0;\n  }\n  else {\n    iVar1 = wget_strcasecmp_ascii(param_2,&DAT_000434ec);\n    if ((iVar1 != 0) && (iVar1 = wget_strcasecmp_ascii(param_2,&DAT_000434f0), iVar1 != 0)) {\n      uVar2 = gettext(\"Unknown cert type \\'%s\\'\\n\");\n      wget_error_printf(uVar2,param_2);\n      return 0xffffffff;\n    }\n    **(undefined **)(param_1 + 0x18) = 1;\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is parse_cert_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0000b38a(param_1,param_2,0,PTR_EVP_PKEY_decrypt_init_00223fc0,PTR_EVP_PKEY_decrypt_00223ff0);\n  return;\n}\n\n",
        "output": "The predicted function name is decrypt_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  FUN_0000e611(DAT_00253c28,param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is plugin_db_list"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](undefined4 *param_1)\n\n{\n  int iVar1;\n  \n  *(undefined8 *)(param_1 + 2) = 0;\n  iVar1 = FUN_00001aed(1,param_1 + 2);\n  if (-1 < iVar1) {\n    memset(param_1 + 0xc,0,0x40);\n    *param_1 = 0xffffffff;\n    param_1[1] = 0;\n  }\n  else {\n    fprintf(*(FILE **)PTR_stderr_00203ff8,\"ALG_PERR: %s(%d): io_setup error : \",\"engines/e_afalg.c\",\n            0xfc);\n    perror((char *)0x0);\n    FUN_00001a71(0,0x69,\"engines/e_afalg.c\",0xfd);\n  }\n  return -1 < iVar1;\n}\n\n",
        "output": "The predicted function name is afalg_init_aio"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,short *param_2)\n\n{\n  void *__ptr;\n  char *__format;\n  short *local_38;\n  long local_30;\n  long local_20;\n  undefined *local_18;\n  \n  local_20 = 0;\n  local_18 = &DAT_000073d6;\n  local_38 = param_2;\n  local_30 = param_1;\n  while( true ) {\n    if (local_30 == 0) break;\n    if ((*(char *)(local_38 + 0x16) != '\\0') && (*local_38 == 7)) {\n      __ptr = (void *)FUN_00006c30(local_38);\n      printf(\"%s%s\",local_18,__ptr);\n      free(__ptr);\n      local_18 = &DAT_00007560;\n      local_20 = local_20 + 1;\n    }\n    local_38 = local_38 + 0xc0;\n    local_30 = local_30 + -1;\n  }\n  __format = (char *)gettext(\"\\n# users=%lu\\n\");\n  printf(__format,local_20);\n  return;\n}\n\n",
        "output": "The predicted function name is list_entries_who"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  undefined8 *puVar1;\n  long *local_18;\n  \n  puVar1 = *(undefined8 **)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  for (local_18 = puVar1 + 3; *local_18 != 0; local_18 = local_18 + 5) {\n    CRYPTO_free((void *)local_18[2]);\n  }\n  CRYPTO_free((void *)puVar1[1]);\n  EVP_KDF_CTX_free(*puVar1);\n  return;\n}\n\n",
        "output": "The predicted function name is kdf_test_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](long param_1,char *param_2,int param_3,size_t *param_4)\n\n{\n  size_t sVar1;\n  ulong uVar2;\n  char *pcVar3;\n  int local_1c;\n  \n  do {\n    do {\n      pcVar3 = fgets(param_2,param_3,*(FILE **)(param_1 + 8));\n      if (pcVar3 == (char *)0x0) {\n        return 0;\n      }\n      sVar1 = strlen(param_2);\n      uVar2 = FUN_0000164a(param_2);\n    } while (uVar2 == 0);\n    for (local_1c = 0; (param_2[local_1c] == '*' && ((ulong)(long)local_1c < uVar2));\n        local_1c = local_1c + 1) {\n    }\n  } while (local_1c == 0);\n  *param_4 = sVar1;\n  return local_1c;\n}\n\n",
        "output": "The predicted function name is find_header"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  int *piVar1;\n  int iVar2;\n  undefined8 uVar3;\n  uchar *out;\n  undefined8 uVar4;\n  EVP_MD *local_28;\n  \n  piVar1 = *(int **)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  local_28 = (EVP_MD *)0x0;\n  uVar3 = OSSL_LIB_CTX_set0_default(DAT_002241a8);\n  out = (uchar *)CRYPTO_malloc((int)*(undefined8 *)(piVar1 + 0x18),\"test/evp_test.c\",0x885);\n  iVar2 = FUN_00018f92(\"test/evp_test.c\",0x885,\"key = OPENSSL_malloc(expected->key_len)\");\n  if (iVar2 == 0) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"INTERNAL_ERROR\";\n    goto LAB_0000cd7e;\n  }\n  if (*piVar1 == 2) {\n    iVar2 = PKCS5_PBKDF2_HMAC(*(char **)(piVar1 + 0xe),(int)*(undefined8 *)(piVar1 + 0x10),\n                              *(uchar **)(piVar1 + 0x12),(int)*(undefined8 *)(piVar1 + 0x14),\n                              piVar1[0xb],*(EVP_MD **)(piVar1 + 0xc),\n                              (int)*(undefined8 *)(piVar1 + 0x18),out);\n    if (iVar2 == 0) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"PBKDF2_ERROR\";\n      goto LAB_0000cd7e;\n    }\n  }\n  else if (*piVar1 == 1) {\n    iVar2 = EVP_PBE_scrypt(*(undefined8 *)(piVar1 + 0xe),*(undefined8 *)(piVar1 + 0x10),\n                           *(undefined8 *)(piVar1 + 0x12),*(undefined8 *)(piVar1 + 0x14),\n                           *(undefined8 *)(piVar1 + 2),*(undefined8 *)(piVar1 + 4),\n                           *(undefined8 *)(piVar1 + 6),*(undefined8 *)(piVar1 + 8),out,\n                           *(undefined8 *)(piVar1 + 0x18));\n    if (iVar2 == 0) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"SCRYPT_ERROR\";\n      goto LAB_0000cd7e;\n    }\n  }\n  else if (*piVar1 == 3) {\n    uVar4 = EVP_MD_get0_name(*(undefined8 *)(piVar1 + 0xc));\n    local_28 = (EVP_MD *)EVP_MD_fetch(DAT_002241a8,uVar4,0);\n    if (local_28 == (EVP_MD *)0x0) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"PKCS12_ERROR\";\n      goto LAB_0000cd7e;\n    }\n    iVar2 = PKCS12_key_gen_uni(*(uchar **)(piVar1 + 0xe),(int)*(undefined8 *)(piVar1 + 0x10),\n                               *(uchar **)(piVar1 + 0x12),(int)*(undefined8 *)(piVar1 + 0x14),\n                               piVar1[10],piVar1[0xb],(int)*(undefined8 *)(piVar1 + 0x18),out,\n                               local_28);\n    if (iVar2 == 0) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"PKCS12_ERROR\";\n      goto LAB_0000cd7e;\n    }\n  }\n  iVar2 = FUN_000060ba(param_1,\"KEY_MISMATCH\",*(undefined8 *)(piVar1 + 0x16),\n                       *(undefined8 *)(piVar1 + 0x18),out,*(undefined8 *)(piVar1 + 0x18));\n  if (iVar2 != 0) {\n    *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n  }\nLAB_0000cd7e:\n  EVP_MD_free(local_28);\n  CRYPTO_free(out);\n  OSSL_LIB_CTX_set0_default(uVar3);\n  return 1;\n}\n\n",
        "output": "The predicted function name is pbe_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nuint [MASK](int param_1,char *param_2)\n\n{\n  int __fd;\n  uint uVar1;\n  DIR *__dirp;\n  int *piVar2;\n  long lVar3;\n  uint *puVar4;\n  \n  __fd = openat(param_1,param_2,0x30900);\n  if (__fd < 0) {\n    uVar1 = 0;\n  }\n  else {\n    __dirp = fdopendir(__fd);\n    if (__dirp == (DIR *)0x0) {\n      close(__fd);\n      uVar1 = 0;\n    }\n    else {\n      piVar2 = __errno_location();\n      *piVar2 = 0;\n      lVar3 = FUN_000046ad(__dirp);\n      puVar4 = (uint *)__errno_location();\n      uVar1 = *puVar4;\n      closedir(__dirp);\n      puVar4 = (uint *)__errno_location();\n      *puVar4 = uVar1;\n      if (lVar3 == 0) {\n        uVar1 = uVar1 & 0xffffff00 | (uint)(uVar1 == 0);\n      }\n      else {\n        uVar1 = 0;\n      }\n    }\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is is_empty_dir"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined8 uVar2;\n  int local_2c;\n  long local_28;\n  int *local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = *(int **)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  uVar2 = 0x100bc;\n  iVar1 = strcmp(param_2,\"Key\");\n  if (iVar1 == 0) {\n    local_28 = 0;\n    local_2c = 0;\n    if (*(long *)(local_20 + 2) == 0) {\n      local_18 = 0;\n    }\n    else {\n      uVar2 = 0x100f0;\n      local_18 = EVP_MD_get0_name(*(undefined8 *)(local_20 + 2));\n    }\n    if (*local_20 != 0) {\n      uVar2 = 0x1011f;\n      local_2c = FUN_00010ea5(&local_28,param_3,DAT_002241b8);\n    }\n    if (local_2c == 0) {\n      uVar2 = 0x10142;\n      local_2c = FUN_00010ea5(&local_28,param_3,DAT_002241b0);\n    }\n    if ((local_2c == 0) || (local_28 == 0)) {\n      *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n      uVar2 = 1;\n    }\n    else if (*local_20 == 0) {\n      iVar1 = EVP_DigestSignInit_ex\n                        (*(undefined8 *)(local_20 + 4),local_20 + 6,local_18,DAT_002241a8,0,local_28\n                         ,0,uVar2);\n      if (iVar1 == 0) {\n        *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DIGESTSIGNINIT_ERROR\";\n      }\n      uVar2 = 1;\n    }\n    else {\n      iVar1 = EVP_DigestVerifyInit_ex\n                        (*(undefined8 *)(local_20 + 4),local_20 + 6,local_18,DAT_002241a8,0,local_28\n                         ,0);\n      if (iVar1 == 0) {\n        *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DIGESTVERIFYINIT_ERROR\";\n      }\n      uVar2 = 1;\n    }\n  }\n  else {\n    iVar1 = strcmp(param_2,\"Input\");\n    if (iVar1 == 0) {\n      if (local_20[1] == 0) {\n        uVar2 = FUN_000061e9(param_3,local_20 + 8);\n      }\n      else {\n        uVar2 = FUN_000066e2(param_3,local_20 + 10,local_20 + 0xc);\n      }\n    }\n    else {\n      iVar1 = strcmp(param_2,\"Output\");\n      if (iVar1 == 0) {\n        uVar2 = FUN_000066e2(param_3,local_20 + 0xe,local_20 + 0x10);\n      }\n      else {\n        if (local_20[1] == 0) {\n          iVar1 = strcmp(param_2,\"Count\");\n          if (iVar1 == 0) {\n            uVar2 = FUN_00006443(param_3,*(undefined8 *)(local_20 + 8));\n            goto LAB_0001037f;\n          }\n          iVar1 = strcmp(param_2,\"Ncopy\");\n          if (iVar1 == 0) {\n            uVar2 = FUN_000062f7(param_3,*(undefined8 *)(local_20 + 8));\n            goto LAB_0001037f;\n          }\n        }\n        iVar1 = strcmp(param_2,\"Ctrl\");\n        if (iVar1 == 0) {\n          if (*(long *)(local_20 + 6) == 0) {\n            uVar2 = 0xffffffff;\n          }\n          else {\n            uVar2 = FUN_0000b5de(param_1,*(undefined8 *)(local_20 + 6),param_3);\n          }\n        }\n        else {\n          uVar2 = 0;\n        }\n      }\n    }\n  }\nLAB_0001037f:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is digestsigver_test_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_000036d5(0x31,2,0);\n  return;\n}\n\n",
        "output": "The predicted function name is test_http_keep_alive_1_require_no"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8\n[MASK](undefined8 param_1,undefined4 param_2,undefined8 param_3,undefined4 param_4,\n            undefined8 param_5,undefined4 param_6,uchar *param_7,int param_8)\n\n{\n  undefined8 uVar1;\n  long in_FS_OFFSET;\n  size_t local_20;\n  EVP_PKEY_CTX *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = EVP_PKEY_CTX_new_id(0x3fd,(ENGINE *)0x0);\n  local_20 = (size_t)param_8;\n  EVP_PKEY_derive_init(local_18);\n  uVar1 = EVP_md5_sha1();\n  EVP_PKEY_CTX_set_tls1_prf_md(local_18,uVar1);\n  EVP_PKEY_CTX_set1_tls1_prf_secret(local_18,&DAT_00213500,0x30);\n  EVP_PKEY_CTX_add1_tls1_prf_seed(local_18,param_1,param_2);\n  EVP_PKEY_CTX_add1_tls1_prf_seed(local_18,param_3,param_4);\n  EVP_PKEY_CTX_add1_tls1_prf_seed(local_18,param_5,param_6);\n  EVP_PKEY_derive(local_18,param_7,&local_20);\n  EVP_PKEY_CTX_free(local_18);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is do_PRF"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_14;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_00009ddc(&PTR_s_KeyUpdateRequested_0021f180,2,&local_14,param_2);\n  if (iVar1 != 0) {\n    *(undefined4 *)(param_1 + 0x10) = local_14;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1 != 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is parse_key_update_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong [MASK](long param_1,undefined4 param_2)\n\n{\n  int iVar1;\n  ulong uVar2;\n  long in_FS_OFFSET;\n  undefined local_98 [136];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = wget_hash_file_fd(param_1,param_2,local_98,0x81,0,0);\n  if (iVar1 == -1) {\n    uVar2 = 0xffffffff;\n  }\n  else {\n    iVar1 = wget_strcasecmp_ascii(local_98,param_1 + 0x10);\n    uVar2 = (ulong)(iVar1 == 0);\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is check_file_fd"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](size_t param_1)\n\n{\n  malloc(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyalloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 *param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  int *piVar4;\n  long in_FS_OFFSET;\n  undefined local_b8 [48];\n  long local_88;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_0000b4eb(param_1,param_1 + 2,0x30);\n  if (iVar1 == 0) {\n    iVar1 = memcmp(param_1 + 2,\"GCIDEIDX\",8);\n    if (iVar1 == 0) {\n      iVar1 = FUN_0000f700(*(undefined4 *)(param_1 + 1),local_b8);\n      if (iVar1 == 0) {\n        if (param_1[3] * (param_1[5] + 1) == local_88) {\n          uVar2 = 0;\n        }\n        else {\n          uVar2 = *param_1;\n          uVar3 = gettext(\"index file `%s\\' is corrupted\");\n          dico_log(4,0,uVar3,uVar2);\n          uVar2 = 1;\n        }\n      }\n      else {\n        uVar2 = *param_1;\n        piVar4 = __errno_location();\n        dico_log(4,*piVar4,\"fstat `%s\\'\",uVar2);\n        uVar2 = 1;\n      }\n    }\n    else {\n      uVar2 = *param_1;\n      uVar3 = gettext(\"file `%s\\' is not a valid gcide index file\");\n      dico_log(4,0,uVar3,uVar2);\n      uVar2 = 1;\n    }\n  }\n  else {\n    uVar2 = 1;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is _open_index"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  FUN_00009ddc(&PTR_s_TLSv1_3_0021ef00,7,param_1 + 0x1b4,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is parse_protocol"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *param_1)\n\n{\n  int iVar1;\n  char *pcVar2;\n  size_t __n;\n  long in_FS_OFFSET;\n  char *local_40;\n  int local_2c;\n  uint local_28;\n  uint local_24;\n  char *local_20;\n  ulong local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  for (local_40 = param_1; ((*local_40 != '\\0' && (local_40[1] != '\\0')) && (local_40[1] == ' '));\n      local_40 = local_40 + 2) {\n  }\n  if (*local_40 == '\\0') {\n    pcVar2 = \"whois.ripe.net\";\n  }\n  else {\n    pcVar2 = strchr(local_40,0x40);\n    if (pcVar2 == (char *)0x0) {\n      pcVar2 = strpbrk(local_40,\".-:\");\n      if (pcVar2 == (char *)0x0) {\n        for (local_20 = local_40; *local_20 != '\\0'; local_20 = local_20 + 1) {\n        }\n        iVar1 = strncasecmp(local_40,\"as\",2);\n        if ((iVar1 == 0) && ((('/' < local_40[2] && (local_40[2] < ':')) || (local_40[2] == ' '))))\n        {\n          iVar1 = atoi(local_40 + 2);\n          pcVar2 = (char *)FUN_0000bfda(iVar1,&DAT_0021f880);\n        }\n        else {\n          iVar1 = strncasecmp(local_20 + -2,\"jp\",2);\n          if (iVar1 == 0) {\n            pcVar2 = \"whois.nic.ad.jp\";\n          }\n          else if (*local_20 == '!') {\n            pcVar2 = \"whois.networksolutions.com\";\n          }\n          else {\n            pcVar2 = \"\";\n          }\n        }\n      }\n      else {\n        pcVar2 = strchr(local_40,0x3a);\n        if (pcVar2 == (char *)0x0) {\n          local_18 = FUN_0000cd65(local_40);\n          if (local_18 == 0) {\n            for (local_24 = 0; (&PTR_s__br_com_0021fa40)[local_24] != (undefined *)0x0;\n                local_24 = local_24 + 2) {\n              iVar1 = FUN_0000cc4d(local_40,(&PTR_s__br_com_0021fa40)[local_24]);\n              if (iVar1 != 0) {\n                pcVar2 = (&PTR_s__br_com_0021fa40)[local_24 + 1];\n                goto LAB_0000bfc4;\n              }\n            }\n            pcVar2 = strchr(local_40,0x2e);\n            if (pcVar2 == (char *)0x0) {\n              for (local_24 = 0; (&PTR_DAT_0021a1e0)[local_24] != (undefined *)0x0;\n                  local_24 = local_24 + 2) {\n                __n = strlen((&PTR_DAT_0021a1e0)[local_24]);\n                iVar1 = strncasecmp(local_40,(&PTR_DAT_0021a1e0)[local_24],__n);\n                if (iVar1 == 0) {\n                  pcVar2 = (&PTR_DAT_0021a1e0)[local_24 + 1];\n                  goto LAB_0000bfc4;\n                }\n              }\n              if (DAT_00220fb0 != 0) {\n                puts(\"I guess it\\'s a netblock name but I don\\'t know where to look it up.\");\n              }\n              pcVar2 = \"whois.arin.net\";\n            }\n            else {\n              if (DAT_00220fb0 != 0) {\n                puts(\"I guess it\\'s a domain but I don\\'t know where to look it up.\");\n              }\n              pcVar2 = \"\";\n            }\n          }\n          else {\n            local_24 = 0;\n            while ((&PTR_s_whois_apnic_net_0021a290)[(ulong)local_24 * 3] != (undefined *)0x0) {\n              if ((*(ulong *)(&DAT_0021a288 + (ulong)local_24 * 0x18) & local_18) ==\n                  *(ulong *)(&DAT_0021a280 + (ulong)local_24 * 0x18)) {\n                pcVar2 = (&PTR_s_whois_apnic_net_0021a290)[(ulong)local_24 * 3];\n                goto LAB_0000bfc4;\n              }\n              local_24 = local_24 + 1;\n            }\n            if (DAT_00220fb0 != 0) {\n              puts(\n                  \"I don\\'t know where this IP has been delegated.\\nI\\'ll try ARIN and hope for the best...\"\n                  );\n            }\n            pcVar2 = \"whois.arin.net\";\n          }\n        }\n        else {\n          local_2c = 0;\n          local_28 = 0;\n          iVar1 = sscanf(local_40,\"%x:%x:\",&local_2c,&local_28);\n          if (iVar1 == 0) {\n            pcVar2 = \"\";\n          }\n          else {\n            local_18 = (ulong)(int)(local_28 & 0xffff | local_2c << 0x10);\n            local_24 = 0;\n            while ((&PTR_s_whois_apnic_net_0021f650)[(ulong)local_24 * 3] != (undefined *)0x0) {\n              if ((*(ulong *)(&DAT_0021f648 + (ulong)local_24 * 0x18) & local_18) ==\n                  *(ulong *)(&DAT_0021f640 + (ulong)local_24 * 0x18)) {\n                pcVar2 = (&PTR_s_whois_apnic_net_0021f650)[(ulong)local_24 * 3];\n                goto LAB_0000bfc4;\n              }\n              local_24 = local_24 + 1;\n            }\n            if (DAT_00220fb0 != 0) {\n              puts(\n                  \"Delegation server of this address is not known.\\nThe fallback is ARIN, hoping for success.\"\n                  );\n            }\n            pcVar2 = \"whois.arin.net\";\n          }\n        }\n      }\n    }\n    else {\n      pcVar2 = \"\";\n    }\n  }\nLAB_0000bfc4:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return pcVar2;\n}\n\n",
        "output": "The predicted function name is whichwhois"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Type propagation algorithm not settling */\n\nint [MASK](int *param_1,char *param_2,long param_3,ushort *param_4,char **param_5,\n                char **param_6,int param_7)\n\n{\n  undefined *__dest;\n  long lVar1;\n  char **__envp;\n  char **__argv;\n  undefined8 *puVar2;\n  int iVar3;\n  __uid_t __uid;\n  __gid_t __gid;\n  uint uVar4;\n  int *piVar5;\n  char *pcVar6;\n  size_t sVar7;\n  ulong uVar8;\n  size_t sVar9;\n  void *pvVar10;\n  sched_param *__param;\n  char ***pppcVar11;\n  long in_FS_OFFSET;\n  char **appcStack304 [2];\n  char acStack287 [7];\n  char **ppcStack288;\n  ushort *local_118;\n  long local_110;\n  char *local_108;\n  int *local_100;\n  ushort local_f2;\n  __pid_t local_f0;\n  int local_ec;\n  int local_e8;\n  uint local_e4;\n  undefined8 *local_e0;\n  undefined8 *local_d8;\n  char *local_d0;\n  uint *local_c8;\n  size_t local_c0;\n  size_t local_b8;\n  undefined *local_b0;\n  undefined8 uStack168;\n  ulong uStack16;\n  \n  pppcVar11 = appcStack304 + 1;\n  uStack16 = *(ulong *)(in_FS_OFFSET + 0x28);\n  if (param_4 == (ushort *)0x0) {\n    local_f2 = 0;\n  }\n  else {\n    local_f2 = *param_4;\n  }\n  appcStack304[1] = param_6;\n  ppcStack288 = param_5;\n  local_118 = param_4;\n  local_110 = param_3;\n  local_108 = param_2;\n  local_100 = param_1;\n  if (((local_f2 & 0x40) == 0) && (((local_f2 & 0x3f) != 0 || (param_3 != 0)))) {\n    appcStack304[0] = (char **)0x40038;\n    local_f0 = fork();\n  }\n  else {\n    appcStack304[0] = (char **)0x4002b;\n    local_f0 = vfork();\n  }\n  if (local_f0 != 0) {\n    if (local_f0 < 0) {\n      appcStack304[0] = (char **)0x40055;\n      piVar5 = __errno_location();\n      iVar3 = *piVar5;\n    }\n    else {\n      if (local_100 != (int *)0x0) {\n        *local_100 = local_f0;\n      }\n      iVar3 = 0;\n    }\n    if (uStack16 != *(ulong *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n      appcStack304[0] = (char **)0x40736;\n      __stack_chk_fail();\n    }\n    return iVar3;\n  }\n  if ((local_f2 & 8) != 0) {\n    appcStack304[0] = (char **)0x400ad;\n    iVar3 = sigprocmask(2,(sigset_t *)(local_118 + 0x44),(sigset_t *)0x0);\n    if (iVar3 != 0) {\n                    /* WARNING: Subroutine does not return */\n      appcStack304[0] = (char **)0x400bb;\n      _exit(0x7f);\n    }\n  }\n  if ((local_f2 & 4) != 0) {\n    appcStack304[0] = (char **)0x400e7;\n    memset(&stack0xffffffffffffff58,0,0x98);\n    uStack168 = 0;\n    for (local_ec = 1; local_ec < 0x42; local_ec = local_ec + 1) {\n      appcStack304[0] = (char **)0x40119;\n      iVar3 = sigismember((sigset_t *)(local_118 + 4),local_ec);\n      if (iVar3 != 0) {\n        appcStack304[0] = (char **)0x40139;\n        iVar3 = sigaction(local_ec,(sigaction *)&stack0xffffffffffffff58,(sigaction *)0x0);\n        if (iVar3 != 0) {\n                    /* WARNING: Subroutine does not return */\n          appcStack304[0] = (char **)0x40147;\n          _exit(0x7f);\n        }\n      }\n    }\n  }\n  if ((local_f2 & 0x30) == 0x10) {\n    appcStack304[0] = (char **)0x40181;\n    iVar3 = sched_setparam(0,(sched_param *)(local_118 + 0x84));\n    if (iVar3 == -1) {\n                    /* WARNING: Subroutine does not return */\n      appcStack304[0] = (char **)0x40190;\n      _exit(0x7f);\n    }\n  }\n  else if ((local_f2 & 0x20) != 0) {\n    if ((local_f2 & 0x10) == 0) {\n      __param = (sched_param *)0x0;\n    }\n    else {\n      __param = (sched_param *)(local_118 + 0x84);\n    }\n    appcStack304[0] = (char **)0x401dc;\n    iVar3 = sched_setscheduler(0,*(int *)(local_118 + 0x86),__param);\n    if (iVar3 == -1) {\n                    /* WARNING: Subroutine does not return */\n      appcStack304[0] = (char **)0x401eb;\n      _exit(0x7f);\n    }\n  }\n  if ((local_f2 & 2) != 0) {\n    appcStack304[0] = (char **)0x40210;\n    iVar3 = setpgid(0,*(__pid_t *)(local_118 + 2));\n    if (iVar3 != 0) {\n                    /* WARNING: Subroutine does not return */\n      appcStack304[0] = (char **)0x4021e;\n      _exit(0x7f);\n    }\n  }\n  if ((local_f2 & 1) != 0) {\n    appcStack304[0] = (char **)0x40232;\n    __uid = getuid();\n    appcStack304[0] = (char **)0x40239;\n    iVar3 = seteuid(__uid);\n    if (iVar3 == 0) {\n      appcStack304[0] = (char **)0x40242;\n      __gid = getgid();\n      appcStack304[0] = (char **)0x40249;\n      iVar3 = setegid(__gid);\n      if (iVar3 == 0) goto LAB_00040257;\n    }\n                    /* WARNING: Subroutine does not return */\n    appcStack304[0] = (char **)0x40257;\n    _exit(0x7f);\n  }\nLAB_00040257:\n  if (local_110 != 0) {\n    for (local_e8 = 0; local_e8 < *(int *)(local_110 + 4); local_e8 = local_e8 + 1) {\n      local_c8 = (uint *)(*(long *)(local_110 + 8) + (long)local_e8 * 0x20);\n      switch(*local_c8) {\n      case 0:\n        appcStack304[0] = (char **)0x402dc;\n        iVar3 = close(local_c8[2]);\n        if (iVar3 != 0) {\n                    /* WARNING: Subroutine does not return */\n          appcStack304[0] = (char **)0x402ee;\n          _exit(0x7f);\n        }\n        break;\n      case 1:\n        appcStack304[0] = (char **)0x403ba;\n        uVar4 = dup2(local_c8[2],local_c8[3]);\n        if (uVar4 != local_c8[3]) {\n                    /* WARNING: Subroutine does not return */\n          appcStack304[0] = (char **)0x403d4;\n          _exit(0x7f);\n        }\n        break;\n      case 2:\n        appcStack304[0] = (char **)0x4031c;\n        local_e4 = open(*(char **)(local_c8 + 4),local_c8[6],(ulong)local_c8[7]);\n        if (local_e4 == 0xffffffff) {\n                    /* WARNING: Subroutine does not return */\n          appcStack304[0] = (char **)0x40335;\n          _exit(0x7f);\n        }\n        if (local_e4 != local_c8[2]) {\n          appcStack304[0] = (char **)0x40364;\n          uVar4 = dup2(local_e4,local_c8[2]);\n          if (uVar4 != local_c8[2]) {\n                    /* WARNING: Subroutine does not return */\n            appcStack304[0] = (char **)0x4037e;\n            _exit(0x7f);\n          }\n          appcStack304[0] = (char **)0x4038b;\n          iVar3 = close(local_e4);\n          if (iVar3 != 0) {\n                    /* WARNING: Subroutine does not return */\n            appcStack304[0] = (char **)0x4039d;\n            _exit(0x7f);\n          }\n        }\n        break;\n      case 3:\n        appcStack304[0] = (char **)0x403e7;\n        iVar3 = chdir(*(char **)(local_c8 + 2));\n        if (iVar3 < 0) {\n                    /* WARNING: Subroutine does not return */\n          appcStack304[0] = (char **)0x403f5;\n          _exit(0x7f);\n        }\n        break;\n      case 4:\n        appcStack304[0] = (char **)0x40406;\n        iVar3 = fchdir(local_c8[2]);\n        if (iVar3 < 0) {\n                    /* WARNING: Subroutine does not return */\n          appcStack304[0] = (char **)0x40414;\n          _exit(0x7f);\n        }\n      }\n    }\n  }\n  if (param_7 != 0) {\n    appcStack304[0] = (char **)0x40458;\n    pcVar6 = strchr(local_108,0x2f);\n    if (pcVar6 == (char *)0x0) {\n      appcStack304[0] = (char **)0x40493;\n      local_e0 = (undefined8 *)getenv(\"PATH\");\n      if (local_e0 == (undefined8 *)0x0) {\n        appcStack304[0] = (char **)0x404bc;\n        sVar7 = confstr(0,(char *)0x0,0);\n        local_c0 = sVar7;\n        uVar8 = (sVar7 + 0x1f) / 0x10;\n        pppcVar11 = appcStack304 + uVar8 * -2 + 1;\n        local_e0 = (undefined8 *)((long)&stack0xfffffffffffffee0 + uVar8 * -2 * 8);\n        *(char *)(undefined8 *)((long)&stack0xfffffffffffffee0 + uVar8 * -2 * 8) = ':';\n        appcStack304[uVar8 * -2] = (char **)0x40534;\n        confstr(0,(char *)((long)&stack0xfffffffffffffee0 + uVar8 * -0x10 + 1),sVar7);\n      }\n      pcVar6 = local_108;\n      *(undefined8 *)((long)pppcVar11 + -8) = 0x40543;\n      sVar7 = strlen(pcVar6);\n      puVar2 = local_e0;\n      local_c0 = sVar7 + 1;\n      *(undefined8 *)((long)pppcVar11 + -8) = 0x4055d;\n      sVar9 = strlen((char *)puVar2);\n      sVar7 = local_c0;\n      pcVar6 = local_108;\n      local_b8 = sVar9;\n      lVar1 = ((local_c0 + sVar9 + 0x1f) / 0x10) * -0x10;\n      local_b0 = (undefined *)((ulong)((long)pppcVar11 + lVar1 + 0xf) & 0xfffffffffffffff0);\n      *(undefined8 *)((long)pppcVar11 + lVar1 + -8) = 0x405e2;\n      pvVar10 = memcpy((void *)(sVar9 + 1 +\n                               ((ulong)((long)pppcVar11 + lVar1 + 0xf) & 0xfffffffffffffff0)),pcVar6\n                       ,sVar7);\n      local_b0 = (undefined *)((long)pvVar10 + -1);\n      *(undefined *)((long)pvVar10 + -1) = 0x2f;\n      local_d8 = local_e0;\n      do {\n        puVar2 = local_d8;\n        local_e0 = local_d8;\n        *(undefined8 *)((long)pppcVar11 + lVar1 + -8) = 0x4062b;\n        local_d8 = (undefined8 *)strchrnul((char *)puVar2,0x3a);\n        puVar2 = local_e0;\n        if (local_d8 == local_e0) {\n          local_d0 = local_b0 + 1;\n        }\n        else {\n          sVar7 = (long)local_d8 - (long)local_e0;\n          __dest = local_b0 + -((long)local_d8 - (long)local_e0);\n          *(undefined8 *)((long)pppcVar11 + lVar1 + -8) = 0x406a7;\n          local_d0 = (char *)memcpy(__dest,puVar2,sVar7);\n        }\n        pcVar6 = local_d0;\n        __argv = ppcStack288;\n        __envp = appcStack304[1];\n        *(undefined8 *)((long)pppcVar11 + lVar1 + -8) = 0x406ce;\n        execve(pcVar6,__argv,__envp);\n        *(undefined8 *)((long)pppcVar11 + lVar1 + -8) = 0x406d3;\n        piVar5 = __errno_location();\n        puVar2 = local_d8;\n        iVar3 = *piVar5;\n        if (iVar3 != 0xd) {\n          if (iVar3 < 0xe) {\n            if (iVar3 != 2) {\nLAB_000406f0:\n                    /* WARNING: Subroutine does not return */\n              *(undefined8 *)((long)pppcVar11 + lVar1 + -8) = 0x406fa;\n              _exit(0x7f);\n            }\n          }\n          else if ((iVar3 != 0x14) && (iVar3 != 0x74)) goto LAB_000406f0;\n        }\n        local_d8 = (undefined8 *)((long)local_d8 + 1);\n        if (*(char *)puVar2 == '\\0') {\n                    /* WARNING: Subroutine does not return */\n          *(undefined8 *)((long)pppcVar11 + lVar1 + -8) = 0x40722;\n          _exit(0x7f);\n        }\n      } while( true );\n    }\n  }\n  appcStack304[0] = (char **)0x4047d;\n  execve(local_108,ppcStack288,appcStack304[1]);\n                    /* WARNING: Subroutine does not return */\n  appcStack304[0] = (char **)0x40487;\n  _exit(0x7f);\n}\n\n",
        "output": "The predicted function name is gl_posix_spawn_internal"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00003658(param_1,0x30,param_2,0);\n  return;\n}\n\n",
        "output": "The predicted function name is set_email1"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0000b38a(param_1,param_2,0,PTR_EVP_PKEY_sign_init_00223fc8,PTR_EVP_PKEY_sign_00223fd0);\n  return;\n}\n\n",
        "output": "The predicted function name is sign_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *param_1,long param_2)\n\n{\n  char *pcVar1;\n  char *local_30;\n  long local_28;\n  char *local_20;\n  \n  local_28 = 0;\n  for (local_30 = param_1; local_30 < param_1 + param_2; local_30 = local_30 + 1) {\n    if (*local_30 == '\\\\') {\n      if (local_30 < param_1 + param_2 + -1) {\n        local_28 = local_28 + 1;\n        local_30 = local_30 + 1;\n      }\n    }\n    else {\n      local_28 = local_28 + 1;\n    }\n  }\n  pcVar1 = (char *)FUN_0001f967(local_28 + 1);\n  local_20 = pcVar1;\n  for (local_30 = param_1; local_30 < param_1 + param_2; local_30 = local_30 + 1) {\n    if (*local_30 == '\\\\') {\n      if (local_30 < param_1 + param_2 + -1) {\n        local_30 = local_30 + 1;\n        *local_20 = *local_30;\n        local_20 = local_20 + 1;\n      }\n    }\n    else {\n      *local_20 = *local_30;\n      local_20 = local_20 + 1;\n    }\n  }\n  *local_20 = '\\0';\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is strmemdup_esc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](undefined8 param_1,int param_2)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long in_FS_OFFSET;\n  undefined8 local_b8;\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  int local_84;\n  undefined8 local_80;\n  undefined4 local_74;\n  undefined8 local_70;\n  undefined local_68 [40];\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined local_12 [2];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_74 = 0;\n  local_70 = 0;\n  local_84 = param_2;\n  local_80 = param_1;\n  local_70 = FUN_00002d68(&DAT_00013d1b);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x175,\"kctx = get_kdfbyname(OSSL_KDF_NAME_HKDF)\",\n                       local_70);\n  if (iVar1 != 0) {\n    if (local_84 == 4) {\n      OSSL_PARAM_construct_utf8_string(&local_b8,local_80,&DAT_00013eac,0);\n    }\n    else {\n      OSSL_PARAM_construct_octet_string(&local_b8,local_80,local_12,2);\n    }\n    OSSL_PARAM_construct_end(&local_b8);\n    local_40 = local_b8;\n    local_38 = local_b0;\n    local_30 = local_a8;\n    local_28 = local_a0;\n    local_20 = local_98;\n    uVar2 = EVP_KDF_CTX_set_params(local_70,local_68);\n    iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x17d,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                         &DAT_00013c2d,uVar2,0);\n    if (iVar1 != 0) {\n      local_74 = 1;\n    }\n  }\n  EVP_KDF_CTX_free(local_70);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_74;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is do_kdf_hkdf_set_invalid_param"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  FUN_0000b01a(param_1 + 0x1fc,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is parse_expected_client_sign_hash"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  undefined8 uVar1;\n  int iVar2;\n  long lVar3;\n  char *__format;\n  int local_30;\n  \n  iVar2 = wget_vector_size(DAT_00253c30);\n  for (local_30 = 0; local_30 < iVar2; local_30 = local_30 + 1) {\n    lVar3 = wget_vector_get(DAT_00253c30,local_30);\n    if (*(long *)(lVar3 + 0x28) != 0) {\n      uVar1 = *(undefined8 *)(lVar3 + 0x10);\n      __format = (char *)gettext(\"Options for %s:\\n\");\n      printf(__format,uVar1);\n      (**(code **)(lVar3 + 0x28))(lVar3,&DAT_000416c3,0);\n      putchar(10);\n    }\n  }\n  DAT_00253c40 = 1;\n  return;\n}\n\n",
        "output": "The predicted function name is plugin_db_show_help"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](long param_1)\n\n{\n  char *pcVar1;\n  long lVar2;\n  \n  if (param_1 == 0) {\n    if (DAT_00253e88 != 0) {\n      (*wget_free)(DAT_00253e88);\n      DAT_00253e88 = 0;\n    }\n    lVar2 = 0;\n  }\n  else {\n    lVar2 = DAT_00253e88;\n    if (DAT_00253e88 == 0) {\n      pcVar1 = getenv(\"XDG_DATA_HOME\");\n      if ((pcVar1 == (char *)0x0) || (*pcVar1 == '\\0')) {\n        DAT_00253e88 = wget_aprintf(\"%s/.local/share/wget\",param_1);\n      }\n      else {\n        DAT_00253e88 = wget_aprintf(\"%s/wget\",pcVar1);\n      }\n      FUN_000279b2(DAT_00253e88,0);\n      lVar2 = DAT_00253e88;\n    }\n  }\n  return lVar2;\n}\n\n",
        "output": "The predicted function name is get_xdg_data_home"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 8);\n}\n\n",
        "output": "The predicted function name is impl_file_get_source_url"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  dico_iterator_destroy(param_1 + 0x18);\n  dico_list_destroy(param_1 + 0x20);\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_free_result"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](longlong *param_1,char **param_2)\n\n{\n  int iVar1;\n  longlong lVar2;\n  \n  iVar1 = strcmp(*param_2,\"Range\");\n  if (iVar1 == 0) {\n    lVar2 = atoll(param_2[1] + 6);\n    *param_1 = lVar2;\n  }\n  return iVar1 == 0;\n}\n\n",
        "output": "The predicted function name is get_requested_range"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](int *param_1,int param_2,int param_3)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined4 *puVar3;\n  \n  iVar1 = getdtablesize();\n  if ((((param_2 < 0) || (param_3 < 0)) || (iVar1 <= param_2)) || (iVar1 <= param_3)) {\n    uVar2 = 9;\n  }\n  else {\n    if ((param_1[1] == *param_1) && (iVar1 = FUN_00028a6d(param_1), iVar1 != 0)) {\n      return 0xc;\n    }\n    puVar3 = (undefined4 *)((long)param_1[1] * 0x20 + *(long *)(param_1 + 2));\n    *puVar3 = 1;\n    puVar3[2] = param_2;\n    puVar3[3] = param_3;\n    param_1[1] = param_1[1] + 1;\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is rpl_posix_spawn_file_actions_adddup2"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](size_t param_1,size_t param_2)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = calloc(param_1,param_2);\n  if (pvVar1 == (void *)0x0) {\n    pvVar1 = (void *)FUN_0002785b();\n  }\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is my_calloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  EVP_MD_meth_free(DAT_00205340);\n  DAT_00205340 = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is destroy_digests"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined * [MASK](void)\n\n{\n  return &DAT_0000e340;\n}\n\n",
        "output": "The predicted function name is fake_rsa_st_settable_ctx_params"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  long in_FS_OFFSET;\n  undefined8 local_38;\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = 0;\n  ptr = (void *)FUN_00002d87(\"sha256\",\"secret\",&DAT_00013be2);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x6d,\"params\",ptr);\n  if (iVar1 != 0) {\n    local_38 = FUN_00002d68(\"TLS1-PRF\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x6e,\"kctx = get_kdfbyname(OSSL_KDF_NAME_TLS1_PRF)\",\n                         local_38);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_38,ptr);\n      iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0x6f,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        uVar2 = EVP_KDF_derive(local_38,local_28,0,0);\n        iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x70,\"EVP_KDF_derive(kctx, out, 0, NULL)\",\n                             &DAT_00013c2d,uVar2,0);\n        if (iVar1 != 0) {\n          uVar2 = 1;\n          goto LAB_000032bd;\n        }\n      }\n    }\n  }\n  uVar2 = 0;\nLAB_000032bd:\n  EVP_KDF_CTX_free(local_38);\n  CRYPTO_free(ptr);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_tls1_prf_zero_output_size"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8\n[MASK](undefined8 param_1,undefined8 *param_2,undefined4 *param_3,undefined8 *param_4)\n\n{\n  *param_2 = *param_4;\n  *param_3 = (int)param_4[1];\n  return 0;\n}\n\n",
        "output": "The predicted function name is server_npn_cb"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,ulong param_2,char param_3)\n\n{\n  byte bVar1;\n  long lVar2;\n  long lVar3;\n  uint local_24;\n  uint local_20;\n  \n  bVar1 = *(byte *)(param_1 + 0xfa);\n  local_20 = (uint)bVar1;\n  lVar2 = param_1 + 0x10;\n  lVar3 = param_1 + 0xe0;\n  local_24 = local_20;\n  do {\n    local_24 = local_24 - 1;\n    if ((int)local_24 < 0) break;\n  } while (param_2 < *(ulong *)(lVar2 + (long)(int)local_24 * 8));\n  if (((int)local_24 < 0) || (param_2 != *(ulong *)(lVar2 + (long)(int)local_24 * 8))) {\n    while (local_20 = local_20 - 1, (int)local_24 < (int)local_20) {\n      *(undefined8 *)(lVar2 + ((long)(int)local_20 + 1) * 8) =\n           *(undefined8 *)(lVar2 + (long)(int)local_20 * 8);\n      *(undefined *)(lVar3 + (long)(int)local_20 + 1) = *(undefined *)(lVar3 + (int)local_20);\n    }\n    *(ulong *)(((long)(int)local_24 + 1) * 8 + lVar2) = param_2;\n    *(char *)(lVar3 + (long)(int)local_24 + 1) = param_3;\n    *(byte *)(param_1 + 0xfa) = bVar1 + 1;\n  }\n  else {\n    *(char *)(lVar3 + (int)local_24) = *(char *)(lVar3 + (int)local_24) + param_3;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is factor_insert_multiplicity"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,long param_2)\n\n{\n  FUN_0000c6ad(\"Client signing hash\",*(undefined4 *)(param_2 + 0x1fc),\n               *(undefined4 *)(param_1 + 0x7c));\n  return;\n}\n\n",
        "output": "The predicted function name is check_client_sign_hash"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (DAT_002533f9 == '\\0') {\n    if (((DAT_00253407 == '\\0') && (DAT_002531a0 == 0)) || (DAT_00253401 == '\\x01')) {\n      uVar1 = FUN_0000d528(param_1);\n    }\n    else {\n      uVar1 = 0;\n    }\n  }\n  else {\n    uVar1 = 0;\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is get_local_filename"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong [MASK](char *param_1,char *param_2,char param_3)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  int iVar6;\n  uint uVar7;\n  undefined4 extraout_var;\n  ulong uVar8;\n  char *local_28;\n  char *local_20;\n  \n  if (*param_1 == '\\0') {\n    iVar5 = strcmp(param_2,\"/\");\n    uVar8 = CONCAT44(extraout_var,iVar5) & 0xffffffffffffff00 | (ulong)(iVar5 == 0);\n  }\n  else {\n    local_28 = param_2;\n    local_20 = param_1;\n    if (param_3 == '\\0') {\n      do {\n        if ((*local_20 == '\\0') || (*local_28 == '\\0')) break;\n        pcVar1 = local_20 + 1;\n        cVar3 = *local_20;\n        pcVar2 = local_28 + 1;\n        cVar4 = *local_28;\n        local_28 = pcVar2;\n        local_20 = pcVar1;\n      } while (cVar3 == cVar4);\n    }\n    else {\n      for (; (*local_20 != '\\0' && (*local_28 != '\\0')); local_28 = local_28 + 1) {\n        iVar5 = FUN_0002857d((int)*local_20);\n        iVar6 = FUN_0002857d();\n        if (iVar5 != iVar6) break;\n        local_20 = local_20 + 1;\n      }\n    }\n    if ((*local_20 == '\\0') && ((*local_28 == '\\0' || (*local_28 == '/')))) {\n      uVar7 = 1;\n    }\n    else {\n      uVar7 = 0;\n    }\n    uVar8 = (ulong)uVar7;\n  }\n  return uVar8;\n}\n\n",
        "output": "The predicted function name is match_subdir"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  OPENSSL_sk_push(param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is sk_EVP_TEST_BUFFER_push"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  long in_FS_OFFSET;\n  undefined8 local_30;\n  undefined local_1a [10];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = 0;\n  ptr = (void *)FUN_000037e4(\"sha256\",&DAT_00013cc3,0,&DAT_00013cf5,\"label\");\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x1af,\"params\",ptr);\n  if (iVar1 != 0) {\n    local_30 = FUN_00002d68(&DAT_00013d1b);\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x1b0,\"kctx = get_kdfbyname(OSSL_KDF_NAME_HKDF)\",\n                         local_30);\n    if (iVar1 != 0) {\n      uVar2 = EVP_KDF_derive(local_30,local_1a,10,ptr);\n      iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x1b1,\n                           \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar2,0);\n      if (iVar1 != 0) {\n        uVar2 = 1;\n        goto LAB_0000494f;\n      }\n    }\n  }\n  uVar2 = 0;\nLAB_0000494f:\n  EVP_KDF_CTX_free(local_30);\n  CRYPTO_free(ptr);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_hkdf_empty_key"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  return DAT_00253d60;\n}\n\n",
        "output": "The predicted function name is get_exit_status"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2,undefined8 param_3)\n\n{\n  long lVar1;\n  int iVar2;\n  undefined8 uVar3;\n  \n  lVar1 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  iVar2 = strcmp(param_2,\"Input\");\n  if (iVar2 == 0) {\n    uVar3 = FUN_000066e2(param_3,lVar1,lVar1 + 8);\n  }\n  else {\n    iVar2 = strcmp(param_2,\"Output\");\n    if (iVar2 == 0) {\n      uVar3 = FUN_000066e2(param_3,lVar1 + 0x10,lVar1 + 0x18);\n    }\n    else {\n      uVar3 = 0;\n    }\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is encode_test_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *param_1,char *param_2)\n\n{\n  strcmp(param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is opt_compare"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  FUN_0000b0d1(param_1 + 0x208,param_2,*(undefined8 *)(param_1 + 0x230));\n  return;\n}\n\n",
        "output": "The predicted function name is parse_expected_client_ca_names"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00003860(param_1,2,param_2,0);\n  return;\n}\n\n",
        "output": "The predicted function name is set_altname_dns"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  FUN_00009d51(param_2,param_1 + 0x214);\n  return;\n}\n\n",
        "output": "The predicted function name is parse_test_enable_client_sctp_label_bug"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,long param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  if ((param_2 == 0) || (iVar1 = wget_strcasecmp_ascii(param_2,&DAT_0004354a), iVar1 == 0)) {\n    **(undefined4 **)(param_1 + 0x18) = 0;\n  }\n  else {\n    iVar1 = wget_strcasecmp_ascii(param_2,&DAT_000436ac);\n    if (iVar1 == 0) {\n      **(undefined4 **)(param_1 + 0x18) = 1;\n    }\n    else {\n      iVar1 = wget_strcasecmp_ascii(param_2,&DAT_000436b1);\n      if (iVar1 != 0) {\n        uVar2 = gettext(\"Unknown address family \\'%s\\'\\n\");\n        wget_error_printf(uVar2,param_2);\n        return 0xffffffff;\n      }\n      **(undefined4 **)(param_1 + 0x18) = 2;\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is parse_prefer_family"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  return param_1;\n}\n\n",
        "output": "The predicted function name is ossl_check_GENERAL_NAME_sk_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Removing unreachable block (ram,0x00001bd6) */\n\nundefined4 [MASK](void)\n\n{\n  return 0;\n}\n\n",
        "output": "The predicted function name is isnan_2pt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_00003bff(1,1);\n  return;\n}\n\n",
        "output": "The predicted function name is test_kdf_hkdf_gettables_expandonly"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  FUN_00009d51(param_2,param_1 + 0x40);\n  return;\n}\n\n",
        "output": "The predicted function name is parse_client_enable_pha"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *param_1,char **param_2,undefined8 *param_3)\n\n{\n  char *pcVar1;\n  int iVar2;\n  char *local_38;\n  char *local_30;\n  char *local_28;\n  char *local_20;\n  \n  if ((param_1 == (char *)0x0) || (iVar2 = access(param_1,2), iVar2 != 0)) {\n    wget_buffer_memcpy(param_3,*param_2,param_2[1]);\n    wget_debug_printf(\"  %.*s -> %s\\n\",(ulong)param_2[1] & 0xffffffff,*param_2,*param_3);\n  }\n  else {\n    pcVar1 = *param_2;\n    local_38 = pcVar1;\n    for (local_30 = pcVar1; local_28 = param_1, local_20 = param_1, *local_30 != '\\\"';\n        local_30 = local_30 + 1) {\n      if (*local_30 == '/') {\n        local_38 = local_30 + 1;\n      }\n    }\n    for (; *local_28 != '\\0'; local_28 = local_28 + 1) {\n      if (*local_28 == '/') {\n        local_20 = local_28 + 1;\n      }\n    }\n    wget_buffer_memcpy(param_3,pcVar1,(long)local_38 - (long)pcVar1);\n    wget_buffer_strcat(param_3,local_20);\n    wget_debug_printf(\"  %.*s -> %s\\n\",(ulong)param_2[1] & 0xffffffff,pcVar1,param_1);\n    wget_debug_printf(\"       -> %s\\n\",*param_3);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is convert_link_file_only"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  if ((*(byte *)(param_1 + 0xa8) & 1) != 0) {\n    wget_http_free_challenges(param_1 + 0x20);\n  }\n  wget_http_free_challenges(param_1 + 0x28);\n  wget_metalink_free(param_1 + 0x18);\n  wget_vector_free(param_1 + 0x30);\n  wget_list_free(param_1 + 0x38);\n  if (*(long *)(param_1 + 0x58) != 0) {\n    (*wget_free)(*(undefined8 *)(param_1 + 0x58));\n    *(undefined8 *)(param_1 + 0x58) = 0;\n  }\n  if (*(long *)(param_1 + 0x50) != 0) {\n    (*wget_free)(*(undefined8 *)(param_1 + 0x50));\n    *(undefined8 *)(param_1 + 0x50) = 0;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is job_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  wget_hashmap_free(&DAT_00253bf0);\n  return;\n}\n\n",
        "output": "The predicted function name is blacklist_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  wget_fprintf(DAT_00253c78,\"\\nSite Statistics:\\n\");\n  wget_fprintf(DAT_00253c78,\"  %6s %5s %6s %s\\n\",\"Status\",&DAT_000418dd,&DAT_000418d8,&DAT_000418d4)\n  ;\n  wget_vector_browse(DAT_00253c60,FUN_00012b0d,DAT_00253c78);\n  return;\n}\n\n",
        "output": "The predicted function name is print_human"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long lVar3;\n  long in_FS_OFFSET;\n  undefined8 local_1b8;\n  undefined8 local_1b0;\n  undefined8 local_1a8;\n  undefined8 local_1a0;\n  undefined8 local_198;\n  int local_17c;\n  int local_178;\n  int local_174;\n  undefined8 local_170;\n  undefined8 local_168 [4];\n  undefined8 uStack328;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_17c = 0;\n  local_48 = 0;\n  local_40 = 0;\n  local_38 = 0;\n  local_30 = 0;\n  for (local_178 = 0; local_178 < 3; local_178 = local_178 + 1) {\n    local_174 = 1;\n    OSSL_PARAM_construct_utf8_string(&local_1b8,\"cipher\",\"CAMELLIA-256-CBC\",0);\n    local_168[0] = local_1b8;\n    local_168[1] = local_1b0;\n    local_168[2] = local_1a8;\n    local_168[3] = local_1a0;\n    uStack328 = local_198;\n    lVar3 = (long)local_174;\n    local_174 = local_174 + 1;\n    OSSL_PARAM_construct_utf8_string(&local_1b8,&DAT_000141e1,&DAT_000141dc,0);\n    local_168[lVar3 * 5] = local_1b8;\n    local_168[lVar3 * 5 + 1] = local_1b0;\n    local_168[lVar3 * 5 + 2] = local_1a8;\n    local_168[lVar3 * 5 + 3] = local_1a0;\n    local_168[lVar3 * 5 + 4] = local_198;\n    lVar3 = (long)local_174;\n    local_174 = local_174 + 1;\n    OSSL_PARAM_construct_utf8_string(&local_1b8,&DAT_00013d10,\"FEEDBACK\",0);\n    local_168[lVar3 * 5] = local_1b8;\n    local_168[lVar3 * 5 + 1] = local_1b0;\n    local_168[lVar3 * 5 + 2] = local_1a8;\n    local_168[lVar3 * 5 + 3] = local_1a0;\n    local_168[lVar3 * 5 + 4] = local_198;\n    lVar3 = (long)local_174;\n    local_174 = local_174 + 1;\n    OSSL_PARAM_construct_octet_string(&local_1b8,&DAT_00013cfa,&DAT_00219160,0x20);\n    local_168[lVar3 * 5] = local_1b8;\n    local_168[lVar3 * 5 + 1] = local_1b0;\n    local_168[lVar3 * 5 + 2] = local_1a8;\n    local_168[lVar3 * 5 + 3] = local_1a0;\n    local_168[lVar3 * 5 + 4] = local_198;\n    lVar3 = (long)local_174;\n    local_174 = local_174 + 1;\n    OSSL_PARAM_construct_octet_string\n              (&local_1b8,&DAT_00013cf5,&DAT_00219180 + (long)local_178 * 5,5);\n    local_168[lVar3 * 5] = local_1b8;\n    local_168[lVar3 * 5 + 1] = local_1b0;\n    local_168[lVar3 * 5 + 2] = local_1a8;\n    local_168[lVar3 * 5 + 3] = local_1a0;\n    local_168[lVar3 * 5 + 4] = local_198;\n    lVar3 = (long)local_174;\n    local_174 = local_174 + 1;\n    OSSL_PARAM_construct_octet_string(&local_1b8,&DAT_00013be2,&DAT_00219560,0x10);\n    local_168[lVar3 * 5] = local_1b8;\n    local_168[lVar3 * 5 + 1] = local_1b0;\n    local_168[lVar3 * 5 + 2] = local_1a8;\n    local_168[lVar3 * 5 + 3] = local_1a0;\n    local_168[lVar3 * 5 + 4] = local_198;\n    lVar3 = (long)local_174;\n    OSSL_PARAM_construct_end(&local_1b8);\n    local_168[lVar3 * 5] = local_1b8;\n    local_168[lVar3 * 5 + 1] = local_1b0;\n    local_168[lVar3 * 5 + 2] = local_1a8;\n    local_168[lVar3 * 5 + 3] = local_1a0;\n    local_168[lVar3 * 5 + 4] = local_198;\n    local_170 = FUN_00002d68(\"KBKDF\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x420,&DAT_000141f4,local_170);\n    if (iVar1 == 0) {\nLAB_00007695:\n      local_17c = 0;\n    }\n    else {\n      uVar2 = EVP_KDF_derive(local_170,&local_48,0x20,local_168);\n      iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x422,\n                           \"EVP_KDF_derive(kctx, result, sizeof(result), params)\",&DAT_00013c2d,\n                           uVar2,0);\n      if ((iVar1 == 0) ||\n         (iVar1 = FUN_0000e848(\"test/evp_kdf_test.c\",0x424,\"result\",\"outputs[i]\",&local_48,0x20,\n                               &DAT_002191a0 + (long)local_178 * 0x20,0x20), iVar1 == 0))\n      goto LAB_00007695;\n      local_17c = 1;\n    }\n    EVP_KDF_CTX_free(local_170);\n    if (local_17c != 1) break;\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_17c;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_kdf_kbkdf_6803_256"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0000b38a(param_1,param_2,0,PTR_EVP_PKEY_derive_init_00223f90,0);\n  return;\n}\n\n",
        "output": "The predicted function name is pderive_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 *param_1,long param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  char **ppcVar2;\n  size_t sVar3;\n  \n  iVar1 = *(int *)(param_1 + 1);\n  if (iVar1 == 1) {\n    ppcVar2 = (char **)dico_list_item(param_1[4],param_2);\n    sVar3 = strlen(*ppcVar2);\n    dico_stream_write(param_3,*ppcVar2,sVar3);\n  }\n  else if (iVar1 == 0) {\n    ppcVar2 = (char **)(param_2 * 0x30 + param_1[4]);\n    sVar3 = strlen(*ppcVar2);\n    dico_stream_write(param_3,*ppcVar2,sVar3);\n  }\n  else if (iVar1 == 2) {\n    FUN_000032d6(param_3,*param_1,param_2 * 0x30 + param_1[4]);\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is outline_output_result"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_00003f0e(\"https://1.2.3.4:65536/pkix\");\n  return;\n}\n\n",
        "output": "The predicted function name is test_http_url_invalid_port"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,CONF *param_2,char *param_3)\n\n{\n  bool bVar1;\n  int iVar2;\n  stack_st_CONF_VALUE *psVar3;\n  undefined8 uVar4;\n  long lVar5;\n  int local_28;\n  ulong local_20;\n  \n  psVar3 = NCONF_get_section(param_2,param_3);\n  iVar2 = FUN_000146a7(\"test/helpers/ssl_test_ctx.c\",0x30c,\n                       \"sk_conf = NCONF_get_section(conf, client_section)\",psVar3);\n  if (iVar2 == 0) {\n    uVar4 = 0;\n  }\n  else {\n    local_28 = 0;\n    while( true ) {\n      uVar4 = FUN_00009d27(psVar3);\n      iVar2 = OPENSSL_sk_num(uVar4);\n      if (iVar2 <= local_28) break;\n      bVar1 = false;\n      uVar4 = FUN_00009d27(psVar3);\n      lVar5 = OPENSSL_sk_value(uVar4,local_28);\n      for (local_20 = 0; local_20 < 0xb; local_20 = local_20 + 1) {\n        iVar2 = strcmp(*(char **)(lVar5 + 8),(&PTR_s_VerifyCallback_0021f460)[local_20 * 2]);\n        if (iVar2 == 0) {\n          iVar2 = (*(code *)(&PTR_FUN_0021f468)[local_20 * 2])(param_1);\n          if (iVar2 == 0) {\n            FUN_0001261b(\"test/helpers/ssl_test_ctx.c\",0x316,\"Bad value %s for option %s\",\n                         *(undefined8 *)(lVar5 + 0x10),*(undefined8 *)(lVar5 + 8));\n            return 0;\n          }\n          bVar1 = true;\n          break;\n        }\n      }\n      if (!bVar1) {\n        FUN_0001261b(\"test/helpers/ssl_test_ctx.c\",0x31e,\"Unknown test option: %s\",\n                     *(undefined8 *)(lVar5 + 8));\n        return 0;\n      }\n      local_28 = local_28 + 1;\n    }\n    uVar4 = 1;\n  }\n  return uVar4;\n}\n\n",
        "output": "The predicted function name is parse_client_options"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  int local_38;\n  int local_34;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_34 = 0;\n  local_28 = param_1;\n  local_20 = param_2;\n  for (local_38 = 0;\n      (local_34 == 0 && ((&PTR_s____REQUEST____002053e0)[local_38] != (undefined *)0x0));\n      local_38 = local_38 + 1) {\n    local_34 = FUN_0000288d((&PTR_s____REQUEST____002053e0)[local_38],&local_28);\n  }\n  if (local_34 == 0) {\n    lVar1 = mu_sieve_get_tag_untyped(param_1,\"noreply\");\n    if (lVar1 != 0) {\n      local_34 = mu_sieve_vlist_do(param_1,lVar1,FUN_0000288d,&local_28);\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_34;\n}\n\n",
        "output": "The predicted function name is noreply_address_p"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00010b84(param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is log_write_error_stdout"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00022516(param_2,0,1);\n  return;\n}\n\n",
        "output": "The predicted function name is parse_execute"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int param_1)\n\n{\n  close(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is closeconn"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00010a72(stdout,param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is write_error_stdout"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  if (DAT_00205380 == (code *)0x0) {\n    EVP_PKEY_meth_get_cleanup(DAT_00205350,&DAT_00205380);\n  }\n  (*DAT_00205380)(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_rsa_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0002049c(param_1,param_2,1,0x20);\n  return;\n}\n\n",
        "output": "The predicted function name is parse_filenames"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined * [MASK](char *param_1)\n\n{\n  int iVar1;\n  undefined **local_10;\n  \n  local_10 = &PTR_PTR_DAT_00224020;\n  while( true ) {\n    if (*local_10 == (undefined *)0x0) {\n      return (undefined *)0x0;\n    }\n    iVar1 = strcmp(param_1,*(char **)*local_10);\n    if (iVar1 == 0) break;\n    local_10 = local_10 + 1;\n  }\n  return *local_10;\n}\n\n",
        "output": "The predicted function name is find_test"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](void)\n\n{\n  return DAT_00253c10 == 0;\n}\n\n",
        "output": "The predicted function name is queue_empty"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = wget_strdup(param_2);\n  FUN_0000de87(param_1,uVar1);\n  return;\n}\n\n",
        "output": "The predicted function name is dl_error_set"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,code *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  undefined8 *puVar2;\n  int local_1c;\n  ulong local_18;\n  \n  local_1c = 0;\n  do {\n    iVar1 = FUN_00006028(param_1);\n    if (iVar1 <= local_1c) {\n      return 1;\n    }\n    puVar2 = (undefined8 *)FUN_00006042(param_1,local_1c);\n    for (local_18 = 0; local_18 < (ulong)puVar2[2]; local_18 = local_18 + 1) {\n      iVar1 = (*param_2)(param_3,*puVar2,puVar2[1]);\n      if (iVar1 < 1) {\n        return 0;\n      }\n    }\n    local_1c = local_1c + 1;\n  } while( true );\n}\n\n",
        "output": "The predicted function name is evp_test_buffer_do"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *param_1,char param_2)\n\n{\n  char *local_10;\n  \n  local_10 = param_1;\n  do {\n    if (*local_10 == '\\0') {\n      return local_10;\n    }\n    if ((*local_10 == '\\\\') && ((local_10[1] == '\\\\' || (param_2 == local_10[1])))) {\n      local_10 = local_10 + 1;\n    }\n    else if (param_2 == *local_10) {\n      return local_10;\n    }\n    local_10 = local_10 + 1;\n  } while( true );\n}\n\n",
        "output": "The predicted function name is strchrnul_esc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  FUN_0000249a();\n  FUN_00002571();\n  FUN_00002aa1();\n  FUN_000023e2();\n  return 1;\n}\n\n",
        "output": "The predicted function name is dasync_destroy"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong [MASK](long param_1,char *param_2,char *param_3)\n\n{\n  long lVar1;\n  int iVar2;\n  ulong uVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  \n  lVar1 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  iVar2 = strcmp(param_2,\"Key\");\n  if (iVar2 == 0) {\n    uVar3 = FUN_000066e2(param_3,lVar1 + 0x20,lVar1 + 0x28);\n  }\n  else {\n    iVar2 = strcmp(param_2,\"IV\");\n    if (iVar2 == 0) {\n      uVar3 = FUN_000066e2(param_3,lVar1 + 0x30,lVar1 + 0x38);\n    }\n    else {\n      iVar2 = strcmp(param_2,\"Custom\");\n      if (iVar2 == 0) {\n        uVar3 = FUN_000066e2(param_3,lVar1 + 0x60,lVar1 + 0x68);\n      }\n      else {\n        iVar2 = strcmp(param_2,\"Salt\");\n        if (iVar2 == 0) {\n          uVar3 = FUN_000066e2(param_3,lVar1 + 0x70,lVar1 + 0x78);\n        }\n        else {\n          iVar2 = strcmp(param_2,\"Algorithm\");\n          if (iVar2 == 0) {\n            pcVar4 = CRYPTO_strdup(param_3,\"test/evp_test.c\",0x4d6);\n            *(char **)(lVar1 + 0x18) = pcVar4;\n            if (*(long *)(lVar1 + 0x18) == 0) {\n              uVar3 = 0xffffffff;\n            }\n            else {\n              uVar3 = 1;\n            }\n          }\n          else {\n            iVar2 = strcmp(param_2,\"Input\");\n            if (iVar2 == 0) {\n              uVar3 = FUN_000066e2(param_3,lVar1 + 0x40,lVar1 + 0x48);\n            }\n            else {\n              iVar2 = strcmp(param_2,\"Output\");\n              if (iVar2 == 0) {\n                uVar3 = FUN_000066e2(param_3,lVar1 + 0x50,lVar1 + 0x58);\n              }\n              else {\n                iVar2 = strcmp(param_2,\"XOF\");\n                if (iVar2 == 0) {\n                  *(undefined4 *)(lVar1 + 0x80) = 1;\n                  uVar3 = (ulong)*(uint *)(lVar1 + 0x80);\n                }\n                else {\n                  iVar2 = strcmp(param_2,\"NoReinit\");\n                  if (iVar2 == 0) {\n                    *(undefined4 *)(lVar1 + 0x84) = 1;\n                    uVar3 = (ulong)*(uint *)(lVar1 + 0x84);\n                  }\n                  else {\n                    iVar2 = strcmp(param_2,\"Ctrl\");\n                    if (iVar2 == 0) {\n                      pcVar4 = CRYPTO_strdup(param_3,\"test/evp_test.c\",0x4e4);\n                      if (pcVar4 == (char *)0x0) {\n                        uVar3 = 0xffffffff;\n                      }\n                      else {\n                        uVar5 = FUN_00005f9a(pcVar4);\n                        uVar6 = FUN_00005fb6(*(undefined8 *)(lVar1 + 0x88));\n                        iVar2 = OPENSSL_sk_push(uVar6,uVar5);\n                        uVar3 = (ulong)(iVar2 != 0);\n                      }\n                    }\n                    else {\n                      iVar2 = strcmp(param_2,\"OutputSize\");\n                      if (iVar2 == 0) {\n                        iVar2 = atoi(param_3);\n                        *(int *)(lVar1 + 0x90) = iVar2;\n                        if (*(int *)(lVar1 + 0x90) < 0) {\n                          uVar3 = 0xffffffff;\n                        }\n                        else {\n                          uVar3 = 1;\n                        }\n                      }\n                      else {\n                        iVar2 = strcmp(param_2,\"BlockSize\");\n                        if (iVar2 == 0) {\n                          iVar2 = atoi(param_3);\n                          *(int *)(lVar1 + 0x94) = iVar2;\n                          if (*(int *)(lVar1 + 0x94) < 0) {\n                            uVar3 = 0xffffffff;\n                          }\n                          else {\n                            uVar3 = 1;\n                          }\n                        }\n                        else {\n                          uVar3 = 0;\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is mac_test_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void *param_1)\n\n{\n  memset(param_1,0,0x50);\n  return 0;\n}\n\n",
        "output": "The predicted function name is rpl_posix_spawn_file_actions_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,long param_4,\n                undefined8 *param_5)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  int local_34;\n  undefined8 local_30;\n  undefined local_28 [8];\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_34 = 0;\n  local_20 = 0;\n  iVar1 = mu_header_sget_value_n(param_2,&DAT_00004209,1,&local_30);\n  if (iVar1 == 0) {\n    iVar1 = mu_address_create(local_28,local_30);\n    if (iVar1 == 0) {\n      iVar1 = FUN_000026c1(param_3,local_28);\n      if (iVar1 == 0) {\n        if (param_4 != 0) {\n          local_34 = mu_sieve_vlist_do(param_1,param_4,FUN_000026c1,local_28);\n        }\n      }\n      else {\n        local_34 = 1;\n      }\n      mu_address_destroy(local_28);\n    }\n  }\n  if (local_34 == 0) {\n    iVar1 = mu_header_sget_value_n(param_2,&DAT_0000420c,1,&local_30);\n    if (iVar1 == 0) {\n      iVar1 = mu_address_create(local_28,local_30);\n      if (iVar1 == 0) {\n        iVar1 = FUN_000026c1(param_3,local_28);\n        if (iVar1 == 0) {\n          if (param_4 != 0) {\n            local_34 = mu_sieve_vlist_do(param_1,param_4,FUN_000026c1,local_28);\n          }\n        }\n        else {\n          local_34 = 1;\n        }\n        mu_address_destroy(local_28);\n      }\n    }\n  }\n  *param_5 = local_20;\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_34;\n}\n\n",
        "output": "The predicted function name is match_addresses"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong [MASK](undefined8 param_1,undefined8 *param_2,undefined8 param_3,int param_4)\n\n{\n  ulong uVar1;\n  undefined8 uVar2;\n  \n  if (param_2 == (undefined8 *)0x0) {\n    uVar1 = FUN_000024bb(param_3);\n  }\n  else {\n    if (param_4 != 0x40) {\n      *param_2 = 0;\n    }\n    else {\n      uVar2 = FUN_0000248d();\n      *param_2 = uVar2;\n    }\n    uVar1 = (ulong)(param_4 == 0x40);\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is dasync_digests"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  FUN_00001a42();\n  FUN_00003198();\n  return 1;\n}\n\n",
        "output": "The predicted function name is afalg_destroy"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  undefined8 uVar1;\n  long lVar2;\n  char cVar3;\n  long in_FS_OFFSET;\n  undefined8 uVar4;\n  char *__format;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar2 = *(long *)(*(long *)(param_1 + 0x38) + 8);\n  cVar3 = FUN_00001be7();\n  if (((cVar3 == '\\0') && (cVar3 = FUN_00001be7(), cVar3 == '\\0')) &&\n     (cVar3 = FUN_00001c1d(param_1), cVar3 == '\\0')) {\n    FUN_000058cd(&local_28);\n    printf(\"\\t<!-- circle-%d -->\\n\",(ulong)*(uint *)(param_1 + 0x14));\n    uVar1 = *(undefined8 *)(lVar2 + 0x20);\n    uVar4 = FUN_00001b1f(local_20);\n    __format = (char *)FUN_00001b03(local_28);\n    printf(__format,uVar4,uVar1,\"\\t<circle id=\\\"dwg-object-%d\\\" cx=\\\"%f\\\" cy=\\\"%f\\\" r=\\\"%f\\\"\\n\\t\",\n           (ulong)*(uint *)(param_1 + 0x14));\n    FUN_00001e87(*(undefined8 *)(param_1 + 0x38));\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is output_CIRCLE"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  *(byte *)(param_1 + 0x18) = *(byte *)(param_1 + 0x18) | 2;\n  return;\n}\n\n",
        "output": "The predicted function name is impl_action_accept"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  size_t local_30;\n  uchar *local_28;\n  EVP_PKEY_CTX *local_20;\n  EVP_PKEY_CTX **local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = (EVP_PKEY_CTX *)0x0;\n  local_18 = *(EVP_PKEY_CTX ***)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  local_28 = (uchar *)0x0;\n  local_20 = EVP_PKEY_CTX_dup(*local_18);\n  iVar1 = FUN_00018f92(\"test/evp_test.c\",0x7b3,\"dctx = EVP_PKEY_CTX_dup(expected->ctx)\",local_20);\n  if (iVar1 == 0) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DERIVE_ERROR\";\n  }\n  else {\n    iVar1 = EVP_PKEY_derive(local_20,(uchar *)0x0,&local_30);\n    if (0 < iVar1) {\n      iVar1 = FUN_0001881a(\"test/evp_test.c\",0x7b9,\"got_len\",&DAT_0001c72b,local_30,0);\n      if (iVar1 != 0) {\n        local_28 = (uchar *)CRYPTO_malloc((int)local_30,\"test/evp_test.c\",0x7bd);\n        iVar1 = FUN_00018f92(\"test/evp_test.c\",0x7bd,\"got = OPENSSL_malloc(got_len)\",local_28);\n        if (iVar1 == 0) {\n          *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DERIVE_ERROR\";\n        }\n        else {\n          iVar1 = EVP_PKEY_derive(local_20,local_28,&local_30);\n          if (iVar1 < 1) {\n            *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DERIVE_ERROR\";\n          }\n          else {\n            iVar1 = FUN_000060ba(param_1,\"SHARED_SECRET_MISMATCH\",local_18[4],local_18[5],local_28,\n                                 local_30);\n            if (iVar1 != 0) {\n              *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n            }\n          }\n        }\n        goto LAB_0000c3c1;\n      }\n    }\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DERIVE_ERROR\";\n  }\nLAB_0000c3c1:\n  CRYPTO_free(local_28);\n  EVP_PKEY_CTX_free(local_20);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is pderive_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  int *piVar2;\n  char *pcVar3;\n  long in_FS_OFFSET;\n  uint local_24;\n  uint local_20;\n  uint local_1c;\n  uint local_18;\n  uint local_14;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = FUN_00000e07(param_1,1);\n  if (local_18 != 0xffffffff) {\n    FUN_0000100a(param_2,&local_24,&local_20);\n    local_1c = 0xffffffff;\n    if (((local_24 & 0x80000) != 0) && ((local_18 & 0x80000) == 0)) {\n      local_1c = 1;\n    }\n    if (((local_20 & 0x80000) != 0) && ((local_18 & 0x80000) != 0)) {\n      local_1c = 0;\n    }\n    if (local_1c != 0xffffffff) {\n      iVar1 = fcntl(param_1,2,(ulong)local_1c);\n      if (iVar1 == -1) {\n        piVar2 = __errno_location();\n        pcVar3 = strerror(*piVar2);\n        builtin_error(\"can\\'t set status for fd %d: %s\",param_1,pcVar3);\n      }\n    }\n    local_24 = local_24 & 0xfff7ffff;\n    local_20 = local_20 & 0xfff7ffff;\n    local_18 = local_18 & 0xfff7ffff;\n    local_14 = (local_18 | local_24) & ~local_20;\n    if (local_14 != local_18) {\n      iVar1 = fcntl(param_1,4,(ulong)local_14);\n      if (iVar1 == -1) {\n        piVar2 = __errno_location();\n        pcVar3 = strerror(*piVar2);\n        builtin_error(\"can\\'t set flags for fd %d: %s\",param_1,pcVar3);\n      }\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is setone"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  if (DAT_002053a0 == (code *)0x0) {\n    EVP_PKEY_meth_get_keygen(DAT_00205350,0,&DAT_002053a0);\n  }\n  (*DAT_002053a0)(param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_rsa_keygen"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined4 param_1)\n\n{\n  FUN_00009e5e(&PTR_s_TLSv1_3_0021ef00,7,param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is ssl_protocol_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  X509_NAME *nm;\n  int local_c;\n  \n  if (param_1 != 0) {\n    uVar2 = FUN_0000bd13(param_1);\n    iVar1 = OPENSSL_sk_num(uVar2);\n    if (iVar1 != 0) {\n      local_c = 0;\n      while( true ) {\n        uVar2 = FUN_0000bd13(param_1);\n        iVar1 = OPENSSL_sk_num(uVar2);\n        if (iVar1 <= local_c) break;\n        uVar2 = FUN_0000bd13(param_1);\n        nm = (X509_NAME *)OPENSSL_sk_value(uVar2,local_c);\n        X509_NAME_print_ex(DAT_00220190,nm,4,0x82031f);\n        BIO_puts(DAT_00220190,\"\\n\");\n        local_c = local_c + 1;\n      }\n      return;\n    }\n  }\n  FUN_0001295d(\"    <empty>\");\n  return;\n}\n\n",
        "output": "The predicted function name is print_ca_names"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 *param_1,undefined8 *param_2)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  long lVar3;\n  undefined8 uVar4;\n  int local_2c;\n  \n  if (param_2[6] == 0) {\n    if ((*(byte *)(param_2 + 0x15) >> 1 & 1) != 1) {\n      lVar3 = param_2[0x11] - param_1[1];\n      if (0 < lVar3) {\n        if ((param_1[2] == 0) || ((long)param_1[2] < lVar3)) {\n          param_1[2] = lVar3;\n        }\n        return 0;\n      }\n      *(byte *)(param_2 + 0x15) = *(byte *)(param_2 + 0x15) | 4;\n      *(byte *)(param_2 + 0x15) =\n           *(byte *)(param_2 + 0x15) & 0xfd | (*(byte *)(param_2 + 0x15) >> 2 & 1) * '\\x02';\n      uVar4 = wget_thread_self();\n      param_2[0xe] = uVar4;\n      param_2[0xc] = 0;\n      *param_1 = param_2;\n      wget_debug_printf(\"dequeue job %s\\n\",*(undefined8 *)*param_2);\n      return 1;\n    }\n  }\n  else {\n    for (local_2c = 0; iVar2 = wget_vector_size(param_2[6]), local_2c < iVar2;\n        local_2c = local_2c + 1) {\n      lVar3 = wget_vector_get(param_2[6],local_2c);\n      if ((*(byte *)(lVar3 + 0x20) & 1) != 1) {\n        *(byte *)(lVar3 + 0x20) = *(byte *)(lVar3 + 0x20) | 1;\n        uVar4 = wget_thread_self();\n        *(undefined8 *)(lVar3 + 0x18) = uVar4;\n        param_2[0xc] = lVar3;\n        *param_1 = param_2;\n        uVar4 = *(undefined8 *)param_2[3];\n        uVar1 = wget_vector_size(param_2[6]);\n        wget_debug_printf(\"dequeue chunk %d/%d %s\\n\",local_2c + 1,uVar1,uVar4);\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is _search_queue_for_free_job"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  FUN_000069ac(param_1,param_2,8,param_3,param_4);\n  return;\n}\n\n",
        "output": "The predicted function name is icmp_echo_encode"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return 0;\n}\n\n",
        "output": "The predicted function name is is_kdf_disabled"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbyte * [MASK](byte *param_1)\n\n{\n  byte bVar1;\n  int iVar2;\n  size_t sVar3;\n  undefined4 *puVar4;\n  ulong uVar5;\n  byte *pbVar6;\n  byte bVar7;\n  int local_30;\n  byte *local_28;\n  byte *local_20;\n  byte *local_18;\n  byte *local_10;\n  \n  bVar7 = 0;\n  if (param_1 == (byte *)0x0) {\n    local_28 = (byte *)0x0;\n  }\n  else {\n    sVar3 = strlen((char *)param_1);\n    local_30 = (int)sVar3 + 10;\n    local_28 = (byte *)calloc((long)local_30,1);\n    local_18 = local_28 + local_30;\n    local_20 = local_28;\n    for (local_10 = param_1; *local_10 != 0; local_10 = local_10 + 1) {\n      iVar2 = (int)local_28;\n      if ((long)local_18 - (long)local_20 < 9) {\n        local_30 = local_30 + 10;\n        local_28 = (byte *)realloc(local_28,(long)local_30);\n        local_20 = local_28 + ((int)local_20 - iVar2);\n        *local_20 = 0;\n        local_18 = local_28 + local_30;\n      }\n      bVar1 = *local_10;\n      if (bVar1 == 0x3c) {\n        uVar5 = 0xffffffffffffffff;\n        pbVar6 = local_20;\n        do {\n          if (uVar5 == 0) break;\n          uVar5 = uVar5 - 1;\n          bVar1 = *pbVar6;\n          pbVar6 = pbVar6 + (ulong)bVar7 * -2 + 1;\n        } while (bVar1 != 0);\n        *(undefined4 *)(local_20 + (~uVar5 - 1)) = 0x3b746c26;\n        *(undefined *)((long)(local_20 + (~uVar5 - 1)) + 4) = 0;\n        local_20 = local_20 + 4;\n      }\n      else if (bVar1 < 0x3d) {\n        if (bVar1 == 0x26) {\n          uVar5 = 0xffffffffffffffff;\n          pbVar6 = local_20;\n          do {\n            if (uVar5 == 0) break;\n            uVar5 = uVar5 - 1;\n            bVar1 = *pbVar6;\n            pbVar6 = pbVar6 + (ulong)bVar7 * -2 + 1;\n          } while (bVar1 != 0);\n          *(undefined4 *)(local_20 + (~uVar5 - 1)) = 0x706d6126;\n          *(undefined2 *)((long)(local_20 + (~uVar5 - 1)) + 4) = 0x3b;\n          local_20 = local_20 + 5;\n        }\n        else if (bVar1 == 0x27) {\n          uVar5 = 0xffffffffffffffff;\n          pbVar6 = local_20;\n          do {\n            if (uVar5 == 0) break;\n            uVar5 = uVar5 - 1;\n            bVar1 = *pbVar6;\n            pbVar6 = pbVar6 + (ulong)bVar7 * -2 + 1;\n          } while (bVar1 != 0);\n          *(undefined4 *)(local_20 + (~uVar5 - 1)) = 0x39332326;\n          *(undefined2 *)((long)(local_20 + (~uVar5 - 1)) + 4) = 0x3b;\n          local_20 = local_20 + 5;\n        }\n        else {\n          if (bVar1 != 0x22) goto LAB_00004fe1;\n          uVar5 = 0xffffffffffffffff;\n          pbVar6 = local_20;\n          do {\n            if (uVar5 == 0) break;\n            uVar5 = uVar5 - 1;\n            bVar1 = *pbVar6;\n            pbVar6 = pbVar6 + (ulong)bVar7 * -2 + 1;\n          } while (bVar1 != 0);\n          puVar4 = (undefined4 *)(local_20 + (~uVar5 - 1));\n          *puVar4 = 0x6f757126;\n          *(undefined2 *)(puVar4 + 1) = 0x3b74;\n          *(undefined *)((long)puVar4 + 6) = 0;\n          local_20 = local_20 + 6;\n        }\n      }\n      else if (bVar1 == 0x60) {\n        uVar5 = 0xffffffffffffffff;\n        pbVar6 = local_20;\n        do {\n          if (uVar5 == 0) break;\n          uVar5 = uVar5 - 1;\n          bVar1 = *pbVar6;\n          pbVar6 = pbVar6 + (ulong)bVar7 * -2 + 1;\n        } while (bVar1 != 0);\n        *(undefined4 *)(local_20 + (~uVar5 - 1)) = 0x36392326;\n        *(undefined2 *)((long)(local_20 + (~uVar5 - 1)) + 4) = 0x3b;\n        local_20 = local_20 + 5;\n      }\n      else if (bVar1 < 0x61) {\n        if (bVar1 == 0x3e) {\n          uVar5 = 0xffffffffffffffff;\n          pbVar6 = local_20;\n          do {\n            if (uVar5 == 0) break;\n            uVar5 = uVar5 - 1;\n            bVar1 = *pbVar6;\n            pbVar6 = pbVar6 + (ulong)bVar7 * -2 + 1;\n          } while (bVar1 != 0);\n          *(undefined4 *)(local_20 + (~uVar5 - 1)) = 0x3b746726;\n          *(undefined *)((long)(local_20 + (~uVar5 - 1)) + 4) = 0;\n          local_20 = local_20 + 4;\n        }\n        else {\nLAB_00004fe1:\n          if (*local_10 < 0x7f) {\n            if (0x13 < *local_10) {\n              *local_20 = *local_10;\n              local_20[1] = 0;\n              local_20 = local_20 + 1;\n            }\n          }\n          else {\n            sprintf((char *)local_20,\"&#x%X;\",(ulong)*local_10);\n            sVar3 = strlen((char *)local_20);\n            local_20[sVar3] = 0;\n            local_20 = local_20 + sVar3;\n          }\n        }\n      }\n      else if (bVar1 == 0x7b) {\n        uVar5 = 0xffffffffffffffff;\n        pbVar6 = local_20;\n        do {\n          if (uVar5 == 0) break;\n          uVar5 = uVar5 - 1;\n          bVar1 = *pbVar6;\n          pbVar6 = pbVar6 + (ulong)bVar7 * -2 + 1;\n        } while (bVar1 != 0);\n        puVar4 = (undefined4 *)(local_20 + (~uVar5 - 1));\n        *puVar4 = 0x32312326;\n        *(undefined2 *)(puVar4 + 1) = 0x3b33;\n        *(undefined *)((long)puVar4 + 6) = 0;\n        local_20 = local_20 + 6;\n      }\n      else {\n        if (bVar1 != 0x7d) goto LAB_00004fe1;\n        uVar5 = 0xffffffffffffffff;\n        pbVar6 = local_20;\n        do {\n          if (uVar5 == 0) break;\n          uVar5 = uVar5 - 1;\n          bVar1 = *pbVar6;\n          pbVar6 = pbVar6 + (ulong)bVar7 * -2 + 1;\n        } while (bVar1 != 0);\n        puVar4 = (undefined4 *)(local_20 + (~uVar5 - 1));\n        *puVar4 = 0x32312326;\n        *(undefined2 *)(puVar4 + 1) = 0x3b35;\n        *(undefined *)((long)puVar4 + 6) = 0;\n        local_20 = local_20 + 6;\n      }\n    }\n    *local_20 = 0;\n  }\n  return local_28;\n}\n\n",
        "output": "The predicted function name is htmlescape"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x10);\n}\n\n",
        "output": "The predicted function name is impl_get_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  long lVar1;\n  char cVar2;\n  long in_FS_OFFSET;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  undefined8 uVar8;\n  undefined8 uVar9;\n  char *__format;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  undefined8 local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar1 = *(long *)(*(long *)(param_1 + 0x38) + 8);\n  local_50 = *(undefined8 *)(lVar1 + 0x20);\n  local_58 = *(undefined8 *)(lVar1 + 0x18);\n  local_40 = *(undefined8 *)(lVar1 + 0x30);\n  local_48 = *(undefined8 *)(lVar1 + 0x28);\n  local_30 = *(undefined8 *)(lVar1 + 0x40);\n  local_38 = *(undefined8 *)(lVar1 + 0x38);\n  local_20 = *(undefined8 *)(lVar1 + 0x50);\n  local_28 = *(undefined8 *)(lVar1 + 0x48);\n  cVar2 = FUN_00001b4b(local_58,local_50);\n  if (cVar2 == '\\0') {\n    cVar2 = FUN_00001b4b(local_48,local_40);\n    if (cVar2 == '\\0') {\n      cVar2 = FUN_00001b4b(local_38,local_30);\n      if (cVar2 == '\\0') {\n        cVar2 = FUN_00001b4b(local_28,local_20);\n        if (cVar2 == '\\0') {\n          cVar2 = FUN_00001c1d(param_1);\n          if (cVar2 == '\\0') {\n            FUN_0000558b(local_58,local_50,&local_98);\n            FUN_0000558b(local_48,local_40,&local_88);\n            FUN_0000558b(local_38,local_30,&local_78);\n            FUN_0000558b(local_28,local_20,&local_68);\n            printf(\"\\t<!-- solid-%d -->\\n\",(ulong)*(uint *)(param_1 + 0x14));\n            uVar3 = FUN_00001b1f(local_60);\n            uVar4 = FUN_00001b03(local_68);\n            uVar5 = FUN_00001b1f(local_70);\n            uVar6 = FUN_00001b03(local_78);\n            uVar7 = FUN_00001b1f(local_80);\n            uVar8 = FUN_00001b03(local_88);\n            uVar9 = FUN_00001b1f(local_90);\n            __format = (char *)FUN_00001b03(local_98);\n            printf(__format,uVar9,uVar8,uVar7,uVar6,uVar5,uVar4,uVar3,\n                   \"\\t<polygon id=\\\"dwg-object-%d\\\" points=\\\"%f,%f %f,%f %f,%f %f,%f\\\"\\n\\t\",\n                   (ulong)*(uint *)(param_1 + 0x14));\n            FUN_00001e87(*(undefined8 *)(param_1 + 0x38));\n          }\n        }\n      }\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is output_SOLID"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,undefined8 param_2,char *param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  size_t sVar5;\n  long in_FS_OFFSET;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  char *local_60;\n  undefined8 local_58;\n  long local_50;\n  int local_44;\n  char *local_40;\n  long local_38;\n  undefined8 local_30;\n  char *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  local_60 = param_3;\n  local_58 = param_2;\n  local_50 = param_1;\n  uVar3 = EVP_KDF_CTX_kdf(param_2);\n  local_30 = EVP_KDF_settable_ctx_params(uVar3);\n  local_28 = CRYPTO_strdup(local_60,\"test/evp_test.c\",0xab1);\n  iVar2 = FUN_00018f92(\"test/evp_test.c\",0xab1,\"name = OPENSSL_strdup(value)\",local_28);\n  if (iVar2 == 0) {\n    uVar3 = 0;\n    goto LAB_0000efb5;\n  }\n  pcVar4 = strchr(local_28,0x3a);\n  local_40 = pcVar4;\n  if (pcVar4 != (char *)0x0) {\n    local_40 = pcVar4 + 1;\n    *pcVar4 = '\\0';\n  }\n  if (local_40 == (char *)0x0) {\n    sVar5 = 0;\n  }\n  else {\n    sVar5 = strlen(local_40);\n  }\n  local_44 = OSSL_PARAM_allocate_from_text\n                       (*(undefined8 *)(local_38 + 0x338),local_30,local_28,local_40,sVar5,0);\n  *(long *)(local_38 + 0x338) = *(long *)(local_38 + 0x338) + 0x28;\n  puVar1 = *(undefined8 **)(local_38 + 0x338);\n  OSSL_PARAM_construct_end(&local_98);\n  *puVar1 = local_98;\n  puVar1[1] = local_90;\n  puVar1[2] = local_88;\n  puVar1[3] = local_80;\n  puVar1[4] = local_78;\n  if (local_44 == 0) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + local_50 + 0x17) = \"KDF_PARAM_ERROR\";\n    CRYPTO_free(local_28);\n    uVar3 = 0;\n    goto LAB_0000efb5;\n  }\n  if (local_40 != (char *)0x0) {\n    iVar2 = strcmp(local_28,\"digest\");\n    if (iVar2 == 0) {\n      iVar2 = FUN_00011e19(local_40);\n      if (iVar2 != 0) {\n        FUN_00016f06(\"test/evp_test.c\",0xac1,\"skipping, \\'%s\\' is disabled\",local_40);\n        *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + local_50 + 7) = 1;\n      }\n    }\n  }\n  if (local_40 != (char *)0x0) {\n    iVar2 = strcmp(local_28,\"cipher\");\n    if (iVar2 != 0) {\n      iVar2 = strcmp(local_28,\"cekalg\");\n      if (iVar2 != 0) goto LAB_0000ef98;\n    }\n    iVar2 = FUN_00011e77(local_40);\n    if (iVar2 != 0) {\n      FUN_00016f06(\"test/evp_test.c\",0xac9,\"skipping, \\'%s\\' is disabled\",local_40);\n      *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + local_50 + 7) = 1;\n    }\n  }\nLAB_0000ef98:\n  CRYPTO_free(local_28);\n  uVar3 = 1;\nLAB_0000efb5:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is kdf_test_ctrl"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 [MASK](undefined8 param_1,undefined4 param_2)\n\n{\n  _DAT_002130c4 = param_2;\n  return 1;\n}\n\n",
        "output": "The predicted function name is fake_rsa_keymgmt_has"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](undefined8 param_1)\n\n{\n  long lVar1;\n  \n  lVar1 = CRYPTO_zalloc(0x238,\"test/helpers/ssl_test_ctx.c\",0x2d6);\n  if (lVar1 != 0) {\n    *(undefined8 *)(lVar1 + 0x230) = param_1;\n    *(undefined4 *)(lVar1 + 8) = 0x100;\n    *(undefined4 *)(lVar1 + 0xc) = 0x200;\n  }\n  return lVar1;\n}\n\n",
        "output": "The predicted function name is SSL_TEST_CTX_new"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0000fe57(param_1,param_2,0,0);\n  return;\n}\n\n",
        "output": "The predicted function name is digestsign_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid [MASK](long param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  char cVar3;\n  uint uVar4;\n  long in_FS_OFFSET;\n  double dVar5;\n  double dVar6;\n  double dVar7;\n  double local_90;\n  double local_88;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar2 = *(long *)(*(long *)(param_1 + 0x38) + 8);\n  cVar3 = FUN_00001be7();\n  if (((cVar3 == '\\0') && (cVar3 = FUN_00001be7(), cVar3 == '\\0')) &&\n     (cVar3 = FUN_00001c1d(param_1), cVar3 == '\\0')) {\n    local_88 = DAT_000067c0 / *(double *)(lVar2 + 0x20);\n    dVar5 = DAT_000067c0 / *(double *)(lVar2 + 0x28);\n    dVar6 = DAT_000067c0 / *(double *)(lVar2 + 0x30);\n    uVar4 = (uint)(local_88 < 0.0);\n    _DAT_00209280 = DAT_002091f8;\n    _DAT_00209288 = DAT_00209200;\n    _DAT_00209298 = DAT_00209208;\n    _DAT_002092a0 = DAT_00209200;\n    printf(\"\\t<!-- ray-%d -->\\n\",(ulong)*(uint *)(param_1 + 0x14));\n    local_90 = (*(double *)(&DAT_00209280 + (long)(int)uVar4 * 0x18) - *(double *)(lVar2 + 8)) *\n               local_88;\n    local_88 = (*(double *)(&DAT_00209280 + (long)(int)(1 - uVar4) * 0x18) - *(double *)(lVar2 + 8))\n               * local_88;\n    dVar7 = (*(double *)(&DAT_00209280 + (long)(int)(uint)(dVar5 < 0.0) * 0x18) -\n            *(double *)(lVar2 + 0x10)) * dVar5;\n    dVar5 = (*(double *)(&DAT_00209280 + (long)(int)(1 - (uint)(dVar5 < 0.0)) * 0x18) -\n            *(double *)(lVar2 + 0x10)) * dVar5;\n    if ((local_90 <= dVar5) && (dVar7 <= local_88)) {\n      if (local_90 < dVar7) {\n        local_90 = dVar7;\n      }\n      if (local_88 < dVar5) {\n        local_88 = dVar5;\n      }\n      if ((local_90 <=\n           (*(double *)(&DAT_00209290 + (long)(int)(1 - uVar4) * 0x18) - *(double *)(lVar2 + 0x18))\n           * dVar6) &&\n         ((*(double *)(&DAT_00209290 + (long)(int)uVar4 * 0x18) - *(double *)(lVar2 + 0x18)) * dVar6\n          <= local_88)) {\n        printf(\"\\t<path id=\\\"dwg-object-%d\\\" d=\\\"M %f,%f L %f,%f\\\"\\n\\t\",\n               (ulong)*(uint *)(param_1 + 0x14));\n        FUN_00001e87(*(undefined8 *)(param_1 + 0x38));\n      }\n    }\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is output_RAY"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void **param_1)\n\n{\n  if (param_1 != (void **)0x0) {\n    CRYPTO_free(*param_1);\n    CRYPTO_free(param_1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is evp_test_buffer_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined [MASK](void)\n\n{\n  return DAT_00253e98;\n}\n\n",
        "output": "The predicted function name is is_testing"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *param_1,void *param_2,long param_3,int param_4)\n\n{\n  ssize_t sVar1;\n  int local_c;\n  \n  if ((((param_1 == (char *)0x0) || (param_2 == (void *)0x0)) || (param_3 == 0)) || (param_4 < 0)) {\n    local_c = -1;\n  }\n  else {\n    sVar1 = fgetxattr(param_4,param_1,param_2,param_3 - 1);\n    local_c = (int)sVar1;\n    if (local_c < 0) {\n      local_c = -1;\n    }\n    else {\n      if ((int)param_3 <= local_c) {\n        local_c = (int)param_3 + -1;\n      }\n      *(undefined *)((long)param_2 + (long)local_c) = 0;\n    }\n  }\n  return local_c;\n}\n\n",
        "output": "The predicted function name is read_xattr_metadata"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 * [MASK](undefined8 param_1,code *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  undefined8 *local_18;\n  \n  DAT_00204310 = 0;\n  local_18 = (undefined8 *)malloc(0x28);\n  if (local_18 == (undefined8 *)0x0) {\n    local_18 = (undefined8 *)0x0;\n  }\n  else {\n    *local_18 = param_1;\n    iVar1 = (*param_2)(param_1,param_3,local_18);\n    if (iVar1 == 0) {\n      local_18[3] = DAT_00204310;\n    }\n    else {\n      free(local_18);\n      local_18 = (undefined8 *)0x0;\n    }\n  }\n  return local_18;\n}\n\n",
        "output": "The predicted function name is outline_match0"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  iVar1 = wget_strcasecmp_ascii(param_2,&DAT_0004376d);\n  if (iVar1 == 0) {\n    **(undefined4 **)(param_1 + 0x18) = 2;\n  }\n  else {\n    iVar1 = wget_strcasecmp_ascii(param_2,&DAT_00043772);\n    if (iVar1 == 0) {\n      **(undefined4 **)(param_1 + 0x18) = 1;\n    }\n    else {\n      iVar1 = wget_strcasecmp_ascii(param_2,&DAT_0004354a);\n      if (iVar1 != 0) {\n        if (*param_2 == '\\0') {\n          uVar2 = gettext(\"Missing required type specifier\\n\");\n          wget_error_printf(uVar2);\n          return 0xffffffff;\n        }\n        uVar2 = gettext(\"Invalid type specifier: %s\\n\");\n        wget_error_printf(uVar2,param_2);\n        return 0xffffffff;\n      }\n      **(undefined4 **)(param_1 + 0x18) = 0;\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is parse_https_enforce"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  EVP_DigestVerifyUpdate(param_1,param_2,param_3);\n  return;\n}\n\n",
        "output": "The predicted function name is digestverify_update_fn"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](char *param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  iVar1 = strcasecmp(param_1,\"i386\");\n  if (iVar1 == 0) {\n    uVar2 = 3;\n  }\n  else {\n    iVar1 = strcasecmp(param_1,\"iamcu\");\n    if (iVar1 == 0) {\n      uVar2 = 6;\n    }\n    else {\n      iVar1 = strcasecmp(param_1,\"l1om\");\n      if (iVar1 == 0) {\n        uVar2 = 0xb4;\n      }\n      else {\n        iVar1 = strcasecmp(param_1,\"k1om\");\n        if (iVar1 == 0) {\n          uVar2 = 0xb5;\n        }\n        else {\n          iVar1 = strcasecmp(param_1,\"x86_64\");\n          if (iVar1 == 0) {\n            uVar2 = 0x3e;\n          }\n          else {\n            iVar1 = strcasecmp(param_1,\"x86-64\");\n            if (iVar1 == 0) {\n              uVar2 = 0x3e;\n            }\n            else {\n              iVar1 = strcasecmp(param_1,\"none\");\n              if (iVar1 == 0) {\n                uVar2 = 0;\n              }\n              else {\n                uVar2 = gettext(\"Unknown machine type: %s\\n\");\n                error(uVar2,param_1);\n                uVar2 = 0xffffffff;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is elf_machine"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  FUN_0000ae56(param_1 + 0x1e8,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is parse_expected_server_sign_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long in_FS_OFFSET;\n  undefined8 local_d8;\n  undefined8 local_d0;\n  undefined8 local_c8;\n  undefined8 local_c0;\n  undefined8 local_b8;\n  undefined4 local_a4;\n  undefined4 local_a0;\n  undefined4 local_9c;\n  undefined8 local_98;\n  void *local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  undefined8 local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined local_38 [40];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_9c = 0;\n  local_98 = 0;\n  local_a4 = 1;\n  local_a0 = 1;\n  local_90 = (void *)FUN_0000511d(\"passwordPASSWORDpassword\",\"sha256\",\n                                  \"saltSALTsaltSALTsaltSALTsaltSALTsalt\",&local_a4,&local_a0);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x2f8,\"params\",local_90);\n  if (iVar1 != 0) {\n    local_98 = FUN_00002d68(\"PBKDF2\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x2f9,\"kctx = get_kdfbyname(OSSL_KDF_NAME_PBKDF2)\",\n                         local_98);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_98,local_90);\n      iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0x2fb,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        uVar2 = EVP_KDF_derive(local_98,local_38,0x19,0);\n        iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x2fc,\n                             \"EVP_KDF_derive(kctx, out, sizeof(out), NULL)\",&DAT_00013c2d,uVar2,0);\n        if (iVar1 != 0) {\n          local_a0 = 0;\n          OSSL_PARAM_construct_int(&local_d8,\"pkcs5\",&local_a0);\n          local_88 = local_d8;\n          local_80 = local_d0;\n          local_78 = local_c8;\n          local_70 = local_c0;\n          local_68 = local_b8;\n          OSSL_PARAM_construct_end(&local_d8);\n          local_60 = local_d8;\n          local_58 = local_d0;\n          local_50 = local_c8;\n          local_48 = local_c0;\n          local_40 = local_b8;\n          iVar1 = EVP_KDF_CTX_set_params(local_98,&local_88);\n          iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0x304,\n                               \"EVP_KDF_CTX_set_params(kctx, mode_params)\",iVar1 != 0);\n          if (iVar1 != 0) {\n            uVar2 = EVP_KDF_derive(local_98,local_38,0x19,0);\n            iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x305,\n                                 \"EVP_KDF_derive(kctx, out, sizeof(out), NULL)\",&DAT_00013c2d,uVar2,\n                                 0);\n            if (iVar1 != 0) {\n              local_9c = 1;\n            }\n          }\n        }\n      }\n    }\n  }\n  EVP_KDF_CTX_free(local_98);\n  CRYPTO_free(local_90);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_9c;\n}\n\n",
        "output": "The predicted function name is test_kdf_pbkdf2_small_iterations_pkcs5"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nuint [MASK](undefined8 param_1,undefined8 param_2,char *param_3,uint param_4,void *param_5,\n                 uint param_6)\n\n{\n  uint local_28;\n  \n  BIO_snprintf(param_3,(ulong)param_4,\"psk\");\n  local_28 = param_6;\n  if (0x14 < param_6) {\n    local_28 = 0x14;\n  }\n  memset(param_5,0x5a,(ulong)local_28);\n  return local_28;\n}\n\n",
        "output": "The predicted function name is clnt_psk_callback"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  code *pcVar1;\n  __pid_t _Var2;\n  int iVar3;\n  __pid_t _Var4;\n  int *piVar5;\n  undefined8 uVar6;\n  long in_FS_OFFSET;\n  int local_48 [2];\n  undefined8 local_40;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  _Var2 = fork();\n  if (_Var2 < 0) {\n    pcVar1 = *(code **)(DAT_00202178 + 0x80);\n    piVar5 = __errno_location();\n    (*pcVar1)(DAT_00202180,*piVar5);\n  }\n  else if (_Var2 == 0) {\n    iVar3 = (**(code **)(DAT_00202178 + 0xa8))(DAT_00202180,&DAT_00001249,\"PROCINFO\",5,local_48);\n    if (iVar3 != 0) {\n      if (local_48[0] == 5) {\n        _Var4 = getpid();\n        FUN_00000ca6((double)_Var4,local_40,&DAT_00001270);\n        _Var4 = getppid();\n        FUN_00000ca6((double)_Var4,local_40,&DAT_00001274);\n      }\n      else if (*(int *)(DAT_00202178 + 0x18) != 0) {\n        pcVar1 = *(code **)(DAT_00202178 + 0x70);\n        uVar6 = gettext(\"fork: PROCINFO is not an array!\");\n        (*pcVar1)(DAT_00202180,uVar6);\n      }\n    }\n  }\n  FUN_00000c70((double)_Var2,param_2);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is do_fork"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Type propagation algorithm not settling */\n\nlong [MASK](CONF *param_1,char *param_2,undefined8 param_3)\n\n{\n  bool bVar1;\n  int iVar2;\n  stack_st_CONF_VALUE *psVar3;\n  long lVar4;\n  undefined8 uVar5;\n  int local_30;\n  long local_28;\n  ulong local_20;\n  \n  local_28 = 0;\n  psVar3 = NCONF_get_section(param_1,param_2);\n  iVar2 = FUN_000146a7(\"test/helpers/ssl_test_ctx.c\",0x34f,\n                       \"sk_conf = NCONF_get_section(conf, test_section)\",psVar3);\n  if (iVar2 != 0) {\n    local_28 = FUN_0000b2b5(param_3);\n    iVar2 = FUN_000146a7(\"test/helpers/ssl_test_ctx.c\",0x350,\"ctx = SSL_TEST_CTX_new(libctx)\",\n                         local_28);\n    if (iVar2 != 0) {\n      local_30 = 0;\n      do {\n        uVar5 = FUN_00009d27(psVar3);\n        iVar2 = OPENSSL_sk_num(uVar5);\n        if (iVar2 <= local_30) {\n          return local_28;\n        }\n        bVar1 = false;\n        uVar5 = FUN_00009d27(psVar3);\n        lVar4 = OPENSSL_sk_value(uVar5,local_30);\n        iVar2 = strcmp(*(char **)(lVar4 + 8),\"client\");\n        if (iVar2 == 0) {\n          iVar2 = FUN_0000b627(local_28 + 0x18,param_1,*(undefined8 *)(lVar4 + 0x10));\njoined_r0x0000bb9a:\n          if (iVar2 == 0) break;\n        }\n        else {\n          iVar2 = strcmp(*(char **)(lVar4 + 8),\"server\");\n          if (iVar2 == 0) {\n            iVar2 = FUN_0000b7ca(local_28 + 0x60,param_1,*(undefined8 *)(lVar4 + 0x10));\n            goto joined_r0x0000bb9a;\n          }\n          iVar2 = strcmp(*(char **)(lVar4 + 8),\"server2\");\n          if (iVar2 == 0) {\n            iVar2 = FUN_0000b7ca(local_28 + 0xa0,param_1,*(undefined8 *)(lVar4 + 0x10));\n            goto joined_r0x0000bb9a;\n          }\n          iVar2 = strcmp(*(char **)(lVar4 + 8),\"resume-client\");\n          if (iVar2 == 0) {\n            iVar2 = FUN_0000b627(local_28 + 0xe0,param_1,*(undefined8 *)(lVar4 + 0x10));\n            goto joined_r0x0000bb9a;\n          }\n          iVar2 = strcmp(*(char **)(lVar4 + 8),\"resume-server\");\n          if (iVar2 == 0) {\n            iVar2 = FUN_0000b7ca(local_28 + 0x128,param_1,*(undefined8 *)(lVar4 + 0x10));\n            goto joined_r0x0000bb9a;\n          }\n          iVar2 = strcmp(*(char **)(lVar4 + 8),\"resume-server2\");\n          if (iVar2 == 0) {\n            iVar2 = FUN_0000b7ca(local_28 + 0x168,param_1,*(undefined8 *)(lVar4 + 0x10));\n            goto joined_r0x0000bb9a;\n          }\n          for (local_20 = 0; local_20 < 0x1e; local_20 = local_20 + 1) {\n            iVar2 = strcmp(*(char **)(lVar4 + 8),(&PTR_s_ExpectedResult_0021f280)[local_20 * 2]);\n            if (iVar2 == 0) {\n              iVar2 = (*(code *)(&PTR_FUN_0021f288)[local_20 * 2])(local_28);\n              if (iVar2 == 0) {\n                FUN_0001261b(\"test/helpers/ssl_test_ctx.c\",0x372,\"Bad value %s for option %s\",\n                             *(undefined8 *)(lVar4 + 0x10),*(undefined8 *)(lVar4 + 8));\n                goto LAB_0000bcf9;\n              }\n              bVar1 = true;\n              break;\n            }\n          }\n          if (!bVar1) {\n            FUN_0001261b(\"test/helpers/ssl_test_ctx.c\",0x37a,\"Unknown test option: %s\",\n                         *(undefined8 *)(lVar4 + 8));\n            break;\n          }\n        }\n        local_30 = local_30 + 1;\n      } while( true );\n    }\n  }\nLAB_0000bcf9:\n  FUN_0000b505(local_28);\n  return 0;\n}\n\n",
        "output": "The predicted function name is SSL_TEST_CTX_create"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8\n[MASK](long param_1,undefined8 param_2,undefined8 param_3,int param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  long in_FS_OFFSET;\n  char local_418 [1032];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_4 < 0) {\n    uVar2 = 1;\n  }\n  else {\n    if (param_4 == 0) {\n      pcVar3 = \"does not match\";\n    }\n    else {\n      pcVar3 = \"matches\";\n    }\n    BIO_snprintf(local_418,0x400,\"%s: %s: [%s] %s [%s]\",*(undefined8 *)(param_1 + 8),param_2,param_3\n                 ,pcVar3,param_5);\n    iVar1 = FUN_00003606(local_418);\n    if (iVar1 == 0) {\n      FUN_0000671a(\"test/v3nametest.c\",0x113,&DAT_0000eb42,local_418);\n      uVar2 = 0;\n    }\n    else {\n      uVar2 = 1;\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is check_message"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00003658(param_1,0xd,param_2,0x30,\"dummy@example.com\",0);\n  return;\n}\n\n",
        "output": "The predicted function name is set_cn_and_email"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ASN1_VALUE **param_1,uchar **param_2,long param_3)\n\n{\n  ASN1_ITEM *it;\n  \n  it = (ASN1_ITEM *)FUN_00002cec();\n  ASN1_item_d2i(param_1,param_2,param_3,it);\n  return;\n}\n\n",
        "output": "The predicted function name is d2i_ASN1_INT64_DATA"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](long *param_1,long param_2)\n\n{\n  long lVar1;\n  \n  LOCK();\n  lVar1 = *param_1;\n  *param_1 = *param_1 + param_2;\n  return lVar1;\n}\n\n",
        "output": "The predicted function name is fetch_and_add_longlong"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  ulong uVar2;\n  BIO_METHOD *type;\n  long in_FS_OFFSET;\n  undefined4 local_44;\n  void *local_40;\n  BIO *local_38;\n  BIO *local_30;\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_44 = 0;\n  local_38 = (BIO *)0x0;\n  local_30 = BIO_new_mem_buf(\"Hello World\\n\",0xc);\n  iVar1 = FUN_000078e9(\"test/bio_memleak_test.c\",0x72,&DAT_0000d168,local_30);\n  if (iVar1 != 0) {\n    iVar1 = BIO_read(local_30,local_28,5);\n    iVar1 = FUN_00005eaa(\"test/bio_memleak_test.c\",0x74,\"BIO_read(bio, data, 5)\",&DAT_0000d22d,iVar1\n                         ,5);\n    if ((iVar1 != 0) &&\n       (iVar1 = FUN_00007e1c(\"test/bio_memleak_test.c\",0x76,&DAT_0000d24e,\"\\\"Hello\\\"\",local_28,5,\n                             \"Hello\",5), iVar1 != 0)) {\n      uVar2 = BIO_ctrl(local_30,0x73,0,&local_40);\n      iVar1 = FUN_000060a6(\"test/bio_memleak_test.c\",0x78,\"BIO_get_mem_ptr(bio, &bufmem)\",\n                           &DAT_0000d1ee,uVar2 & 0xffffffff,0);\n      if (iVar1 != 0) {\n        BIO_ctrl(local_30,9,0,(void *)0x0);\n        type = BIO_s_mem();\n        local_38 = BIO_new(type);\n        iVar1 = FUN_000078e9(\"test/bio_memleak_test.c\",0x7d,&DAT_0000d2d2,local_38);\n        if (iVar1 != 0) {\n          BIO_ctrl(local_38,0x72,1,local_40);\n          BIO_set_flags(local_38,0x200);\n          iVar1 = BIO_read(local_38,local_28,0x10);\n          iVar1 = FUN_00005eaa(\"test/bio_memleak_test.c\",0x82,\"BIO_read(bio2, data, 16)\",\n                               &DAT_0000d296,iVar1,7);\n          if ((iVar1 != 0) &&\n             (iVar1 = FUN_00007e1c(\"test/bio_memleak_test.c\",0x84,&DAT_0000d24e,\"\\\" World\\\\n\\\"\",\n                                   local_28,7,\" World\\n\",7), iVar1 != 0)) {\n            uVar2 = BIO_ctrl(local_38,1,0,(void *)0x0);\n            iVar1 = FUN_000060a6(\"test/bio_memleak_test.c\",0x86,\"BIO_reset(bio2)\",&DAT_0000d1ee,\n                                 uVar2 & 0xffffffff,0);\n            if (iVar1 != 0) {\n              iVar1 = BIO_read(local_38,local_28,0x10);\n              iVar1 = FUN_00005eaa(\"test/bio_memleak_test.c\",0x88,\"BIO_read(bio2, data, 16)\",\n                                   &DAT_0000d296,iVar1,7);\n              if ((iVar1 != 0) &&\n                 (iVar1 = FUN_00007e1c(\"test/bio_memleak_test.c\",0x8a,&DAT_0000d24e,\"\\\" World\\\\n\\\"\",\n                                       local_28,7,\" World\\n\",7), iVar1 != 0)) {\n                local_44 = 1;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  BIO_free(local_30);\n  BIO_free(local_38);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_44;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_bio_rdonly_mem_buf"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined4 param_4)\n\n{\n  EVP_CIPHER *pEVar1;\n  \n  pEVar1 = EVP_aes_128_cbc();\n  FUN_0000333c(param_1,param_2,param_3,param_4,pEVar1);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_aes128_init_key"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](void)\n\n{\n  long in_FS_OFFSET;\n  bool bVar1;\n  undefined *local_20;\n  long local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = &DAT_00211010;\n  local_18 = FUN_00002e0f(0,&local_20,4);\n  bVar1 = local_18 != 0;\n  if (bVar1) {\n    FUN_00002e81(local_18);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return bVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_uint64"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8\n[MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n            undefined8 param_5,ulong param_6)\n\n{\n  int iVar1;\n  ulong local_10;\n  \n  __gmpz_powm(param_4,param_3,param_5,param_1);\n  iVar1 = __gmpz_cmp_ui(param_4,1);\n  if ((iVar1 != 0) && (iVar1 = __gmpz_cmp(param_4,param_2), iVar1 != 0)) {\n    local_10 = 1;\n    while( true ) {\n      if (param_6 <= local_10) {\n        return 0;\n      }\n      __gmpz_powm_ui(param_4,param_4,2,param_1);\n      iVar1 = __gmpz_cmp(param_4,param_2);\n      if (iVar1 == 0) break;\n      iVar1 = __gmpz_cmp_ui(param_4,1);\n      if (iVar1 == 0) {\n        return 0;\n      }\n      local_10 = local_10 + 1;\n    }\n    return 1;\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is mp_millerrabin"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  FUN_00006a4c(param_1,param_2,param_3,param_4);\n  return;\n}\n\n",
        "output": "The predicted function name is icmp_echo_decode"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  size_t sVar3;\n  long lVar4;\n  long in_FS_OFFSET;\n  undefined8 local_198;\n  undefined8 local_190;\n  undefined8 local_188;\n  undefined8 local_180;\n  undefined8 local_178;\n  int local_168;\n  undefined4 local_164;\n  char *local_160;\n  char *local_158;\n  char *local_150;\n  undefined *local_148;\n  undefined8 local_140;\n  undefined8 local_138 [4];\n  undefined8 uStack280;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_160 = \"prf\";\n  local_158 = \"sha256\";\n  local_150 = \"test\";\n  local_148 = &DAT_00014269;\n  local_48 = 0;\n  local_40 = 0;\n  local_38 = 0;\n  local_30 = 0;\n  local_168 = 1;\n  OSSL_PARAM_construct_utf8_string(&local_198,\"digest\",\"sha256\",0);\n  local_138[0] = local_198;\n  local_138[1] = local_190;\n  local_138[2] = local_188;\n  local_138[3] = local_180;\n  uStack280 = local_178;\n  lVar4 = (long)local_168;\n  local_168 = local_168 + 1;\n  OSSL_PARAM_construct_utf8_string(&local_198,&DAT_000141e1,local_148,0);\n  local_138[lVar4 * 5] = local_198;\n  local_138[lVar4 * 5 + 1] = local_190;\n  local_138[lVar4 * 5 + 2] = local_188;\n  local_138[lVar4 * 5 + 3] = local_180;\n  local_138[lVar4 * 5 + 4] = local_178;\n  lVar4 = (long)local_168;\n  local_168 = local_168 + 1;\n  OSSL_PARAM_construct_octet_string(&local_198,&DAT_00013cfa,&DAT_00219210,0x10);\n  local_138[lVar4 * 5] = local_198;\n  local_138[lVar4 * 5 + 1] = local_190;\n  local_138[lVar4 * 5 + 2] = local_188;\n  local_138[lVar4 * 5 + 3] = local_180;\n  local_138[lVar4 * 5 + 4] = local_178;\n  sVar3 = strlen(local_160);\n  lVar4 = (long)local_168;\n  local_168 = local_168 + 1;\n  OSSL_PARAM_construct_octet_string(&local_198,&DAT_00013cf5,local_160,sVar3);\n  local_138[lVar4 * 5] = local_198;\n  local_138[lVar4 * 5 + 1] = local_190;\n  local_138[lVar4 * 5 + 2] = local_188;\n  local_138[lVar4 * 5 + 3] = local_180;\n  local_138[lVar4 * 5 + 4] = local_178;\n  sVar3 = strlen(local_150);\n  lVar4 = (long)local_168;\n  local_168 = local_168 + 1;\n  OSSL_PARAM_construct_octet_string(&local_198,&DAT_00013cfe,local_150,sVar3);\n  local_138[lVar4 * 5] = local_198;\n  local_138[lVar4 * 5 + 1] = local_190;\n  local_138[lVar4 * 5 + 2] = local_188;\n  local_138[lVar4 * 5 + 3] = local_180;\n  local_138[lVar4 * 5 + 4] = local_178;\n  lVar4 = (long)local_168;\n  OSSL_PARAM_construct_end(&local_198);\n  local_138[lVar4 * 5] = local_198;\n  local_138[lVar4 * 5 + 1] = local_190;\n  local_138[lVar4 * 5 + 2] = local_188;\n  local_138[lVar4 * 5 + 3] = local_180;\n  local_138[lVar4 * 5 + 4] = local_178;\n  local_140 = FUN_00002d68(\"KBKDF\");\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x4dc,&DAT_000141f4,local_140);\n  if (iVar1 != 0) {\n    uVar2 = EVP_KDF_derive(local_140,&local_48,0x20,local_138);\n    iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x4dd,\n                         \"EVP_KDF_derive(kctx, result, sizeof(result), params)\",&DAT_00013c2d,uVar2,\n                         0);\n    if (iVar1 != 0) {\n      iVar1 = FUN_0000e848(\"test/evp_kdf_test.c\",0x4de,\"result\",\"output\",&local_48,0x20,\n                           &DAT_00219220,0x20);\n      if (iVar1 != 0) {\n        local_164 = 1;\n        goto LAB_000084f4;\n      }\n    }\n  }\n  local_164 = 0;\nLAB_000084f4:\n  EVP_KDF_CTX_free(local_140);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_164;\n}\n\n",
        "output": "The predicted function name is test_kdf_kbkdf_8009_prf1"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](int param_1)\n\n{\n  if (param_1 == 6) {\n    return 1;\n  }\n  if (param_1 < 7) {\n    if (param_1 == 0) {\n      return 3;\n    }\n    if (param_1 == 3) {\n      return 1;\n    }\n  }\n  else {\n    if (param_1 == 0x3e) {\n      return 3;\n    }\n    if ((0x3d < param_1) && (param_1 - 0xb4U < 2)) {\n      return 2;\n    }\n  }\n  return 3;\n}\n\n",
        "output": "The predicted function name is elf_class"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](void *param_1,size_t param_2)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = realloc(param_1,param_2);\n  if ((pvVar1 == (void *)0x0) && ((param_1 == (void *)0x0 || (param_2 != 0)))) {\n    pvVar1 = (void *)FUN_0002785b();\n  }\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is my_realloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0002049c(param_1,param_2,0,0x400);\n  return;\n}\n\n",
        "output": "The predicted function name is parse_stringlist"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](undefined8 param_1,undefined4 param_2,undefined8 param_3,undefined8 param_4,\n                undefined8 param_5)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  undefined8 uVar3;\n  undefined4 local_50;\n  undefined4 local_4c;\n  undefined4 local_48;\n  int local_44;\n  char *local_40;\n  void *local_38;\n  void *local_30;\n  void *local_28;\n  char *local_20;\n  char *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar1 = __isoc99_sscanf(param_4,&DAT_0000e112,&local_50);\n  uVar3 = 0x39eb;\n  iVar2 = FUN_00008f35(\"test/http_test.c\",0xd2,\"sscanf(exp_port, \\\"%d\\\", &exp_num)\",&DAT_0000e115,\n                       uVar1,1);\n  if (iVar2 == 0) {\n    iVar2 = 0;\n    goto LAB_00003cb8;\n  }\n  iVar2 = OSSL_HTTP_parse_url(param_1,&local_48,&local_40,&local_38,&local_30,&local_4c,&local_28,\n                              &local_20,&local_18,uVar3);\n  iVar2 = FUN_0000a9e9(\"test/http_test.c\",0xd5,\n                       \"OSSL_HTTP_parse_url(url, &ssl, &user, &host, &port, &num, &path, &query, &frag)\"\n                       ,iVar2 != 0);\n  if (iVar2 == 0) {\nLAB_00003b5a:\n    local_44 = 0;\n  }\n  else {\n    iVar2 = FUN_0000aac1(\"test/http_test.c\",0xd6,&DAT_0000e199,\"exp_host\",local_38,param_3);\n    if (iVar2 == 0) goto LAB_00003b5a;\n    iVar2 = FUN_0000aac1(\"test/http_test.c\",0xd7,&DAT_0000e1a7,\"exp_port\",local_30,param_4);\n    if (iVar2 == 0) goto LAB_00003b5a;\n    iVar2 = FUN_00008f35(\"test/http_test.c\",0xd8,&DAT_0000e1b4,\"exp_num\",local_4c,local_50);\n    if (iVar2 == 0) goto LAB_00003b5a;\n    iVar2 = FUN_0000aac1(\"test/http_test.c\",0xd9,&DAT_0000e1c1,\"exp_path\",local_28,param_5);\n    if (iVar2 == 0) goto LAB_00003b5a;\n    iVar2 = FUN_00008f35(\"test/http_test.c\",0xda,&DAT_0000e1ce,\"exp_ssl\",local_48,param_2);\n    if (iVar2 == 0) goto LAB_00003b5a;\n    local_44 = 1;\n  }\n  if ((local_44 != 0) && (*local_40 != '\\0')) {\n    local_44 = FUN_0000aac1(\"test/http_test.c\",0xdc,&DAT_0000e1e8,\"\\\"user:pass\\\"\",local_40,\n                            \"user:pass\");\n  }\n  if ((local_44 != 0) && (*local_18 != '\\0')) {\n    local_44 = FUN_0000aac1(\"test/http_test.c\",0xde,&DAT_0000e1f5,&DAT_0000e1f0,local_18,\n                            &DAT_0000e1ed);\n  }\n  if ((local_44 != 0) && (*local_20 != '\\0')) {\n    local_44 = FUN_0000aac1(\"test/http_test.c\",0xe0,\"query\",&DAT_0000e1fc,local_20,&DAT_0000e1fa);\n  }\n  CRYPTO_free(local_40);\n  CRYPTO_free(local_38);\n  CRYPTO_free(local_30);\n  CRYPTO_free(local_28);\n  CRYPTO_free(local_20);\n  CRYPTO_free(local_18);\n  iVar2 = local_44;\nLAB_00003cb8:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar2;\n}\n\n",
        "output": "The predicted function name is test_http_url_ok"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long *param_1,int *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  int local_50;\n  long local_48;\n  undefined8 *local_40;\n  undefined8 *local_38;\n  undefined8 *local_30;\n  char *local_28;\n  char *local_20;\n  undefined8 *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_40 = *(undefined8 **)(*param_1 + 0x20);\n  local_38 = (undefined8 *)*local_40;\n  if (param_2 != (int *)0x0) {\n    wget_thread_mutex_lock(DAT_00253c68);\n    if (DAT_00253c70 == 0) {\n      DAT_00253c70 = wget_stringmap_create(0x80);\n      FUN_000125ae(DAT_00253c70,0);\n      FUN_000125d4(DAT_00253c70,0);\n      local_50 = 0;\n      while( true ) {\n        iVar1 = wget_vector_size(DAT_00253c60);\n        if (iVar1 <= local_50) break;\n        local_30 = (undefined8 *)wget_vector_get(DAT_00253c60,local_50);\n        FUN_00012539(DAT_00253c70,*(undefined8 *)*local_30,local_30);\n        local_50 = local_50 + 1;\n      }\n    }\n    local_28 = (char *)wget_strdup(*local_38);\n    local_20 = strrchr(local_28,0x2e);\n    if (local_20 != (char *)0x0) {\n      *local_20 = '\\0';\n    }\n    iVar1 = FUN_00012566(DAT_00253c70,local_28,&local_48);\n    if (local_28 != (char *)0x0) {\n      (*wget_free)(local_28);\n      local_28 = (char *)0x0;\n    }\n    if ((iVar1 != 0) && (local_48 != 0)) {\n      if (param_2[3] == 0) {\n        if (param_2[2] == 0) {\n          if (*param_2 == 0) {\n            if (param_2[1] != 0) {\n              *(undefined4 *)(local_48 + 0x44) = 4;\n            }\n          }\n          else {\n            *(undefined4 *)(local_48 + 0x44) = 3;\n          }\n        }\n        else {\n          *(undefined4 *)(local_48 + 0x44) = 2;\n        }\n      }\n      else {\n        *(undefined4 *)(local_48 + 0x44) = 1;\n      }\n      wget_thread_mutex_unlock(DAT_00253c68);\n      goto LAB_00012af7;\n    }\n    wget_thread_mutex_unlock(DAT_00253c68);\n  }\n  local_18 = (undefined8 *)FUN_00012510(1,0x68);\n  local_18[6] = local_40[0xf];\n  local_18[7] = local_40[0x10];\n  *local_18 = local_38;\n  *(int *)(local_18 + 8) = (int)*(short *)(param_1 + 0x18);\n  *(undefined *)(local_18 + 9) = *(undefined *)(param_1 + 0x19);\n  *(byte *)(local_18 + 0xb) =\n       *(byte *)(local_18 + 0xb) & 0xfe | *(int *)((long)local_40 + 0x94) != 0;\n  uVar2 = wget_strdup(param_1[6]);\n  local_18[10] = uVar2;\n  local_18[0xc] = param_1[0x11];\n  local_18[3] = *(undefined8 *)(*param_1 + 0x1d8);\n  local_18[4] = param_1[0xd];\n  local_18[5] = *(long *)(*param_1 + 0x1e0) - *(long *)(*param_1 + 0x1d8);\n  local_18[1] = param_1[0xf];\n  local_18[2] = *(undefined8 *)(param_1[0xc] + 8);\n  iVar1 = wget_strcasecmp_ascii(*param_1 + 0x1c8,&DAT_00041860);\n  if (iVar1 == 0) {\n    *(undefined *)((long)local_18 + 0x49) = 1;\n  }\n  else {\n    iVar1 = wget_strcasecmp_ascii(*param_1 + 0x1c8,&DAT_00041864);\n    if (iVar1 == 0) {\n      local_18[1] = param_1[0xe];\n      *(undefined *)((long)local_18 + 0x49) = 2;\n    }\n    else {\n      iVar1 = wget_strcasecmp_ascii(*param_1 + 0x1c8,&DAT_00041869);\n      if (iVar1 == 0) {\n        *(undefined *)((long)local_18 + 0x49) = 3;\n      }\n    }\n  }\n  wget_thread_mutex_lock(DAT_00253c68);\n  wget_vector_add(DAT_00253c60,local_18);\n  if (DAT_00253c70 != 0) {\n    FUN_00012539(DAT_00253c70,*(undefined8 *)*local_18,local_18);\n  }\n  wget_thread_mutex_unlock(DAT_00253c68);\nLAB_00012af7:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is stats_site_add"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,char **param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  int iVar3;\n  undefined8 uVar4;\n  size_t sVar5;\n  long lVar6;\n  long in_FS_OFFSET;\n  long local_38;\n  undefined8 local_30;\n  char *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_28 = (char *)wget_strmemdup(*param_2,param_2[1]);\n  if ((param_2[1] == (char *)0x0) || ((param_2[1] != (char *)0x0 && (**param_2 == '#')))) {\n    if (local_28 != (char *)0x0) {\n      (*wget_free)(local_28);\n      local_28 = (char *)0x0;\n    }\n    uVar4 = 0xffffffff;\n  }\n  else {\n    wget_iri_unescape_url_inline(local_28);\n    sVar5 = strlen(local_28);\n    iVar3 = wget_memiconv(param_3,local_28,sVar5,\"utf-8\",&local_38,&local_30);\n    if (local_28 != (char *)0x0) {\n      (*wget_free)(local_28);\n      local_28 = (char *)0x0;\n    }\n    if (iVar3 == 0) {\n      lVar6 = wget_iri_relative_to_abs(param_1,local_38,local_30,param_4);\n      if (local_38 != 0) {\n        (*wget_free)(local_38);\n        local_38 = 0;\n      }\n      if (lVar6 == 0) {\n        pcVar1 = *param_2;\n        pcVar2 = param_2[1];\n        uVar4 = gettext(\"Cannot resolve relative URI %.*s\\n\");\n        wget_error_printf(uVar4,(ulong)pcVar2 & 0xffffffff,pcVar1);\n        uVar4 = 0xfffffffd;\n      }\n      else {\n        uVar4 = 0;\n      }\n    }\n    else {\n      pcVar1 = *param_2;\n      pcVar2 = param_2[1];\n      uVar4 = gettext(\"URL \\'%.*s\\' not followed (conversion failed)\\n\");\n      wget_info_printf(uVar4,(ulong)pcVar2 & 0xffffffff,pcVar1);\n      uVar4 = 0xfffffffe;\n    }\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar4;\n}\n\n",
        "output": "The predicted function name is normalize_uri"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nuint [MASK](int param_1,int param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  int *piVar3;\n  char *pcVar4;\n  uint local_10;\n  \n  iVar1 = fcntl(param_1,1);\n  if (iVar1 == -1) {\n    if (param_2 != 0) {\n      piVar3 = __errno_location();\n      pcVar4 = strerror(*piVar3);\n      builtin_error(\"can\\'t get status for fd %d: %s\",param_1,pcVar4);\n    }\n    uVar2 = 0xffffffff;\n  }\n  else {\n    local_10 = fcntl(param_1,3);\n    if (local_10 == 0xffffffff) {\n      if (param_2 != 0) {\n        piVar3 = __errno_location();\n        pcVar4 = strerror(*piVar3);\n        builtin_error(\"Can\\'t get flags for fd %d: %s\",param_1,pcVar4);\n      }\n      uVar2 = 0xffffffff;\n    }\n    else {\n      if (iVar1 != 0) {\n        local_10 = local_10 | 0x80000;\n      }\n      uVar2 = FUN_00000dca();\n      uVar2 = uVar2 & local_10;\n    }\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is getflags"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long *param_1,undefined8 *param_2)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  undefined4 uVar3;\n  int iVar4;\n  long lVar5;\n  int local_2c;\n  \n  lVar1 = *param_1;\n  if (param_2[6] == 0) {\n    if (((*(byte *)(param_2 + 0x15) & 2) != 0) && (lVar1 == param_2[0xe])) {\n      *(byte *)(param_2 + 0x15) = *(byte *)(param_2 + 0x15) & 0xfb;\n      *(byte *)(param_2 + 0x15) =\n           *(byte *)(param_2 + 0x15) & 0xfd | (*(byte *)(param_2 + 0x15) >> 2 & 1) * '\\x02';\n      param_2[0xe] = 0;\n      wget_debug_printf(\"released job %s\\n\",*(undefined8 *)*param_2);\n    }\n  }\n  else {\n    for (local_2c = 0; iVar4 = wget_vector_size(param_2[6]), local_2c < iVar4;\n        local_2c = local_2c + 1) {\n      lVar5 = wget_vector_get(param_2[6],local_2c);\n      if (((*(byte *)(lVar5 + 0x20) & 1) != 0) && (lVar1 == *(long *)(lVar5 + 0x18))) {\n        *(byte *)(lVar5 + 0x20) = *(byte *)(lVar5 + 0x20) & 0xfe;\n        *(undefined8 *)(lVar5 + 0x18) = 0;\n        uVar2 = *(undefined8 *)(param_2[9] + 8);\n        uVar3 = wget_vector_size(param_2[6]);\n        wget_debug_printf(\"released chunk %d/%d %s\\n\",local_2c + 1,uVar3,uVar2);\n      }\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is _release_job"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  int local_1bc;\n  char *local_1b0;\n  uint local_1a4 [3];\n  utsname local_198;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_1a4[0] = 0xffffffff;\n  local_1a4[1] = 0xffffffff;\n  local_1a4[2] = 0xffffffff;\n  iVar1 = uname(&local_198);\n  if (iVar1 == 0) {\n    local_1b0 = strtok(local_198.release,\".\");\n    local_1bc = 0;\n    while ((local_1bc < 3 && (local_1b0 != (char *)0x0))) {\n      uVar2 = atoi(local_1b0);\n      local_1a4[local_1bc] = uVar2;\n      local_1b0 = strtok((char *)0x0,\".\");\n      local_1bc = local_1bc + 1;\n    }\n    if ((int)(local_1a4[2] + local_1a4[0] * 0x10000 + local_1a4[1] * 0x100) < 0x40100) {\n      fprintf(*(FILE **)PTR_stderr_00203ff8,\n              \"ALG_ERR: ASYNC AFALG not supported this kernel(%d.%d.%d)\\n\",(ulong)local_1a4[0],\n              (ulong)local_1a4[1],(ulong)local_1a4[2]);\n      fprintf(*(FILE **)PTR_stderr_00203ff8,\n              \"ALG_ERR: ASYNC AFALG requires kernel version %d.%d.%d or later\\n\",4,1,0);\n      FUN_00001a71(0,0x6b,\"engines/e_afalg.c\",0x354);\n      uVar3 = 0;\n    }\n    else {\n      iVar1 = socket(0x26,5,0);\n      if (iVar1 == -1) {\n        FUN_00001a71(0,0x6d,\"engines/e_afalg.c\",0x35b);\n        uVar3 = 0;\n      }\n      else {\n        close(iVar1);\n        uVar3 = 1;\n      }\n    }\n  }\n  else {\n    FUN_00001a71(0,0x6f,\"engines/e_afalg.c\",0x343);\n    uVar3 = 0;\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is afalg_chk_platform"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  *(undefined8 *)(param_1 + 0x60) = param_2;\n  *(undefined8 *)(param_1 + 0x68) = param_3;\n  return;\n}\n\n",
        "output": "The predicted function name is ping_set_event_handler"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00003658(param_1,0xd,\"dummy value\",0xd,param_2,0);\n  return;\n}\n\n",
        "output": "The predicted function name is set_cn2"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined ** [MASK](undefined8 param_1,int param_2,undefined4 *param_3)\n\n{\n  undefined **ppuVar1;\n  \n  *param_3 = 0;\n  if (param_2 == 0xc) {\n    ppuVar1 = &PTR_s_RSA_rsaEncryption_002127c0;\n  }\n  else if (param_2 == 0x16) {\n    ppuVar1 = &PTR_s_fake_rsa_00212880;\n  }\n  else if (param_2 == 10) {\n    ppuVar1 = &PTR_s_RSA_rsaEncryption_00212720;\n  }\n  else {\n    ppuVar1 = (undefined **)0x0;\n  }\n  return ppuVar1;\n}\n\n",
        "output": "The predicted function name is fake_rsa_query"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x40);\n}\n\n",
        "output": "The predicted function name is gcide_iterator_compare_count"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2,undefined8 param_3)\n\n{\n  long lVar1;\n  int iVar2;\n  undefined8 uVar3;\n  \n  lVar1 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  iVar2 = strcmp(param_2,\"N\");\n  if (iVar2 == 0) {\n    uVar3 = FUN_0000c400(param_3,lVar1 + 8);\n  }\n  else {\n    iVar2 = strcmp(param_2,\"p\");\n    if (iVar2 == 0) {\n      uVar3 = FUN_0000c400(param_3,lVar1 + 0x18);\n    }\n    else {\n      iVar2 = strcmp(param_2,\"r\");\n      if (iVar2 == 0) {\n        uVar3 = FUN_0000c400(param_3,lVar1 + 0x10);\n      }\n      else {\n        iVar2 = strcmp(param_2,\"maxmem\");\n        if (iVar2 == 0) {\n          uVar3 = FUN_0000c400(param_3,lVar1 + 0x20);\n        }\n        else {\n          uVar3 = 0;\n        }\n      }\n    }\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is scrypt_test_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  undefined8 *puVar1;\n  long lVar2;\n  int iVar3;\n  void *ptr;\n  \n  puVar1 = *(undefined8 **)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  lVar2 = puVar1[2];\n  iVar3 = EVP_KDF_CTX_set_params(*puVar1,puVar1 + 3);\n  if (iVar3 == 0) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KDF_CTRL_ERROR\";\n  }\n  else {\n    if (lVar2 == 0) {\n      iVar3 = 1;\n    }\n    else {\n      iVar3 = (int)lVar2;\n    }\n    ptr = CRYPTO_malloc(iVar3,\"test/evp_test.c\",0xae6);\n    iVar3 = FUN_00018f92(\"test/evp_test.c\",0xae6,\"got = OPENSSL_malloc(got_len == 0 ? 1 : got_len)\",\n                         ptr);\n    if (iVar3 == 0) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"INTERNAL_ERROR\";\n    }\n    else {\n      iVar3 = EVP_KDF_derive(*puVar1,ptr,lVar2,0);\n      if (iVar3 < 1) {\n        *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KDF_DERIVE_ERROR\";\n      }\n      else {\n        iVar3 = FUN_000060ba(param_1,\"KDF_MISMATCH\",puVar1[1],puVar1[2],ptr,lVar2);\n        if (iVar3 != 0) {\n          *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n        }\n      }\n    }\n    CRYPTO_free(ptr);\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is kdf_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  wget_thread_mutex_init(&DAT_00253c50);\n  DAT_00253c48 = wget_hashmap_create(0x10,FUN_00011ef8,FUN_00011e84);\n  wget_hashmap_set_key_destructor(DAT_00253c48,FUN_00011f82);\n  DAT_00253c58 = param_1;\n  wget_server_set_stats_callback(FUN_000122f7);\n  return;\n}\n\n",
        "output": "The predicted function name is server_stats_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,int param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  long local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_0000e1b9(param_1,&local_20,&local_18);\n  if ((iVar1 == 0) && (param_2 != 0)) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = wget_strmemdup(param_1 + local_20,local_18);\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is dl_get_name_from_path"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  BIO_METHOD *type;\n  BIO *bp;\n  long in_FS_OFFSET;\n  undefined4 local_a4;\n  undefined8 local_98;\n  char *local_90;\n  undefined8 local_88;\n  undefined local_78 [104];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_a4 = 0;\n  type = BIO_s_mem();\n  bp = BIO_new(type);\n  iVar1 = FUN_000078e9(\"test/bio_memleak_test.c\",0x19,&DAT_0000d168,bp);\n  if (iVar1 != 0) {\n    local_98 = 10;\n    local_90 = \"BIO test\\n\";\n    local_88 = 10;\n    BIO_ctrl(bp,0x72,0,&local_98);\n    BIO_set_flags(bp,0x200);\n    iVar1 = BIO_read(bp,local_78,100);\n    iVar1 = FUN_00005eaa(\"test/bio_memleak_test.c\",0x20,\"BIO_read(bio, buf, sizeof(buf))\",\n                         \"sizeof(str)\",iVar1,10);\n    if ((iVar1 != 0) &&\n       (iVar1 = FUN_00007e1c(\"test/bio_memleak_test.c\",0x22,&DAT_0000d1b4,&DAT_0000d1b0,local_78,10,\n                             \"BIO test\\n\",10), iVar1 != 0)) {\n      local_a4 = 1;\n    }\n  }\n  BIO_free(bp);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_a4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_bio_memleak"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong [MASK](long param_1,long param_2,long param_3)\n\n{\n  undefined2 uVar1;\n  bool bVar2;\n  char cVar3;\n  undefined uVar4;\n  int iVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  ulong uVar8;\n  undefined8 uVar9;\n  undefined8 uVar10;\n  long in_FS_OFFSET;\n  int local_e0;\n  uint local_dc;\n  uint local_d8;\n  undefined4 local_d4;\n  void *local_d0;\n  long local_c8 [19];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  switch(*(undefined2 *)(param_2 + 0x70)) {\n  default:\n    uVar9 = FUN_00013a0d(0,3,*(undefined8 *)(param_2 + 0x38));\n    uVar1 = *(undefined2 *)(param_2 + 0x70);\n    uVar10 = gettext(\"unexpected failure: fts_info=%d: %s\\nplease report to %s\");\n    error(0,0,uVar10,uVar1,uVar9,\"bug-coreutils@gnu.org\");\n                    /* WARNING: Subroutine does not return */\n    abort();\n  case 1:\n    if ((*(char *)(param_3 + 9) == '\\x01') ||\n       ((*(char *)(param_3 + 10) == '\\x01' &&\n        (cVar3 = FUN_000046ed(*(undefined4 *)(param_1 + 0x2c),*(undefined8 *)(param_2 + 0x30)),\n        cVar3 == '\\x01')))) {\n      if (*(long *)(param_2 + 0x58) == 0) {\n        uVar9 = FUN_0000f7ab(*(undefined8 *)(param_2 + 0x30));\n        cVar3 = FUN_0000464e(uVar9);\n        if (cVar3 != '\\0') {\n          uVar9 = FUN_000137cd(2,4,*(undefined8 *)(param_2 + 0x38));\n          uVar10 = FUN_000137cd(1,4,&DAT_0001dfb0);\n          uVar6 = FUN_000137cd(0,4,&DAT_0001dfb3);\n          uVar7 = gettext(\"refusing to remove %s or %s directory: skipping %s\");\n          error(0,0,uVar7,uVar6,uVar10,uVar9);\n          FUN_00004e1b(param_1,param_2);\n          uVar8 = 4;\n          break;\n        }\n        if (((*(long *)(param_3 + 0x10) != 0) &&\n            (*(long *)(param_2 + 0x80) == **(long **)(param_3 + 0x10))) &&\n           (*(long *)(param_2 + 0x78) == *(long *)(*(long *)(param_3 + 0x10) + 8))) {\n          iVar5 = strcmp(*(char **)(param_2 + 0x38),\"/\");\n          if (iVar5 == 0) {\n            uVar9 = FUN_00013893(4,*(undefined8 *)(param_2 + 0x38));\n            uVar10 = gettext(\"it is dangerous to operate recursively on %s\");\n            error(0,0,uVar10,uVar9);\n          }\n          else {\n            uVar9 = FUN_000137cd(1,4,&DAT_0001dfeb);\n            uVar10 = FUN_000137cd(0,4,*(undefined8 *)(param_2 + 0x38));\n            uVar6 = gettext(\"it is dangerous to operate recursively on %s (same as %s)\");\n            error(0,0,uVar6,uVar10,uVar9);\n          }\n          uVar9 = gettext(\"use --no-preserve-root to override this failsafe\");\n          error(0,0,uVar9);\n          FUN_00004e1b(param_1,param_2);\n          uVar8 = 4;\n          break;\n        }\n        if (*(char *)(param_3 + 0x18) != '\\0') {\n          bVar2 = false;\n          local_d0 = (void *)FUN_0000ff4b(*(undefined8 *)(param_2 + 0x30),&DAT_0001dfb0,0);\n          if ((local_d0 == (void *)0x0) || (iVar5 = FUN_0001d280(local_d0,local_c8), iVar5 != 0)) {\n            uVar9 = FUN_000137cd(1,4,*(undefined8 *)(param_2 + 0x30));\n            uVar10 = FUN_000137cd(0,4,local_d0);\n            uVar6 = gettext(\"failed to stat %s: skipping %s\");\n            error(0,0,uVar6,uVar10,uVar9);\n            bVar2 = true;\n          }\n          free(local_d0);\n          if ((bVar2) || (*(long *)(param_1 + 0x18) != local_c8[0])) {\n            if (!bVar2) {\n              uVar9 = FUN_00013893(4,*(undefined8 *)(param_2 + 0x38));\n              uVar10 = gettext(\"skipping %s, since it\\'s on a different device\");\n              error(0,0,uVar10,uVar9);\n              uVar9 = gettext(\"and --preserve-root=all is in effect\");\n              error(0,0,uVar9);\n            }\n            FUN_00004e1b(param_1,param_2);\n            uVar8 = 4;\n            break;\n          }\n        }\n      }\n      local_dc = FUN_000048e5(param_1,param_2,1,param_3,2,&local_e0);\n      if ((local_dc == 2) && (local_e0 == 4)) {\n        local_dc = FUN_00004ea4(param_1,param_2,param_3,1);\n        FUN_00004e1b(param_1,param_2);\n      }\n      if (local_dc != 2) {\n        FUN_00004e56(param_2);\n        FUN_00004e1b(param_1,param_2);\n      }\n      uVar8 = (ulong)local_dc;\n    }\n    else {\n      if (*(char *)(param_3 + 10) == '\\0') {\n        local_d4 = 0x15;\n      }\n      else {\n        local_d4 = 0x27;\n      }\n      uVar9 = FUN_00013893(4,*(undefined8 *)(param_2 + 0x38));\n      uVar10 = gettext(\"cannot remove %s\");\n      error(0,local_d4,uVar10,uVar9);\n      FUN_00004e56(param_2);\n      FUN_00004e1b(param_1,param_2);\n      uVar8 = 4;\n    }\n    break;\n  case 2:\n    uVar9 = FUN_00013a0d(0,3,*(undefined8 *)(param_2 + 0x38));\n    uVar10 = gettext(\n                    \"WARNING: Circular directory structure.\\nThis almost certainly means that you have a corrupted file system.\\nNOTIFY YOUR SYSTEM MANAGER.\\nThe following directory is part of the cycle:\\n  %s\\n\"\n                    );\n    error(0,0,uVar10,uVar9);\n    FUN_00004e1b(param_1,param_2);\n    uVar8 = 4;\n    break;\n  case 3:\n  case 4:\n  case 6:\n  case 8:\n  case 10:\n  case 0xb:\n  case 0xc:\n  case 0xd:\n    if ((((*(short *)(param_2 + 0x70) == 6) && (*(char *)(param_3 + 8) != '\\0')) &&\n        (0 < *(long *)(param_2 + 0x58))) && (*(long *)(param_2 + 0x78) != *(long *)(param_1 + 0x18))\n       ) {\n      FUN_00004e56(param_2);\n      uVar9 = FUN_00013893(4,*(undefined8 *)(param_2 + 0x38));\n      uVar10 = gettext(\"skipping %s, since it\\'s on a different device\");\n      error(0,0,uVar10,uVar9);\n      uVar8 = 4;\n    }\n    else {\n      if ((*(short *)(param_2 + 0x70) == 6) || (*(short *)(param_2 + 0x70) == 4)) {\n        uVar4 = 1;\n      }\n      else {\n        uVar4 = 0;\n      }\n      local_d8 = FUN_000048e5(param_1,param_2,uVar4,param_3,3,0);\n      if (local_d8 == 2) {\n        uVar8 = FUN_00004ea4(param_1,param_2,param_3,uVar4);\n      }\n      else {\n        uVar8 = (ulong)local_d8;\n      }\n    }\n    break;\n  case 7:\n    uVar9 = FUN_00013a0d(0,3,*(undefined8 *)(param_2 + 0x38));\n    uVar10 = gettext(\"traversal failed: %s\");\n    error(0,*(undefined4 *)(param_2 + 0x40),uVar10,uVar9);\n    FUN_00004e1b(param_1,param_2);\n    uVar8 = 4;\n  }\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar8;\n}\n\n",
        "output": "The predicted function name is rm_fts"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,code **param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  iVar1 = (**param_2)(0,param_1,param_2[1]);\n  if (iVar1 == 0) {\n    if (*(int *)(param_1 + 0x10) == 2) {\n      dico_list_iterate(*(undefined8 *)(param_1 + 0x20),FUN_0000efba,param_2);\n      iVar1 = (**param_2)(1,param_1,param_2[1]);\n      if (iVar1 != 0) {\n        return 1;\n      }\n    }\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is inorder_helper"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00010aaf(stderr,param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is write_info_stderr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void *param_1)\n\n{\n  if (*(int *)((long)param_1 + 8) == 1) {\n    dico_list_destroy((long)param_1 + 0x20);\n  }\n  free(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is outline_free_result"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int param_1,char *param_2)\n\n{\n  char cVar1;\n  undefined4 uVar2;\n  int iVar3;\n  FILE *__stream;\n  size_t sVar4;\n  ssize_t sVar5;\n  char *pcVar6;\n  ulong uVar7;\n  long in_FS_OFFSET;\n  byte bVar8;\n  int local_614;\n  int local_610;\n  char *local_608;\n  undefined local_5f8 [16];\n  char local_5e8 [208];\n  undefined local_518 [255];\n  undefined2 uStack1049;\n  undefined auStack1047 [1031];\n  long local_10;\n  \n  bVar8 = 0;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_614 = 0;\n  local_610 = DAT_0021a010;\n  __stream = fdopen(param_1,\"r\");\n  sVar4 = strlen(param_2);\n  sVar5 = write(param_1,param_2,sVar4);\n  if (sVar5 < 0) {\n    FUN_0000cdfd(\"write\");\n  }\nLAB_0000c7a2:\n  while( true ) {\n    pcVar6 = fgets(local_5e8,200,__stream);\n    if (pcVar6 == (char *)0x0) {\n      iVar3 = ferror(__stream);\n      if (iVar3 != 0) {\n        FUN_0000cdfd(\"fgets\");\n      }\n      if (local_610 == 1) {\n        FUN_0000ceeb(\n                    \"Catastrophic error: disclaimer text has been changed.\\nPlease upgrade this program.\\n\"\n                    );\n      }\n      if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    if (local_610 != 1) break;\n    sVar4 = strlen((&PTR_s_The_Data_in_Network_0021a100)[local_614 + 1]);\n    iVar3 = strncmp(local_5e8,(&PTR_s_The_Data_in_Network_0021a100)[local_614 + 1],sVar4);\n    if (iVar3 == 0) {\n      local_610 = 0;\n    }\n  }\n  if (local_610 == 0) goto code_r0x0000c581;\n  goto LAB_0000c62c;\ncode_r0x0000c581:\n  for (local_614 = 0; (&PTR_s_The_Data_in_Network_0021a100)[local_614] != (undefined *)0x0;\n      local_614 = local_614 + 2) {\n    sVar4 = strlen((&PTR_s_The_Data_in_Network_0021a100)[local_614]);\n    iVar3 = strncmp(local_5e8,(&PTR_s_The_Data_in_Network_0021a100)[local_614],sVar4);\n    if (iVar3 == 0) {\n      local_610 = 1;\n      break;\n    }\n  }\n  if (local_610 != 1) {\nLAB_0000c62c:\n    iVar3 = strncmp(local_5e8,\"% referto:\",10);\n    if ((iVar3 == 0) &&\n       (iVar3 = sscanf(local_5e8,\"%% referto: whois -h %255s -p %15s %1021[^\\n\\r]\",local_518,\n                       local_5f8,(long)&uStack1049 + 1), iVar3 == 3)) {\n      if (DAT_00220fb0 != 0) {\n        printf(\"Detected referral to %s on %s.\\n\",(long)&uStack1049 + 1,local_518);\n      }\n      uVar7 = 0xffffffffffffffff;\n      pcVar6 = (char *)((long)&uStack1049 + 1);\n      do {\n        if (uVar7 == 0) break;\n        uVar7 = uVar7 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + (ulong)bVar8 * -2 + 1;\n      } while (cVar1 != '\\0');\n      *(undefined2 *)((long)&uStack1049 + ~uVar7) = 0xa0d;\n      *(undefined *)((long)&uStack1049 + ~uVar7 + 2) = 0;\n      uVar2 = FUN_0000ca89(local_518,local_5f8);\n      FUN_0000c458(uVar2,(long)&uStack1049 + 1);\n      FUN_0000cc04(uVar2);\n    }\n    else {\n      for (local_608 = local_5e8;\n          ((*local_608 != '\\0' && (*local_608 != '\\r')) && (*local_608 != '\\n'));\n          local_608 = local_608 + 1) {\n      }\n      *local_608 = '\\0';\n      fprintf(stdout,\"%s\\n\",local_5e8);\n    }\n  }\n  goto LAB_0000c7a2;\n}\n\n",
        "output": "The predicted function name is do_query"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long in_FS_OFFSET;\n  undefined4 local_54;\n  undefined4 local_50;\n  undefined4 local_4c;\n  undefined8 local_48;\n  void *local_40;\n  undefined local_38 [40];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_4c = 0;\n  local_48 = 0;\n  local_54 = 0x1000;\n  local_50 = 0;\n  local_40 = (void *)FUN_0000511d(\"passwordPASSWORDpassword\",\"sha256\",\n                                  \"saltSALTsaltSALTsaltSALTsaltSALTsalt\",&local_54,&local_50);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x266,\"params\",local_40);\n  if (iVar1 != 0) {\n    local_48 = FUN_00002d68(\"PBKDF2\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x267,\"kctx = get_kdfbyname(OSSL_KDF_NAME_PBKDF2)\",\n                         local_48);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_48,local_40);\n      iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0x268,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        uVar2 = EVP_KDF_derive(local_48,local_38,0xd,0);\n        iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x26a,\n                             \"EVP_KDF_derive(kctx, out, 112 / 8 - 1, NULL)\",&DAT_00013c2d,uVar2,0);\n        if (iVar1 != 0) {\n          local_4c = 1;\n        }\n      }\n    }\n  }\n  EVP_KDF_CTX_free(local_48);\n  CRYPTO_free(local_40);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_4c;\n}\n\n",
        "output": "The predicted function name is test_kdf_pbkdf2_small_output"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x10);\n}\n\n",
        "output": "The predicted function name is impl_file_get_local_filename"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 * [MASK](undefined8 *param_1,undefined8 *param_2,byte param_3)\n\n{\n  undefined8 *local_10;\n  \n  if (param_1 == (undefined8 *)0x0) {\n    local_10 = (undefined8 *)FUN_0000fafe(1,0xb0);\n  }\n  else {\n    memset(param_1,0,0xb0);\n    local_10 = param_1;\n  }\n  local_10[9] = param_2;\n  *local_10 = *param_2;\n  *(byte *)((long)local_10 + 0xa9) = *(byte *)((long)local_10 + 0xa9) & 0xfe | param_3 & 1;\n  DAT_00253c18 = DAT_00253c18 + 1;\n  local_10[0xf] = DAT_00253c18;\n  return local_10;\n}\n\n",
        "output": "The predicted function name is job_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  long local_28;\n  void *local_20;\n  long local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  local_20 = (void *)0x0;\n  iVar1 = EVP_DigestSign(*(undefined8 *)(local_18 + 0x10),0,&local_28,\n                         *(undefined8 *)(local_18 + 0x28),*(undefined8 *)(local_18 + 0x30));\n  if (iVar1 == 0) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DIGESTSIGN_LENGTH_ERROR\";\n  }\n  else {\n    local_20 = CRYPTO_malloc((int)local_28,\"test/evp_test.c\",0xd36);\n    iVar1 = FUN_00018f92(\"test/evp_test.c\",0xd36,\"got = OPENSSL_malloc(got_len)\",local_20);\n    if (iVar1 == 0) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"MALLOC_FAILURE\";\n    }\n    else {\n      local_28 = local_28 * 2;\n      iVar1 = EVP_DigestSign(*(undefined8 *)(local_18 + 0x10),local_20,&local_28,\n                             *(undefined8 *)(local_18 + 0x28),*(undefined8 *)(local_18 + 0x30));\n      if (iVar1 == 0) {\n        *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DIGESTSIGN_ERROR\";\n      }\n      else {\n        iVar1 = FUN_000060ba(param_1,\"SIGNATURE_MISMATCH\",*(undefined8 *)(local_18 + 0x38),\n                             *(undefined8 *)(local_18 + 0x40),local_20,local_28);\n        if (iVar1 != 0) {\n          *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n        }\n      }\n    }\n  }\n  CRYPTO_free(local_20);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is oneshot_digestsign_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](long param_1,int *param_2)\n\n{\n  int iVar1;\n  ushort **ppuVar2;\n  undefined8 uVar3;\n  long lVar4;\n  long in_FS_OFFSET;\n  long local_b8;\n  char *local_b0;\n  undefined8 local_a8;\n  long local_a0;\n  char local_98 [136];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_0000170d(param_1,local_98,0x80,&local_b8);\n  if (iVar1 == 0) {\n    lVar4 = 0;\n  }\n  else {\n    *param_2 = iVar1;\n    for (local_b0 = local_98 + iVar1; *local_b0 != '\\0'; local_b0 = local_b0 + 1) {\n      ppuVar2 = __ctype_b_loc();\n      if (((*ppuVar2)[*local_b0] & 0x2000) == 0) break;\n    }\n    local_a8 = FUN_0000169c(local_b0);\n    local_a0 = FUN_0000184b(local_b0,local_a8);\n    if (local_a0 == 0) {\n      lVar4 = 0;\n    }\n    else {\n      uVar3 = FUN_000017bc(param_1,local_98,0x80);\n      *(undefined8 *)(local_a0 + 0x18) = uVar3;\n      FUN_0000170d(param_1,local_98,0x80,&local_b8);\n      fseek(*(FILE **)(param_1 + 8),-local_b8,1);\n      lVar4 = ftell(*(FILE **)(param_1 + 8));\n      *(long *)(local_a0 + 0x20) = lVar4 - *(long *)(local_a0 + 0x18);\n      lVar4 = local_a0;\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return lVar4;\n}\n\n",
        "output": "The predicted function name is read_entry"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = 0;\n  local_30 = 0;\n  local_28 = 0;\n  local_20 = 0;\n  ptr = (void *)FUN_000076f4(\"sha256\",&DAT_00014269,&DAT_00219202,0,&DAT_00014265,&DAT_00014260);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x47e,\"params\",ptr);\n  if (iVar1 == 0) {\n    uVar2 = 0;\n    goto LAB_00007d77;\n  }\n  uVar3 = FUN_00002d68(\"KBKDF\");\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x483,&DAT_000141f4,uVar3);\n  if (iVar1 == 0) {\nLAB_00007d48:\n    uVar2 = 0;\n  }\n  else {\n    iVar1 = EVP_KDF_CTX_set_params(uVar3,ptr);\n    iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0x484,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                         iVar1 != 0);\n    if (iVar1 == 0) goto LAB_00007d48;\n    uVar2 = EVP_KDF_derive(uVar3,&local_38,0x20,0);\n    iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x485,\n                         \"EVP_KDF_derive(kctx, result, sizeof(result), NULL)\",&DAT_00013c2d,uVar2,0)\n    ;\n    if (iVar1 == 0) goto LAB_00007d48;\n    uVar2 = 1;\n  }\n  EVP_KDF_CTX_free(uVar3);\n  CRYPTO_free(ptr);\nLAB_00007d77:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_kbkdf_empty_key"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined * [MASK](void)\n\n{\n  int iVar1;\n  undefined *puVar2;\n  \n  puVar2 = (undefined *)CRYPTO_malloc(1,\"test/fake_rsaprov.c\",0x78);\n  iVar1 = FUN_0000879a(\"test/fake_rsaprov.c\",0x78,\"gctx = OPENSSL_malloc(1)\",puVar2);\n  if (iVar1 == 0) {\n    puVar2 = (undefined *)0x0;\n  }\n  else {\n    *puVar2 = 1;\n  }\n  return puVar2;\n}\n\n",
        "output": "The predicted function name is fake_rsa_gen_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  EVP_DigestSignUpdate(param_1,param_2,param_3);\n  return;\n}\n\n",
        "output": "The predicted function name is digestsign_update_fn"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  long lVar1;\n  \n  lVar1 = wget_read_file(param_2,0);\n  if (lVar1 != 0) {\n    FUN_0001b83f(param_1,lVar1,param_3,param_4);\n    (*wget_free)(lVar1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is rss_parse_localfile"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined * [MASK](void)\n\n{\n  return &DAT_00210760;\n}\n\n",
        "output": "The predicted function name is ASN1_UINT32_DATA_it"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return *(undefined8 *)PTR_gcide_markup_yyin_00212fc0;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyget_in"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  return param_1;\n}\n\n",
        "output": "The predicted function name is ossl_check_OPENSSL_STRING_freefunc_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,char *param_2)\n\n{\n  char *pcVar1;\n  \n  CRYPTO_free(*(void **)(param_1 + 0x28));\n  pcVar1 = CRYPTO_strdup(param_2,\"test/helpers/ssl_test_ctx.c\",399);\n  *(char **)(param_1 + 0x28) = pcVar1;\n  FUN_000146a7(\"test/helpers/ssl_test_ctx.c\",399,\"ctx->reneg_ciphers\",\n               *(undefined8 *)(param_1 + 0x28));\n  return;\n}\n\n",
        "output": "The predicted function name is parse_client_reneg_ciphers"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = FUN_000044b1(&DAT_00013d10,5);\n  if ((((iVar1 != 0) && (iVar1 = FUN_000044b1(&DAT_00013cfa,4), iVar1 != 0)) &&\n      (iVar1 = FUN_000044b1(&DAT_00013cf5,4), iVar1 != 0)) &&\n     (iVar1 = FUN_000044b1(&DAT_00013cfe,4), iVar1 != 0)) {\n    return 1;\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is test_kdf_hkdf_set_ctx_param_fail"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](char *param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  long in_FS_OFFSET;\n  undefined local_b8 [24];\n  uint local_a0;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_0000f6f0(param_1,local_b8);\n  if (iVar1 == 0) {\n    if ((local_a0 & 0xf000) == 0x4000) {\n      iVar1 = access(param_1,4);\n      if (iVar1 == 0) {\n        uVar2 = 0;\n      }\n      else {\n        uVar2 = gettext(\"gcide: `%s\\' is not readable\");\n        dico_log(4,0,uVar2,param_1);\n        uVar2 = 1;\n      }\n    }\n    else {\n      uVar2 = gettext(\"gcide: `%s\\' is not a directory\");\n      dico_log(4,0,uVar2,param_1);\n      uVar2 = 1;\n    }\n  }\n  else {\n    uVar2 = gettext(\"gcide: cannot stat `%s\\'\");\n    piVar3 = __errno_location();\n    dico_log(4,*piVar3,uVar2,param_1);\n    uVar2 = 1;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is gcide_check_dir"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  int iVar1;\n  int iVar2;\n  ulong uVar3;\n  undefined8 uVar4;\n  \n  uVar3 = ERR_peek_last_error();\n  iVar1 = FUN_00005fd2(uVar3);\n  iVar2 = FUN_00005ffc(uVar3);\n  if ((((iVar1 == 6) && (iVar2 == 0x9c)) || ((iVar1 == 6 && (iVar2 == 0x72)))) || (iVar2 == 0x8010c)\n     ) {\n    ERR_clear_error();\n    uVar4 = 1;\n  }\n  else if ((iVar1 == 0x10) && ((iVar2 == 0x81 || (iVar2 == 0x8d)))) {\n    ERR_clear_error();\n    uVar4 = 1;\n  }\n  else {\n    uVar4 = 0;\n  }\n  return uVar4;\n}\n\n",
        "output": "The predicted function name is key_unsupported"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  CRYPTO_free(*(void **)(param_1 + 0x10));\n  CRYPTO_free(*(void **)(param_1 + 0x50));\n  CRYPTO_free(*(void **)(param_1 + 0x90));\n  CRYPTO_free(*(void **)(param_1 + 0x18));\n  CRYPTO_free(*(void **)(param_1 + 0x58));\n  CRYPTO_free(*(void **)(param_1 + 0x98));\n  CRYPTO_free(*(void **)(param_1 + 0x28));\n  CRYPTO_free(*(void **)(param_1 + 0x68));\n  CRYPTO_free(*(void **)(param_1 + 0x70));\n  CRYPTO_free(*(void **)(param_1 + 0xa8));\n  CRYPTO_free(*(void **)(param_1 + 0xb0));\n  CRYPTO_free(*(void **)(param_1 + 0x30));\n  CRYPTO_free(*(void **)(param_1 + 0x38));\n  CRYPTO_free(*(void **)(param_1 + 0x80));\n  CRYPTO_free(*(void **)(param_1 + 0xc0));\n  return;\n}\n\n",
        "output": "The predicted function name is ssl_test_extra_conf_free_data"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined4 param_2,undefined4 param_3,undefined8 param_4)\n\n{\n  if (DAT_002053c8 == (code *)0x0) {\n    EVP_PKEY_meth_get_ctrl(DAT_00205350,&DAT_002053c8,0);\n  }\n  (*DAT_002053c8)(param_1,param_2,param_3,param_4);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_rsa_ctrl"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,long param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  size_t local_18;\n  size_t local_10;\n  \n  local_18 = 0;\n  local_10 = 0;\n  if (*(long *)(param_1 + 0xa0) != 0) {\n    local_18 = strlen(*(char **)(param_1 + 0xa0));\n  }\n  if (*(long *)(param_2 + 0x228) != 0) {\n    local_10 = strlen(*(char **)(param_2 + 0x228));\n  }\n  if ((local_18 == 0) && (local_10 == 0)) {\n    uVar2 = 1;\n  }\n  else {\n    iVar1 = FUN_000147f4(\"test/ssl_test.c\",0xd1,\"result->result_session_ticket_app_data\",\n                         \"test_ctx->expected_session_ticket_app_data\",\n                         *(undefined8 *)(param_1 + 0xa0),*(undefined8 *)(param_2 + 0x228));\n    if (iVar1 == 0) {\n      uVar2 = 0;\n    }\n    else {\n      uVar2 = 1;\n    }\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is check_session_ticket_app_data"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_00003f0e(\"htttps://1.2.3.4:65535/pkix\");\n  return;\n}\n\n",
        "output": "The predicted function name is test_http_url_invalid_prefix"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](undefined4 *param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_14;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_00009ddc(&PTR_DAT_0021f0e0,2,&local_14,param_2);\n  if (iVar1 != 0) {\n    *param_1 = local_14;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1 != 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is parse_test_method"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return 1;\n}\n\n",
        "output": "The predicted function name is afalg_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long *param_1)\n\n{\n  int iVar1;\n  \n  FUN_0000cc6f(param_1);\n  dico_list_append(DAT_00215a70,DAT_00215a78);\n  DAT_00215a78 = param_1;\n  if ((*param_1 != 0) && (iVar1 = strcmp(*(char **)param_1[1],\"grk\"), iVar1 == 0)) {\n    DAT_00215b58 = 1;\n    return;\n  }\n  DAT_00215b58 = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is push_tag"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 * [MASK](char *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  long lVar1;\n  int iVar2;\n  size_t sVar3;\n  long lVar4;\n  undefined8 *puVar5;\n  code *pcVar6;\n  long in_FS_OFFSET;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar3 = strlen(param_1);\n  lVar4 = FUN_0000e064(param_2,param_3);\n  if (lVar4 == 0) {\n    puVar5 = (undefined8 *)0x0;\n  }\n  else {\n    puVar5 = (undefined8 *)FUN_00010d0c(sVar3 + 0x41);\n    puVar5[4] = 0;\n    puVar5[5] = 0;\n    puVar5[6] = 0;\n    puVar5[7] = 0;\n    wget_strscpy(puVar5 + 8,param_1,sVar3 + 1);\n    *puVar5 = 0;\n    puVar5[1] = &PTR_FUN_00253040;\n    puVar5[2] = puVar5 + 8;\n    puVar5[3] = lVar4;\n    pcVar6 = (code *)FUN_0000e12d(lVar4,\"wget_plugin_initializer\",param_3);\n    if (pcVar6 == (code *)0x0) {\n      FUN_00011260(puVar5);\n      puVar5 = (undefined8 *)0x0;\n    }\n    else {\n      iVar2 = (*pcVar6)(puVar5);\n      if (iVar2 == 0) {\n        wget_vector_add(DAT_00253c30,puVar5);\n        FUN_00010d2a(DAT_00253c38,puVar5[2],puVar5);\n      }\n      else {\n        FUN_0000defe(param_3,\"Plugin failed to initialize\");\n        FUN_00011260(puVar5);\n        puVar5 = (undefined8 *)0x0;\n      }\n    }\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar5;\n}\n\n",
        "output": "The predicted function name is load_plugin"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_2c;\n  undefined4 local_28;\n  undefined4 local_24;\n  undefined8 local_20;\n  void *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_24 = 0;\n  local_20 = 0;\n  local_2c = 0x1000;\n  local_28 = 0;\n  local_18 = (void *)FUN_0000511d(\"passwordPASSWORDpassword\",&DAT_00013c6c,\n                                  \"saltSALTsaltSALTsaltSALTsaltSALTsalt\",&local_2c,&local_28);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x31b,\"params\",local_18);\n  if (iVar1 != 0) {\n    local_20 = FUN_00002d68(\"PBKDF2\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x31c,\"kctx = get_kdfbyname(OSSL_KDF_NAME_PBKDF2)\",\n                         local_20);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_20,local_18);\n      iVar1 = FUN_0000e3f6(\"test/evp_kdf_test.c\",0x31e,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        local_24 = 1;\n      }\n    }\n  }\n  EVP_KDF_CTX_free(local_20);\n  CRYPTO_free(local_18);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_24;\n}\n\n",
        "output": "The predicted function name is test_kdf_pbkdf2_invalid_digest"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](byte *param_1)\n\n{\n  byte *local_20;\n  int local_c;\n  \n  local_c = 0;\n  for (local_20 = param_1; *local_20 != 0; local_20 = local_20 + 1) {\n    local_c = (uint)*local_20 + local_c * 0x65;\n  }\n  return local_c;\n}\n\n",
        "output": "The predicted function name is hash_url"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  undefined4 uVar1;\n  long lVar2;\n  \n  lVar2 = FUN_0002066a(param_2,0x2d);\n  uVar1 = FUN_0002049c(param_1,lVar2,0,0x400);\n  if ((lVar2 != 0) && (lVar2 != 0)) {\n    (*wget_free)(lVar2);\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is parse_excluded_directories"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  undefined4 uVar1;\n  long in_FS_OFFSET;\n  void *local_20;\n  long local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = (void *)0x0;\n  local_18 = FUN_00003d49(param_1,&local_20,1);\n  if (local_18 == 0) {\n    uVar1 = 0xffffffff;\n  }\n  else {\n    uVar1 = FUN_000039d3(local_20,local_18,param_2,param_3,param_4);\n    CRYPTO_free(local_20);\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is do_decode_custom"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  FUN_00016b1c(param_1);\n  ERR_clear_error();\n  if (*(long *)(\"EVP_PKEY_verify_recover_init\" + param_1) != 0) {\n    if (*(long *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0xf) != 0) {\n      (**(code **)(*(long *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0xf) + 0x10))(param_1);\n    }\n    CRYPTO_free(*(void **)(\"EVP_PKEY_verify_recover_init\" + param_1));\n    *(undefined8 *)(\"EVP_PKEY_verify_recover_init\" + param_1) = 0;\n  }\n  CRYPTO_free(*(void **)(\"EVP_CIPHER_CTX_set_flags\" + param_1 + 9));\n  *(undefined8 *)(\"EVP_CIPHER_CTX_set_flags\" + param_1 + 9) = 0;\n  CRYPTO_free(*(void **)(\"EVP_CIPHER_CTX_set_flags\" + param_1 + 0x11));\n  *(undefined8 *)(\"EVP_CIPHER_CTX_set_flags\" + param_1 + 0x11) = 0;\n  *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n  *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 0;\n  *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0xf) = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is clear_test"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,long param_2)\n\n{\n  FUN_0000c6ad(\"Server certificate\",*(undefined4 *)(param_2 + 0x1e0),*(undefined4 *)(param_1 + 100))\n  ;\n  return;\n}\n\n",
        "output": "The predicted function name is check_server_cert_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  long lVar1;\n  char cVar2;\n  undefined8 uVar3;\n  \n  lVar1 = DAT_00253360;\n  if (DAT_00253360 == 0) {\n    uVar3 = gettext(\"Password: \");\n    wget_fprintf(stderr,uVar3);\n  }\n  else {\n    uVar3 = gettext(\"Password for user \\\"%s\\\": \");\n    wget_fprintf(stderr,uVar3,lVar1);\n  }\n  cVar2 = FUN_000279a5();\n  if (cVar2 == '\\x01') {\n    wget_strdup(&DAT_0004684c);\n  }\n  else {\n    getpass(\"\");\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is prompt_for_password"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](char *param_1,char *param_2)\n\n{\n  int iVar1;\n  char *local_18;\n  char *local_10;\n  \n  for (local_18 = param_1; local_10 = param_2, *local_18 != '\\0'; local_18 = local_18 + 1) {\n  }\n  for (; *local_10 != '\\0'; local_10 = local_10 + 1) {\n  }\n  while( true ) {\n    local_10 = local_10 + -1;\n    local_18 = local_18 + -1;\n    if (((local_18 < param_1) || (local_10 < param_2)) ||\n       (iVar1 = tolower((int)*local_18), iVar1 != *local_10)) break;\n    if (local_10 == param_2) {\n      return 1;\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is domcmp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long *param_1,long param_2)\n\n{\n  int iVar1;\n  undefined8 *puVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined4 local_28;\n  undefined4 local_24;\n  byte local_20;\n  byte local_1f;\n  undefined local_1e;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  puVar2 = (undefined8 *)FUN_00011e66(0x18);\n  uVar3 = wget_http_get_host(param_1);\n  uVar3 = wget_strdup(uVar3);\n  *puVar2 = uVar3;\n  uVar3 = wget_tcp_get_ip(*param_1);\n  uVar3 = wget_strdup(uVar3);\n  puVar2[1] = uVar3;\n  *(undefined4 *)(puVar2 + 2) = *(undefined4 *)((long)param_1 + 0x2c);\n  wget_thread_mutex_lock(DAT_00253c50);\n  iVar1 = wget_hashmap_contains(DAT_00253c48,puVar2);\n  if (iVar1 == 0) {\n    local_38 = *puVar2;\n    local_30 = puVar2[1];\n    local_24 = *(undefined4 *)(puVar2 + 2);\n    local_28 = *(undefined4 *)(*param_1 + 0x5c);\n    if (param_2 == 0) {\n      local_1e = 0xff;\n      local_20 = 0xff;\n      local_1f = 0xff;\n    }\n    else {\n      local_1e = *(long *)(param_2 + 0x28) != 0;\n      local_20 = *(byte *)(param_2 + 0xcb) >> 2 & 1;\n      local_1f = *(byte *)(param_2 + 0xcb) >> 3 & 1;\n    }\n    FUN_0001205b(&local_38);\n    wget_hashmap_put(DAT_00253c48,puVar2,puVar2);\n  }\n  else {\n    FUN_00011f82(puVar2);\n  }\n  wget_thread_mutex_unlock(DAT_00253c50);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is server_stats_add"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long *param_1)\n\n{\n  if (*(short *)(param_1 + 0x18) == 200) {\n    if (*(long *)(*(long *)(*param_1 + 0x20) + 0x60) == 0) {\n      FUN_00012eb7(&DAT_00253ca0);\n    }\n    else {\n      FUN_00012eb7(&DAT_00253cb0);\n    }\n  }\n  else if ((((*(short *)(param_1 + 0x18) == 0x12d) || (*(short *)(param_1 + 0x18) == 0x12e)) ||\n           (*(short *)(param_1 + 0x18) == 0x12f)) ||\n          ((*(short *)(param_1 + 0x18) == 0x133 || (*(short *)(param_1 + 0x18) == 0x134)))) {\n    FUN_00012eb7(&DAT_00253ca4);\n  }\n  else if (*(short *)(param_1 + 0x18) == 0x130) {\n    FUN_00012eb7(&DAT_00253ca8);\n  }\n  else {\n    FUN_00012eb7(&DAT_00253cac);\n  }\n  if (DAT_00253348 != 0) {\n    FUN_000126e1(param_1,0);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is add_statistics"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined4 param_1)\n\n{\n  FUN_00009e5e(&PTR_s_Simple_0021f100,7,param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is ssl_handshake_mode_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  long local_10;\n  \n  for (local_10 = *(long *)(param_1 + 8);\n      (-1 < *(long *)(local_10 + 0x58) && (*(long *)(local_10 + 0x20) == 0));\n      local_10 = *(long *)(local_10 + 8)) {\n    *(undefined8 *)(local_10 + 0x20) = 1;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is mark_ancestor_dirs"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](char **param_1,char *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  char **local_40;\n  in_addr local_30;\n  int local_2c;\n  ulong **local_28;\n  char *local_20;\n  hostent *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_2c = 0;\n  local_2c = inet_aton(param_2,&local_30);\n  local_40 = param_1;\n  do {\n    if (*local_40 == (char *)0x0) {\n      uVar2 = 0;\nLAB_0000c161:\n      if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n      return uVar2;\n    }\n    local_20 = *local_40;\n    iVar1 = strcmp(local_20,param_2);\n    if (iVar1 == 0) {\n      uVar2 = 1;\n      goto LAB_0000c161;\n    }\n    if (local_2c != 0) {\n      local_18 = gethostbyname(local_20);\n      if (local_18 != (hostent *)0x0) {\n        for (local_28 = (ulong **)local_18->h_addr_list; *local_28 != (ulong *)0x0;\n            local_28 = local_28 + 1) {\n          if (**local_28 == (ulong)local_30) {\n            uVar2 = 1;\n            goto LAB_0000c161;\n          }\n        }\n      }\n    }\n    local_40 = local_40 + 1;\n  } while( true );\n}\n\n",
        "output": "The predicted function name is is_ripe_server"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](double *param_1)\n\n{\n  double in_stack_00000008;\n  double in_stack_00000010;\n  double in_stack_00000018;\n  double in_stack_00000020;\n  double in_stack_00000028;\n  double in_stack_00000030;\n  \n  *param_1 = in_stack_00000030 * in_stack_00000010 - in_stack_00000028 * in_stack_00000018;\n  param_1[1] = in_stack_00000020 * in_stack_00000018 - in_stack_00000030 * in_stack_00000008;\n  param_1[2] = in_stack_00000028 * in_stack_00000008 - in_stack_00000020 * in_stack_00000010;\n  return;\n}\n\n",
        "output": "The predicted function name is cross"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (*(long *)(param_1 + 0x28) == 0) {\n    uVar1 = 0;\n  }\n  else {\n    uVar1 = FUN_00002b0e(param_1,*(undefined8 *)(param_1 + 0x28),0);\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is outline_info"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined uVar3;\n  uint uVar4;\n  undefined4 uVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  long in_FS_OFFSET;\n  undefined8 uVar8;\n  long local_70;\n  undefined local_68 [16];\n  undefined local_58 [24];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_002533d2 != '\\0') {\n    if (DAT_002533c4 == 0) {\n      uVar3 = 0x42;\n    }\n    else {\n      uVar3 = 0x62;\n    }\n    local_70 = wget_get_timemillis();\n    iVar2 = DAT_00253cac;\n    local_70 = local_70 - param_1;\n    if (local_70 == 0) {\n      local_70 = 1;\n    }\n    if (DAT_002533c4 == 0) {\n      uVar4 = 1000;\n    }\n    else {\n      uVar4 = 8000;\n    }\n    if (DAT_00253407 == '\\0') {\n      uVar5 = FUN_0000fad2();\n      iVar1 = DAT_00253ca4;\n      uVar6 = wget_human_readable(local_58,0x10,(long)(DAT_00253ce0 * (ulong)uVar4) / local_70);\n      uVar8 = 0x1636e;\n      uVar7 = wget_human_readable(local_68,0x10,DAT_00253ce0);\n      FUN_0000d394(DAT_00253cf4,\"Files: %d  Bytes: %s [%s%c/s] Redirects: %d  Todo: %d  Errors: %d\",\n                   DAT_00253ca0,uVar7,uVar6,uVar3,iVar1,uVar5,iVar2,uVar8);\n    }\n    else {\n      uVar5 = FUN_0000fad2();\n      uVar6 = wget_human_readable(local_58,0x10,(long)(DAT_00253ce0 * (ulong)uVar4) / local_70);\n      uVar8 = 0x162ac;\n      uVar7 = wget_human_readable(local_68,0x10,DAT_00253ce0);\n      FUN_0000d394(DAT_00253cf4,\"Headers: %d (%d redirects & %d errors) Bytes: %s [%s%c/s] Todo: %d\"\n                   ,DAT_00253cac + DAT_00253ca0 + DAT_00253ca4 + DAT_00253ca8,DAT_00253ca4,\n                   DAT_00253cac,uVar7,uVar6,uVar3,uVar5,uVar8);\n    }\n  }\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is print_progress_report"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  size_t sVar3;\n  long lVar4;\n  long in_FS_OFFSET;\n  undefined8 local_1a8;\n  undefined8 local_1a0;\n  undefined8 local_198;\n  undefined8 local_190;\n  undefined8 local_188;\n  int local_178;\n  undefined4 local_174;\n  char *local_170;\n  char *local_168;\n  char *local_160;\n  undefined *local_158;\n  undefined8 local_150;\n  undefined8 local_148 [4];\n  undefined8 uStack296;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_170 = \"prf\";\n  local_168 = \"sha384\";\n  local_160 = \"test\";\n  local_158 = &DAT_00014269;\n  local_58 = 0;\n  local_50 = 0;\n  local_48 = 0;\n  local_40 = 0;\n  local_38 = 0;\n  local_30 = 0;\n  local_178 = 1;\n  OSSL_PARAM_construct_utf8_string(&local_1a8,\"digest\",\"sha384\",0);\n  local_148[0] = local_1a8;\n  local_148[1] = local_1a0;\n  local_148[2] = local_198;\n  local_148[3] = local_190;\n  uStack296 = local_188;\n  lVar4 = (long)local_178;\n  local_178 = local_178 + 1;\n  OSSL_PARAM_construct_utf8_string(&local_1a8,&DAT_000141e1,local_158,0);\n  local_148[lVar4 * 5] = local_1a8;\n  local_148[lVar4 * 5 + 1] = local_1a0;\n  local_148[lVar4 * 5 + 2] = local_198;\n  local_148[lVar4 * 5 + 3] = local_190;\n  local_148[lVar4 * 5 + 4] = local_188;\n  lVar4 = (long)local_178;\n  local_178 = local_178 + 1;\n  OSSL_PARAM_construct_octet_string(&local_1a8,&DAT_00013cfa,&DAT_00219240,0x20);\n  local_148[lVar4 * 5] = local_1a8;\n  local_148[lVar4 * 5 + 1] = local_1a0;\n  local_148[lVar4 * 5 + 2] = local_198;\n  local_148[lVar4 * 5 + 3] = local_190;\n  local_148[lVar4 * 5 + 4] = local_188;\n  sVar3 = strlen(local_170);\n  lVar4 = (long)local_178;\n  local_178 = local_178 + 1;\n  OSSL_PARAM_construct_octet_string(&local_1a8,&DAT_00013cf5,local_170,sVar3);\n  local_148[lVar4 * 5] = local_1a8;\n  local_148[lVar4 * 5 + 1] = local_1a0;\n  local_148[lVar4 * 5 + 2] = local_198;\n  local_148[lVar4 * 5 + 3] = local_190;\n  local_148[lVar4 * 5 + 4] = local_188;\n  sVar3 = strlen(local_160);\n  lVar4 = (long)local_178;\n  local_178 = local_178 + 1;\n  OSSL_PARAM_construct_octet_string(&local_1a8,&DAT_00013cfe,local_160,sVar3);\n  local_148[lVar4 * 5] = local_1a8;\n  local_148[lVar4 * 5 + 1] = local_1a0;\n  local_148[lVar4 * 5 + 2] = local_198;\n  local_148[lVar4 * 5 + 3] = local_190;\n  local_148[lVar4 * 5 + 4] = local_188;\n  lVar4 = (long)local_178;\n  OSSL_PARAM_construct_end(&local_1a8);\n  local_148[lVar4 * 5] = local_1a8;\n  local_148[lVar4 * 5 + 1] = local_1a0;\n  local_148[lVar4 * 5 + 2] = local_198;\n  local_148[lVar4 * 5 + 3] = local_190;\n  local_148[lVar4 * 5 + 4] = local_188;\n  local_150 = FUN_00002d68(\"KBKDF\");\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x508,&DAT_000141f4,local_150);\n  if (iVar1 != 0) {\n    uVar2 = EVP_KDF_derive(local_150,&local_58,0x30,local_148);\n    iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x509,\n                         \"EVP_KDF_derive(kctx, result, sizeof(result), params)\",&DAT_00013c2d,uVar2,\n                         0);\n    if (iVar1 != 0) {\n      iVar1 = FUN_0000e848(\"test/evp_kdf_test.c\",0x50a,\"result\",\"output\",&local_58,0x30,\n                           &DAT_00219260,0x30);\n      if (iVar1 != 0) {\n        local_174 = 1;\n        goto LAB_000089ad;\n      }\n    }\n  }\n  local_174 = 0;\nLAB_000089ad:\n  EVP_KDF_CTX_free(local_150);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_174;\n}\n\n",
        "output": "The predicted function name is test_kdf_kbkdf_8009_prf2"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00018921(param_1,param_2,4);\n  FUN_00018221(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is fts_skip_tree"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  void **ppvVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  ppvVar1 = *(void ***)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  EVP_MAC_free(ppvVar1[1]);\n  CRYPTO_free(*ppvVar1);\n  uVar2 = FUN_00005fc4(FUN_00009627);\n  uVar3 = FUN_00005fb6(ppvVar1[0x11]);\n  OPENSSL_sk_pop_free(uVar3,uVar2);\n  CRYPTO_free(ppvVar1[3]);\n  CRYPTO_free(ppvVar1[4]);\n  CRYPTO_free(ppvVar1[6]);\n  CRYPTO_free(ppvVar1[0xc]);\n  CRYPTO_free(ppvVar1[0xe]);\n  CRYPTO_free(ppvVar1[8]);\n  CRYPTO_free(ppvVar1[10]);\n  return;\n}\n\n",
        "output": "The predicted function name is mac_test_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](char *param_1)\n\n{\n  char *pcVar1;\n  undefined8 uVar2;\n  \n  if ((param_1 != (char *)0x0) && (pcVar1 = strchr(param_1,0x2f), pcVar1 == (char *)0x0)) {\n    uVar2 = wget_aprintf(&DAT_000411c5,param_1);\n    return uVar2;\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is convert_to_path_if_not"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 *param_2)\n\n{\n  wget_fprintf(param_1,\"  %6d %5lld %6lld %s\\n\",*(undefined4 *)(param_2 + 8),param_2[4] - param_2[3]\n               ,param_2[1],*(undefined8 *)*param_2);\n  return 0;\n}\n\n",
        "output": "The predicted function name is print_human_entry"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0000fe57(param_1,param_2,1,0);\n  return;\n}\n\n",
        "output": "The predicted function name is digestverify_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](long param_1,long param_2,char param_3)\n\n{\n  uint uVar1;\n  int iVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  long lVar5;\n  bool bVar6;\n  int local_38;\n  \n  if ((param_2 == 0) && (param_3 != '\\0')) {\n    if (**(long **)(param_1 + 0x18) != 0) {\n      wget_vector_free(*(undefined8 *)(param_1 + 0x18));\n      DAT_002532fc = 0;\n    }\n    DAT_00253420 = 1;\n    iVar2 = 0;\n  }\n  else if ((param_2 == 0) || (param_3 != '\\0')) {\n    if ((param_2 == 0) && (param_3 == '\\0')) {\n      DAT_00253420 = 0;\n      iVar2 = 0;\n    }\n    else {\n      iVar2 = -1;\n    }\n  }\n  else {\n    if (**(long **)(param_1 + 0x18) != 0) {\n      wget_vector_free(*(undefined8 *)(param_1 + 0x18));\n      DAT_002532fc = 0;\n    }\n    iVar2 = FUN_0002049c(param_1,param_2,0);\n    if (iVar2 == 0) {\n      uVar4 = **(undefined8 **)(param_1 + 0x18);\n      DAT_00253420 = 0;\n      uVar1 = 0;\n      for (local_38 = 0; iVar2 = wget_vector_size(uVar4), local_38 < iVar2; local_38 = local_38 + 1)\n      {\n        uVar3 = wget_vector_get(uVar4,local_38);\n        iVar2 = wget_content_encoding_by_name(uVar3);\n        if (iVar2 == -1) {\n          uVar4 = wget_content_encoding_to_name(0xffffffff);\n          uVar3 = gettext(\"Compression type %s not supported\\n\");\n          wget_error_printf(uVar3,uVar4);\n          return -1;\n        }\n        if ((1 << ((byte)iVar2 & 0x1f) & uVar1) != 0) {\n          uVar4 = wget_content_encoding_to_name(iVar2);\n          uVar3 = gettext(\"Duplicate type %s\");\n          wget_error_printf(uVar3,uVar4);\n          return -1;\n        }\n        bVar6 = iVar2 == 5;\n        if ((iVar2 == 3) || (iVar2 == 4)) {\n          bVar6 = true;\n        }\n        if (iVar2 == 6) {\n          bVar6 = true;\n        }\n        if (iVar2 == 8) {\n          bVar6 = true;\n        }\n        if (bVar6) {\n          uVar4 = wget_content_encoding_to_name(iVar2);\n          uVar3 = gettext(\"Lib for type %s not built\");\n          wget_error_printf(uVar3,uVar4);\n          return -1;\n        }\n        uVar1 = uVar1 | 1 << ((byte)iVar2 & 0x1f);\n        lVar5 = (long)DAT_002532fc;\n        DAT_002532fc = DAT_002532fc + 1;\n        *(int *)((long)&DAT_002530c8 + (lVar5 + 0x84) * 4) = iVar2;\n      }\n      iVar2 = 0;\n    }\n  }\n  return iVar2;\n}\n\n",
        "output": "The predicted function name is parse_compression"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](undefined8 param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  bool local_8d;\n  uint local_8c;\n  ulong local_88;\n  long local_78 [2];\n  ulong local_68;\n  undefined local_58 [16];\n  undefined local_48 [16];\n  undefined local_38 [16];\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar2 = __gmpz_cmp_ui(param_1,1);\n  if (iVar2 < 1) {\n    local_8d = false;\n  }\n  else {\n    iVar2 = __gmpz_cmp_ui(param_1,0x17ded79);\n    if (iVar2 < 0) {\n      local_8d = true;\n    }\n    else {\n      __gmpz_inits(local_58,local_48,local_38,local_28,0);\n      __gmpz_sub_ui(local_38,param_1,1);\n      uVar3 = __gmpz_scan1(local_38,0);\n      __gmpz_tdiv_q_2exp(local_58,local_38,uVar3);\n      __gmpz_set_ui(local_48,2);\n      cVar1 = FUN_00003d76(param_1,local_38,local_48,local_28,local_58,uVar3);\n      if (cVar1 == '\\x01') {\n        if (DAT_00215010 != '\\0') {\n          __gmpz_set(local_28,local_38);\n          FUN_000069eb(local_28,local_78);\n        }\n        local_8c = 0;\n        while( true ) {\n          if (0x29b < local_8c) {\n            uVar3 = gettext(\"Lucas prime test failure.  This should not happen\");\n            error(0,0,uVar3);\n                    /* WARNING: Subroutine does not return */\n            abort();\n          }\n          if (DAT_00215010 == '\\0') {\n            local_8d = local_8c == 0x18;\n          }\n          else {\n            local_88 = 0;\n            local_8d = true;\n            while ((local_88 < local_68 && (local_8d != false))) {\n              __gmpz_divexact(local_28,local_38,local_88 * 0x10 + local_78[0]);\n              __gmpz_powm(local_28,local_48,local_28,param_1);\n              iVar2 = __gmpz_cmp_ui(local_28,1);\n              local_88 = local_88 + 1;\n              local_8d = iVar2 != 0;\n            }\n          }\n          if (local_8d != false) break;\n          __gmpz_add_ui(local_48,local_48,(&DAT_0000e240)[local_8c]);\n          cVar1 = FUN_00003d76(param_1,local_38,local_48,local_28,local_58,uVar3);\n          if (cVar1 != '\\x01') {\n            local_8d = false;\n            break;\n          }\n          local_8c = local_8c + 1;\n        }\n        if (DAT_00215010 != '\\0') {\n          FUN_00002c73(local_78);\n        }\n      }\n      else {\n        local_8d = false;\n      }\n      __gmpz_clears(local_58,local_48,local_38,local_28,0);\n    }\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_8d;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is mp_prime_p"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  undefined8 *puVar2;\n  \n  puVar2 = (undefined8 *)EVP_CIPHER_CTX_get_cipher_data(param_1);\n  iVar1 = EVP_CIPHER_impl_ctx_size(param_2);\n  CRYPTO_clear_free(*puVar2,(long)iVar1,\"engines/e_dasync.c\",0x2ee);\n  return 1;\n}\n\n",
        "output": "The predicted function name is dasync_cipher_cleanup_helper"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  if ((param_2 == (char *)0x0) || (*param_2 == '\\0')) {\n    uVar2 = gettext(\"Empty progress type\\n\");\n    wget_error_printf(uVar2);\n    uVar2 = 0xffffffff;\n  }\n  else {\n    iVar1 = wget_strcasecmp_ascii(param_2,&DAT_0004354a);\n    if (iVar1 == 0) {\n      **(undefined **)(param_1 + 0x18) = 0;\n    }\n    else {\n      iVar1 = wget_strcasecmp_ascii(param_2,&DAT_0004354f);\n      if (iVar1 != 0) {\n        uVar2 = gettext(\"Unknown progress type \\'%s\\'\\n\");\n        wget_error_printf(uVar2,param_2);\n        return 0xffffffff;\n      }\n      **(undefined **)(param_1 + 0x18) = 1;\n    }\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is parse_progress_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,ulong param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined8 uVar1;\n  \n  if (param_2 < 0xc) {\n    uVar1 = 0xffffffff;\n  }\n  else {\n    *(undefined8 *)(param_1 + 8) = 0;\n    FUN_000069ac(param_1,param_2,0x11,param_3,param_4);\n    uVar1 = 0;\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is icmp_address_encode"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  FUN_0000643e(param_1,param_3,0);\n  return;\n}\n\n",
        "output": "The predicted function name is servername_reject_cb"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_00004240(&PTR_FUN_00214ba0);\n  return;\n}\n\n",
        "output": "The predicted function name is test_long_64bit"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](char *param_1)\n\n{\n  int iVar1;\n  undefined4 local_c;\n  \n  local_c = 0;\n  iVar1 = strcasecmp(param_1,\"tsonly\");\n  if (iVar1 == 0) {\n    local_c = 1;\n  }\n  else {\n    iVar1 = strcasecmp(param_1,\"tsaddr\");\n    if (iVar1 == 0) {\n      local_c = 2;\n    }\n    else {\n      error(1,0,\"unsupported timestamp type: %s\",param_1);\n    }\n  }\n  return local_c;\n}\n\n",
        "output": "The predicted function name is decode_ip_timestamp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void *param_1)\n\n{\n  free(*(void **)((long)param_1 + 0x30));\n  free(param_1);\n  return 0;\n}\n\n",
        "output": "The predicted function name is free_ref"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](undefined8 param_1,undefined8 param_2,undefined8 *param_3,undefined8 *param_4)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  uVar2 = OSSL_LIB_CTX_new();\n  *param_4 = uVar2;\n  iVar1 = FUN_0000879a(\"test/fake_rsaprov.c\",0x189,\"*provctx = OSSL_LIB_CTX_new()\",*param_4);\n  if (iVar1 != 0) {\n    *param_3 = &DAT_002128c0;\n  }\n  return iVar1 != 0;\n}\n\n",
        "output": "The predicted function name is fake_rsa_provider_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Type propagation algorithm not settling */\n\nchar * [MASK](in_addr *param_1)\n\n{\n  hostent *phVar1;\n  char *pcVar2;\n  \n  phVar1 = gethostbyaddr(param_1,4,2);\n  if (phVar1 == (hostent *)0x0) {\n    pcVar2 = inet_ntoa((in_addr)param_1->s_addr);\n  }\n  else {\n    pcVar2 = phVar1->h_name;\n  }\n  return pcVar2;\n}\n\n",
        "output": "The predicted function name is get_hostname"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](char *param_1)\n\n{\n  bool bVar1;\n  int iVar2;\n  ushort **ppuVar3;\n  char *local_20;\n  char *local_10;\n  \n  bVar1 = true;\n  local_20 = param_1;\n  while( true ) {\n    if (!bVar1) {\n      return 0;\n    }\n    while (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[*local_20] & 0x2000) != 0) {\n      local_20 = local_20 + 1;\n    }\n    if (*local_20 == '\\0') break;\n    local_10 = local_20;\n    while ((*local_10 != '\\0' && (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[*local_10] & 0x2000) == 0))\n          ) {\n      local_10 = local_10 + 1;\n    }\n    if (*local_10 == '\\0') {\n      bVar1 = false;\n    }\n    else {\n      *local_10 = '\\0';\n    }\n    iVar2 = OSSL_PROVIDER_available(DAT_002241a8,local_20);\n    if (iVar2 != 0) {\n      return 1;\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is prov_available"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined * [MASK](void)\n\n{\n  return &DAT_00210820;\n}\n\n",
        "output": "The predicted function name is INVALIDTEMPLATE_it"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long **param_1)\n\n{\n  long lVar1;\n  \n  if ((*(byte *)(param_1 + 0x15) >> 4 & 1) == 1) {\n    FUN_0000f72d(param_1[8],param_1);\n  }\n  else {\n    lVar1 = wget_aprintf(\"http://%s\",**param_1 + 8);\n    FUN_00014525(0,\"utf-8\",lVar1,4,0);\n    FUN_0000f72d(param_1[8],param_1);\n    if (lVar1 != 0) {\n      (*wget_free)(lVar1);\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is fallback_to_http"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8\n[MASK](int param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,undefined8 param_5\n            ,undefined8 param_6,undefined4 param_7)\n\n{\n  if (-1 < param_1) {\n    if (param_1 < 2) {\n      FUN_00005b76(param_1 == 1,param_2,param_3,param_4,param_5,param_6,param_7);\n    }\n    else if (param_1 == 2) {\n      FUN_000051cd(param_4,param_5,param_6,param_7);\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is recv_address"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return DAT_00205360;\n}\n\n",
        "output": "The predicted function name is dasync_aes_128_cbc_hmac_sha1"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long in_FS_OFFSET;\n  undefined4 local_5c;\n  undefined4 local_58;\n  undefined4 local_54;\n  undefined8 local_50;\n  long local_48;\n  void *local_40;\n  undefined local_38 [40];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_54 = 0;\n  local_50 = 0;\n  local_48 = 0;\n  local_5c = 0x1000;\n  local_58 = 0;\n  local_40 = (void *)FUN_0000511d(\"passwordPASSWORDpassword\",\"sha256\",\n                                  \"saltSALTsaltSALTsaltSALTsaltSALTsalt\",&local_5c,&local_58);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x285,\"params\",local_40);\n  if (iVar1 != 0) {\n    local_50 = FUN_00002d68(\"PBKDF2\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x286,\"kctx = get_kdfbyname(OSSL_KDF_NAME_PBKDF2)\",\n                         local_50);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_50,local_40);\n      iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0x288,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        if (local_48 != 0) {\n          uVar2 = EVP_KDF_derive(local_50,local_38,local_48,0);\n          iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x289,\"EVP_KDF_derive(kctx, out, len, NULL)\",\n                               &DAT_00013c2d,uVar2,0);\n          if (iVar1 == 0) goto LAB_00005868;\n        }\n        local_54 = 1;\n      }\n    }\n  }\nLAB_00005868:\n  EVP_KDF_CTX_free(local_50);\n  CRYPTO_free(local_40);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_54;\n}\n\n",
        "output": "The predicted function name is test_kdf_pbkdf2_large_output"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](char param_1)\n\n{\n  long lVar1;\n  \n  if (param_1 == '\\0') {\n    lVar1 = DAT_00253e80;\n    if ((DAT_00253e80 == 0) &&\n       (lVar1 = wget_strnglob(&DAT_00046824,1,0x4000), DAT_00253e80 = lVar1, lVar1 == 0)) {\n      lVar1 = wget_strdup(&DAT_00046826);\n      DAT_00253e80 = lVar1;\n    }\n  }\n  else {\n    if (DAT_00253e80 != 0) {\n      (*wget_free)(DAT_00253e80);\n      DAT_00253e80 = 0;\n    }\n    lVar1 = 0;\n  }\n  return lVar1;\n}\n\n",
        "output": "The predicted function name is get_home_dir"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,char *param_2)\n\n{\n  char *pcVar1;\n  \n  CRYPTO_free(*(void **)(param_1 + 8));\n  pcVar1 = CRYPTO_strdup(param_2,\"test/helpers/ssl_test_ctx.c\",0x160);\n  *(char **)(param_1 + 8) = pcVar1;\n  FUN_000146a7(\"test/helpers/ssl_test_ctx.c\",0x160,\"ctx->npn_protocols\",*(undefined8 *)(param_1 + 8)\n              );\n  return;\n}\n\n",
        "output": "The predicted function name is parse_server_npn_protocols"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x10);\n}\n\n",
        "output": "The predicted function name is gcide_compare_count"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,long param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long lVar3;\n  undefined4 *puVar4;\n  \n  if ((param_1 == 0) || (param_2 == 0)) {\n    uVar2 = 0;\n  }\n  else {\n    lVar3 = EVP_CIPHER_CTX_get0_cipher(param_1);\n    if (lVar3 == 0) {\n      uVar2 = 0;\n    }\n    else {\n      puVar4 = (undefined4 *)EVP_CIPHER_CTX_get_cipher_data(param_1);\n      if (puVar4 == (undefined4 *)0x0) {\n        uVar2 = 0;\n      }\n      else {\n        iVar1 = EVP_CIPHER_CTX_get_nid(param_1);\n        if (((iVar1 == 0x1a7) || (iVar1 == 0x1ab)) || (iVar1 == 0x1a3)) {\n          iVar1 = EVP_CIPHER_CTX_get_iv_length(param_1);\n          if (iVar1 == 0x10) {\n            iVar1 = FUN_0000232e(puVar4,\"skcipher\",\"cbc(aes)\");\n            if (iVar1 < 1) {\n              uVar2 = 0;\n            }\n            else {\n              iVar1 = EVP_CIPHER_CTX_get_key_length();\n              if (((iVar1 < 1) || (iVar1 = FUN_00002290(puVar4,param_2,iVar1), iVar1 < 1)) ||\n                 (iVar1 = FUN_00001dfe(), iVar1 == 0)) {\n                close(puVar4[1]);\n                close(puVar4[2]);\n                uVar2 = 0;\n              }\n              else {\n                *puVar4 = 0x1890671;\n                uVar2 = 1;\n              }\n            }\n          }\n          else {\n            uVar2 = 0;\n          }\n        }\n        else {\n          uVar2 = 0;\n        }\n      }\n    }\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is afalg_cipher_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0000fb27(param_2);\n  return 0;\n}\n\n",
        "output": "The predicted function name is _queue_free_func"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,long param_2)\n\n{\n  FUN_0000c6ad(\"Server signing hash\",*(undefined4 *)(param_2 + 0x1e4),\n               *(undefined4 *)(param_1 + 0x68));\n  return;\n}\n\n",
        "output": "The predicted function name is check_server_sign_hash"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  wget_hashmap_free(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is wget_stringmap_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,SSL *param_2,long param_3)\n\n{\n  void *parg;\n  \n  if (*(int *)(param_3 + 4) != 0) {\n    parg = (void *)FUN_0000a1cf(*(undefined4 *)(param_3 + 4));\n    SSL_ctrl(param_2,0x37,0,parg);\n  }\n  if (*(int *)(param_3 + 0x40) != 0) {\n    SSL_set_post_handshake_auth(param_2,1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is configure_handshake_ssl"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  ASN1_ITEM *it;\n  \n  it = (ASN1_ITEM *)FUN_00002bd6();\n  ASN1_item_new(it);\n  return;\n}\n\n",
        "output": "The predicted function name is ASN1_UINT32_DATA_new"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  if (DAT_002533d3 == '\\x01') {\n    FUN_000136d3(param_1,param_2);\n  }\n  else {\n    FUN_0001363a(param_1,param_2);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is regex_match"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  return param_1;\n}\n\n",
        "output": "The predicted function name is ossl_check_CONF_VALUE_freefunc_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  FUN_00012e99(&DAT_00253ce0,param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is quota_modify_read"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return 1;\n}\n\n",
        "output": "The predicted function name is dasync_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_14;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_00009ddc(&PTR_DAT_0021f1a0,3,&local_14,param_2);\n  if (iVar1 != 0) {\n    *(undefined4 *)(param_1 + 0x20) = local_14;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1 != 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is parse_ct_validation"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined4 param_1)\n\n{\n  FUN_00009e5e(&PTR_DAT_0021efc0,4,param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is ssl_servername_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_2c;\n  undefined4 local_28;\n  undefined4 local_24;\n  undefined8 local_20;\n  void *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_24 = 0;\n  local_20 = 0;\n  local_2c = 0x1000;\n  local_28 = 0;\n  local_18 = (void *)FUN_0000511d(\"passwordPASSWORDpassword\",\"sha256\",\"saltSALT\",&local_2c,&local_28\n                                 );\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x29f,\"params\",local_18);\n  if (iVar1 != 0) {\n    local_20 = FUN_00002d68(\"PBKDF2\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x2a0,\"kctx = get_kdfbyname(OSSL_KDF_NAME_PBKDF2)\",\n                         local_20);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_20,local_18);\n      iVar1 = FUN_0000e3f6(\"test/evp_kdf_test.c\",0x2a2,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        local_24 = 1;\n      }\n    }\n  }\n  EVP_KDF_CTX_free(local_20);\n  CRYPTO_free(local_18);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_24;\n}\n\n",
        "output": "The predicted function name is test_kdf_pbkdf2_small_salt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](undefined4 *param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_14;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_00009ddc(&PTR_DAT_0021ef80,4,&local_14,param_2);\n  if (iVar1 != 0) {\n    *param_1 = local_14;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1 != 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is parse_client_verify_callback"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 *param_1,undefined8 *param_2)\n\n{\n  DAT_00204310 = DAT_00204310 + 1;\n  utf8_strcasecmp(*param_1,*param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is compare_entry"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  *(undefined8 *)(param_1 + 0x50) = param_2;\n  return;\n}\n\n",
        "output": "The predicted function name is ping_set_packetsize"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ASN1_VALUE *param_1)\n\n{\n  ASN1_ITEM *it;\n  \n  it = (ASN1_ITEM *)FUN_00002e02();\n  ASN1_item_free(param_1,it);\n  return;\n}\n\n",
        "output": "The predicted function name is ASN1_UINT64_DATA_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nundefined8 [MASK](long param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  ulong local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_40 = 0;\n  local_38 = 0;\n  local_30 = 0;\n  local_28 = 0;\n  local_20 = 0;\n  local_48 = *(undefined8 *)(param_1 + 0x20);\n  local_18 = (ulong)CONCAT24(*(undefined2 *)(param_1 + 0x58),*(undefined4 *)(param_1 + 0x5c));\n  wget_thread_mutex_lock(DAT_00253c08);\n  if (DAT_00253c00 != 0) {\n    iVar1 = wget_hashmap_get(DAT_00253c00,&local_48,&local_50);\n    if (iVar1 != 0) goto LAB_0000eab4;\n  }\n  local_50 = 0;\nLAB_0000eab4:\n  wget_thread_mutex_unlock(DAT_00253c08);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_50;\n}\n\n",
        "output": "The predicted function name is host_get"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_000036d5(0x31,2,1);\n  return;\n}\n\n",
        "output": "The predicted function name is test_http_keep_alive_1_require_yes"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                 undefined8 param_5)\n\n{\n  if (DAT_002053b0 == (code *)0x0) {\n    EVP_PKEY_meth_get_encrypt(DAT_00205350,0,&DAT_002053b0);\n  }\n  (*DAT_002053b0)(param_1,param_2,param_3,param_4,param_5);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_rsa_encrypt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  printf(\"%30s%s\",&DAT_00046466,param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is print_next"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](undefined8 param_1,undefined8 *param_2,undefined8 *param_3,int param_4)\n\n{\n  undefined8 uVar1;\n  undefined4 local_c;\n  \n  local_c = 1;\n  if (param_2 == (undefined8 *)0x0) {\n    *param_3 = &DAT_002052e8;\n    local_c = 2;\n  }\n  else if (param_4 == 0x1a3) {\n    uVar1 = FUN_00002557();\n    *param_2 = uVar1;\n  }\n  else if (param_4 == 0x394) {\n    uVar1 = FUN_00002564();\n    *param_2 = uVar1;\n  }\n  else {\n    local_c = 0;\n    *param_2 = 0;\n  }\n  return local_c;\n}\n\n",
        "output": "The predicted function name is dasync_ciphers"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  int iVar3;\n  undefined4 uVar4;\n  long in_FS_OFFSET;\n  undefined8 local_198;\n  undefined8 local_190;\n  undefined8 local_188;\n  undefined8 local_180;\n  undefined8 local_178;\n  undefined4 local_15c;\n  undefined8 *local_158;\n  undefined8 local_150;\n  undefined8 local_148;\n  undefined8 uStack320;\n  undefined8 uStack312;\n  undefined8 uStack304;\n  undefined8 uStack296;\n  undefined8 auStack288 [15];\n  undefined local_a8 [136];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_158 = auStack288;\n  OSSL_PARAM_construct_utf8_string(&local_198,\"digest\",\"sha512\",0);\n  puVar2 = local_158;\n  local_148 = local_198;\n  uStack320 = local_190;\n  uStack312 = local_188;\n  uStack304 = local_180;\n  uStack296 = local_178;\n  local_158 = local_158 + 5;\n  OSSL_PARAM_construct_octet_string(&local_198,&DAT_00013cfa,&DAT_002190a0,0x42);\n  uVar1 = local_190;\n  *puVar2 = local_198;\n  puVar2[1] = uVar1;\n  uVar1 = local_180;\n  puVar2[2] = local_188;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_178;\n  puVar2 = local_158;\n  local_158 = local_158 + 5;\n  OSSL_PARAM_construct_octet_string(&local_198,&DAT_00013cfe,&DAT_002190f0,0x10);\n  uVar1 = local_190;\n  *puVar2 = local_198;\n  puVar2[1] = uVar1;\n  uVar1 = local_180;\n  puVar2[2] = local_188;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_178;\n  puVar2 = local_158;\n  OSSL_PARAM_construct_end(&local_198);\n  *puVar2 = local_198;\n  puVar2[1] = local_190;\n  puVar2[2] = local_188;\n  puVar2[3] = local_180;\n  puVar2[4] = local_178;\n  local_150 = FUN_00002d68(\"X963KDF\");\n  iVar3 = FUN_0000e315(\"test/evp_kdf_test.c\",0x3a7,\"kctx = get_kdfbyname(OSSL_KDF_NAME_X963KDF)\",\n                       local_150);\n  if (iVar3 != 0) {\n    uVar4 = EVP_KDF_derive(local_150,local_a8,0x80,&local_148);\n    iVar3 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x3a8,\n                         \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar4,0);\n    if (iVar3 != 0) {\n      iVar3 = FUN_0000e848(\"test/evp_kdf_test.c\",0x3a9,&DAT_00013c68,\"expected\",local_a8,0x80,\n                           &DAT_00014b20,0x80);\n      if (iVar3 != 0) {\n        local_15c = 1;\n        goto LAB_00006c41;\n      }\n    }\n  }\n  local_15c = 0;\nLAB_00006c41:\n  EVP_KDF_CTX_free(local_150);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_15c;\n}\n\n",
        "output": "The predicted function name is test_kdf_x963"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](int param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined8 uVar3;\n  int *piVar4;\n  \n  cVar1 = FUN_00016bfc();\n  if (cVar1 == '\\0') {\n    iVar2 = FUN_000047a2(param_1,param_2,param_3,0x100);\n    if (iVar2 == 0) {\n      if ((*(uint *)(param_3 + 0x18) & 0xf000) == 0xa000) {\n        uVar3 = 0;\n      }\n      else {\n        iVar2 = faccessat(param_1,param_2,2,0x200);\n        if (iVar2 == 0) {\n          uVar3 = 0;\n        }\n        else {\n          piVar4 = __errno_location();\n          if (*piVar4 == 0xd) {\n            uVar3 = 1;\n          }\n          else {\n            uVar3 = 0xffffffff;\n          }\n        }\n      }\n    }\n    else {\n      uVar3 = 0xffffffff;\n    }\n  }\n  else {\n    uVar3 = 0;\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is write_protected_non_symlink"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2,char param_3)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  if (*(long *)(param_1 + 0x18) != 0) {\n    if ((((param_2 == (char *)0x0) || (iVar1 = strcmp(param_2,\"1\"), iVar1 == 0)) ||\n        (iVar1 = wget_strcasecmp_ascii(param_2,&DAT_00043497), iVar1 == 0)) ||\n       ((iVar1 = wget_strcasecmp_ascii(param_2,&DAT_00043499), iVar1 == 0 ||\n        (iVar1 = wget_strcasecmp_ascii(param_2,&DAT_0004349d), iVar1 == 0)))) {\n      *(bool *)*(undefined8 *)(param_1 + 0x18) = param_3 == '\\0';\n    }\n    else {\n      if ((((*param_2 != '\\0') &&\n           ((iVar1 = strcmp(param_2,\"0\"), iVar1 != 0 &&\n            (iVar1 = wget_strcasecmp_ascii(param_2,&DAT_000434a2), iVar1 != 0)))) &&\n          (iVar1 = wget_strcasecmp_ascii(param_2,&DAT_000434a4), iVar1 != 0)) &&\n         (iVar1 = wget_strcasecmp_ascii(param_2,&DAT_000434a7), iVar1 != 0)) {\n        uVar2 = gettext(\"Invalid boolean value \\'%s\\'\\n\");\n        wget_error_printf(uVar2,param_2);\n        return 0xffffffff;\n      }\n      **(char **)(param_1 + 0x18) = param_3;\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is parse_bool"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](BIO *param_1)\n\n{\n  DAT_002132fc = DAT_00213530;\n  DAT_00213304 = DAT_00213538;\n  DAT_0021330c = DAT_00213540;\n  BIO_write(param_1,&DAT_002132e0,0x30);\n  return 1;\n}\n\n",
        "output": "The predicted function name is send_hello_verify"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  ASN1_OBJECT *pAVar2;\n  long in_FS_OFFSET;\n  undefined4 local_24;\n  ASN1_OBJECT *local_20;\n  uchar *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_24 = 0;\n  local_18 = &DAT_00211020;\n  local_20 = ASN1_OBJECT_create(0,&DAT_00211028,5,\"C\",\"countryName\");\n  iVar1 = FUN_00006f73(\"test/asn1_decode_test.c\",0xd4,\n                       \"obj = ASN1_OBJECT_create(NID_undef, cn_der, sizeof(cn_der), \\\"C\\\", \\\"countryName\\\")\"\n                       ,local_20);\n  if (iVar1 != 0) {\n    pAVar2 = d2i_ASN1_OBJECT(&local_20,&local_18,8);\n    iVar1 = FUN_00006f73(\"test/asn1_decode_test.c\",0xd7,\"d2i_ASN1_OBJECT(&obj, &p, sizeof(oid_der))\"\n                         ,pAVar2);\n    if (iVar1 != 0) {\n      local_24 = 1;\n    }\n  }\n  ASN1_OBJECT_free(local_20);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_24;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_reuse_asn1_object"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](int param_1)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strchr(\"\\r\\n!,-./:;?\",param_1);\n  return pcVar1 != (char *)0x0;\n}\n\n",
        "output": "The predicted function name is _is_nl_or_punct"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return 0;\n}\n\n",
        "output": "The predicted function name is ping_router"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = *(undefined8 *)(param_1 + 8);\n  *(undefined8 *)(param_1 + 8) = 0;\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is take_value"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  char cVar1;\n  long in_FS_OFFSET;\n  undefined8 uVar2;\n  char *pcVar3;\n  int local_54;\n  uint local_50;\n  uint local_4c;\n  long local_48;\n  undefined8 *local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48 = *(long *)(*(long *)(param_1 + 0x38) + 8);\n  cVar1 = FUN_00001c1d(param_1);\n  if ((((cVar1 == '\\0') &&\n       (local_4c = dwg_object_polyline_2d_get_numpoints(param_1,&local_54), local_4c != 0)) &&\n      (local_54 == 0)) &&\n     (((local_40 = (undefined8 *)dwg_object_polyline_2d_get_points(param_1,&local_54), local_54 == 0\n       && (cVar1 = FUN_00001b99(*local_40,local_40[1]), cVar1 == '\\0')) &&\n      (cVar1 = FUN_00001be7(), cVar1 == '\\0')))) {\n    local_28 = *local_40;\n    local_20 = local_40[1];\n    FUN_0000558b(local_28,local_20,&local_38);\n    printf(\"\\t<!-- polyline_2d-%d -->\\n\",(ulong)*(uint *)(param_1 + 0x14));\n    uVar2 = FUN_00001b1f(local_30);\n    pcVar3 = (char *)FUN_00001b03(local_38);\n    printf(pcVar3,uVar2,\"\\t<path id=\\\"dwg-object-%d\\\" d=\\\"M %f,%f\",(ulong)*(uint *)(param_1 + 0x14))\n    ;\n    for (local_50 = 1; local_50 < local_4c; local_50 = local_50 + 1) {\n      local_28 = local_40[(ulong)local_50 * 2];\n      local_20 = local_40[(ulong)local_50 * 2 + 1];\n      cVar1 = FUN_00001b4b(local_28,local_20);\n      if (cVar1 == '\\0') {\n        FUN_0000558b(local_28,local_20,&local_38);\n        uVar2 = FUN_00001b1f(local_30);\n        pcVar3 = (char *)FUN_00001b03(local_38);\n        printf(pcVar3,uVar2,\" L %f,%f\");\n      }\n    }\n    if ((*(ushort *)(local_48 + 0x30) & 1) != 0) {\n      printf(\" Z\");\n    }\n    printf(\"\\\"\\n\\t\");\n    FUN_00001e87(*(undefined8 *)(param_1 + 0x38));\n    free(local_40);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is output_POLYLINE_2D"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  undefined2 uVar1;\n  undefined8 uVar2;\n  bool bVar3;\n  int iVar4;\n  undefined8 uVar5;\n  \n  bVar3 = false;\n  if (DAT_002533e3 != '\\0') {\n    iVar4 = wget_hsts_host_match\n                      (DAT_00253300,*(undefined8 *)(param_1 + 0x20),*(undefined2 *)(param_1 + 0x58))\n    ;\n    if (iVar4 != 0) {\n      bVar3 = true;\n    }\n  }\n  if (bVar3) {\n    uVar1 = *(undefined2 *)(param_1 + 0x58);\n    uVar2 = *(undefined8 *)(param_1 + 0x20);\n    uVar5 = gettext(\"HSTS in effect for %s:%hu\\n\");\n    wget_info_printf(uVar5,uVar2,uVar1);\n    wget_iri_set_scheme(param_1,1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is test_modify_hsts"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,long param_2)\n\n{\n  FUN_0000c6ad(\"Client signing\",*(undefined4 *)(param_2 + 0x200),*(undefined4 *)(param_1 + 0x80));\n  return;\n}\n\n",
        "output": "The predicted function name is check_client_sign_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong * [MASK](void)\n\n{\n  long lVar1;\n  int iVar2;\n  long *plVar3;\n  int *piVar4;\n  undefined8 uVar5;\n  \n  plVar3 = (long *)wget_http_get_response_cb();\n  if (plVar3 == (long *)0x0) {\n    plVar3 = (long *)0x0;\n  }\n  else {\n    lVar1 = *(long *)(*plVar3 + 0x30);\n    plVar3[0xc] = *(long *)(lVar1 + 8);\n    if (-1 < *(int *)(lVar1 + 0x20)) {\n      if (plVar3[0x11] != 0) {\n        if ((DAT_00253414 != '\\0') && (DAT_00253cf0 != '\\x01')) {\n          FUN_0001f539(plVar3[0x11],*(undefined4 *)(lVar1 + 0x20));\n        }\n        if ((DAT_00253cf0 == '\\0') && ((*(byte *)((long)plVar3 + 0xcb) & 2) == 0)) {\n          iVar2 = 0;\n        }\n        else {\n          iVar2 = 1;\n        }\n        FUN_0001c15e(*(undefined4 *)(lVar1 + 0x20),plVar3[0x11] - (long)iVar2);\n      }\n      if (((DAT_002533d7 != '\\0') && (iVar2 = fsync(*(int *)(lVar1 + 0x20)), iVar2 < 0)) &&\n         (piVar4 = __errno_location(), *piVar4 == 5)) {\n        piVar4 = __errno_location();\n        iVar2 = *piVar4;\n        uVar5 = gettext(\"Failed to fsync errno=%d\\n\");\n        wget_error_printf(uVar5,iVar2);\n        FUN_0001fa1d();\n      }\n      close(*(int *)(lVar1 + 0x20));\n      *(undefined4 *)(lVar1 + 0x20) = 0xffffffff;\n    }\n    if (DAT_002533d2 != '\\0') {\n      FUN_0000d4c6(*(undefined4 *)(lVar1 + 0x24));\n    }\n    if ((*(byte *)((long)plVar3 + 0xcb) & 2) != 0) {\n      FUN_0001fa1d(7);\n    }\n    if (lVar1 != 0) {\n      (*wget_free)(lVar1);\n    }\n  }\n  return plVar3;\n}\n\n",
        "output": "The predicted function name is http_receive_response"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,long param_2,long param_3,char param_4)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined8 uVar3;\n  char *__format;\n  int *piVar4;\n  undefined8 uVar5;\n  long in_FS_OFFSET;\n  undefined local_b8 [152];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_4 == '\\0') {\n    iVar2 = 0;\n  }\n  else {\n    iVar2 = 0x200;\n  }\n  iVar2 = unlinkat(*(int *)(param_1 + 0x2c),*(char **)(param_2 + 0x30),iVar2);\n  if (iVar2 == 0) {\n    if (*(char *)(param_3 + 0x1a) != '\\0') {\n      uVar3 = FUN_00013893(4,*(undefined8 *)(param_2 + 0x38));\n      if (param_4 == '\\0') {\n        __format = (char *)gettext(\"removed %s\\n\");\n      }\n      else {\n        __format = (char *)gettext(\"removed directory %s\\n\");\n      }\n      printf(__format,uVar3);\n    }\n    uVar3 = 2;\n    goto LAB_000050cb;\n  }\n  piVar4 = __errno_location();\n  if (*piVar4 == 0x1e) {\n    iVar2 = FUN_000149a7(*(undefined4 *)(param_1 + 0x2c),*(undefined8 *)(param_2 + 0x30),local_b8);\n    if (iVar2 != 0) {\n      piVar4 = __errno_location();\n      if (*piVar4 == 2) goto LAB_00004fd6;\n    }\n    piVar4 = __errno_location();\n    *piVar4 = 0x1e;\n  }\nLAB_00004fd6:\n  piVar4 = __errno_location();\n  cVar1 = FUN_00004de2(param_3,*piVar4);\n  if (cVar1 != '\\0') {\n    uVar3 = 2;\n    goto LAB_000050cb;\n  }\n  if (*(short *)(param_2 + 0x70) == 4) {\n    piVar4 = __errno_location();\n    if (*piVar4 != 0x27) {\n      piVar4 = __errno_location();\n      if (*piVar4 != 0x15) {\n        piVar4 = __errno_location();\n        if (*piVar4 != 0x14) {\n          piVar4 = __errno_location();\n          if (*piVar4 != 0x11) goto LAB_0000506f;\n        }\n      }\n    }\n    if ((*(int *)(param_2 + 0x40) == 1) || (*(int *)(param_2 + 0x40) == 0xd)) {\n      piVar4 = __errno_location();\n      *piVar4 = *(int *)(param_2 + 0x40);\n    }\n  }\nLAB_0000506f:\n  uVar3 = FUN_00013893(4,*(undefined8 *)(param_2 + 0x38));\n  uVar5 = gettext(\"cannot remove %s\");\n  piVar4 = __errno_location();\n  error(0,*piVar4,uVar5,uVar3);\n  FUN_00004e56(param_2);\n  uVar3 = 4;\nLAB_000050cb:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is excise"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8\n[MASK](long *param_1,long param_2,undefined8 param_3,undefined8 *param_4,undefined8 *param_5)\n\n{\n  undefined8 uVar1;\n  long lVar2;\n  \n  if ((param_1 == (long *)0x0) || (param_2 == 0)) {\n    uVar1 = 0xffffffff;\n  }\n  else if (*(long *)(param_2 + 0x10) == 0) {\n    lVar2 = FUN_00000c12(*(undefined4 *)(param_2 + 8),param_2 + 0x30);\n    if (lVar2 == 0) {\n      uVar1 = 0xffffffff;\n    }\n    else {\n      *(long *)(param_2 + 0x10) = lVar2;\n      *param_4 = 0;\n      *param_5 = 0;\n      *param_1 = lVar2;\n      uVar1 = *(undefined8 *)(param_2 + 0x60);\n    }\n  }\n  else {\n    (**(code **)(DAT_00202118 + 0x130))(*(undefined8 *)(param_2 + 0x10));\n    *(undefined8 *)(param_2 + 0x10) = 0;\n    uVar1 = 0xffffffff;\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is readfile_get_record"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 *param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  iVar1 = wget_strcmp(param_1[1],param_2);\n  if (iVar1 != 0) {\n    wget_debug_printf(\"blacklist set filename: %s -> %s\\n\",param_1[1],param_2);\n    wget_hashmap_remove_nofree(DAT_00253bf0,*param_1);\n    if (param_1[1] != 0) {\n      (*wget_free)(param_1[1]);\n      param_1[1] = 0;\n    }\n    uVar2 = wget_strdup(param_2);\n    param_1[1] = uVar2;\n    wget_hashmap_put(DAT_00253bf0,*param_1,param_1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is blacklist_set_filename"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  int local_28;\n  undefined8 local_20;\n  char *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_00253d64 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    local_20 = wget_vector_create(0x10,0);\n    FUN_000116b9(local_20);\n    iVar1 = wget_vector_size(local_20);\n    for (local_28 = 0; local_28 < iVar1; local_28 = local_28 + 1) {\n      local_18 = (char *)wget_vector_get(local_20,local_28);\n      puts(local_18);\n    }\n    wget_vector_free(&local_20);\n    FUN_0001fa1d(0);\n    uVar2 = 0xffffffff;\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is list_plugins"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  char cVar1;\n  long in_FS_OFFSET;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  char *__format;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  cVar1 = FUN_00001be7();\n  if (cVar1 == '\\0') {\n    cVar1 = FUN_00001be7();\n    if (cVar1 == '\\0') {\n      cVar1 = FUN_00001be7();\n      if (cVar1 == '\\0') {\n        cVar1 = FUN_00001c1d(param_1);\n        if (cVar1 == '\\0') {\n          FUN_000058cd(&local_48);\n          FUN_000058cd(&local_28);\n          printf(\"\\t<!-- line-%d -->\\n\",(ulong)*(uint *)(param_1 + 0x14));\n          uVar2 = FUN_00001b1f(local_20);\n          uVar3 = FUN_00001b03(local_28);\n          uVar4 = FUN_00001b1f(local_40);\n          __format = (char *)FUN_00001b03(local_48);\n          printf(__format,uVar4,uVar3,uVar2,\"\\t<path id=\\\"dwg-object-%d\\\" d=\\\"M %f,%f L %f,%f\\\"\\n\\t\"\n                 ,(ulong)*(uint *)(param_1 + 0x14));\n          FUN_00001e87(*(undefined8 *)(param_1 + 0x38));\n        }\n      }\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is output_LINE"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nuint [MASK](BIO *param_1,BIO *param_2,char param_3,uint param_4,ASN1_VALUE *param_5,\n                 ASN1_ITEM *param_6)\n\n{\n  char cVar1;\n  undefined uVar2;\n  bool bVar3;\n  int iVar4;\n  uint uVar5;\n  char *pcVar6;\n  long in_FS_OFFSET;\n  char *local_30;\n  char *local_28;\n  long local_20;\n  char *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = BIO_ctrl(param_1,3,0,&local_30);\n  local_28 = local_30;\n  if (local_20 < 4) {\nLAB_00002f78:\n    bVar3 = false;\n  }\n  else {\n    iVar4 = strncmp(local_30,\"GET \",4);\n    if (iVar4 != 0) goto LAB_00002f78;\n    bVar3 = true;\n  }\n  if (bVar3) {\n    local_28 = local_28 + 4;\n  }\n  else {\n    if (local_20 < 5) {\nLAB_00002fb7:\n      uVar2 = 0;\n    }\n    else {\n      iVar4 = strncmp(local_28,\"POST \",5);\n      if (iVar4 != 0) goto LAB_00002fb7;\n      uVar2 = 1;\n    }\n    iVar4 = FUN_0000a9e9(\"test/http_test.c\",0x2e,\"count >= 5 && strncmp(hdr, \\\"POST \\\", 5) == 0\",\n                         uVar2);\n    if (iVar4 == 0) {\n      uVar5 = 0;\n      goto LAB_00003370;\n    }\n    local_28 = local_28 + 5;\n  }\n  local_18 = local_28;\n  local_28 = strchr(local_28,0x20);\n  if (local_28 == (char *)0x0) {\n    uVar5 = 0;\n  }\n  else {\n    local_28 = local_28 + 1;\n    iVar4 = FUN_0000ac9e(\"test/http_test.c\",0x38,\"++hdr\",\"\\\"HTTP/1.\\\"\",local_28,7,\"HTTP/1.\",7);\n    if (iVar4 == 0) {\n      uVar5 = 0;\n    }\n    else {\n      local_28 = local_28 + 7;\n      iVar4 = FUN_000096c1(\"test/http_test.c\",0x3c,&DAT_0000dfb2,&DAT_0000dfad,0x30,(int)*local_28);\n      if (iVar4 != 0) {\n        cVar1 = *local_28;\n        local_28 = local_28 + 1;\n        iVar4 = FUN_000096c1(\"test/http_test.c\",0x3c,\"*hdr++\",&DAT_0000dfb6,(int)cVar1,0x31);\n        if (iVar4 != 0) {\n          cVar1 = *local_28;\n          local_28 = local_28 + 1;\n          iVar4 = FUN_00009529(\"test/http_test.c\",0x3e,\"*hdr++\",&DAT_0000dfc1,(int)cVar1,0xd);\n          if (iVar4 != 0) {\n            cVar1 = *local_28;\n            local_28 = local_28 + 1;\n            iVar4 = FUN_00009529(\"test/http_test.c\",0x3e,\"*hdr++\",&DAT_0000dfc6,(int)cVar1,10);\n            if (iVar4 != 0) {\n              local_20 = local_20 - ((long)local_28 - (long)local_30);\n              if ((local_20 < 0) || (param_2 == (BIO *)0x0)) {\n                uVar5 = 0;\n              }\n              else {\n                iVar4 = strncmp(local_18,\"/path/result.crt\",0x10);\n                if (iVar4 == 0) {\n                  iVar4 = BIO_printf(param_2,\"HTTP/1.%c 200 OK\\r\\n\",(ulong)(uint)(int)param_3);\n                  if (iVar4 < 1) {\n                    uVar5 = 0;\n                  }\n                  else {\n                    if (param_4 == (param_3 == '0')) {\n                      if (param_3 == '0') {\n                        pcVar6 = \"keep-alive\";\n                      }\n                      else {\n                        pcVar6 = \"close\";\n                      }\n                      iVar4 = BIO_printf(param_2,\"Connection: %s\\r\\n\",pcVar6);\n                      if (iVar4 < 1) {\n                        uVar5 = 0;\n                        goto LAB_00003370;\n                      }\n                    }\n                    if (bVar3) {\n                      uVar5 = ASN1_item_i2d(param_5,(uchar **)0x0,param_6);\n                      if ((int)uVar5 < 1) {\n                        uVar5 = 0;\n                      }\n                      else {\n                        iVar4 = BIO_printf(param_2,\n                                           \"Content-Type: application/x-x509-ca-cert\\r\\nContent-Length: %d\\r\\n\\r\\n\"\n                                           ,(ulong)uVar5);\n                        if (iVar4 < 1) {\n                          uVar5 = 0;\n                        }\n                        else {\n                          uVar5 = ASN1_item_i2d_bio(param_6,param_2,param_5);\n                        }\n                      }\n                    }\n                    else {\n                      iVar4 = strncmp(local_28,\"Connection: \",0xc);\n                      if (iVar4 == 0) {\n                        local_28 = strstr(local_28 + 0xc,\"\\r\\n\");\n                        if (local_28 == (char *)0x0) {\n                          uVar5 = 0;\n                          goto LAB_00003370;\n                        }\n                        local_28 = local_28 + 2;\n                      }\n                      iVar4 = BIO_write(param_2,local_28,(int)local_20);\n                      uVar5 = (uint)(local_20 == iVar4);\n                    }\n                  }\n                }\n                else if (bVar3) {\n                  iVar4 = BIO_printf(param_2,\n                                     \"HTTP/1.%c 301 Moved Permanently\\r\\nLocation: %s\\r\\n\\r\\n\",\n                                     (ulong)(uint)(int)param_3,\"/path/result.crt\");\n                  uVar5 = (uint)(0 < iVar4);\n                }\n                else {\n                  uVar5 = 0;\n                }\n              }\n              goto LAB_00003370;\n            }\n          }\n          uVar5 = 0;\n          goto LAB_00003370;\n        }\n      }\n      uVar5 = 0;\n    }\n  }\nLAB_00003370:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar5;\n}\n\n",
        "output": "The predicted function name is mock_http_server"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 *param_1,undefined8 *param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = wget_strcasecmp_ascii(*param_1,*param_2);\n  if ((iVar1 == 0) && (iVar1 = wget_strcasecmp_ascii(param_1[1],param_2[1]), iVar1 == 0)) {\n    return 0;\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is compare_wget_http_param"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  return DAT_00253c40;\n}\n\n",
        "output": "The predicted function name is plugin_db_help_forwarded"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *param_1,code *param_2,undefined8 param_3,undefined8 param_4,\n                undefined8 param_5)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long in_FS_OFFSET;\n  undefined8 local_138;\n  undefined8 local_130;\n  undefined8 local_128;\n  undefined8 local_120;\n  undefined8 local_118;\n  undefined8 local_100;\n  undefined8 local_f8;\n  undefined8 local_f0;\n  code *local_e8;\n  char *local_e0;\n  undefined4 local_d0;\n  int local_cc;\n  undefined8 local_c8;\n  char *local_c0;\n  undefined8 local_b8;\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  undefined8 local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_d0 = 2;\n  local_c8 = 0;\n  local_cc = 0;\n  local_100 = param_5;\n  local_f8 = param_4;\n  local_f0 = param_3;\n  local_e8 = param_2;\n  local_e0 = param_1;\n  local_c0 = param_1;\n  if (*param_1 == '\\0') {\n    local_c8 = FUN_000033da(0);\n    iVar1 = FUN_0000879a(\"test/fake_rsaprov.c\",0x12a,\"key = fake_rsa_keymgmt_new(NULL)\",local_c8);\n    if (iVar1 != 0) {\n      uVar2 = FUN_0000349e(local_c8,0,0);\n      iVar1 = FUN_00006f57(\"test/fake_rsaprov.c\",300,\"fake_rsa_keymgmt_import(key, 0, NULL)\",\n                           &DAT_0000e138,uVar2,0);\n      if (iVar1 != 0) {\n        OSSL_PARAM_construct_int(&local_138,&DAT_0000e1ee,&local_d0);\n        local_b8 = local_138;\n        local_b0 = local_130;\n        local_a8 = local_128;\n        local_a0 = local_120;\n        local_98 = local_118;\n        OSSL_PARAM_construct_utf8_string(&local_138,\"data-type\",&DAT_0000e05c,0);\n        local_90 = local_138;\n        local_88 = local_130;\n        local_80 = local_128;\n        local_78 = local_120;\n        local_70 = local_118;\n        OSSL_PARAM_construct_octet_string(&local_138,\"reference\",&local_c8,8);\n        local_68 = local_138;\n        local_60 = local_130;\n        local_58 = local_128;\n        local_50 = local_120;\n        local_48 = local_118;\n        OSSL_PARAM_construct_end(&local_138);\n        local_40 = local_138;\n        local_38 = local_130;\n        local_30 = local_128;\n        local_28 = local_120;\n        local_20 = local_118;\n        local_cc = (*local_e8)(&local_b8,local_f0);\n        *local_c0 = '\\x01';\n      }\n    }\n  }\n  else if (*param_1 == '\\x02') {\n    FUN_0000670e(\"test/fake_rsaprov.c\",0x13d,\"fake_rsa_load() called in error state\");\n  }\n  else {\n    FUN_0000670e(\"test/fake_rsaprov.c\",0x141,\"fake_rsa_load() called in eof state\");\n  }\n  FUN_0000670e(\"test/fake_rsaprov.c\",0x145,\"fake_rsa_load called - rv: %d\",local_cc);\n  if (local_cc == 0) {\n    FUN_00003443(local_c8);\n    *local_c0 = '\\x02';\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_cc;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is fake_rsa_st_load"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](undefined8 param_1,undefined8 param_2,char param_3)\n\n{\n  int iVar1;\n  bool bVar2;\n  \n  iVar1 = FUN_00020c38(param_1,param_2,(int)param_3);\n  if (-1 < iVar1) {\n    bVar2 = DAT_002533dd == '\\0';\n    if (bVar2) {\n      DAT_002533a0 = 5;\n    }\n    else {\n      DAT_002533a0 = 0;\n    }\n    DAT_00253423 = !bVar2;\n    DAT_002533ff = !bVar2;\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is parse_mirror"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](X509_STORE_CTX *param_1)\n\n{\n  X509_STORE_CTX_set_error(param_1,0x32);\n  return 0;\n}\n\n",
        "output": "The predicted function name is verify_reject_cb"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void *param_1)\n\n{\n  free(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyfree"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  OPENSSL_sk_num(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is sk_EVP_TEST_BUFFER_num"
    }
]