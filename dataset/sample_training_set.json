[
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](FILE *stream,char *command_name,char *package,char *version,char **authors,\n                    size_t n_authors)\n\n{\n  undefined8 uVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *pcVar5;\n  char *pcVar6;\n  char *pcVar7;\n  char *pcVar8;\n  char *pcVar9;\n  char *pcVar10;\n  char *pcVar11;\n  \n  if (command_name == (char *)0x0) {\n    fprintf((FILE *)stream,\"%s %s\\n\",package,version);\n  }\n  else {\n    fprintf((FILE *)stream,\"%s (%s) %s\\n\",command_name,package,version);\n  }\n  uVar1 = gettext(&DAT_0000fc6b);\n  fprintf((FILE *)stream,\"Copyright %s %d Free Software Foundation, Inc.\",uVar1,0x7e4);\n  fputc_unlocked(10,(FILE *)stream);\n  pcVar2 = (char *)gettext(\n                          \"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\"\n                          );\n  fprintf((FILE *)stream,pcVar2,\"https://gnu.org/licenses/gpl.html\");\n  fputc_unlocked(10,(FILE *)stream);\n  switch(n_authors) {\n  case 0:\n    break;\n  case 1:\n    pcVar2 = *authors;\n    pcVar3 = (char *)gettext(\"Written by %s.\\n\");\n    fprintf((FILE *)stream,pcVar3,pcVar2);\n    break;\n  case 2:\n    pcVar2 = authors[1];\n    pcVar3 = *authors;\n    pcVar4 = (char *)gettext(\"Written by %s and %s.\\n\");\n    fprintf((FILE *)stream,pcVar4,pcVar3,pcVar2);\n    break;\n  case 3:\n    pcVar2 = authors[2];\n    pcVar3 = authors[1];\n    pcVar4 = *authors;\n    pcVar5 = (char *)gettext(\"Written by %s, %s, and %s.\\n\");\n    fprintf((FILE *)stream,pcVar5,pcVar4,pcVar3,pcVar2);\n    break;\n  case 4:\n    pcVar2 = authors[3];\n    pcVar3 = authors[2];\n    pcVar4 = authors[1];\n    pcVar5 = *authors;\n    pcVar6 = (char *)gettext(\"Written by %s, %s, %s,\\nand %s.\\n\");\n    fprintf((FILE *)stream,pcVar6,pcVar5,pcVar4,pcVar3,pcVar2);\n    break;\n  case 5:\n    pcVar2 = authors[4];\n    pcVar3 = authors[3];\n    pcVar4 = authors[2];\n    pcVar5 = authors[1];\n    pcVar6 = *authors;\n    uVar1 = 0xd17f;\n    pcVar7 = (char *)gettext(\"Written by %s, %s, %s,\\n%s, and %s.\\n\");\n    fprintf((FILE *)stream,pcVar7,pcVar6,pcVar5,pcVar4,pcVar3,pcVar2,uVar1);\n    break;\n  case 6:\n    pcVar2 = authors[5];\n    pcVar3 = authors[4];\n    pcVar4 = authors[3];\n    pcVar5 = authors[2];\n    pcVar6 = authors[1];\n    pcVar7 = *authors;\n    pcVar8 = (char *)gettext(\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\");\n    fprintf((FILE *)stream,pcVar8,pcVar7,pcVar6,pcVar5,pcVar4,pcVar3,pcVar2);\n    break;\n  case 7:\n    pcVar2 = authors[6];\n    pcVar3 = authors[5];\n    pcVar4 = authors[4];\n    pcVar5 = authors[3];\n    pcVar6 = authors[2];\n    pcVar7 = authors[1];\n    pcVar8 = *authors;\n    uVar1 = 0xd287;\n    pcVar9 = (char *)gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\");\n    fprintf((FILE *)stream,pcVar9,pcVar8,pcVar7,pcVar6,pcVar5,pcVar4,pcVar3,pcVar2,uVar1);\n    break;\n  case 8:\n    pcVar2 = authors[7];\n    pcVar3 = authors[6];\n    pcVar4 = authors[5];\n    pcVar5 = authors[4];\n    pcVar6 = authors[3];\n    pcVar7 = authors[2];\n    pcVar8 = authors[1];\n    pcVar9 = *authors;\n    pcVar10 = (char *)gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\");\n    fprintf((FILE *)stream,pcVar10,pcVar9,pcVar8,pcVar7,pcVar6,pcVar5,pcVar4,pcVar3,pcVar2);\n    break;\n  case 9:\n    pcVar2 = authors[8];\n    pcVar3 = authors[7];\n    pcVar4 = authors[6];\n    pcVar5 = authors[5];\n    pcVar6 = authors[4];\n    pcVar7 = authors[3];\n    pcVar8 = authors[2];\n    pcVar9 = authors[1];\n    pcVar10 = *authors;\n    uVar1 = 0xd3d7;\n    pcVar11 = (char *)gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\");\n    fprintf((FILE *)stream,pcVar11,pcVar10,pcVar9,pcVar8,pcVar7,pcVar6,pcVar5,pcVar4,pcVar3,pcVar2,\n            uVar1);\n    break;\n  default:\n    pcVar2 = authors[8];\n    pcVar3 = authors[7];\n    pcVar4 = authors[6];\n    pcVar5 = authors[5];\n    pcVar6 = authors[4];\n    pcVar7 = authors[3];\n    pcVar8 = authors[2];\n    pcVar9 = authors[1];\n    pcVar10 = *authors;\n    uVar1 = 0xd48d;\n    pcVar11 = (char *)gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\");\n    fprintf((FILE *)stream,pcVar11,pcVar10,pcVar9,pcVar8,pcVar7,pcVar6,pcVar5,pcVar4,pcVar3,pcVar2,\n            uVar1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is version_etc_arn"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](FILE *fp)\n\n{\n  int iVar1;\n  __off_t _Var2;\n  int *piVar3;\n  int saved_errno;\n  int result;\n  int fd;\n  \n  saved_errno = 0;\n  iVar1 = fileno((FILE *)fp);\n  if (iVar1 < 0) {\n    iVar1 = fclose((FILE *)fp);\n    return iVar1;\n  }\n  iVar1 = __freading(fp);\n  if (iVar1 != 0) {\n    iVar1 = fileno((FILE *)fp);\n    _Var2 = lseek(iVar1,0,1);\n    if (_Var2 == -1) goto LAB_0000dbaf;\n  }\n  iVar1 = rpl_fflush(fp);\n  if (iVar1 != 0) {\n    piVar3 = __errno_location();\n    saved_errno = *piVar3;\n  }\nLAB_0000dbaf:\n  result = fclose((FILE *)fp);\n  if (saved_errno != 0) {\n    piVar3 = __errno_location();\n    *piVar3 = saved_errno;\n    result = -1;\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is rpl_fclose"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](void *p,size_t n,size_t s)\n\n{\n  void *pvVar1;\n  \n  if (SUB168(ZEXT816(n) * ZEXT816(s),0) < 0 || SUB168(ZEXT816(n) * ZEXT816(s) >> 0x40,0) != 0) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  pvVar1 = xrealloc(p,n * s);\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is xnrealloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *arg)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quote_n(0,arg);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is quote"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  char *pcVar1;\n  \n  fputc_unlocked(10,stdout);\n  pcVar1 = (char *)gettext(\"Report bugs to: %s\\n\");\n  printf(pcVar1,\"bug-coreutils@gnu.org\");\n  pcVar1 = (char *)gettext(\"%s home page: <%s>\\n\");\n  printf(pcVar1,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n  pcVar1 = (char *)gettext(\"General help using GNU software: <%s>\\n\");\n  printf(pcVar1,\"https://www.gnu.org/gethelp/\");\n  return;\n}\n\n",
        "output": "The predicted function name is emit_bug_reporting_address"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](size_t n)\n\n{\n  void *pvVar1;\n  void *p;\n  \n  pvVar1 = malloc(n);\n  if ((pvVar1 == (void *)0x0) && (n != 0)) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is xmalloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nquoting_options * [MASK](quoting_options *o)\n\n{\n  int iVar1;\n  int *piVar2;\n  quoting_options *pqVar3;\n  int e;\n  quoting_options *p;\n  \n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  if (o == (quoting_options *)0x0) {\n    o = &default_quoting_options;\n  }\n  pqVar3 = (quoting_options *)xmemdup(o,0x38);\n  piVar2 = __errno_location();\n  *piVar2 = iVar1;\n  return pqVar3;\n}\n\n",
        "output": "The predicted function name is clone_quoting_options"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nchar * [MASK](char *arg,size_t argsize,char ch)\n\n{\n  long lVar1;\n  char *pcVar2;\n  long in_FS_OFFSET;\n  quoting_options options;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  options._0_8_ = default_quoting_options._0_8_;\n  options.quote_these_too._0_8_ = default_quoting_options.quote_these_too._0_8_;\n  options.quote_these_too._8_8_ = default_quoting_options.quote_these_too._8_8_;\n  options.quote_these_too._16_8_ = default_quoting_options.quote_these_too._16_8_;\n  options.quote_these_too._24_8_ = default_quoting_options.quote_these_too._24_8_;\n  options.left_quote = default_quoting_options.left_quote;\n  options.right_quote = default_quoting_options.right_quote;\n  set_char_quoting(&options,ch,1);\n  pcVar2 = quotearg_n_options(0,arg,argsize,&options);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return pcVar2;\n}\n\n",
        "output": "The predicted function name is quotearg_char_mem"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](sha512_ctx *ctx,void *resbuf)\n\n{\n  __uint64_t v;\n  int i;\n  char *r;\n  \n  for (i = 0; i < 6; i = i + 1) {\n    v = __bswap_64(ctx->state[i]);\n    set_uint64((char *)((long)resbuf + (long)i * 8),v);\n  }\n  return resbuf;\n}\n\n",
        "output": "The predicted function name is sha384_read_ctx"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nchar * [MASK](int n,quoting_style s,char *arg)\n\n{\n  long lVar1;\n  char *pcVar2;\n  long in_FS_OFFSET;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  char *local_70;\n  char *local_68;\n  char *local_58;\n  quoting_style local_50;\n  int local_4c;\n  quoting_options options;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  local_58 = arg;\n  local_50 = s;\n  local_4c = n;\n  quoting_options_from_style((quoting_options *)&local_98,s);\n  options._0_8_ = local_98;\n  options.quote_these_too._0_8_ = local_90;\n  options.quote_these_too._8_8_ = local_88;\n  options.quote_these_too._16_8_ = local_80;\n  options.quote_these_too._24_8_ = local_78;\n  options.left_quote = local_70;\n  options.right_quote = local_68;\n  set_char_quoting(&options,':',1);\n  pcVar2 = quotearg_n_options(local_4c,local_58,0xffffffffffffffff,&options);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return pcVar2;\n}\n\n",
        "output": "The predicted function name is quotearg_n_style_colon"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *s,size_t s_len)\n\n{\n  char *dst;\n  size_t i;\n  \n  i = 0;\n  dst = s;\n  while( true ) {\n    if (s_len <= i) {\n      if (dst < s + s_len) {\n        *dst = '\\0';\n      }\n      return s;\n    }\n    if (s[i] == '\\0') break;\n    if (s[i] == '\\\\') {\n      if (i == s_len - 1) {\n        return (char *)0x0;\n      }\n      i = i + 1;\n      if (s[i] == '\\\\') {\n        *dst = '\\\\';\n      }\n      else {\n        if (s[i] != 'n') {\n          return (char *)0x0;\n        }\n        *dst = '\\n';\n      }\n    }\n    else {\n      *dst = s[i];\n    }\n    dst = dst + 1;\n    i = i + 1;\n  }\n  return (char *)0x0;\n}\n\n",
        "output": "The predicted function name is filename_unescape"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *arg,size_t argsize)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quote_n_mem(0,arg,argsize);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is quote_mem"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](FILE *fp,fadvice_t advice)\n\n{\n  int fd;\n  \n  if (fp != (FILE *)0x0) {\n    fd = fileno((FILE *)fp);\n    fdadvise(fd,0,0,advice);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is fadvise"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int c)\n\n{\n  if (c - 0x61U < 0x1a) {\n    c = c + -0x20;\n  }\n  return c;\n}\n\n",
        "output": "The predicted function name is c_toupper"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *s)\n\n{\n  return s;\n}\n\n",
        "output": "The predicted function name is bad_cast"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](FILE *stream,void *resblock)\n\n{\n  int iVar1;\n  \n  iVar1 = shaxxx_stream(stream,\"sha512\",resblock,0x40,sha512_init_ctx,sha512_finish_ctx);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is sha512_stream"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  slotvec *__ptr;\n  int i;\n  slotvec *sv;\n  \n  __ptr = slotvec;\n  for (i = 1; i < nslots; i = i + 1) {\n    free(__ptr[i].val);\n  }\n  if (__ptr->val != slot0) {\n    free(__ptr->val);\n    slotvec0.size = 0x100;\n    slotvec0.val = slot0;\n  }\n  if (__ptr != &slotvec0) {\n    free(__ptr);\n    slotvec = &slotvec0;\n  }\n  nslots = 1;\n  return;\n}\n\n",
        "output": "The predicted function name is quotearg_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *arg,size_t argsize)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_n_mem(0,arg,argsize);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is quotearg_mem"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Removing unreachable block (ram,0x00001a37) */\n/* WARNING: Removing unreachable block (ram,0x00001a43) */\n\nvoid [MASK](void)\n\n{\n  return;\n}\n\n",
        "output": "The predicted function name is deregister_tm_clones"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](void *ptr,size_t alignment)\n\n{\n  ulong uVar1;\n  char *p0;\n  char *p1;\n  \n  uVar1 = (long)ptr + (alignment - 1);\n  return (void *)(uVar1 - uVar1 % alignment);\n}\n\n",
        "output": "The predicted function name is ptr_align"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *left_quote,char *right_quote,char *arg)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_n_custom(0,left_quote,right_quote,arg);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is quotearg_custom"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](FILE *fp,off_t offset,int whence)\n\n{\n  int iVar1;\n  __off_t _Var2;\n  off_t pos;\n  \n  if (((fp->_IO_read_end == fp->_IO_read_ptr) && (fp->_IO_write_ptr == fp->_IO_write_base)) &&\n     (fp->_IO_save_base == (char *)0x0)) {\n    iVar1 = fileno((FILE *)fp);\n    _Var2 = lseek(iVar1,offset,whence);\n    if (_Var2 == -1) {\n      iVar1 = -1;\n    }\n    else {\n      fp->_flags = fp->_flags & 0xffffffef;\n      fp->_offset = _Var2;\n      iVar1 = 0;\n    }\n  }\n  else {\n    iVar1 = fseeko((FILE *)fp,offset,whence);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is rpl_fseeko"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](int n,char *arg,size_t argsize)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_n_options(n,arg,argsize,&quote_quoting_options);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is quote_n_mem"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *string)\n\n{\n  size_t sVar1;\n  char *pcVar2;\n  \n  sVar1 = strlen(string);\n  pcVar2 = (char *)xmemdup(string,sVar1 + 1);\n  return pcVar2;\n}\n\n",
        "output": "The predicted function name is xstrdup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](int c)\n\n{\n  if (c < 0x41) {\n    if ((c < 0x3a) && (0xe < c - 0x21U)) {\n      return false;\n    }\n  }\n  else {\n    if (c < 0x5b) {\n      return false;\n    }\n    if ((0x60 < c) && (3 < c - 0x7bU)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n",
        "output": "The predicted function name is c_ispunct"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](char *buffer,size_t len,void *resblock)\n\n{\n  long lVar1;\n  void *pvVar2;\n  long in_FS_OFFSET;\n  sha512_ctx ctx;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  sha512_init_ctx(&ctx);\n  sha512_process_bytes(buffer,len,&ctx);\n  pvVar2 = sha512_finish_ctx(&ctx,resblock);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return pvVar2;\n}\n\n",
        "output": "The predicted function name is sha512_buffer"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](_Bool ignore)\n\n{\n  ignore_EPIPE = ignore;\n  return;\n}\n\n",
        "output": "The predicted function name is close_stdout_set_ignore_EPIPE"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](int c)\n\n{\n  _Bool _Var1;\n  \n  if ((c < 9) || ((0xd < c && (c != 0x20)))) {\n    _Var1 = false;\n  }\n  else {\n    _Var1 = true;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is c_isspace"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](int category)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = setlocale_null_androidfix(category);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is setlocale_null"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nchar * [MASK](int n,char *left_quote,char *right_quote,char *arg,size_t argsize)\n\n{\n  long lVar1;\n  char *pcVar2;\n  long in_FS_OFFSET;\n  quoting_options o;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  o._0_8_ = default_quoting_options._0_8_;\n  o.quote_these_too._0_8_ = default_quoting_options.quote_these_too._0_8_;\n  o.quote_these_too._8_8_ = default_quoting_options.quote_these_too._8_8_;\n  o.quote_these_too._16_8_ = default_quoting_options.quote_these_too._16_8_;\n  o.quote_these_too._24_8_ = default_quoting_options.quote_these_too._24_8_;\n  o.left_quote = default_quoting_options.left_quote;\n  o.right_quote = default_quoting_options.right_quote;\n  set_custom_quoting(&o,left_quote,right_quote);\n  pcVar2 = quotearg_n_options(n,arg,argsize,&o);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return pcVar2;\n}\n\n",
        "output": "The predicted function name is quotearg_n_custom_mem"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](EVP_PKEY_CTX *ctx)\n\n{\n  undefined *puVar1;\n  \n  puVar1 = PTR___gmon_start___00211fd0;\n  if (PTR___gmon_start___00211fd0 != (undefined *)0x0) {\n    puVar1 = (undefined *)(*(code *)PTR___gmon_start___00211fd0)();\n  }\n  return (int)puVar1;\n}\n\n",
        "output": "The predicted function name is _init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](char *filename,int *binary,uchar *bin_result,_Bool *missing)\n\n{\n  _Bool _Var1;\n  int iVar2;\n  int iVar3;\n  char *pcVar4;\n  int *piVar5;\n  _Bool is_stdin;\n  int err;\n  FILE *fp;\n  \n  iVar2 = strcmp(filename,\"-\");\n  *missing = false;\n  if (iVar2 != 0) {\n    fp = fopen_safer(filename,\"r\");\n    if (fp == (FILE *)0x0) {\n      if ((ignore_missing != false) && (piVar5 = __errno_location(), *piVar5 == 2)) {\n        *missing = true;\n        return true;\n      }\n      pcVar4 = quotearg_n_style_colon(0,shell_escape_quoting_style,filename);\n      piVar5 = __errno_location();\n      error(0,*piVar5,&DAT_0000efce,pcVar4);\n      return false;\n    }\n  }\n  else {\n    have_read_stdin = true;\n    fp = stdin;\n  }\n  fadvise(fp,FADVISE_SEQUENTIAL);\n  iVar3 = sha384_stream(fp,bin_result);\n  if (iVar3 == 0) {\n    if ((iVar2 != 0) && (iVar2 = rpl_fclose(fp), iVar2 != 0)) {\n      pcVar4 = quotearg_n_style_colon(0,shell_escape_quoting_style,filename);\n      piVar5 = __errno_location();\n      error(0,*piVar5,&DAT_0000efce,pcVar4);\n      return false;\n    }\n    _Var1 = true;\n  }\n  else {\n    pcVar4 = quotearg_n_style_colon(0,shell_escape_quoting_style,filename);\n    piVar5 = __errno_location();\n    error(0,*piVar5,&DAT_0000efce,pcVar4);\n    if (fp != stdin) {\n      rpl_fclose(fp);\n    }\n    _Var1 = false;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is digest_file"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](quoting_options *o,int i)\n\n{\n  int iVar1;\n  quoting_options *local_20;\n  int r;\n  \n  local_20 = o;\n  if (o == (quoting_options *)0x0) {\n    local_20 = &default_quoting_options;\n  }\n  iVar1 = local_20->flags;\n  local_20->flags = i;\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is set_quoting_flags"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](void *p,size_t *pn)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = x2nrealloc(p,pn,1);\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is x2realloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](int n,quoting_style s,char *arg,size_t argsize)\n\n{\n  long lVar1;\n  char *pcVar2;\n  long in_FS_OFFSET;\n  quoting_options o;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  quoting_options_from_style(&o,s);\n  pcVar2 = quotearg_n_options(n,arg,argsize,&o);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return pcVar2;\n}\n\n",
        "output": "The predicted function name is quotearg_n_style_mem"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  char *__s;\n  FILE *__stream;\n  \n  __stream = stdout;\n  __s = (char *)gettext(\"\\nWith no FILE, or when FILE is -, read standard input.\\n\");\n  fputs_unlocked(__s,__stream);\n  return;\n}\n\n",
        "output": "The predicted function name is emit_stdin_note"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](FILE *stream,char *alg,void *resblock,ssize_t hashlen)\n\n{\n  return -0x61;\n}\n\n",
        "output": "The predicted function name is afalg_stream"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](void *p,size_t n)\n\n{\n  void *pvVar1;\n  \n  if ((n == 0) && (p != (void *)0x0)) {\n    free(p);\n    pvVar1 = (void *)0x0;\n  }\n  else {\n    pvVar1 = realloc(p,n);\n    if ((pvVar1 == (void *)0x0) && (n != 0)) {\n                    /* WARNING: Subroutine does not return */\n      xalloc_die();\n    }\n  }\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is xrealloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  char *write_error;\n  \n  iVar1 = close_stream(stdout);\n  if (iVar1 != 0) {\n    if (ignore_EPIPE == true) {\n      piVar2 = __errno_location();\n      if (*piVar2 == 0x20) goto LAB_0000391a;\n    }\n    uVar3 = gettext(\"write error\");\n    if (file_name == (char *)0x0) {\n      piVar2 = __errno_location();\n      error(0,*piVar2,&DAT_0000f4f8,uVar3);\n    }\n    else {\n      pcVar4 = quotearg_colon(file_name);\n      piVar2 = __errno_location();\n      error(0,*piVar2,\"%s: %s\",pcVar4,uVar3);\n    }\n                    /* WARNING: Subroutine does not return */\n    _exit(exit_failure);\n  }\nLAB_0000391a:\n  iVar1 = close_stream(stderr);\n  if (iVar1 != 0) {\n                    /* WARNING: Subroutine does not return */\n    _exit(exit_failure);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is close_stdout"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](FILE *stream,char *command_name,char *package,char *version,char **authors)\n\n{\n  size_t n_authors;\n  \n  for (n_authors = 0; authors[n_authors] != (char *)0x0; n_authors = n_authors + 1) {\n  }\n  version_etc_arn(stream,command_name,package,version,authors,n_authors);\n  return;\n}\n\n",
        "output": "The predicted function name is version_etc_ar"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](int c)\n\n{\n  _Bool _Var1;\n  \n  switch(c) {\n  case 0x30:\n  case 0x31:\n  case 0x32:\n  case 0x33:\n  case 0x34:\n  case 0x35:\n  case 0x36:\n  case 0x37:\n  case 0x38:\n  case 0x39:\n  case 0x41:\n  case 0x42:\n  case 0x43:\n  case 0x44:\n  case 0x45:\n  case 0x46:\n  case 0x61:\n  case 0x62:\n  case 99:\n  case 100:\n  case 0x65:\n  case 0x66:\n    _Var1 = true;\n    break;\n  default:\n    _Var1 = false;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is c_isxdigit"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](sha512_ctx *ctx)\n\n{\n  ctx->state[0] = 0x6a09e667f3bcc908;\n  ctx->state[1] = 0xbb67ae8584caa73b;\n  ctx->state[2] = 0x3c6ef372fe94f82b;\n  ctx->state[3] = 0xa54ff53a5f1d36f1;\n  ctx->state[4] = 0x510e527fade682d1;\n  ctx->state[5] = 0x9b05688c2b3e6c1f;\n  ctx->state[6] = 0x1f83d9abfb41bd6b;\n  ctx->state[7] = 0x5be0cd19137e2179;\n  ctx->total[1] = 0;\n  ctx->total[0] = ctx->total[1];\n  ctx->buflen = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is sha512_init_ctx"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong [MASK](uintmax_t n)\n\n{\n  return n;\n}\n\n",
        "output": "The predicted function name is select_plural"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](FILE *stream,char *command_name,char *package,char *version,...)\n\n{\n  long lVar1;\n  char in_AL;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  va_list authors;\n  undefined local_b8 [32];\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  authors[0].gp_offset = 0x20;\n  authors[0].fp_offset = 0x30;\n  authors[0].overflow_arg_area = &stack0x00000008;\n  authors[0].reg_save_area = local_b8;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  version_etc_va(stream,command_name,package,version,authors);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is version_etc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int category,char *buf,size_t bufsize)\n\n{\n  int iVar1;\n  \n  iVar1 = setlocale_null_unlocked(category,buf,bufsize);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is setlocale_null_r"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void *buffer,size_t len,sha512_ctx *ctx)\n\n{\n  size_t sVar1;\n  void *buffer_00;\n  ulong local_38;\n  void *local_30;\n  size_t left_over_1;\n  size_t left_over;\n  size_t add;\n  \n  local_38 = len;\n  local_30 = buffer;\n  if (ctx->buflen != 0) {\n    sVar1 = ctx->buflen;\n    local_38 = 0x100 - sVar1;\n    if (len <= 0x100 - sVar1) {\n      local_38 = len;\n    }\n    memcpy((void *)((long)ctx->buffer + sVar1),buffer,local_38);\n    ctx->buflen = ctx->buflen + local_38;\n    if (0x80 < ctx->buflen) {\n      sha512_process_block(ctx->buffer,ctx->buflen & 0xffffffffffffff80,ctx);\n      ctx->buflen = (ulong)((uint)ctx->buflen & 0x7f);\n      memcpy(ctx->buffer,(void *)((long)ctx->buffer + (local_38 + sVar1 & 0xffffffffffffff80)),\n             ctx->buflen);\n    }\n    local_30 = (void *)((long)buffer + local_38);\n    local_38 = len - local_38;\n  }\n  if (0x7f < local_38) {\n    if (((ulong)local_30 & 7) == 0) {\n      sha512_process_block(local_30,local_38 & 0xffffffffffffff80,ctx);\n      local_30 = (void *)((long)local_30 + (local_38 & 0xffffffffffffff80));\n      local_38 = local_38 & 0x7f;\n    }\n    else {\n      for (; 0x80 < local_38; local_38 = local_38 - 0x80) {\n        buffer_00 = memcpy(ctx->buffer,local_30,0x80);\n        sha512_process_block(buffer_00,0x80,ctx);\n        local_30 = (void *)((long)local_30 + 0x80);\n      }\n    }\n  }\n  if (local_38 != 0) {\n    sVar1 = ctx->buflen;\n    memcpy((void *)((long)ctx->buffer + sVar1),local_30,local_38);\n    left_over_1 = sVar1 + local_38;\n    if (0x7f < left_over_1) {\n      sha512_process_block(ctx->buffer,0x80,ctx);\n      left_over_1 = left_over_1 - 0x80;\n      memcpy(ctx->buffer,ctx->buffer + 0x10,left_over_1);\n    }\n    ctx->buflen = left_over_1;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is sha512_process_bytes"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](char *s,size_t s_len,uchar **hex_digest,char **file_name,_Bool escaped_filename)\n\n{\n  size_t sVar1;\n  undefined uVar2;\n  char *pcVar3;\n  size_t i;\n  \n  if (s_len == 0) {\n    uVar2 = 0;\n  }\n  else {\n    for (i = s_len - 1; (i != 0 && (s[i] != ')')); i = i - 1) {\n    }\n    if (s[i] == ')') {\n      *file_name = s;\n      if ((escaped_filename == false) || (pcVar3 = filename_unescape(s,i), pcVar3 != (char *)0x0)) {\n        s[i] = '\\0';\n        do {\n          do {\n            sVar1 = i;\n            i = sVar1 + 1;\n          } while (s[i] == ' ');\n        } while (s[i] == '\\t');\n        if (s[i] == '=') {\n          for (i = sVar1 + 2; (s[i] == ' ' || (s[i] == '\\t')); i = i + 1) {\n          }\n          *hex_digest = (uchar *)(s + i);\n          uVar2 = hex_digits(*hex_digest);\n        }\n        else {\n          uVar2 = 0;\n        }\n      }\n      else {\n        uVar2 = 0;\n      }\n    }\n    else {\n      uVar2 = 0;\n    }\n  }\n  return (_Bool)uVar2;\n}\n\n",
        "output": "The predicted function name is bsd_split_3"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](int n,char *arg,size_t argsize)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_n_options(n,arg,argsize,&default_quoting_options);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is quotearg_n_mem"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n__uint64_t [MASK](__uint64_t __bsx)\n\n{\n  return __bsx >> 0x38 | (__bsx & 0xff000000000000) >> 0x28 | (__bsx & 0xff0000000000) >> 0x18 |\n         (__bsx & 0xff00000000) >> 8 | (__bsx & 0xff000000) << 8 | (__bsx & 0xff0000) << 0x18 |\n         (__bsx & 0xff00) << 0x28 | __bsx << 0x38;\n}\n\n",
        "output": "The predicted function name is __bswap_64"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](int category)\n\n{\n  char *pcVar1;\n  char *result;\n  \n  pcVar1 = setlocale(category,(char *)0x0);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is setlocale_null_androidfix"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *program)\n\n{\n  long lVar1;\n  FILE *__stream;\n  int iVar2;\n  char *pcVar3;\n  char *__format;\n  long in_FS_OFFSET;\n  char *node;\n  infomap *map_prog;\n  char *lc_messages;\n  infomap infomap [7];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  infomap[0].program = \"[\";\n  infomap[0].node = \"test invocation\";\n  infomap[1].program = \"coreutils\";\n  infomap[1].node = \"Multi-call invocation\";\n  infomap[2].program = \"sha224sum\";\n  infomap[2].node = \"sha2 utilities\";\n  infomap[3].program = \"sha256sum\";\n  infomap[3].node = \"sha2 utilities\";\n  infomap[4].program = \"sha384sum\";\n  infomap[4].node = \"sha2 utilities\";\n  infomap[5].program = \"sha512sum\";\n  infomap[5].node = \"sha2 utilities\";\n  infomap[6].program = (char *)0x0;\n  infomap[6].node = (char *)0x0;\n  for (map_prog = infomap; map_prog->program != (char *)0x0; map_prog = map_prog + 1) {\n    iVar2 = strcmp(program,map_prog->program);\n    if (iVar2 == 0) break;\n  }\n  node = program;\n  if (map_prog->node != (char *)0x0) {\n    node = map_prog->node;\n  }\n  pcVar3 = (char *)gettext(\"\\n%s online help: <%s>\\n\");\n  printf(pcVar3,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n  pcVar3 = setlocale(5,(char *)0x0);\n  if (pcVar3 != (char *)0x0) {\n    iVar2 = strncmp(pcVar3,\"en_\",3);\n    __stream = stdout;\n    if (iVar2 != 0) {\n      pcVar3 = (char *)gettext(\n                              \"Report any translation bugs to <https://translationproject.org/team/>\\n\"\n                              );\n      fputs_unlocked(pcVar3,__stream);\n    }\n  }\n  pcVar3 = (char *)gettext(\"Full documentation <%s%s>\\n\");\n  printf(pcVar3,\"https://www.gnu.org/software/coreutils/\",program);\n  if (node == program) {\n    pcVar3 = \" invocation\";\n  }\n  else {\n    pcVar3 = \"\";\n  }\n  __format = (char *)gettext(\"or available locally via: info \\'(coreutils) %s%s\\'\\n\");\n  printf(__format,node,pcVar3);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is emit_ancillary_info"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](FILE *stream,char *command_name,char *package,char *version,\n                   __va_list_tag *authors)\n\n{\n  long lVar1;\n  char **ppcVar2;\n  long in_FS_OFFSET;\n  size_t n_authors;\n  char *authtab [10];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  for (n_authors = 0; n_authors < 10; n_authors = n_authors + 1) {\n    if (authors->gp_offset < 0x30) {\n      ppcVar2 = (char **)((ulong)authors->gp_offset + (long)authors->reg_save_area);\n      authors->gp_offset = authors->gp_offset + 8;\n    }\n    else {\n      ppcVar2 = (char **)authors->overflow_arg_area;\n      authors->overflow_arg_area = ppcVar2 + 1;\n    }\n    authtab[n_authors] = *ppcVar2;\n    if (authtab[n_authors] == (char *)0x0) break;\n  }\n  version_etc_arn(stream,command_name,package,version,authtab,n_authors);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is version_etc_va"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](size_t n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = xcalloc(n,1);\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is xzalloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int fd,int target)\n\n{\n  int iVar1;\n  int result;\n  \n  iVar1 = fcntl(fd,0,(ulong)(uint)target);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is rpl_fcntl_DUPFD"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](sha512_ctx *ctx,void *resbuf)\n\n{\n  void *pvVar1;\n  \n  sha512_conclude_ctx(ctx);\n  pvVar1 = sha384_read_ctx(ctx,resbuf);\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is sha384_finish_ctx"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](char *s,size_t s_len,uchar **hex_digest,int *binary,char **file_name)\n\n{\n  size_t sVar1;\n  long lVar2;\n  undefined uVar3;\n  _Bool _Var4;\n  int iVar5;\n  char *pcVar6;\n  bool escaped_filename_00;\n  _Bool escaped_filename;\n  size_t i;\n  size_t algo_name_len;\n  \n  for (i = 0; (s[i] == ' ' || (s[i] == '\\t')); i = i + 1) {\n  }\n  escaped_filename_00 = s[i] == '\\\\';\n  if (escaped_filename_00) {\n    i = i + 1;\n  }\n  iVar5 = strncmp(s + i,\"SHA384\",6);\n  if (iVar5 == 0) {\n    sVar1 = i + 6;\n    if (s[i + 6] == ' ') {\n      sVar1 = i + 7;\n    }\n    i = sVar1;\n    if (s[i] == '(') {\n      *binary = 0;\n      uVar3 = bsd_split_3(s + i + 1,s_len - (i + 1),hex_digest,file_name,escaped_filename_00);\n    }\n    else {\n      uVar3 = 0;\n    }\n  }\n  else if (s_len - i < min_digest_line_length + (s[i] == '\\\\')) {\n    uVar3 = 0;\n  }\n  else {\n    *hex_digest = (uchar *)(s + i);\n    lVar2 = i + digest_hex_bytes;\n    if ((s[lVar2] == ' ') || (s[lVar2] == '\\t')) {\n      sVar1 = lVar2 + 1;\n      s[lVar2] = '\\0';\n      _Var4 = hex_digits(*hex_digest);\n      if (_Var4 == true) {\n        i = sVar1;\n        if ((s_len - sVar1 == 1) || ((s[sVar1] != ' ' && (s[sVar1] != '*')))) {\n          if (bsd_reversed == 0) {\n            return false;\n          }\n          bsd_reversed = 1;\n        }\n        else if (bsd_reversed != 1) {\n          bsd_reversed = 0;\n          i = lVar2 + 2;\n          *binary = (uint)(s[sVar1] == '*');\n        }\n        *file_name = s + i;\n        if (escaped_filename_00) {\n          pcVar6 = filename_unescape(s + i,s_len - i);\n          uVar3 = pcVar6 != (char *)0x0;\n        }\n        else {\n          uVar3 = 1;\n        }\n      }\n      else {\n        uVar3 = 0;\n      }\n    }\n    else {\n      uVar3 = 0;\n    }\n  }\n  return (_Bool)uVar3;\n}\n\n",
        "output": "The predicted function name is split_3"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *msgid,quoting_style s)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *translation;\n  char *locale_code;\n  \n  pcVar2 = (char *)gettext(msgid);\n  if (pcVar2 == msgid) {\n    pcVar2 = locale_charset();\n    iVar1 = c_strcasecmp(pcVar2,\"UTF-8\");\n    if (iVar1 == 0) {\n      if (*msgid == '`') {\n        pcVar2 = &DAT_0000f90e;\n      }\n      else {\n        pcVar2 = &DAT_0000f912;\n      }\n    }\n    else {\n      iVar1 = c_strcasecmp(pcVar2,\"GB18030\");\n      if (iVar1 == 0) {\n        if (*msgid == '`') {\n          pcVar2 = &DAT_0000f91e;\n        }\n        else {\n          pcVar2 = &DAT_0000f922;\n        }\n      }\n      else if (s == clocale_quoting_style) {\n        pcVar2 = \"\\\"\";\n      }\n      else {\n        pcVar2 = \"\\'\";\n      }\n    }\n  }\n  return pcVar2;\n}\n\n",
        "output": "The predicted function name is gettext_quote"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](sha512_ctx *ctx)\n\n{\n  ctx->state[0] = 0xcbbb9d5dc1059ed8;\n  ctx->state[1] = 0x629a292a367cd507;\n  ctx->state[2] = 0x9159015a3070dd17;\n  ctx->state[3] = 0x152fecd8f70e5939;\n  ctx->state[4] = 0x67332667ffc00b31;\n  ctx->state[5] = 0x8eb44a8768581511;\n  ctx->state[6] = 0xdb0c2e0d64f98fa7;\n  ctx->state[7] = 0x47b5481dbefa4fa4;\n  ctx->total[1] = 0;\n  ctx->total[0] = ctx->total[1];\n  ctx->buflen = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is sha384_init_ctx"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](uchar *s)\n\n{\n  ushort **ppuVar1;\n  byte *local_20;\n  uint i;\n  \n  i = 0;\n  local_20 = s;\n  while( true ) {\n    if (digest_hex_bytes <= i) {\n      return *local_20 == 0;\n    }\n    ppuVar1 = __ctype_b_loc();\n    if (((*ppuVar1)[*local_20] & 0x1000) == 0) break;\n    local_20 = local_20 + 1;\n    i = i + 1;\n  }\n  return false;\n}\n\n",
        "output": "The predicted function name is hex_digits"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](int n,quoting_style s,char *arg)\n\n{\n  long lVar1;\n  char *pcVar2;\n  long in_FS_OFFSET;\n  quoting_options o;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  quoting_options_from_style(&o,s);\n  pcVar2 = quotearg_n_options(n,arg,0xffffffffffffffff,&o);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return pcVar2;\n}\n\n",
        "output": "The predicted function name is quotearg_n_style"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](int n,char *arg)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quote_n_mem(n,arg,0xffffffffffffffff);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is quote_n"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *arg,size_t argsize,quoting_options *o)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_alloc_mem(arg,argsize,(size_t *)0x0,o);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is quotearg_alloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *file)\n\n{\n  file_name = file;\n  return;\n}\n\n",
        "output": "The predicted function name is close_stdout_set_file_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](EVP_PKEY_CTX *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  long lVar1;\n  \n  _init(param_1);\n  lVar1 = 0;\n  do {\n    (*(code *)(&__frame_dummy_init_array_entry)[lVar1])((ulong)param_1 & 0xffffffff,param_2,param_3)\n    ;\n    lVar1 = lVar1 + 1;\n  } while (lVar1 != 1);\n  return;\n}\n\n",
        "output": "The predicted function name is __libc_csu_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](int c)\n\n{\n  return c - 0x30U < 10;\n}\n\n",
        "output": "The predicted function name is c_isdigit"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int status)\n\n{\n  FILE *pFVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  pcVar3 = program_name;\n  if (status == 0) {\n    pcVar2 = (char *)gettext(\n                            \"Usage: %s [OPTION]... [FILE]...\\nPrint or check %s (%d-bit) checksums.\\n\"\n                            );\n    printf(pcVar2,pcVar3,\"SHA384\",0x180);\n    emit_stdin_note();\n    pFVar1 = stdout;\n    pcVar3 = (char *)gettext(\"\\n  -b, --binary         read in binary mode\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pcVar3 = (char *)gettext(\"  -c, --check          read %s sums from the FILEs and check them\\n\");\n    printf(pcVar3,\"SHA384\");\n    pFVar1 = stdout;\n    pcVar3 = (char *)gettext(\"      --tag            create a BSD-style checksum\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = stdout;\n    pcVar3 = (char *)gettext(\"  -t, --text           read in text mode (default)\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -z, --zero           end each output line with NUL, not newline,\\n                       and disable file name escaping\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nThe following five options are useful only when verifying checksums:\\n      --ignore-missing  don\\'t fail or report status for missing files\\n      --quiet          don\\'t print OK for each successfully verified file\\n      --status         don\\'t output anything, status code shows success\\n      --strict         exit non-zero for improperly formatted checksum lines\\n  -w, --warn           warn about improperly formatted checksum lines\\n\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = stdout;\n    pcVar3 = (char *)gettext(\"      --help     display this help and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = stdout;\n    pcVar3 = (char *)gettext(\"      --version  output version information and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pcVar3 = (char *)gettext(\n                            \"\\nThe sums are computed as described in %s.  When checking, the input\\nshould be a former output of this program.  The default mode is to print a\\nline with checksum, a space, a character indicating input mode (\\'*\\' for binary,\\n\\' \\' for text or where binary is insignificant), and name for each FILE.\\n\\nNote: There is no difference between binary mode and text mode on GNU systems.\\n\"\n                            );\n    printf(pcVar3,\"FIPS-180-2\");\n    emit_ancillary_info(\"sha384sum\");\n  }\n  else {\n    pcVar2 = (char *)gettext(\"Try \\'%s --help\\' for more information.\\n\");\n    fprintf(stderr,pcVar2,pcVar3);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(status);\n}\n\n",
        "output": "The predicted function name is usage"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nquoting_options *\n[MASK](quoting_options *__return_storage_ptr__,quoting_style style)\n\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  quoting_options o;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if (style == custom_quoting_style) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  o._0_8_ = (ulong)style;\n  *(ulong *)__return_storage_ptr__ = o._0_8_;\n  *(undefined8 *)__return_storage_ptr__->quote_these_too = 0;\n  *(undefined8 *)(__return_storage_ptr__->quote_these_too + 2) = 0;\n  *(undefined8 *)(__return_storage_ptr__->quote_these_too + 4) = 0;\n  *(undefined8 *)(__return_storage_ptr__->quote_these_too + 6) = 0;\n  __return_storage_ptr__->left_quote = (char *)0x0;\n  __return_storage_ptr__->right_quote = (char *)0x0;\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return __return_storage_ptr__;\n}\n\n",
        "output": "The predicted function name is quoting_options_from_style"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *cp,u64 v)\n\n{\n  *(u64 *)cp = v;\n  return;\n}\n\n",
        "output": "The predicted function name is set_uint64"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nsize_t [MASK](wchar_t *pwc,char *s,size_t n,mbstate_t *ps)\n\n{\n  _Bool _Var1;\n  size_t sVar2;\n  long in_FS_OFFSET;\n  wchar_t *local_30;\n  uchar uc;\n  wchar_t wc;\n  size_t ret;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = pwc;\n  if (pwc == (wchar_t *)0x0) {\n    local_30 = &wc;\n  }\n  ret = mbrtowc(local_30,s,n,(mbstate_t *)ps);\n  sVar2 = ret;\n  if (((0xfffffffffffffffd < ret) && (n != 0)) &&\n     (_Var1 = hard_locale(0), sVar2 = ret, _Var1 != true)) {\n    *local_30 = (uint)(byte)*s;\n    sVar2 = 1;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return sVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is rpl_mbrtowc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](int c)\n\n{\n  return c - 0x21U < 0x5e;\n}\n\n",
        "output": "The predicted function name is c_isgraph"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](sha512_ctx *ctx,void *resbuf)\n\n{\n  void *pvVar1;\n  \n  sha512_conclude_ctx(ctx);\n  pvVar1 = sha512_read_ctx(ctx,resbuf);\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is sha512_finish_ctx"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](int category)\n\n{\n  long lVar1;\n  _Bool _Var2;\n  int iVar3;\n  long in_FS_OFFSET;\n  char locale [257];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar3 = setlocale_null_r(category,locale,0x101);\n  if (iVar3 == 0) {\n    iVar3 = strcmp(locale,\"C\");\n    if ((iVar3 == 0) || (iVar3 = strcmp(locale,\"POSIX\"), iVar3 == 0)) {\n      _Var2 = false;\n    }\n    else {\n      _Var2 = true;\n    }\n  }\n  else {\n    _Var2 = false;\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return _Var2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is hard_locale"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](quoting_options *o,quoting_style s)\n\n{\n  if (o == (quoting_options *)0x0) {\n    o = &default_quoting_options;\n  }\n  o->style = s;\n  return;\n}\n\n",
        "output": "The predicted function name is set_quoting_style"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](void *p,size_t s)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = xmalloc(s);\n  pvVar1 = memcpy(pvVar1,p,s);\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is xmemdup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nquoting_style [MASK](quoting_options *o)\n\n{\n  if (o == (quoting_options *)0x0) {\n    o = &default_quoting_options;\n  }\n  return o->style;\n}\n\n",
        "output": "The predicted function name is get_quoting_style"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](void)\n\n{\n  char *codeset;\n  \n  codeset = nl_langinfo(0xe);\n  if (codeset == (char *)0x0) {\n    codeset = \"\";\n  }\n  if (*codeset == '\\0') {\n    codeset = \"ASCII\";\n  }\n  return codeset;\n}\n\n",
        "output": "The predicted function name is locale_charset"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *argv0)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *__s1;\n  char *local_20;\n  char *slash;\n  char *base;\n  \n  if (argv0 != (char *)0x0) {\n    pcVar2 = strrchr(argv0,0x2f);\n    __s1 = argv0;\n    if (pcVar2 != (char *)0x0) {\n      __s1 = pcVar2 + 1;\n    }\n    local_20 = argv0;\n    if (((6 < (long)__s1 - (long)argv0) &&\n        (iVar1 = strncmp(__s1 + -7,\"/.libs/\",7), local_20 = argv0, iVar1 == 0)) &&\n       (iVar1 = strncmp(__s1,\"lt-\",3), local_20 = __s1, iVar1 == 0)) {\n      program_invocation_short_name = __s1 + 3;\n      local_20 = program_invocation_short_name;\n    }\n    program_invocation_name = local_20;\n    program_name = local_20;\n    return;\n  }\n  fwrite(\"A NULL argv[0] was passed through an exec system call.\\n\",1,0x37,stderr);\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
        "output": "The predicted function name is set_program_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](char *checkfile_name)\n\n{\n  long lVar1;\n  _Bool _Var2;\n  int iVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  int *piVar6;\n  ulong uVar7;\n  long in_FS_OFFSET;\n  char *local_e0;\n  _Bool missing;\n  _Bool properly_formatted_lines;\n  _Bool matched_checksums;\n  _Bool is_stdin;\n  _Bool needs_escape;\n  _Bool ok;\n  int binary;\n  char *line;\n  size_t line_chars_allocated;\n  char *filename;\n  uchar *hex_digest;\n  FILE *checkfile_stream;\n  uintmax_t n_misformatted_lines;\n  uintmax_t n_improperly_formatted_lines;\n  uintmax_t n_mismatched_checksums;\n  uintmax_t n_open_or_read_failures;\n  uintmax_t line_number;\n  ssize_t line_length;\n  size_t cnt;\n  uchar *bin_buffer;\n  size_t digest_bin_bytes;\n  uchar bin_buffer_unaligned [56];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  n_misformatted_lines = 0;\n  n_improperly_formatted_lines = 0;\n  n_mismatched_checksums = 0;\n  n_open_or_read_failures = 0;\n  properly_formatted_lines = false;\n  matched_checksums = false;\n  bin_buffer = (uchar *)ptr_align(bin_buffer_unaligned,8);\n  iVar3 = strcmp(checkfile_name,\"-\");\n  is_stdin = iVar3 == 0;\n  if (is_stdin) {\n    have_read_stdin = true;\n    local_e0 = (char *)gettext(\"standard input\");\n    checkfile_stream = stdin;\n  }\n  else {\n    checkfile_stream = fopen_safer(checkfile_name,\"r\");\n    local_e0 = checkfile_name;\n    if (checkfile_stream == (FILE *)0x0) {\n      pcVar4 = quotearg_n_style_colon(0,shell_escape_quoting_style,checkfile_name);\n      piVar6 = __errno_location();\n      error(0,*piVar6,&DAT_0000efce,pcVar4);\n      _Var2 = false;\n      goto LAB_00002fb9;\n    }\n  }\n  line_number = 0;\n  line = (char *)0x0;\n  line_chars_allocated = 0;\n  while( true ) {\n    line_number = line_number + 1;\n    if (line_number == 0) {\n      pcVar4 = quotearg_n_style_colon(0,shell_escape_quoting_style,local_e0);\n      uVar5 = gettext(\"%s: too many checksum lines\");\n      error(1,0,uVar5,pcVar4);\n    }\n    line_length = getline(&line,&line_chars_allocated,(FILE *)checkfile_stream);\n    if (line_length < 1) break;\n    if (*line != '#') {\n      if (line[line_length + -1] == '\\n') {\n        line_length = line_length + -1;\n        line[line_length] = '\\0';\n      }\n      _Var2 = split_3(line,line_length,&hex_digest,&binary,&filename);\n      if ((_Var2 == true) && ((is_stdin == false || (iVar3 = strcmp(filename,\"-\"), iVar3 != 0)))) {\n        if ((status_only == true) || (pcVar4 = strchr(filename,10), pcVar4 == (char *)0x0)) {\n          needs_escape = false;\n        }\n        else {\n          needs_escape = true;\n        }\n        properly_formatted_lines = true;\n        ok = digest_file(filename,&binary,bin_buffer,&missing);\n        if (ok == true) {\n          if ((ignore_missing == false) || (missing == false)) {\n            digest_bin_bytes = digest_hex_bytes >> 1;\n            cnt = 0;\n            while (((cnt < digest_bin_bytes &&\n                    (iVar3 = tolower((uint)hex_digest[cnt * 2]),\n                    iVar3 == \"0123456789abcdef8.32\"[(int)(uint)(bin_buffer[cnt] >> 4)])) &&\n                   (iVar3 = tolower((uint)hex_digest[cnt * 2 + 1]),\n                   iVar3 == \"0123456789abcdef8.32\"[(int)(bin_buffer[cnt] & 0xf)]))) {\n              cnt = cnt + 1;\n            }\n            if (cnt == digest_bin_bytes) {\n              matched_checksums = true;\n            }\n            else {\n              n_mismatched_checksums = n_mismatched_checksums + 1;\n            }\n            if (status_only != true) {\n              if ((cnt != digest_bin_bytes) || (quiet != true)) {\n                if (needs_escape != false) {\n                  putchar_unlocked(0x5c);\n                }\n                print_filename(filename,needs_escape);\n              }\n              if (cnt == digest_bin_bytes) {\n                if (quiet != true) {\n                  uVar5 = gettext(&DAT_0000f050);\n                  printf(\": %s\\n\",uVar5);\n                }\n              }\n              else {\n                uVar5 = gettext(\"FAILED\");\n                printf(\": %s\\n\",uVar5);\n              }\n            }\n          }\n        }\n        else {\n          n_open_or_read_failures = n_open_or_read_failures + 1;\n          if (status_only != true) {\n            if (needs_escape != false) {\n              putchar_unlocked(0x5c);\n            }\n            print_filename(filename,needs_escape);\n            uVar5 = gettext(\"FAILED open or read\");\n            printf(\": %s\\n\",uVar5);\n          }\n        }\n      }\n      else {\n        n_misformatted_lines = n_misformatted_lines + 1;\n        if (warn != false) {\n          pcVar4 = quotearg_n_style_colon(0,shell_escape_quoting_style,local_e0);\n          uVar5 = gettext(0xf000);\n          error(0,0,uVar5,pcVar4,line_number,\"SHA384\");\n        }\n        n_improperly_formatted_lines = n_improperly_formatted_lines + 1;\n      }\n    }\n    iVar3 = feof_unlocked((FILE *)checkfile_stream);\n    if ((iVar3 != 0) || (iVar3 = ferror_unlocked((FILE *)checkfile_stream), iVar3 != 0)) break;\n  }\n  free(line);\n  iVar3 = ferror_unlocked((FILE *)checkfile_stream);\n  if (iVar3 == 0) {\n    if ((is_stdin == true) || (iVar3 = rpl_fclose(checkfile_stream), iVar3 == 0)) {\n      if (properly_formatted_lines == true) {\n        if (status_only != true) {\n          if (n_misformatted_lines != 0) {\n            uVar7 = select_plural(n_misformatted_lines);\n            uVar5 = ngettext(\"WARNING: %lu line is improperly formatted\",\n                             \"WARNING: %lu lines are improperly formatted\",uVar7);\n            error(0,0,uVar5,n_misformatted_lines);\n          }\n          if (n_open_or_read_failures != 0) {\n            uVar7 = select_plural(n_open_or_read_failures);\n            uVar5 = ngettext(\"WARNING: %lu listed file could not be read\",\n                             \"WARNING: %lu listed files could not be read\",uVar7);\n            error(0,0,uVar5,n_open_or_read_failures);\n          }\n          if (n_mismatched_checksums != 0) {\n            uVar7 = select_plural(n_mismatched_checksums);\n            uVar5 = ngettext(\"WARNING: %lu computed checksum did NOT match\",\n                             \"WARNING: %lu computed checksums did NOT match\",uVar7);\n            error(0,0,uVar5,n_mismatched_checksums);\n          }\n          if ((ignore_missing != false) && (matched_checksums != true)) {\n            pcVar4 = quotearg_n_style_colon(0,shell_escape_quoting_style,local_e0);\n            uVar5 = gettext(\"%s: no file was verified\");\n            error(0,0,uVar5,pcVar4);\n          }\n        }\n      }\n      else {\n        pcVar4 = quotearg_n_style_colon(0,shell_escape_quoting_style,local_e0);\n        uVar5 = gettext(\"%s: no properly formatted %s checksum lines found\");\n        error(0,0,uVar5,pcVar4,\"SHA384\");\n      }\n      if (((((properly_formatted_lines == false) || (matched_checksums == false)) ||\n           (n_mismatched_checksums != 0)) || (n_open_or_read_failures != 0)) ||\n         ((strict == true && (n_improperly_formatted_lines != 0)))) {\n        _Var2 = false;\n      }\n      else {\n        _Var2 = true;\n      }\n    }\n    else {\n      pcVar4 = quotearg_n_style_colon(0,shell_escape_quoting_style,local_e0);\n      piVar6 = __errno_location();\n      error(0,*piVar6,&DAT_0000efce,pcVar4);\n      _Var2 = false;\n    }\n  }\n  else {\n    pcVar4 = quotearg_n_style_colon(0,shell_escape_quoting_style,local_e0);\n    uVar5 = gettext(\"%s: read error\");\n    error(0,0,uVar5,pcVar4);\n    _Var2 = false;\n  }\nLAB_00002fb9:\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return _Var2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is digest_check"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nsize_t [MASK](char *buffer,size_t buffersize,char *arg,size_t argsize,quoting_options *o)\n\n{\n  int iVar1;\n  int *piVar2;\n  size_t sVar3;\n  int e;\n  quoting_options *p;\n  size_t r;\n  \n  if (o == (quoting_options *)0x0) {\n    o = &default_quoting_options;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  sVar3 = quotearg_buffer_restyled\n                    (buffer,buffersize,arg,argsize,o->style,o->flags,o->quote_these_too,\n                     o->left_quote,o->right_quote);\n  piVar2 = __errno_location();\n  *piVar2 = iVar1;\n  return sVar3;\n}\n\n",
        "output": "The predicted function name is quotearg_buffer"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *arg)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_char(arg,':');\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is quotearg_colon"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *file,_Bool escape)\n\n{\n  char *local_10;\n  \n  local_10 = file;\n  if (escape == true) {\n    for (; *local_10 != '\\0'; local_10 = local_10 + 1) {\n      if (*local_10 == '\\n') {\n        fwrite_unlocked(&DAT_0000efc4,1,2,stdout);\n      }\n      else if (*local_10 == '\\\\') {\n        fwrite_unlocked(&DAT_0000efc7,1,2,stdout);\n      }\n      else {\n        putchar_unlocked((int)*local_10);\n      }\n    }\n  }\n  else {\n    fputs_unlocked(file,stdout);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is print_filename"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](FILE *stream)\n\n{\n  int iVar1;\n  \n  if ((stream != (FILE *)0x0) && (iVar1 = __freading(stream), iVar1 != 0)) {\n    clear_ungetc_buffer_preserving_position(stream);\n    iVar1 = fflush((FILE *)stream);\n    return iVar1;\n  }\n  iVar1 = fflush((FILE *)stream);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is rpl_fflush"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](sha512_ctx *ctx)\n\n{\n  ulong uVar1;\n  long lVar2;\n  __uint64_t _Var3;\n  size_t bytes;\n  size_t size;\n  \n  uVar1 = ctx->buflen;\n  if (uVar1 < 0x70) {\n    lVar2 = 0x10;\n  }\n  else {\n    lVar2 = 0x20;\n  }\n  ctx->total[0] = ctx->total[0] + uVar1;\n  if (ctx->total[0] < uVar1) {\n    ctx->total[1] = ctx->total[1] + 1;\n  }\n  _Var3 = __bswap_64(ctx->total[0] >> 0x3d | ctx->total[1] * 8);\n  set_uint64((char *)(ctx->total + lVar2 + 1),_Var3);\n  _Var3 = __bswap_64(ctx->total[0] << 3);\n  set_uint64((char *)(ctx->buffer + lVar2 + -1),_Var3);\n  memcpy((void *)((long)ctx->buffer + uVar1),fillbuf,(lVar2 * 8 - uVar1) - 0x10);\n  sha512_process_block(ctx->buffer,lVar2 * 8,ctx);\n  return;\n}\n\n",
        "output": "The predicted function name is sha512_conclude_ctx"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](quoting_options *o,char c,int i)\n\n{\n  uint uVar1;\n  uint *puVar2;\n  uchar uc;\n  int shift;\n  int r;\n  uint *p;\n  \n  if (o == (quoting_options *)0x0) {\n    o = &default_quoting_options;\n  }\n  puVar2 = o->quote_these_too + ((byte)c >> 5);\n  uVar1 = *puVar2 >> (c & 0x1fU) & 1;\n  *puVar2 = *puVar2 ^ (i & 1U ^ uVar1) << (c & 0x1fU);\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is set_char_quoting"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](int n,char *arg)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_n_options(n,arg,0xffffffffffffffff,&default_quoting_options);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is quotearg_n"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](FILE *stream)\n\n{\n  int iVar1;\n  int iVar2;\n  long lVar3;\n  int *piVar4;\n  _Bool some_pending;\n  _Bool prev_fail;\n  _Bool fclose_fail;\n  \n  lVar3 = __fpending(stream);\n  iVar1 = ferror_unlocked((FILE *)stream);\n  iVar2 = rpl_fclose(stream);\n  if ((iVar1 == 0) &&\n     ((iVar2 == 0 || ((lVar3 == 0 && (piVar4 = __errno_location(), *piVar4 == 9)))))) {\n    return 0;\n  }\n  if (iVar2 == 0) {\n    piVar4 = __errno_location();\n    *piVar4 = 0;\n  }\n  return -1;\n}\n\n",
        "output": "The predicted function name is close_stream"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *arg,size_t argsize)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_char_mem(arg,argsize,':');\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is quotearg_colon_mem"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](size_t n,size_t s)\n\n{\n  void *pvVar1;\n  void *p;\n  \n  if ((-1 < SUB168(ZEXT816(n) * ZEXT816(s),0) && SUB168(ZEXT816(n) * ZEXT816(s) >> 0x40,0) == 0) &&\n     (pvVar1 = calloc(n,s), pvVar1 != (void *)0x0)) {\n    return pvVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  xalloc_die();\n}\n\n",
        "output": "The predicted function name is xcalloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](FILE *fp)\n\n{\n  if ((fp->_flags & 0x100U) != 0) {\n    rpl_fseeko(fp,0,1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is clear_ungetc_buffer_preserving_position"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](sha512_ctx *ctx,void *resbuf)\n\n{\n  __uint64_t v;\n  int i;\n  char *r;\n  \n  for (i = 0; i < 8; i = i + 1) {\n    v = __bswap_64(ctx->state[i]);\n    set_uint64((char *)((long)resbuf + (long)i * 8),v);\n  }\n  return resbuf;\n}\n\n",
        "output": "The predicted function name is sha512_read_ctx"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](size_t n,size_t s)\n\n{\n  void *pvVar1;\n  \n  if (SUB168(ZEXT816(n) * ZEXT816(s),0) < 0 || SUB168(ZEXT816(n) * ZEXT816(s) >> 0x40,0) != 0) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  pvVar1 = xmalloc(n * s);\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is xnmalloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *arg,char ch)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_char_mem(arg,0xffffffffffffffff,ch);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is quotearg_char"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int c)\n\n{\n  if (c - 0x41U < 0x1a) {\n    c = c + 0x20;\n  }\n  return c;\n}\n\n",
        "output": "The predicted function name is c_tolower"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](quoting_style s,char *arg)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_n_style(0,s,arg);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is quotearg_style"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *arg,size_t argsize,size_t *size,quoting_options *o)\n\n{\n  int iVar1;\n  uint flags_00;\n  int *piVar2;\n  size_t sVar3;\n  char *buffer;\n  int e;\n  int flags;\n  quoting_options *p;\n  size_t bufsize;\n  char *buf;\n  \n  if (o == (quoting_options *)0x0) {\n    o = &default_quoting_options;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  flags_00 = (uint)(size == (size_t *)0x0) | o->flags;\n  sVar3 = quotearg_buffer_restyled\n                    ((char *)0x0,0,arg,argsize,o->style,flags_00,o->quote_these_too,o->left_quote,\n                     o->right_quote);\n  buffer = xcharalloc(sVar3 + 1);\n  quotearg_buffer_restyled\n            (buffer,sVar3 + 1,arg,argsize,o->style,flags_00,o->quote_these_too,o->left_quote,\n             o->right_quote);\n  piVar2 = __errno_location();\n  *piVar2 = iVar1;\n  if (size != (size_t *)0x0) {\n    *size = sVar3;\n  }\n  return buffer;\n}\n\n",
        "output": "The predicted function name is quotearg_alloc_mem"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](quoting_style s,char *arg,size_t argsize)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_n_style_mem(0,s,arg,argsize);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is quotearg_style_mem"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = gettext(\"memory exhausted\");\n  error(exit_failure,0,0x10000,uVar1);\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
        "output": "The predicted function name is xalloc_die"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nFILE * [MASK](char *file,char *mode)\n\n{\n  int iVar1;\n  int iVar2;\n  FILE *__stream;\n  int *piVar3;\n  int fd;\n  int f;\n  int e_1;\n  int e;\n  FILE *fp;\n  \n  __stream = fopen(file,mode);\n  if (((__stream != (FILE *)0x0) && (iVar1 = fileno(__stream), -1 < iVar1)) && (iVar1 < 3)) {\n    iVar1 = dup_safer(iVar1);\n    if (iVar1 < 0) {\n      piVar3 = __errno_location();\n      iVar1 = *piVar3;\n      rpl_fclose((FILE *)__stream);\n      piVar3 = __errno_location();\n      *piVar3 = iVar1;\n      __stream = (FILE *)0x0;\n    }\n    else {\n      iVar2 = rpl_fclose((FILE *)__stream);\n      if ((iVar2 != 0) || (__stream = fdopen(iVar1,mode), __stream == (FILE *)0x0)) {\n        piVar3 = __errno_location();\n        iVar2 = *piVar3;\n        close(iVar1);\n        piVar3 = __errno_location();\n        *piVar3 = iVar2;\n        __stream = (FILE *)0x0;\n      }\n    }\n  }\n  return (FILE *)__stream;\n}\n\n",
        "output": "The predicted function name is fopen_safer"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](int n,char *left_quote,char *right_quote,char *arg)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_n_custom_mem(n,left_quote,right_quote,arg,0xffffffffffffffff);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is quotearg_n_custom"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int argc,char **argv)\n\n{\n  long lVar1;\n  _Bool _Var2;\n  int iVar3;\n  undefined8 uVar4;\n  char **ppcVar5;\n  char *pcVar6;\n  int *piVar7;\n  long in_FS_OFFSET;\n  _Bool missing;\n  _Bool do_check;\n  _Bool ok;\n  _Bool prefix_tag;\n  _Bool needs_escape;\n  int file_is_binary;\n  int binary;\n  int opt;\n  char **operand_lim;\n  char **operandp;\n  size_t i;\n  uchar *bin_buffer;\n  char *short_opts;\n  char *file;\n  uchar bin_buffer_unaligned [56];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  bin_buffer = (uchar *)ptr_align(bin_buffer_unaligned,8);\n  do_check = false;\n  ok = true;\n  binary = -1;\n  prefix_tag = false;\n  set_program_name(*argv);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\n                 \"/home/xin/Downloads/gnu_projects/compilation/x86_64/O0/compile_projects_copy/coreutils-8.32/build/share/locale\"\n                );\n  textdomain(\"coreutils\");\n  atexit(close_stdout);\n  setvbuf(stdout,(char *)0x0,1,0);\n  short_opts = \"bctwz\";\nLAB_00003259:\n  while( true ) {\n    opt = getopt_long(argc,argv,short_opts,long_options,0);\n    if (opt == -1) {\n      min_digest_line_length = 0x62;\n      digest_hex_bytes = 0x60;\n      if ((prefix_tag != false) && (binary == 0)) {\n        uVar4 = gettext(\"--tag does not support --text mode\");\n        error(0,0,uVar4);\n                    /* WARNING: Subroutine does not return */\n        usage(1);\n      }\n      if ((delim != '\\n') && (do_check != false)) {\n        uVar4 = gettext(\"the --zero option is not supported when verifying checksums\");\n        error(0,0,uVar4);\n                    /* WARNING: Subroutine does not return */\n        usage(1);\n      }\n      if ((prefix_tag != false) && (do_check != false)) {\n        uVar4 = gettext(\"the --tag option is meaningless when verifying checksums\");\n        error(0,0,uVar4);\n                    /* WARNING: Subroutine does not return */\n        usage(1);\n      }\n      if ((-1 < binary) && (do_check != false)) {\n        uVar4 = gettext(\"the --binary and --text options are meaningless when verifying checksums\");\n        error(0,0,uVar4);\n                    /* WARNING: Subroutine does not return */\n        usage(1);\n      }\n      if ((ignore_missing != false) && (do_check != true)) {\n        uVar4 = gettext(\"the --ignore-missing option is meaningful only when verifying checksums\");\n        error(0,0,uVar4);\n                    /* WARNING: Subroutine does not return */\n        usage(1);\n      }\n      if ((status_only != false) && (do_check != true)) {\n        uVar4 = gettext(\"the --status option is meaningful only when verifying checksums\");\n        error(0,0,uVar4);\n                    /* WARNING: Subroutine does not return */\n        usage(1);\n      }\n      if ((warn != false) && (do_check != true)) {\n        uVar4 = gettext(\"the --warn option is meaningful only when verifying checksums\");\n        error(0,0,uVar4);\n                    /* WARNING: Subroutine does not return */\n        usage(1);\n      }\n      if ((quiet != false) && (do_check != true)) {\n        uVar4 = gettext(\"the --quiet option is meaningful only when verifying checksums\");\n        error(0,0,uVar4);\n                    /* WARNING: Subroutine does not return */\n        usage(1);\n      }\n      if (((do_check ^ 1U) & strict) != 0) {\n        uVar4 = gettext(\"the --strict option is meaningful only when verifying checksums\");\n        error(0,0,uVar4);\n                    /* WARNING: Subroutine does not return */\n        usage(1);\n      }\n      if (binary < 0) {\n        binary = 0;\n      }\n      ppcVar5 = argv + argc;\n      operand_lim = ppcVar5;\n      if (argc == optind) {\n        operand_lim = ppcVar5 + 1;\n        pcVar6 = bad_cast(\"-\");\n        *ppcVar5 = pcVar6;\n      }\n      for (operandp = argv + optind; operandp < operand_lim; operandp = operandp + 1) {\n        file = *operandp;\n        if (do_check == false) {\n          file_is_binary = binary;\n          _Var2 = digest_file(file,&file_is_binary,bin_buffer,&missing);\n          if (_Var2 == true) {\n            pcVar6 = strchr(file,0x5c);\n            if (((pcVar6 == (char *)0x0) && (pcVar6 = strchr(file,10), pcVar6 == (char *)0x0)) ||\n               (delim != '\\n')) {\n              needs_escape = false;\n            }\n            else {\n              needs_escape = true;\n            }\n            if (prefix_tag != false) {\n              if (needs_escape != false) {\n                putchar_unlocked(0x5c);\n              }\n              fwrite_unlocked(\"SHA384\",1,6,stdout);\n              fwrite_unlocked(&DAT_0000f4b8,1,2,stdout);\n              print_filename(file,needs_escape);\n              fwrite_unlocked(&DAT_0000f4bb,1,4,stdout);\n            }\n            if ((prefix_tag != true) && (needs_escape != false)) {\n              putchar_unlocked(0x5c);\n            }\n            for (i = 0; i < digest_hex_bytes >> 1; i = i + 1) {\n              printf(\"%02x\");\n            }\n            if (prefix_tag != true) {\n              putchar_unlocked(0x20);\n              if (file_is_binary == 0) {\n                iVar3 = 0x20;\n              }\n              else {\n                iVar3 = 0x2a;\n              }\n              putchar_unlocked(iVar3);\n              print_filename(file,needs_escape);\n            }\n            putchar_unlocked((uint)delim);\n          }\n          else {\n            ok = false;\n          }\n        }\n        else {\n          _Var2 = digest_check(file);\n          ok = (_Var2 & ok) != 0;\n        }\n      }\n      if ((have_read_stdin != false) && (iVar3 = rpl_fclose(stdin), iVar3 == -1)) {\n        uVar4 = gettext(\"standard input\");\n        piVar7 = __errno_location();\n        error(1,*piVar7,uVar4);\n      }\n      if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return (int)(ok ^ 1);\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    if (opt != 0x77) break;\n    status_only = false;\n    warn = true;\n    quiet = false;\n  }\n  if (opt < 0x78) {\n    if (opt == 0x62) {\n      binary = 1;\n      goto LAB_00003259;\n    }\n    if (opt < 99) {\n      if (opt == -0x83) {\n        version_etc((FILE *)stdout,\"sha384sum\",\"GNU coreutils\",Version,\"Ulrich Drepper\",\n                    \"Scott Miller\",\"David Madore\",0);\n                    /* WARNING: Subroutine does not return */\n        exit(0);\n      }\n      if (opt == -0x82) {\n                    /* WARNING: Subroutine does not return */\n        usage(0);\n      }\n    }\n    else {\n      if (opt == 99) {\n        do_check = true;\n        goto LAB_00003259;\n      }\n      if (opt == 0x74) {\n        binary = 0;\n        goto LAB_00003259;\n      }\n    }\n  }\n  else {\n    if (opt == 0x81) {\n      status_only = true;\n      warn = false;\n      quiet = false;\n      goto LAB_00003259;\n    }\n    if (opt < 0x82) {\n      if (opt == 0x7a) {\n        delim = '\\0';\n      }\n      else {\n        if (opt != 0x80) goto LAB_0000324f;\n        ignore_missing = true;\n      }\n      goto LAB_00003259;\n    }\n    if (opt == 0x83) {\n      strict = true;\n      goto LAB_00003259;\n    }\n    if (opt < 0x83) {\n      status_only = false;\n      warn = false;\n      quiet = true;\n      goto LAB_00003259;\n    }\n    if (opt == 0x84) {\n      prefix_tag = true;\n      binary = 1;\n      goto LAB_00003259;\n    }\n  }\nLAB_0000324f:\n                    /* WARNING: Subroutine does not return */\n  usage(1);\n}\n\n",
        "output": "The predicted function name is main"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](size_t n)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)xmalloc(n);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is xcharalloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](int c)\n\n{\n  return c - 0x41U < 0x1a;\n}\n\n",
        "output": "The predicted function name is c_isupper"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](int c)\n\n{\n  if (c < 0x5b) {\n    if ((c < 0x41) && (9 < c - 0x30U)) {\n      return false;\n    }\n  }\n  else if (0x19 < c - 0x61U) {\n    return false;\n  }\n  return true;\n}\n\n",
        "output": "The predicted function name is c_isalnum"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](void *p,size_t *pn,size_t s)\n\n{\n  long lVar1;\n  void *pvVar2;\n  size_t n;\n  \n  n = *pn;\n  if (p == (void *)0x0) {\n    if (n == 0) {\n      lVar1 = SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x80)) / ZEXT816(s),0);\n      n = lVar1 + (ulong)(lVar1 == 0);\n    }\n    if (SUB168(ZEXT816(n) * ZEXT816(s),0) < 0 || SUB168(ZEXT816(n) * ZEXT816(s) >> 0x40,0) != 0) {\n                    /* WARNING: Subroutine does not return */\n      xalloc_die();\n    }\n  }\n  else {\n    if (SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x5555555555555554)) / ZEXT816(s),0) <= n) {\n                    /* WARNING: Subroutine does not return */\n      xalloc_die();\n    }\n    n = n + (n >> 1) + 1;\n  }\n  *pn = n;\n  pvVar2 = xrealloc(p,n * s);\n  return pvVar2;\n}\n\n",
        "output": "The predicted function name is x2nrealloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](int n,char *arg,size_t argsize,quoting_options *options)\n\n{\n  int iVar1;\n  size_t buffersize;\n  char *pcVar2;\n  uint flags_00;\n  int *piVar3;\n  slotvec *p;\n  size_t sVar4;\n  bool bVar5;\n  _Bool preallocated;\n  int e;\n  int nmax;\n  int flags;\n  slotvec *sv;\n  char *val;\n  size_t size;\n  size_t qsize;\n  \n  piVar3 = __errno_location();\n  iVar1 = *piVar3;\n  sv = slotvec;\n  if (n < 0) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  if (nslots <= n) {\n    bVar5 = slotvec == &slotvec0;\n    if (0x7ffffffe < n) {\n                    /* WARNING: Subroutine does not return */\n      xalloc_die();\n    }\n    p = slotvec;\n    if (bVar5) {\n      p = (slotvec *)0x0;\n    }\n    sv = (slotvec *)xrealloc(p,(long)(n + 1) << 4);\n    pcVar2 = slotvec0.val;\n    slotvec = sv;\n    if (bVar5) {\n      sv->size = slotvec0.size;\n      sv->val = pcVar2;\n    }\n    memset(sv + nslots,0,(long)((n + 1) - nslots) << 4);\n    nslots = n + 1;\n  }\n  buffersize = sv[n].size;\n  val = sv[n].val;\n  flags_00 = options->flags | 1;\n  sVar4 = quotearg_buffer_restyled\n                    (val,buffersize,arg,argsize,options->style,flags_00,options->quote_these_too,\n                     options->left_quote,options->right_quote);\n  if (buffersize <= sVar4) {\n    sVar4 = sVar4 + 1;\n    sv[n].size = sVar4;\n    if (val != slot0) {\n      free(val);\n    }\n    val = xcharalloc(sVar4);\n    sv[n].val = val;\n    quotearg_buffer_restyled\n              (val,sVar4,arg,argsize,options->style,flags_00,options->quote_these_too,\n               options->left_quote,options->right_quote);\n  }\n  piVar3 = __errno_location();\n  *piVar3 = iVar1;\n  return val;\n}\n\n",
        "output": "The predicted function name is quotearg_n_options"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](quoting_options *o,char *left_quote,char *right_quote)\n\n{\n  quoting_options *local_10;\n  \n  local_10 = o;\n  if (o == (quoting_options *)0x0) {\n    local_10 = &default_quoting_options;\n  }\n  local_10->style = custom_quoting_style;\n  if ((left_quote != (char *)0x0) && (right_quote != (char *)0x0)) {\n    local_10->left_quote = left_quote;\n    local_10->right_quote = right_quote;\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
        "output": "The predicted function name is set_custom_quoting"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](int c)\n\n{\n  _Bool _Var1;\n  \n  if ((c < 0x41) || ((0x5a < c && (0x19 < c - 0x61U)))) {\n    _Var1 = false;\n  }\n  else {\n    _Var1 = true;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is c_isalpha"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *left_quote,char *right_quote,char *arg,size_t argsize)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_n_custom_mem(0,left_quote,right_quote,arg,argsize);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is quotearg_custom_mem"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int category,char *buf,size_t bufsize)\n\n{\n  int iVar1;\n  char *__s;\n  size_t sVar2;\n  char *result;\n  size_t length;\n  \n  __s = setlocale_null_androidfix(category);\n  if (__s == (char *)0x0) {\n    if (bufsize != 0) {\n      *buf = '\\0';\n    }\n    iVar1 = 0x16;\n  }\n  else {\n    sVar2 = strlen(__s);\n    if (sVar2 < bufsize) {\n      memcpy(buf,__s,sVar2 + 1);\n      iVar1 = 0;\n    }\n    else {\n      if (bufsize != 0) {\n        memcpy(buf,__s,bufsize - 1);\n        buf[bufsize - 1] = '\\0';\n      }\n      iVar1 = 0x22;\n    }\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is setlocale_null_unlocked"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](int c)\n\n{\n  return (uint)c < 0x80;\n}\n\n",
        "output": "The predicted function name is c_isascii"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](FILE *stream,void *resblock)\n\n{\n  int iVar1;\n  \n  iVar1 = shaxxx_stream(stream,\"sha384\",resblock,0x30,sha384_init_ctx,sha384_finish_ctx);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is sha384_stream"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int fd)\n\n{\n  int iVar1;\n  \n  iVar1 = rpl_fcntl(fd,0,3);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is dup_safer"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int fd,int target)\n\n{\n  uint uVar1;\n  int iVar2;\n  int *piVar3;\n  int result;\n  int flags;\n  int saved_errno;\n  \n  if (rpl_fcntl_DUPFD_CLOEXEC::have_dupfd_cloexec < 0) {\n    result = rpl_fcntl_DUPFD(fd,target);\n  }\n  else {\n    result = fcntl(fd,0x406,(ulong)(uint)target);\n    if ((result < 0) && (piVar3 = __errno_location(), *piVar3 == 0x16)) {\n      result = rpl_fcntl_DUPFD(fd,target);\n      if (-1 < result) {\n        rpl_fcntl_DUPFD_CLOEXEC::have_dupfd_cloexec = -1;\n      }\n    }\n    else {\n      rpl_fcntl_DUPFD_CLOEXEC::have_dupfd_cloexec = 1;\n    }\n  }\n  if ((-1 < result) && (rpl_fcntl_DUPFD_CLOEXEC::have_dupfd_cloexec == -1)) {\n    uVar1 = fcntl(result,1);\n    if ((-1 < (int)uVar1) && (iVar2 = fcntl(result,2,(ulong)(uVar1 | 1)), iVar2 != -1)) {\n      return result;\n    }\n    piVar3 = __errno_location();\n    iVar2 = *piVar3;\n    close(result);\n    piVar3 = __errno_location();\n    *piVar3 = iVar2;\n    result = -1;\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is rpl_fcntl_DUPFD_CLOEXEC"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int fd,off_t offset,off_t len,fadvice_t advice)\n\n{\n  int __x;\n  \n  posix_fadvise(fd,offset,len,advice);\n  return;\n}\n\n",
        "output": "The predicted function name is fdadvise"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *arg)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = quotearg_n(0,arg);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is quotearg"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 in_stack_00000000;\n  undefined auStack8 [8];\n  \n  (*(code *)PTR___libc_start_main_00211fc8)\n            (main,in_stack_00000000,&stack0x00000008,__libc_csu_init,__libc_csu_fini,param_3,\n             auStack8);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
        "output": "The predicted function name is _start"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](int c)\n\n{\n  _Bool _Var1;\n  \n  if ((c < 0) || ((0x1f < c && (c != 0x7f)))) {\n    _Var1 = false;\n  }\n  else {\n    _Var1 = true;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is c_iscntrl"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](int c)\n\n{\n  _Bool _Var1;\n  \n  if ((c == 0x20) || (c == 9)) {\n    _Var1 = true;\n  }\n  else {\n    _Var1 = false;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is c_isblank"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *s1,char *s2)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  uchar c1;\n  uchar c2;\n  \n  if (s1 == s2) {\n    iVar3 = 0;\n  }\n  else {\n    do {\n      uVar1 = c_tolower((uint)(byte)*s1);\n      uVar2 = c_tolower((uint)(byte)*s2);\n      if ((char)uVar1 == '\\0') break;\n      s1 = (char *)((byte *)s1 + 1);\n      s2 = (char *)((byte *)s2 + 1);\n    } while ((char)uVar1 == (char)uVar2);\n    iVar3 = (uVar1 & 0xff) - (uVar2 & 0xff);\n  }\n  return iVar3;\n}\n\n",
        "output": "The predicted function name is c_strcasecmp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](FILE *stream,char *alg,void *resblock,ssize_t hashlen,\n                 anon_subr_void_sha512_ctx_ptr *init_ctx,\n                 anon_subr_void_ptr_sha512_ctx_ptr_void_ptr *finish_ctx)\n\n{\n  long lVar1;\n  int iVar2;\n  void *buffer_00;\n  size_t sVar3;\n  long in_FS_OFFSET;\n  size_t sum;\n  char *buffer;\n  size_t n;\n  sha512_ctx ctx;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar2 = afalg_stream(stream,alg,resblock,hashlen);\n  if (iVar2 == -5) {\n    iVar2 = 1;\n  }\n  else if (iVar2 == 0) {\n    iVar2 = 0;\n  }\n  else {\n    buffer_00 = malloc(0x8048);\n    if (buffer_00 != (void *)0x0) {\n      (*init_ctx)(&ctx);\n      do {\n        sum = 0;\nLAB_00003e59:\n        iVar2 = feof_unlocked((FILE *)stream);\n        if (iVar2 != 0) goto process_partial_block;\n        sVar3 = fread_unlocked((void *)((long)buffer_00 + sum),1,0x8000 - sum,(FILE *)stream);\n        sum = sum + sVar3;\n        if (sum != 0x8000) goto code_r0x00003ec7;\n        sha512_process_block(buffer_00,0x8000,&ctx);\n      } while( true );\n    }\n    iVar2 = 1;\n  }\nLAB_00003f7d:\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\ncode_r0x00003ec7:\n  if (sVar3 == 0) {\n    iVar2 = ferror_unlocked((FILE *)stream);\n    if (iVar2 == 0) {\nprocess_partial_block:\n      if (sum != 0) {\n        sha512_process_bytes(buffer_00,sum,&ctx);\n      }\n      (*finish_ctx)(&ctx,resblock);\n      free(buffer_00);\n      iVar2 = 0;\n    }\n    else {\n      free(buffer_00);\n      iVar2 = 1;\n    }\n    goto LAB_00003f7d;\n  }\n  goto LAB_00003e59;\n}\n\n",
        "output": "The predicted function name is shaxxx_stream"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](int c)\n\n{\n  return c - 0x61U < 0x1a;\n}\n\n",
        "output": "The predicted function name is c_islower"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](char *buffer,size_t len,void *resblock)\n\n{\n  long lVar1;\n  void *pvVar2;\n  long in_FS_OFFSET;\n  sha512_ctx ctx;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  sha384_init_ctx(&ctx);\n  sha512_process_bytes(buffer,len,&ctx);\n  pvVar2 = sha384_finish_ctx(&ctx,resblock);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return pvVar2;\n}\n\n",
        "output": "The predicted function name is sha384_buffer"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  if (completed_7698 == '\\0') {\n    if (PTR___cxa_finalize_00211fe0 != (undefined *)0x0) {\n      __cxa_finalize(__dso_handle);\n    }\n    deregister_tm_clones();\n    completed_7698 = 1;\n    return;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is __do_global_dtors_aux"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](int c)\n\n{\n  return c - 0x20U < 0x5f;\n}\n\n",
        "output": "The predicted function name is c_isprint"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Removing unreachable block (ram,0x0000decb) */\n/* WARNING: Removing unreachable block (ram,0x0000dd29) */\n/* WARNING: Removing unreachable block (ram,0x0000de5b) */\n/* WARNING: Removing unreachable block (ram,0x0000dcc1) */\n/* WARNING: Heritage AFTER dead removal. Example location: s0xffffffffffffff58 : 0x0000dcd3 */\n/* WARNING: Could not reconcile some variable overlaps */\n/* WARNING: Restarted to delay deadcode elimination for space: stack */\n\nint [MASK](int fd,int action,...)\n\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  int result;\n  int target_1;\n  int target;\n  int x;\n  void *p;\n  va_list arg;\n  ulong local_a8;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if (action == 0) {\n    result = rpl_fcntl_DUPFD(fd,(int)local_a8);\n    goto LAB_0000df10;\n  }\n  if (action == 0x406) {\n    result = rpl_fcntl_DUPFD_CLOEXEC(fd,(int)local_a8);\n    goto LAB_0000df10;\n  }\n  if (action == 0xb) {\nLAB_0000de08:\n    result = fcntl(fd,action);\n  }\n  else {\n    if (action < 0xc) {\n      if (action == 3) goto LAB_0000de08;\n      if (action < 4) {\n        if (action == 1) goto LAB_0000de08;\n        if ((action < 2) && (action != 0)) goto LAB_0000dedd;\n      }\n      else if (action != 8) {\n        if (action < 9) {\n          if (action != 4) {\nLAB_0000dedd:\n            result = fcntl(fd,action,local_a8);\n            goto LAB_0000df10;\n          }\n        }\n        else {\n          if (action == 9) goto LAB_0000de08;\n          if (action != 10) goto LAB_0000dedd;\n        }\n      }\n    }\n    else if (action < 0x408) {\n      if (action < 0x406) {\n        if (action == 0x401) goto LAB_0000de08;\n        if ((action != 0x402) && (action != 0x400)) goto LAB_0000dedd;\n      }\n    }\n    else if (action != 0x409) {\n      if ((0x408 < action) && (action != 0x40a)) goto LAB_0000dedd;\n      goto LAB_0000de08;\n    }\n    result = fcntl(fd,action,local_a8 & 0xffffffff);\n  }\nLAB_0000df10:\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return result;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is rpl_fcntl"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = beep_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is beep"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = wdelch(stdscr);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is delch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int value)\n\n{\n  int iVar1;\n  int code;\n  \n  code = 0;\n  iVar1 = value;\n  if (value < 0) {\n    code = -1;\n    iVar1 = ESCDELAY;\n  }\n  ESCDELAY = iVar1;\n  return code;\n}\n\n",
        "output": "The predicted function name is set_escdelay_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,chtype ch)\n\n{\n  _Bool _Var1;\n  int iVar2;\n  _Bool save_immed;\n  int code;\n  chtype wch;\n  \n  code = -1;\n  if (win != (WINDOW *)0x0) {\n    iVar2 = waddch_nosync(win,ch);\n    if (iVar2 != -1) {\n      _Var1 = win->_immed;\n      win->_immed = true;\n      _nc_synchook(win);\n      win->_immed = _Var1;\n      code = 0;\n    }\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is wechochar"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nSCREEN * [MASK](char *name,FILE *ofp,FILE *ifp)\n\n{\n  SCREEN *pSVar1;\n  SCREEN *rc;\n  \n  if ((SP == (SCREEN *)0x0) || (pSVar1 = SP, SP->_prescreen == false)) {\n    pSVar1 = new_prescr();\n  }\n  pSVar1 = newterm_sp(pSVar1,name,ofp,ifp);\n  _nc_prescreen.allocated = (screen *)0x0;\n  return pSVar1;\n}\n\n",
        "output": "The predicted function name is newterm"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,int a2,int a3,chtype *z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(a1,a2,a3);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = waddchnstr(a1,z,-1);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvwaddchstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  undefined1 *puVar2;\n  size_t sVar3;\n  int j;\n  size_t i;\n  size_t i_1;\n  chtype *fake_map;\n  chtype *real_map;\n  size_t length;\n  \n  if (sp == (SCREEN *)0x0) {\n    puVar2 = acs_map;\n  }\n  else {\n    puVar2 = (undefined1 *)sp->_acs_map;\n  }\n  if (puVar2 == acs_map) {\n    for (j = 1; j < 0x80; j = j + 1) {\n      *(undefined4 *)(acs_map + (long)j * 4) = 0;\n    }\n  }\n  else {\n    for (j = 1; j < 0x80; j = j + 1) {\n      *(chtype *)((long)puVar2 + (long)j * 4) = 0;\n      *(uint *)(acs_map + (long)j * 4) = j | 0x400000;\n      if (sp != (SCREEN *)0x0) {\n        sp->_screen_acs_map[j] = false;\n      }\n    }\n  }\n  *(chtype *)((long)puVar2 + 0x1b0) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x1b4) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x1ac) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x1a8) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x1d4) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x1d0) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x1d8) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x1dc) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x1c4) = 0x2d;\n  *(chtype *)((long)puVar2 + 0x1e0) = 0x7c;\n  *(chtype *)((long)puVar2 + 0x1b8) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x1bc) = 0x7e;\n  *(chtype *)((long)puVar2 + 0x1cc) = 0x5f;\n  *(chtype *)((long)puVar2 + 0x180) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x184) = 0x3a;\n  *(chtype *)((long)puVar2 + 0x198) = 0x27;\n  *(chtype *)((long)puVar2 + 0x19c) = 0x23;\n  *(chtype *)((long)puVar2 + 0x1f8) = 0x6f;\n  *(chtype *)((long)puVar2 + 0xb0) = 0x3c;\n  *(chtype *)((long)puVar2 + 0xac) = 0x3e;\n  *(chtype *)((long)puVar2 + 0xb8) = 0x76;\n  *(chtype *)((long)puVar2 + 0xb4) = 0x5e;\n  *(chtype *)((long)puVar2 + 0x1a0) = 0x23;\n  *(chtype *)((long)puVar2 + 0x1a4) = 0x23;\n  *(chtype *)((long)puVar2 + 0xc0) = 0x23;\n  *(chtype *)((long)puVar2 + 0x1c0) = 0x2d;\n  *(chtype *)((long)puVar2 + 0x1c8) = 0x2d;\n  *(chtype *)((long)puVar2 + 0x1e4) = 0x3c;\n  *(chtype *)((long)puVar2 + 0x1e8) = 0x3e;\n  *(chtype *)((long)puVar2 + 0x1ec) = 0x2a;\n  *(chtype *)((long)puVar2 + 0x1f0) = 0x21;\n  *(chtype *)((long)puVar2 + 500) = 0x66;\n  *(chtype *)((long)puVar2 + 0x130) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x134) = 0x2b;\n  *(chtype *)((long)puVar2 + 300) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x128) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x150) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x154) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x158) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x15c) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x144) = 0x2d;\n  *(chtype *)((long)puVar2 + 0x160) = 0x7c;\n  *(chtype *)((long)puVar2 + 0x138) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x10c) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x110) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x108) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x104) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x11c) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x118) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x120) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x124) = 0x2b;\n  *(chtype *)((long)puVar2 + 0x148) = 0x2d;\n  *(chtype *)((long)puVar2 + 0x164) = 0x7c;\n  *(chtype *)((long)puVar2 + 0x114) = 0x2b;\n  if ((cur_term->type).Strings[0x9b] != (char *)0x0) {\n    _nc_putp_sp(sp,\"ena_acs\",(cur_term->type).Strings[0x9b]);\n  }\n  if (((((cur_term->type).Strings[0x17b] != (char *)0x0) &&\n       ((cur_term->type).Strings[0x19] != (char *)0x0)) &&\n      (iVar1 = strcmp((cur_term->type).Strings[0x17b],(cur_term->type).Strings[0x19]), iVar1 == 0))\n     && ((((cur_term->type).Strings[0x17c] != (char *)0x0 &&\n          ((cur_term->type).Strings[0x26] != (char *)0x0)) &&\n         (iVar1 = strcmp((cur_term->type).Strings[0x17c],(cur_term->type).Strings[0x26]), iVar1 == 0\n         )))) {\n    for (i = 1; i < 0x80; i = i + 1) {\n      if (((*(chtype *)((long)puVar2 + i * 4) == 0) &&\n          (*(chtype *)((long)puVar2 + i * 4) = (chtype)i, puVar2 != acs_map)) &&\n         (SP != (SCREEN *)0x0)) {\n        SP->_screen_acs_map[i] = true;\n      }\n    }\n  }\n  if ((cur_term->type).Strings[0x92] != (char *)0x0) {\n    i_1 = 0;\n    sVar3 = strlen((cur_term->type).Strings[0x92]);\n    for (; i_1 + 1 < sVar3; i_1 = i_1 + 2) {\n      if ((((cur_term->type).Strings[0x92][i_1] != '\\0') &&\n          (-1 < (cur_term->type).Strings[0x92][i_1])) &&\n         (*(uint *)((long)puVar2 + (ulong)(byte)(cur_term->type).Strings[0x92][i_1] * 4) =\n               (byte)(cur_term->type).Strings[0x92][i_1 + 1] | 0x400000, SP != (SCREEN *)0x0)) {\n        SP->_screen_acs_map[(byte)(cur_term->type).Strings[0x92][i_1]] = true;\n      }\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_init_acs_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](short pair,short f,short b)\n\n{\n  int iVar1;\n  \n  iVar1 = init_pair_sp(SP,pair,f,b);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is init_pair"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,int a2,int a3,chtype z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(a1,a2,a3);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = waddch(a1,z);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvwaddch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](char *path)\n\n{\n  long lVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  _Bool result;\n  stat sb;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  result = false;\n  iVar2 = stat(path,(stat *)&sb);\n  if ((iVar2 == 0) && ((sb.st_mode & 0xf000) == 0x8000)) {\n    result = true;\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is _nc_is_file_path"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *string,...)\n\n{\n  long lVar1;\n  char in_AL;\n  int iVar2;\n  TPARM_STATE *tps_00;\n  undefined8 in_RCX;\n  undefined8 in_RDX;\n  undefined8 in_RSI;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  char *result;\n  TPARM_STATE *tps;\n  va_list ap;\n  TPARM_DATA myData;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if (cur_term == (term_conflict *)0x0) {\n    tps_00 = &_nc_prescreen.tparm_state;\n  }\n  else {\n    tps_00 = &cur_term->tparm_state;\n  }\n  result = (char *)0x0;\n  _nc_tparm_err = 0;\n  local_b0 = in_RSI;\n  local_a8 = in_RDX;\n  local_a0 = in_RCX;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  iVar2 = tparm_setup(cur_term,string,&myData);\n  if (iVar2 == 0) {\n    ap[0].gp_offset = 8;\n    ap[0].fp_offset = 0x30;\n    ap[0].overflow_arg_area = &stack0x00000008;\n    ap[0].reg_save_area = local_b8;\n    tparm_copy_valist(&myData,0,ap);\n    result = tparam_internal(tps_00,string,&myData);\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is tiparm"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](SCREEN *sp,int from,int to,int blank)\n\n{\n  bool bVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  int new_from;\n  \n  if (from == to) {\n    bVar1 = false;\n  }\n  else {\n    new_from = sp->_oldnum_list[from];\n    if (new_from == -1) {\n      new_from = from;\n    }\n    if (blank == 0) {\n      iVar2 = update_cost(sp,sp->_curscr->_line[to].text,sp->_newscr->_line[to].text);\n    }\n    else {\n      iVar2 = update_cost_from_blank(sp,sp->_newscr->_line[to].text);\n    }\n    iVar3 = update_cost(sp,sp->_curscr->_line[new_from].text,sp->_newscr->_line[from].text);\n    if (new_from == from) {\n      iVar4 = update_cost_from_blank(sp,sp->_newscr->_line[from].text);\n    }\n    else {\n      iVar4 = update_cost(sp,sp->_curscr->_line[new_from].text,sp->_newscr->_line[from].text);\n    }\n    iVar5 = update_cost(sp,sp->_curscr->_line[from].text,sp->_newscr->_line[to].text);\n    bVar1 = iVar5 + iVar4 <= iVar2 + iVar3;\n  }\n  return bVar1;\n}\n\n",
        "output": "The predicted function name is cost_effective"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](TPARM_DATA *data,int use_TPARM_ARG,__va_list_tag *ap)\n\n{\n  char **ppcVar1;\n  intptr_t *piVar2;\n  int *piVar3;\n  int i;\n  char *value;\n  \n  for (i = 0; i < data->num_actual; i = i + 1) {\n    if (data->p_is_s[i] == (char *)0x0) {\n      if (use_TPARM_ARG == 0) {\n        if (ap->gp_offset < 0x30) {\n          piVar3 = (int *)((ulong)ap->gp_offset + (long)ap->reg_save_area);\n          ap->gp_offset = ap->gp_offset + 8;\n        }\n        else {\n          piVar3 = (int *)ap->overflow_arg_area;\n          ap->overflow_arg_area = piVar3 + 2;\n        }\n        data->param[i] = (long)*piVar3;\n      }\n      else {\n        if (ap->gp_offset < 0x30) {\n          piVar2 = (intptr_t *)((ulong)ap->gp_offset + (long)ap->reg_save_area);\n          ap->gp_offset = ap->gp_offset + 8;\n        }\n        else {\n          piVar2 = (intptr_t *)ap->overflow_arg_area;\n          ap->overflow_arg_area = piVar2 + 1;\n        }\n        data->param[i] = *piVar2;\n      }\n    }\n    else {\n      if (ap->gp_offset < 0x30) {\n        ppcVar1 = (char **)((ulong)ap->gp_offset + (long)ap->reg_save_area);\n        ap->gp_offset = ap->gp_offset + 8;\n      }\n      else {\n        ppcVar1 = (char **)ap->overflow_arg_area;\n        ap->overflow_arg_area = ppcVar1 + 1;\n      }\n      value = *ppcVar1;\n      if (value == (char *)0x0) {\n        value = dummy;\n      }\n      data->p_is_s[i] = value;\n      data->param[i] = 0;\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is tparm_copy_valist"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nvoid [MASK](SCREEN *sp)\n\n{\n  long lVar1;\n  int iVar2;\n  term_conflict *ptVar3;\n  long in_FS_OFFSET;\n  int result;\n  TERMINAL_conflict *termp;\n  termios buf;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  ptVar3 = cur_term;\n  if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n    ptVar3 = sp->_term;\n  }\n  if (ptVar3 != (term_conflict *)0x0) {\n    buf._0_8_ = *(undefined8 *)&ptVar3->Nttyb;\n    buf._16_8_ = *(undefined8 *)&(ptVar3->Nttyb).c_line;\n    buf.c_cc._7_8_ = *(undefined8 *)((ptVar3->Nttyb).c_cc + 7);\n    buf.c_cc._15_8_ = *(undefined8 *)((ptVar3->Nttyb).c_cc + 0xf);\n    buf.c_cc._23_8_ = *(undefined8 *)((ptVar3->Nttyb).c_cc + 0x17);\n    buf._48_8_ = *(undefined8 *)((ptVar3->Nttyb).c_cc + 0x1f);\n    buf.c_ospeed = (ptVar3->Nttyb).c_ospeed;\n    buf._8_8_ = *(ulong *)&(ptVar3->Nttyb).c_cflag & 0xffffff7fffffffff;\n    iVar2 = _nc_set_tty_mode_sp(sp,&buf);\n    if (iVar2 == 0) {\n      *(undefined8 *)&ptVar3->Nttyb = buf._0_8_;\n      *(ulong *)&(ptVar3->Nttyb).c_cflag = buf._8_8_;\n      *(undefined8 *)&(ptVar3->Nttyb).c_line = buf._16_8_;\n      *(undefined8 *)((ptVar3->Nttyb).c_cc + 7) = buf.c_cc._7_8_;\n      *(undefined8 *)((ptVar3->Nttyb).c_cc + 0xf) = buf.c_cc._15_8_;\n      *(undefined8 *)((ptVar3->Nttyb).c_cc + 0x17) = buf.c_cc._23_8_;\n      *(undefined8 *)((ptVar3->Nttyb).c_cc + 0x1f) = buf._48_8_;\n      (ptVar3->Nttyb).c_ospeed = buf.c_ospeed;\n    }\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is qiflush_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nint [MASK](SCREEN *sp)\n\n{\n  long lVar1;\n  term_conflict *ptVar2;\n  long in_FS_OFFSET;\n  int result;\n  TERMINAL_conflict *termp;\n  termios buf;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  result = -1;\n  ptVar2 = cur_term;\n  if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n    ptVar2 = sp->_term;\n  }\n  if (ptVar2 != (term_conflict *)0x0) {\n    buf.c_cc._7_8_ = *(undefined8 *)((ptVar2->Nttyb).c_cc + 7);\n    buf.c_cc._15_8_ = *(undefined8 *)((ptVar2->Nttyb).c_cc + 0xf);\n    buf.c_cc._23_8_ = *(undefined8 *)((ptVar2->Nttyb).c_cc + 0x17);\n    buf._48_8_ = *(undefined8 *)((ptVar2->Nttyb).c_cc + 0x1f);\n    buf.c_ospeed = (ptVar2->Nttyb).c_ospeed;\n    buf._8_8_ = *(ulong *)&(ptVar2->Nttyb).c_cflag & 0xfffffffdffffffff;\n    buf._0_8_ = *(ulong *)&ptVar2->Nttyb & 0xfffffffffffffeff;\n    buf._8_8_ = buf._8_8_ | 0x100000000;\n    buf._16_7_ = (uint7)*(undefined8 *)&(ptVar2->Nttyb).c_line;\n    buf._16_7_ = buf._16_7_ & 0xffffffffffff;\n    buf._16_8_ = CONCAT17(1,buf._16_7_);\n    result = _nc_set_tty_mode_sp(sp,&buf);\n    if (result == 0) {\n      if (sp != (SCREEN *)0x0) {\n        sp->_cbreak = 1;\n      }\n      *(ulong *)&ptVar2->Nttyb = buf._0_8_;\n      *(ulong *)&(ptVar2->Nttyb).c_cflag = buf._8_8_;\n      *(undefined8 *)&(ptVar2->Nttyb).c_line = buf._16_8_;\n      *(undefined8 *)((ptVar2->Nttyb).c_cc + 7) = buf.c_cc._7_8_;\n      *(undefined8 *)((ptVar2->Nttyb).c_cc + 0xf) = buf.c_cc._15_8_;\n      *(undefined8 *)((ptVar2->Nttyb).c_cc + 0x17) = buf.c_cc._23_8_;\n      *(undefined8 *)((ptVar2->Nttyb).c_cc + 0x1f) = buf._48_8_;\n      (ptVar2->Nttyb).c_ospeed = buf.c_ospeed;\n    }\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return result;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is cbreak_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  _nc_screen_wrap_sp(SP);\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_screen_wrap"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,int a2,int a3,chtype *a4,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(a1,a2,a3);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = winchnstr(a1,a4,z);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvwinchnstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp,chtype ch)\n\n{\n  uint uVar1;\n  chtype local_34;\n  chtype my_ch;\n  chtype attr;\n  int chlen;\n  int c8;\n  chtype temp;\n  int j;\n  chtype temp_1;\n  chtype tilde;\n  \n  local_34 = ch;\n  attr = ch;\n  if ((((ch & 0x400000) != 0) && (sp->_acs_map != (chtype *)0x0)) && ((ch & 0xff) < 0x80)) {\n    my_ch = ch;\n    if ((sp->_screen_acs_map[(int)(ch & 0xff)] != true) &&\n       (uVar1 = sp->_acs_map[(int)(ch & 0xff)] & 0xff, uVar1 != 0)) {\n      attr = ch & 0xffbfffff;\n      my_ch = ch & 0xffbfff00 | uVar1;\n    }\n    if ((attr & 0x400000) != 0) {\n      uVar1 = sp->_acs_map[(int)(ch & 0xff)] & 0xff;\n      if (uVar1 == 0) {\n        attr = attr & 0xffbfffff;\n        my_ch = ch;\n      }\n      else {\n        my_ch = attr & 0xffffff00 | uVar1;\n      }\n    }\n    local_34 = my_ch;\n  }\n  if (((cur_term->type).Booleans[0x12] != '\\0') && ((local_34 & 0xff) == 0x7e)) {\n    local_34 = attr & 0xffffff00 | 0x60;\n  }\n  if ((int3)(*sp->_current_attr >> 8) != (int3)(attr >> 8)) {\n    vidputs_sp(sp,attr & 0xffffff00,_nc_outch_sp);\n  }\n  _nc_outch_sp(sp,local_34);\n  sp->_curscol = sp->_curscol + 1;\n  if ((cur_term->type).Strings[0x91] != (char *)0x0) {\n    _nc_putp_sp(sp,\"char_padding\",(cur_term->type).Strings[0x91]);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is PutAttrChar"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](WINDOW *win,short *ypos)\n\n{\n  _Bool result;\n  \n  result = false;\n  if ((*ypos < win->_regtop) || (win->_regbottom < *ypos)) {\n    if (*ypos < win->_maxy) {\n      *ypos = *ypos + 1;\n    }\n  }\n  else if (*ypos == win->_regbottom) {\n    *ypos = win->_regbottom;\n    result = true;\n  }\n  else if (*ypos < win->_maxy) {\n    *ypos = *ypos + 1;\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is newline_forces_scroll"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *cmp)\n\n{\n  WINDOW *local_20;\n  int depth;\n  WINDOW *tst;\n  \n  depth = 0;\n  local_20 = cmp;\n  if (cmp != (WINDOW *)0x0) {\n    while (local_20 = local_20->_parent, local_20 != (WINDOW *)0x0) {\n      depth = depth + 1;\n    }\n  }\n  return depth;\n}\n\n",
        "output": "The predicted function name is parent_depth"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int a1,int a2,char *z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(stdscr,a1,a2);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = winsnstr(stdscr,z,-1);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvinsstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](attr_t a1,short a2,void *z)\n\n{\n  int iVar1;\n  \n  if (stdscr == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    stdscr->_attrs = ((int)a2 & 0xffU) << 8 | a1 & 0xffff00ff;\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is attr_set"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int ToLines,int ToCols,int stolen)\n\n{\n  bool bVar1;\n  int iVar2;\n  _Bool found;\n  int depth;\n  _win_list *wp;\n  WINDOW *win;\n  \n  depth = 0;\n  do {\n    bVar1 = false;\n    for (wp = _nc_globals._nc_windowlist; wp != (_win_list *)0x0; wp = wp->next) {\n      if ((((wp->win)._flags & 0x10U) == 0) && (iVar2 = parent_depth(&wp->win), depth == iVar2)) {\n        bVar1 = true;\n        iVar2 = adjust_window(&wp->win,ToLines,ToCols,stolen);\n        if (iVar2 != 0) {\n          return -1;\n        }\n      }\n    }\n    depth = depth + 1;\n  } while (bVar1);\n  return 0;\n}\n\n",
        "output": "The predicted function name is increase_size"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](TERMTYPE *tp,int n,int token_type)\n\n{\n  int local_14;\n  \n  if (token_type == 0) {\n    local_14 = n + ((uint)tp->num_Booleans - (uint)tp->ext_Booleans);\n  }\n  else if (token_type == 1) {\n    local_14 = n + (((uint)tp->num_Numbers - (uint)tp->ext_Numbers) - (uint)tp->ext_Booleans);\n  }\n  else {\n    local_14 = n + (((uint)tp->num_Strings - (uint)tp->ext_Strings) -\n                   ((uint)tp->ext_Numbers + (uint)tp->ext_Booleans));\n  }\n  return local_14;\n}\n\n",
        "output": "The predicted function name is _nc_ext_data_index"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *name)\n\n{\n  long in_FS_OFFSET;\n  char *dst;\n  long value;\n  char *src;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  dst = (char *)0x0;\n  src = getenv(name);\n  if (src != (char *)0x0) {\n    value = strtol(src,&dst,0);\n    if ((((-1 < value) && (src != dst)) && (*dst == '\\0')) && (value <= (int)value))\n    goto LAB_0001fab8;\n  }\n  value = -1;\nLAB_0001fab8:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return (int)value;\n}\n\n",
        "output": "The predicted function name is _nc_getenv_num"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,chtype *z)\n\n{\n  int iVar1;\n  \n  iVar1 = winchnstr(a1,z,-1);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is winchstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = baudrate_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is baudrate"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = raw_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is raw"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp,int code)\n\n{\n  if (sp != (SCREEN *)0x0) {\n    delscreen(sp);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(code);\n}\n\n",
        "output": "The predicted function name is _nc_free_and_exit_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](void)\n\n{\n  _Bool _Var1;\n  \n  _Var1 = has_colors_sp(SP);\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is has_colors"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *str)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = tigetstr_sp(SP,str);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is tigetstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nTERMTYPE * [MASK](char *name)\n\n{\n  return (TERMTYPE *)0x0;\n}\n\n",
        "output": "The predicted function name is _nc_fallback"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nWINDOW * [MASK](WINDOW *win)\n\n{\n  short sVar1;\n  SCREEN *sp_00;\n  int i;\n  WINDOW *nwin;\n  SCREEN *sp;\n  size_t linesize;\n  \n  nwin = (WINDOW *)0x0;\n  if (win != (WINDOW *)0x0) {\n    sp_00 = _nc_screen_of(win);\n    if ((win->_flags & 0x10U) == 0) {\n      nwin = newwin_sp(sp_00,win->_maxy + 1,win->_maxx + 1,(int)win->_begy,(int)win->_begx);\n    }\n    else {\n      nwin = newpad_sp(sp_00,win->_maxy + 1,win->_maxx + 1);\n    }\n    if (nwin != (WINDOW *)0x0) {\n      nwin->_curx = win->_curx;\n      nwin->_cury = win->_cury;\n      nwin->_maxy = win->_maxy;\n      nwin->_maxx = win->_maxx;\n      nwin->_begy = win->_begy;\n      nwin->_begx = win->_begx;\n      nwin->_yoffset = win->_yoffset;\n      nwin->_flags = win->_flags & 0xfffe;\n      nwin->_attrs = win->_attrs;\n      nwin->_bkgd = win->_bkgd;\n      nwin->_notimeout = win->_notimeout;\n      nwin->_clear = win->_clear;\n      nwin->_leaveok = win->_leaveok;\n      nwin->_scroll = win->_scroll;\n      nwin->_idlok = win->_idlok;\n      nwin->_idcok = win->_idcok;\n      nwin->_immed = win->_immed;\n      nwin->_sync = win->_sync;\n      nwin->_use_keypad = win->_use_keypad;\n      nwin->_delay = win->_delay;\n      nwin->_parx = 0;\n      nwin->_pary = 0;\n      nwin->_parent = (WINDOW *)0x0;\n      nwin->_regtop = win->_regtop;\n      nwin->_regbottom = win->_regbottom;\n      if ((win->_flags & 0x10U) != 0) {\n        *(undefined8 *)&nwin->_pad = *(undefined8 *)&win->_pad;\n        *(undefined4 *)&(nwin->_pad)._pad_bottom = *(undefined4 *)&(win->_pad)._pad_bottom;\n      }\n      sVar1 = win->_maxx;\n      for (i = 0; i <= nwin->_maxy; i = i + 1) {\n        memcpy(nwin->_line[i].text,win->_line[i].text,(ulong)((int)sVar1 + 1) << 2);\n        nwin->_line[i].firstchar = win->_line[i].firstchar;\n        nwin->_line[i].lastchar = win->_line[i].lastchar;\n      }\n    }\n  }\n  return nwin;\n}\n\n",
        "output": "The predicted function name is dupwin"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](WINDOW *z)\n\n{\n  _Bool _Var1;\n  \n  if ((z == (WINDOW *)0x0) || (z->_notimeout == false)) {\n    _Var1 = false;\n  }\n  else {\n    _Var1 = true;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is is_notimeout"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = use_default_colors_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is use_default_colors"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int ToLines,int ToCols)\n\n{\n  _Bool _Var1;\n  bool bVar2;\n  int n;\n  _Bool slk_visible;\n  int result;\n  ripoff_t *rop;\n  \n  result = -1;\n  if (((sp != (SCREEN *)0x0) && (0 < ToLines)) && (0 < ToCols)) {\n    result = 0;\n    sp->_sig_winch = false;\n    _Var1 = is_term_resized_sp(sp,ToLines,ToCols);\n    if (_Var1 != false) {\n      if (((sp == (SCREEN *)0x0) || (sp->_slk == (_SLK *)0x0)) || (sp->_slk->hidden == true)) {\n        bVar2 = false;\n      }\n      else {\n        bVar2 = true;\n      }\n      if (bVar2) {\n        slk_clear();\n      }\n      result = resize_term_sp(sp,ToLines,ToCols);\n      clearok(sp->_curscr,true);\n      for (rop = _nc_prescreen.rippedoff; (long)(rop + -0x18383) < 0x61; rop = rop + 1) {\n        if (((rop->win != sp->_stdscr) && (rop->win != (WINDOW *)0x0)) &&\n           ((rop->line < 0 && (rop->hook != _nc_slk_initialize)))) {\n          if (rop->win == (WINDOW *)0x0) {\n            n = -1;\n          }\n          else {\n            n = rop->win->_maxy + 1;\n          }\n          wtouchln(rop->win,0,n,1);\n          wnoutrefresh(rop->win);\n        }\n      }\n      if (bVar2) {\n        slk_restore_sp(sp);\n        slk_touch_sp(sp);\n        slk_refresh_sp(sp);\n      }\n    }\n    ungetch_sp(sp,0x19a);\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is resizeterm_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nint [MASK](SCREEN *sp,WINDOW *win,_Bool flag)\n\n{\n  long lVar1;\n  ulong uVar2;\n  term_conflict *ptVar3;\n  long in_FS_OFFSET;\n  int result;\n  TERMINAL_conflict *termp;\n  termios buf;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  result = -1;\n  if (sp == (SCREEN *)0x0) {\n    result = -1;\n  }\n  else {\n    ptVar3 = cur_term;\n    if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n      ptVar3 = sp->_term;\n    }\n    if (ptVar3 != (term_conflict *)0x0) {\n      buf._0_8_ = *(undefined8 *)&ptVar3->Nttyb;\n      uVar2 = *(ulong *)&(ptVar3->Nttyb).c_cflag;\n      buf._16_8_ = *(undefined8 *)&(ptVar3->Nttyb).c_line;\n      buf.c_cc._7_8_ = *(undefined8 *)((ptVar3->Nttyb).c_cc + 7);\n      buf.c_cc._15_8_ = *(undefined8 *)((ptVar3->Nttyb).c_cc + 0xf);\n      buf.c_cc._23_8_ = *(undefined8 *)((ptVar3->Nttyb).c_cc + 0x17);\n      buf._48_8_ = *(undefined8 *)((ptVar3->Nttyb).c_cc + 0x1f);\n      buf.c_ospeed = (ptVar3->Nttyb).c_ospeed;\n      if (flag == false) {\n        buf._8_8_ = uVar2 | 0x8000000000;\n      }\n      else {\n        buf._8_8_ = uVar2 & 0xffffff7fffffffff;\n      }\n      result = _nc_set_tty_mode_sp(sp,&buf);\n      if (result == 0) {\n        *(undefined8 *)&ptVar3->Nttyb = buf._0_8_;\n        *(ulong *)&(ptVar3->Nttyb).c_cflag = buf._8_8_;\n        *(undefined8 *)&(ptVar3->Nttyb).c_line = buf._16_8_;\n        *(undefined8 *)((ptVar3->Nttyb).c_cc + 7) = buf.c_cc._7_8_;\n        *(undefined8 *)((ptVar3->Nttyb).c_cc + 0xf) = buf.c_cc._15_8_;\n        *(undefined8 *)((ptVar3->Nttyb).c_cc + 0x17) = buf.c_cc._23_8_;\n        *(undefined8 *)((ptVar3->Nttyb).c_cc + 0x1f) = buf._48_8_;\n        (ptVar3->Nttyb).c_ospeed = buf.c_ospeed;\n      }\n    }\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return result;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is intrflush_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](char *buffer,int limit)\n\n{\n  _Bool result;\n  int n;\n  \n  n = 0;\n  while( true ) {\n    if (limit <= n) {\n      return false;\n    }\n    if (0 < (short)((ushort)(byte)buffer[n * 2] + (ushort)(byte)buffer[(long)(n * 2) + 1] * 0x100))\n    break;\n    n = n + 1;\n  }\n  return true;\n}\n\n",
        "output": "The predicted function name is valid_shorts"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int ToLines,int ToCols)\n\n{\n  _Bool _Var1;\n  short sVar2;\n  int stolen;\n  int result;\n  int myLines;\n  int myCols;\n  int was_stolen;\n  \n  result = 0;\n  if (((sp == (SCREEN *)0x0) || (ToLines < 1)) || (ToCols < 1)) {\n    result = -1;\n  }\n  else {\n    stolen = (int)sp->_lines - (int)sp->_lines_avail;\n    _Var1 = is_term_resized_sp(sp,ToLines,ToCols);\n    if (_Var1 != false) {\n      current_lines = (int)sp->_lines;\n      myCols = (int)sp->_columns;\n      myLines = current_lines;\n      if (sp->_lines < ToLines) {\n        current_cols = myCols;\n        result = increase_size(sp,ToLines,myCols,stolen);\n        myLines = ToLines;\n      }\n      current_lines = myLines;\n      if ((result == 0) && (sp->_columns < ToCols)) {\n        current_cols = myCols;\n        result = increase_size(sp,myLines,ToCols,stolen);\n        current_lines = myLines;\n        myCols = ToCols;\n      }\n      current_cols = myCols;\n      if ((result == 0) && ((ToLines < myLines || (ToCols < myCols)))) {\n        result = decrease_size(sp,ToLines,ToCols,stolen);\n      }\n      if (result == 0) {\n        sVar2 = (short)ToLines;\n        sp->_lines = sVar2;\n        sp->_columns = (short)ToCols;\n        (cur_term->type).Numbers[2] = sVar2;\n        *(cur_term->type).Numbers = (short)ToCols;\n        sp->_lines_avail = sVar2 - (short)stolen;\n        if (sp->oldhash != (ulong *)0x0) {\n          free(sp->oldhash);\n          sp->oldhash = (ulong *)0x0;\n        }\n        if (sp->newhash != (ulong *)0x0) {\n          free(sp->newhash);\n          sp->newhash = (ulong *)0x0;\n        }\n      }\n    }\n    if (result == 0) {\n      LINES = ToLines - stolen;\n      COLS = ToCols;\n    }\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is resize_term_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,MEVENT *aevent)\n\n{\n  undefined8 uVar1;\n  MEVENT *pMVar2;\n  int result;\n  MEVENT *eventp;\n  \n  result = -1;\n  if (((aevent != (MEVENT *)0x0) && (sp != (SCREEN *)0x0)) &&\n     (pMVar2 = sp->_mouse_eventp, pMVar2 != (MEVENT *)0x0)) {\n    uVar1 = *(undefined8 *)&aevent->y;\n    *(undefined8 *)pMVar2 = *(undefined8 *)aevent;\n    *(undefined8 *)&pMVar2->y = uVar1;\n    pMVar2->bstate = aevent->bstate;\n    if (pMVar2 < sp->_mouse_events + 7) {\n      pMVar2 = pMVar2 + 1;\n    }\n    else {\n      pMVar2 = sp->_mouse_events;\n    }\n    sp->_mouse_eventp = pMVar2;\n    result = ungetch_sp(sp,0x199);\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is ungetmouse_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](TERMINAL_conflict *term,char *string,char **p_is_s,int *_nc_popcount)\n\n{\n  int iVar1;\n  char *pcVar2;\n  ushort **ppuVar3;\n  long in_FS_OFFSET;\n  int len;\n  int lastpop;\n  int number;\n  int level;\n  int i;\n  char *cp;\n  TPARM_STATE *tps;\n  size_t len2;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (term == (TERMINAL_conflict *)0x0) {\n    tps = &_nc_prescreen.tparm_state;\n  }\n  else {\n    tps = &term->tparm_state;\n  }\n  lastpop = -1;\n  number = 0;\n  level = -1;\n  cp = string;\n  if (string == (char *)0x0) {\n    iVar1 = 0;\n  }\n  else {\n    len2 = strlen(string);\n    if (tps->fmt_size < len2 + 2) {\n      tps->fmt_size = len2 + tps->fmt_size + 2;\n      pcVar2 = (char *)_nc_doalloc(tps->fmt_buff,tps->fmt_size);\n      tps->fmt_buff = pcVar2;\n      if (tps->fmt_buff == (char *)0x0) {\n        iVar1 = 0;\n        goto LAB_00023ab3;\n      }\n    }\n    memset(p_is_s,0,0x48);\n    *_nc_popcount = 0;\n    while ((long)cp - (long)string < (long)(int)len2) {\n      if (*cp == '%') {\n        cp = cp + 1;\n        cp = parse_format(cp,tps->fmt_buff,&len);\n        switch(*cp) {\n        case '!':\n        case '~':\n          if ((level < 0) && (number < 2)) {\n            number = number + 1;\n          }\n          lastpop = -1;\n          break;\n        case '&':\n        case '*':\n        case '+':\n        case '-':\n        case '/':\n        case '<':\n        case '=':\n        case '>':\n        case 'A':\n        case 'O':\n        case '^':\n        case 'm':\n        case '|':\n          if ((level < 0) && (number < 2)) {\n            number = number + 1;\n          }\n          level = level + -1;\n          lastpop = -1;\n          break;\n        case '\\'':\n          level = level + 1;\n          cp = cp + 2;\n          lastpop = -1;\n          break;\n        case 'P':\n          cp = cp + 1;\n          break;\n        case 'X':\n        case 'c':\n        case 'd':\n        case 'o':\n        case 'x':\n          if (((lastpop < 1) && (level < 0)) && (number < 2)) {\n            number = number + 1;\n          }\n          level = level + -1;\n          lastpop = -1;\n          break;\n        case 'g':\n          level = level + 1;\n          cp = cp + 1;\n          break;\n        case 'l':\n        case 's':\n          if (0 < lastpop) {\n            level = level + -1;\n            p_is_s[(long)lastpop + -1] = dummy;\n          }\n          if ((level < 0) && (number < 2)) {\n            number = number + 1;\n          }\n          break;\n        case 'p':\n          cp = cp + 1;\n          i = (byte)*cp - 0x30;\n          if (((-1 < i) && (i < 10)) && (level = level + 1, lastpop = i, *_nc_popcount < i)) {\n            *_nc_popcount = i;\n          }\n          break;\n        case '{':\n          level = level + 1;\n          do {\n            cp = cp + 1;\n            ppuVar3 = __ctype_b_loc();\n          } while (((*ppuVar3)[(byte)*cp] & 0x800) != 0);\n        }\n      }\n      if (*cp != '\\0') {\n        cp = cp + 1;\n      }\n    }\n    iVar1 = number;\n    if (9 < number) {\n      number = 9;\n      iVar1 = number;\n    }\n  }\nLAB_00023ab3:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is _nc_tparm_analyze"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar [MASK](void)\n\n{\n  char cVar1;\n  \n  cVar1 = killchar_sp(SP);\n  return cVar1;\n}\n\n",
        "output": "The predicted function name is killchar"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int i)\n\n{\n  _nc_make_oldhash_sp(SP,i);\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_make_oldhash"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int ms)\n\n{\n  int iVar1;\n  \n  iVar1 = delay_output_sp(SP,ms);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is delay_output"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  _nc_flush_sp(SP);\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_flush"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,chtype *from,chtype *to)\n\n{\n  chtype *local_30;\n  chtype *local_28;\n  int cost;\n  int i;\n  \n  cost = 0;\n  local_30 = to;\n  local_28 = from;\n  for (i = sp->_curscr->_maxx + 1; 0 < i; i = i + -1) {\n    if (*local_28 != *local_30) {\n      cost = cost + 1;\n    }\n    local_28 = local_28 + 1;\n    local_30 = local_30 + 1;\n  }\n  return cost;\n}\n\n",
        "output": "The predicted function name is update_cost"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](WINDOW *win)\n\n{\n  int i;\n  \n  if (win != (WINDOW *)0x0) {\n    for (i = 0; i <= win->_maxy; i = i + 1) {\n      if (win->_line[i].firstchar != -1) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n",
        "output": "The predicted function name is is_wintouched"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *path)\n\n{\n  _nc_tic_dir(path);\n  _nc_globals.keep_tic_directory = true;\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_keep_tic_dir"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nmmask_t [MASK](SCREEN *sp,mmask_t newmask,mmask_t *oldmask)\n\n{\n  char cVar1;\n  mmask_t result;\n  int b;\n  \n  result = 0;\n  if (sp != (SCREEN *)0x0) {\n    if (oldmask != (mmask_t *)0x0) {\n      *oldmask = sp->_mouse_mask;\n    }\n    if ((newmask != 0) || (sp->_mouse_initialized != false)) {\n      _nc_mouse_init(sp);\n      if (sp->_mouse_type != M_NONE) {\n        result = newmask & 0x1fffffff;\n        mouse_activate(sp,(uint)(result != 0));\n        sp->_mouse_mask = result;\n        sp->_mouse_mask2 = result;\n        for (b = 1; b < 6; b = b + 1) {\n          cVar1 = (char)b;\n          if ((0x10 << ((cVar1 + -1) * '\\x05' & 0x1fU) & sp->_mouse_mask2) != 0) {\n            sp->_mouse_mask2 = sp->_mouse_mask2 | 8 << ((cVar1 + -1) * '\\x05' & 0x1fU);\n          }\n          if ((8 << ((cVar1 + -1) * '\\x05' & 0x1fU) & sp->_mouse_mask2) != 0) {\n            sp->_mouse_mask2 = sp->_mouse_mask2 | 4 << ((cVar1 + -1) * '\\x05' & 0x1fU);\n          }\n          if ((4 << ((cVar1 + -1) * '\\x05' & 0x1fU) & sp->_mouse_mask2) != 0) {\n            sp->_mouse_mask2 =\n                 sp->_mouse_mask2 |\n                 1 << ((cVar1 + -1) * '\\x05' & 0x1fU) | 2 << ((cVar1 + -1) * '\\x05' & 0x1fU);\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is mousemask_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](TERMTYPE *tp)\n\n{\n  char *pcVar1;\n  short *psVar2;\n  char **ppcVar3;\n  uint i;\n  \n  tp->num_Booleans = 0x2c;\n  tp->num_Numbers = 0x27;\n  tp->num_Strings = 0x19e;\n  tp->ext_Booleans = 0;\n  tp->ext_Numbers = 0;\n  tp->ext_Strings = 0;\n  if (tp->Booleans == (char *)0x0) {\n    pcVar1 = (char *)malloc(0x2c);\n    tp->Booleans = pcVar1;\n    if (tp->Booleans == (char *)0x0) {\n                    /* WARNING: Subroutine does not return */\n      _nc_err_abort(\"Out of memory\");\n    }\n  }\n  if (tp->Numbers == (short *)0x0) {\n    psVar2 = (short *)malloc(0x4e);\n    tp->Numbers = psVar2;\n    if (tp->Numbers == (short *)0x0) {\n                    /* WARNING: Subroutine does not return */\n      _nc_err_abort(\"Out of memory\");\n    }\n  }\n  if (tp->Strings == (char **)0x0) {\n    ppcVar3 = (char **)malloc(0xcf0);\n    tp->Strings = ppcVar3;\n    if (tp->Strings == (char **)0x0) {\n                    /* WARNING: Subroutine does not return */\n      _nc_err_abort(\"Out of memory\");\n    }\n  }\n  for (i = 0; i < tp->num_Booleans; i = i + 1) {\n    tp->Booleans[i] = '\\0';\n  }\n  for (i = 0; i < tp->num_Numbers; i = i + 1) {\n    tp->Numbers[i] = -1;\n  }\n  for (i = 0; i < tp->num_Strings; i = i + 1) {\n    tp->Strings[i] = (char *)0x0;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_init_termtype"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = def_prog_mode_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is def_prog_mode"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int line,anon_subr_int_WINDOW_ptr_int *init)\n\n{\n  int iVar1;\n  SCREEN *sp;\n  int rc;\n  \n  if ((SP == (SCREEN *)0x0) || (sp = SP, SP->_prescreen == false)) {\n    sp = new_prescr();\n  }\n  iVar1 = ripoffline_sp(sp,line,init);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is ripoffline"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](ldat *data,int length)\n\n{\n  int local_14;\n  \n  local_14 = length;\n  while (local_14 = local_14 + -1, -1 < local_14) {\n    free(data[local_14].text);\n    data[local_14].text = (chtype *)0x0;\n  }\n  free(data);\n  return -1;\n}\n\n",
        "output": "The predicted function name is cleanup_lines"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int a1,int a2,chtype z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(stdscr,a1,a2);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = waddch(stdscr,z);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvaddch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  term_conflict *ptVar2;\n  int rc;\n  TERMINAL_conflict *termp;\n  \n  rc = -1;\n  ptVar2 = cur_term;\n  if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n    ptVar2 = sp->_term;\n  }\n  if ((ptVar2 != (term_conflict *)0x0) && (iVar1 = _nc_set_tty_mode(&ptVar2->Nttyb), iVar1 == 0)) {\n    if ((sp != (SCREEN *)0x0) && (sp->_keypad_on != false)) {\n      _nc_keypad(sp,1);\n    }\n    rc = 0;\n  }\n  return rc;\n}\n\n",
        "output": "The predicted function name is reset_prog_mode_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](TERMTYPE *tp,char *name,int token_type)\n\n{\n  ushort uVar1;\n  ushort uVar2;\n  ushort uVar3;\n  _Bool _Var4;\n  int n;\n  int j;\n  int first;\n  int last;\n  \n  n = _nc_find_ext_name(tp,name,token_type);\n  if (n < 0) {\n    _Var4 = false;\n  }\n  else {\n    uVar1 = tp->ext_Booleans;\n    uVar2 = tp->ext_Numbers;\n    uVar3 = tp->ext_Strings;\n    for (j = n; j < (int)((uint)uVar3 + (uint)uVar1 + (uint)uVar2 + -1); j = j + 1) {\n      tp->ext_Names[j] = tp->ext_Names[(long)j + 1];\n    }\n    j = _nc_ext_data_index(tp,n,token_type);\n    if (token_type == 1) {\n      uVar1 = tp->num_Numbers;\n      for (; j < (int)(uVar1 - 1); j = j + 1) {\n        tp->Numbers[j] = tp->Numbers[(long)j + 1];\n      }\n      tp->ext_Numbers = tp->ext_Numbers - 1;\n      tp->num_Numbers = tp->num_Numbers - 1;\n    }\n    else if (token_type == 2) {\n      uVar1 = tp->num_Strings;\n      for (; j < (int)(uVar1 - 1); j = j + 1) {\n        tp->Strings[j] = tp->Strings[(long)j + 1];\n      }\n      tp->ext_Strings = tp->ext_Strings - 1;\n      tp->num_Strings = tp->num_Strings - 1;\n    }\n    else if (token_type == 0) {\n      uVar1 = tp->num_Booleans;\n      for (; j < (int)(uVar1 - 1); j = j + 1) {\n        tp->Booleans[j] = tp->Booleans[(long)j + 1];\n      }\n      tp->ext_Booleans = tp->ext_Booleans - 1;\n      tp->num_Booleans = tp->num_Booleans - 1;\n    }\n    _Var4 = true;\n  }\n  return _Var4;\n}\n\n",
        "output": "The predicted function name is _nc_del_ext_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win)\n\n{\n  chtype cVar1;\n  chtype *pcVar2;\n  int code;\n  int y;\n  chtype blank;\n  chtype *sp;\n  chtype *start;\n  chtype *end;\n  \n  code = -1;\n  if (win != (WINDOW *)0x0) {\n    cVar1 = win->_bkgd;\n    for (y = 0; y <= win->_maxy; y = y + 1) {\n      sp = win->_line[y].text;\n      pcVar2 = sp + win->_maxx;\n      for (; sp <= pcVar2; sp = sp + 1) {\n        *sp = cVar1;\n      }\n      win->_line[y].firstchar = 0;\n      win->_line[y].lastchar = win->_maxx;\n    }\n    win->_cury = 0;\n    win->_curx = win->_cury;\n    win->_flags = win->_flags & 0xffbf;\n    _nc_synchook(win);\n    code = 0;\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is werase"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nWINDOW * [MASK](SCREEN *sp)\n\n{\n  WINDOW *pWVar1;\n  \n  if (sp == (SCREEN *)0x0) {\n    pWVar1 = (WINDOW *)0x0;\n  }\n  else {\n    pWVar1 = sp->_curscr;\n  }\n  return pWVar1;\n}\n\n",
        "output": "The predicted function name is _nc_curscr_of"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  \n  if (sp == (SCREEN *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    sp->_echo = 0;\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is noecho_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int fg,int bg)\n\n{\n  _Bool _Var1;\n  int iVar2;\n  _Bool save;\n  int code;\n  \n  code = -1;\n  if ((sp != (SCREEN *)0x0) &&\n     ((((cur_term->type).Strings[0x129] != (char *)0x0 ||\n       ((cur_term->type).Strings[0x12a] != (char *)0x0)) &&\n      ((cur_term->type).Strings[300] == (char *)0x0)))) {\n    if ((fg < 0) || (bg < 0)) {\n      _Var1 = true;\n    }\n    else {\n      _Var1 = false;\n    }\n    sp->_default_color = _Var1;\n    iVar2 = tigetflag(\"AX\");\n    sp->_has_sgr_39_49 = iVar2 == 1;\n    iVar2 = -1;\n    if (-1 < fg) {\n      iVar2 = fg;\n    }\n    sp->_default_fg = iVar2;\n    iVar2 = -1;\n    if (-1 < bg) {\n      iVar2 = bg;\n    }\n    sp->_default_bg = iVar2;\n    if (sp->_color_pairs != (colorpair_t *)0x0) {\n      _Var1 = sp->_default_color;\n      sp->_assumed_color = true;\n      sp->_default_color = true;\n      init_pair_sp(sp,0,(short)fg,(short)bg);\n      sp->_default_color = _Var1;\n    }\n    code = 0;\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is assume_default_colors_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win)\n\n{\n  int result;\n  int i;\n  _win_list *p;\n  _win_list *q;\n  \n  if (win != (WINDOW *)0x0) {\n    q = (_win_list *)0x0;\n    for (p = _nc_globals._nc_windowlist; p != (_win_list *)0x0; p = p->next) {\n      if (win == &p->win) {\n        remove_window_from_screen(win);\n        if (q == (_win_list *)0x0) {\n          _nc_globals._nc_windowlist = p->next;\n        }\n        else {\n          q->next = p->next;\n        }\n        if ((win->_flags & 1U) == 0) {\n          for (i = 0; i <= win->_maxy; i = i + 1) {\n            if (win->_line[i].text != (chtype *)0x0) {\n              free(win->_line[i].text);\n            }\n          }\n        }\n        free(win->_line);\n        free(p);\n        return 0;\n      }\n      q = p;\n    }\n  }\n  return -1;\n}\n\n",
        "output": "The predicted function name is _nc_freewin"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,int a2,int a3,char *a4,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(a1,a2,a3);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = winnstr(a1,a4,z);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvwinnstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,int a2,int a3,chtype *a4,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(a1,a2,a3);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = waddchnstr(a1,a4,z);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvwaddchnstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *z)\n\n{\n  int iVar1;\n  \n  if (z == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = z->_maxx + 1;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is getmaxx"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchtype [MASK](void)\n\n{\n  chtype cVar1;\n  \n  cVar1 = winch(stdscr);\n  return cVar1;\n}\n\n",
        "output": "The predicted function name is inch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *z)\n\n{\n  int iVar1;\n  \n  if (z == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = z->_maxy + 1;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is getmaxy"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,int y,int x)\n\n{\n  WINDOW *pWVar1;\n  int iVar2;\n  int iVar3;\n  int local_24;\n  int rc;\n  int i;\n  WINDOW *orig;\n  \n  rc = -1;\n  if ((((win != (WINDOW *)0x0) && (pWVar1 = win->_parent, pWVar1 != (WINDOW *)0x0)) && (-1 < x)) &&\n     (-1 < y)) {\n    if (win == (WINDOW *)0x0) {\n      iVar3 = -1;\n    }\n    else {\n      iVar3 = win->_maxx + 1;\n    }\n    if (pWVar1 == (WINDOW *)0x0) {\n      iVar2 = -1;\n    }\n    else {\n      iVar2 = pWVar1->_maxx + 1;\n    }\n    if (iVar3 + x <= iVar2) {\n      if (win == (WINDOW *)0x0) {\n        iVar3 = -1;\n      }\n      else {\n        iVar3 = win->_maxy + 1;\n      }\n      if (pWVar1 == (WINDOW *)0x0) {\n        iVar2 = -1;\n      }\n      else {\n        iVar2 = pWVar1->_maxy + 1;\n      }\n      if (iVar3 + y <= iVar2) {\n        wsyncup(win);\n        win->_parx = x;\n        win->_pary = y;\n        i = 0;\n        local_24 = y;\n        while( true ) {\n          if (win == (WINDOW *)0x0) {\n            iVar3 = -1;\n          }\n          else {\n            iVar3 = win->_maxy + 1;\n          }\n          if (iVar3 <= i) break;\n          win->_line[i].text = pWVar1->_line[local_24].text + x;\n          i = i + 1;\n          local_24 = local_24 + 1;\n        }\n        rc = 0;\n      }\n    }\n  }\n  return rc;\n}\n\n",
        "output": "The predicted function name is mvderwin"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nint [MASK](SCREEN *sp)\n\n{\n  long lVar1;\n  ulong uVar2;\n  term_conflict *ptVar3;\n  long in_FS_OFFSET;\n  int result;\n  TERMINAL_conflict *termp;\n  termios buf;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  result = -1;\n  ptVar3 = cur_term;\n  if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n    ptVar3 = sp->_term;\n  }\n  if (ptVar3 != (term_conflict *)0x0) {\n    uVar2 = *(ulong *)&(ptVar3->Nttyb).c_cflag;\n    buf._16_8_ = *(undefined8 *)&(ptVar3->Nttyb).c_line;\n    buf.c_cc._7_8_ = *(undefined8 *)((ptVar3->Nttyb).c_cc + 7);\n    buf.c_cc._15_8_ = *(undefined8 *)((ptVar3->Nttyb).c_cc + 0xf);\n    buf.c_cc._23_8_ = *(undefined8 *)((ptVar3->Nttyb).c_cc + 0x17);\n    buf._48_8_ = *(undefined8 *)((ptVar3->Nttyb).c_cc + 0x1f);\n    buf.c_ospeed = (ptVar3->Nttyb).c_ospeed;\n    buf.c_lflag = (tcflag_t)(uVar2 >> 0x20);\n    buf._8_8_ = uVar2 & 0xffffffff | (ulong)((ptVar3->Ottyb).c_lflag & 0x8000 | buf.c_lflag) << 0x20\n                | 0x300000000;\n    buf._0_8_ = *(ulong *)&ptVar3->Nttyb | 0x40a;\n    result = _nc_set_tty_mode_sp(sp,&buf);\n    if (result == 0) {\n      if (sp != (SCREEN *)0x0) {\n        sp->_raw = 0;\n        sp->_cbreak = 0;\n      }\n      *(ulong *)&ptVar3->Nttyb = buf._0_8_;\n      *(ulong *)&(ptVar3->Nttyb).c_cflag = buf._8_8_;\n      *(undefined8 *)&(ptVar3->Nttyb).c_line = buf._16_8_;\n      *(undefined8 *)((ptVar3->Nttyb).c_cc + 7) = buf.c_cc._7_8_;\n      *(undefined8 *)((ptVar3->Nttyb).c_cc + 0xf) = buf.c_cc._15_8_;\n      *(undefined8 *)((ptVar3->Nttyb).c_cc + 0x17) = buf.c_cc._23_8_;\n      *(undefined8 *)((ptVar3->Nttyb).c_cc + 0x1f) = buf._48_8_;\n      (ptVar3->Nttyb).c_ospeed = buf.c_ospeed;\n    }\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return result;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is noraw_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nname_table_entry * [MASK](_Bool termcap)\n\n{\n  name_table_entry *pnVar1;\n  \n  if (termcap == false) {\n    pnVar1 = _nc_build_names(&_nc_info_table,info_names_data,\"bw\");\n  }\n  else {\n    pnVar1 = _nc_build_names(&_nc_cap_table,cap_names_data,\"bw\");\n  }\n  return pnVar1;\n}\n\n",
        "output": "The predicted function name is _nc_get_table"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win)\n\n{\n  int iVar1;\n  int code;\n  \n  iVar1 = werase(win);\n  if (iVar1 != -1) {\n    win->_clear = true;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is wclear"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar [MASK](void)\n\n{\n  char cVar1;\n  \n  cVar1 = erasechar_sp(SP);\n  return cVar1;\n}\n\n",
        "output": "The predicted function name is erasechar"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int value)\n\n{\n  int iVar1;\n  \n  iVar1 = set_tabsize_sp(SP,value);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is set_tabsize"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *z)\n\n{\n  int iVar1;\n  \n  if (z == (WINDOW *)0x0) {\n    iVar1 = 0;\n  }\n  else {\n    iVar1 = z->_delay;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is wgetdelay"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](SCREEN *sp,chtype ch)\n\n{\n  short sVar1;\n  uint uVar2;\n  ushort **ppuVar3;\n  int check;\n  char *result;\n  \n  uVar2 = ch & 0xff;\n  if (uVar2 < 0x100) {\n    if ((((sp == (SCREEN *)0x0) || (sp->_legacy_coding < 2)) || (uVar2 < 0x80)) || (0x9f < uVar2)) {\n      if ((((uVar2 < 0xa0) || (0xff < uVar2)) || (sp == (SCREEN *)0x0)) ||\n         ((sp->_legacy_coding < 1 &&\n          ((sp->_legacy_coding != 0 ||\n           (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(int)uVar2] & 0x4000) == 0)))))) {\n        return \"^@\" + unctrl_sp::unctrl_table[(int)uVar2];\n      }\n      sVar1 = unctrl_sp::unctrl_c1[(int)(uVar2 - 0x80)];\n    }\n    else {\n      sVar1 = unctrl_sp::unctrl_c1[(int)(uVar2 - 0x80)];\n    }\n    result = \"^@\" + sVar1;\n  }\n  else {\n    result = (char *)0x0;\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is unctrl_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,char *name,char *value)\n\n{\n  int iVar1;\n  int rc;\n  \n  iVar1 = _nc_putp_sp(sp,name,value);\n  if (iVar1 != -1) {\n    _nc_flush();\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is _nc_putp_flush_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = noraw_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is noraw"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int ch)\n\n{\n  int rc;\n  \n  rc = -1;\n  if ((sp != (SCREEN *)0x0) && (-1 < sp->_fifotail)) {\n    if (sp->_fifohead < 0) {\n      sp->_fifohead = 0;\n      if (sp->_fifotail < 0x88) {\n        sp->_fifotail = sp->_fifotail + 1;\n      }\n      else {\n        sp->_fifotail = 0;\n      }\n      if (sp->_fifotail == sp->_fifohead) {\n        sp->_fifotail = -1;\n      }\n      sp->_fifopeek = sp->_fifotail;\n    }\n    else {\n      if (sp->_fifohead < 1) {\n        sp->_fifohead = 0x88;\n      }\n      else {\n        sp->_fifohead = sp->_fifohead + -1;\n      }\n      if (sp->_fifohead == sp->_fifotail) {\n        sp->_fifotail = -1;\n      }\n    }\n    sp->_fifo[(int)sp->_fifohead] = ch;\n    rc = 0;\n  }\n  return rc;\n}\n\n",
        "output": "The predicted function name is ungetch_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](WINDOW *win)\n\n{\n  if (win->_immed != false) {\n    wrefresh(win);\n  }\n  if (win->_sync != false) {\n    wsyncup(win);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_synchook"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *tname,int Filedes,int *errret)\n\n{\n  int iVar1;\n  \n  iVar1 = _nc_setupterm(tname,Filedes,errret,0);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is setupterm"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *text,size_t limit)\n\n{\n  size_t sVar1;\n  char *pcVar2;\n  char *last;\n  \n  pcVar2 = _nc_globals.dbd_blob;\n  if (*text != '\\0') {\n    sVar1 = strlen(_nc_globals.dbd_blob);\n    pcVar2 = pcVar2 + sVar1;\n    last = pcVar2;\n    if (pcVar2 != _nc_globals.dbd_blob) {\n      last = pcVar2 + 1;\n      *pcVar2 = ':';\n    }\n    strcpy(last,text);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is add_to_blob"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int a1,int a2,char *z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(stdscr,a1,a2);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = wgetnstr(stdscr,z,-1);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvgetstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nWINDOW * [MASK](WINDOW *orig,int l,int c,int begy,int begx)\n\n{\n  WINDOW *win;\n  \n  win = (WINDOW *)0x0;\n  if ((orig != (WINDOW *)0x0) &&\n     (((orig->_flags & 0x10U) == 0 || (win = derwin(orig,l,c,begy,begx), win == (WINDOW *)0x0)))) {\n    win = (WINDOW *)0x0;\n  }\n  return win;\n}\n\n",
        "output": "The predicted function name is subpad"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  if ((cur_term->type).Booleans[4] == '\\0') {\n    if ((cur_term->type).Booleans[1] == '\\0') {\n      sp->_curscol = sp->_curscol + -1;\n    }\n    else {\n      sp->_curscol = 0;\n      sp->_cursrow = sp->_cursrow + 1;\n      if (((cur_term->type).Booleans[0xe] == '\\0') && (*sp->_current_attr >> 8 != 0)) {\n        vidputs_sp(sp,0,_nc_outch_sp);\n      }\n    }\n  }\n  else {\n    sp->_curscol = -1;\n    sp->_cursrow = -1;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is wrap_cursor"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](TERMINAL_conflict *termp)\n\n{\n  int iVar1;\n  int rc;\n  \n  iVar1 = del_curterm_sp(SP,termp);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is del_curterm"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,int a2,int a3,int a4,attr_t a5,short a6,void *z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(a1,a2,a3);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = wchgat(a1,a4,a5,a6,z);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvwchgat"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](int ToLines,int ToCols)\n\n{\n  _Bool _Var1;\n  \n  _Var1 = is_term_resized_sp(SP,ToLines,ToCols);\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is is_term_resized"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int flag)\n\n{\n  int rc;\n  \n  rc = -1;\n  if (sp != (SCREEN *)0x0) {\n    if (flag == 0) {\n      if ((cur_term->type).Strings[0x58] != (char *)0x0) {\n        _nc_putp_flush_sp(sp,\"keypad_local\",(cur_term->type).Strings[0x58]);\n      }\n    }\n    else {\n      _nc_putp_flush_sp(sp,\"keypad_xmit\",(cur_term->type).Strings[0x59]);\n    }\n    if ((flag != 0) && (sp->_tried != true)) {\n      _nc_init_keytry(sp);\n      sp->_tried = true;\n    }\n    sp->_keypad_on = flag != 0;\n    rc = 0;\n  }\n  return rc;\n}\n\n",
        "output": "The predicted function name is _nc_keypad"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp,_Bool f)\n\n{\n  if ((sp != (SCREEN *)0x0) && (sp->_prescreen != false)) {\n    sp->_use_env = f;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is use_env_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp,chtype blank,int needclear)\n\n{\n  chtype *pcVar1;\n  int local_28;\n  int j;\n  int count;\n  chtype *cp;\n  \n  local_28 = needclear;\n  if ((sp->_curscr != (WINDOW *)0x0) && (-1 < sp->_cursrow)) {\n    for (j = sp->_curscol; j < sp->_columns; j = j + 1) {\n      if ((-1 < j) && (pcVar1 = sp->_curscr->_line[sp->_cursrow].text + j, blank != *pcVar1)) {\n        *pcVar1 = blank;\n        local_28 = 1;\n      }\n    }\n  }\n  if (local_28 != 0) {\n    if ((int3)(*sp->_current_attr >> 8) != (int3)(blank >> 8)) {\n      vidputs_sp(sp,blank & 0xffffff00,_nc_outch_sp);\n    }\n    if (((cur_term->type).Strings[6] == (char *)0x0) ||\n       ((int)sp->_columns - sp->_curscol < sp->_el_cost)) {\n      count = (int)sp->_columns - sp->_curscol;\n      while (0 < count) {\n        PutChar(sp,blank);\n        count = count + -1;\n      }\n    }\n    else {\n      _nc_putp_sp(sp,\"clr_eol\",(cur_term->type).Strings[6]);\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is ClrToEOL"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](char *name,DBDIRS which)\n\n{\n  char *__s2;\n  bool bVar1;\n  int iVar2;\n  _Bool result;\n  _Bool same_value;\n  char *value;\n  char *cached_value;\n  \n  result = false;\n  if (which < dbdLAST) {\n    __s2 = _nc_globals.dbd_vars[which].value;\n    value = getenv(name);\n    if (value != (char *)0x0) {\n      value = strdup(value);\n    }\n    if (((value == (char *)0x0) && (__s2 == (char *)0x0)) ||\n       ((value != (char *)0x0 && ((__s2 != (char *)0x0 && (iVar2 = strcmp(value,__s2), iVar2 == 0)))\n        ))) {\n      bVar1 = true;\n    }\n    else {\n      bVar1 = false;\n    }\n    _nc_globals.dbd_vars[which].name = name;\n    if (bVar1) {\n      free(value);\n    }\n    else {\n      if (_nc_globals.dbd_vars[which].value != (char *)0x0) {\n        free(_nc_globals.dbd_vars[which].value);\n      }\n      _nc_globals.dbd_vars[which].value = value;\n      result = true;\n    }\n    return result;\n  }\n  return false;\n}\n\n",
        "output": "The predicted function name is update_getenv"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nHashValue [MASK](char *string)\n\n{\n  byte *local_20;\n  long sum;\n  \n  sum = 0;\n  for (local_20 = (byte *)string; *local_20 != 0; local_20 = local_20 + 1) {\n    sum = sum + (int)((uint)*local_20 + (uint)local_20[1] * 0x100);\n  }\n  return (short)sum + (short)(sum / 0x3e2) * -0x3e2;\n}\n\n",
        "output": "The predicted function name is info_hash"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](WINDOW *win)\n\n{\n  int iVar1;\n  SCREEN *pSVar2;\n  int i;\n  SCREEN *sp;\n  \n  pSVar2 = _nc_screen_of(win);\n  if (((win != (WINDOW *)0x0) && (pSVar2 != (SCREEN *)0x0)) && (pSVar2->slk_format == 4)) {\n    iVar1 = wmove(win,0,0);\n    if (iVar1 != -1) {\n      if (win == (WINDOW *)0x0) {\n        iVar1 = -1;\n      }\n      else {\n        iVar1 = win->_maxx + 1;\n      }\n      whline(win,0,iVar1);\n    }\n    wmove(win,0,0);\n    for (i = 0; i < pSVar2->_slk->maxlab; i = i + 1) {\n      mvwprintw(win,0,pSVar2->_slk->ent[i].ent_x,\"F%d\",(ulong)(i + 1));\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is slk_paint_info"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int a1,int a2,chtype *a3,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(stdscr,a1,a2);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = waddchnstr(stdscr,a3,z);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvaddchnstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,char *str,int n)\n\n{\n  int iVar1;\n  chtype *pcVar2;\n  int local_3c;\n  int i;\n  int col;\n  int row;\n  chtype *text;\n  \n  i = 0;\n  if ((win == (WINDOW *)0x0) || (str == (char *)0x0)) {\n    i = -1;\n  }\n  else {\n    col = (int)win->_curx;\n    pcVar2 = win->_line[(int)win->_cury].text;\n    local_3c = n;\n    if (n < 0) {\n      local_3c = (win->_maxx - col) + 1;\n    }\n    do {\n      if (local_3c <= i) break;\n      iVar1 = i + 1;\n      str[i] = (char)pcVar2[col];\n      col = col + 1;\n      i = iVar1;\n    } while (col <= win->_maxx);\n    str[i] = '\\0';\n  }\n  return i;\n}\n\n",
        "output": "The predicted function name is winnstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](TRIES **tree,char *string)\n\n{\n  TRIES *__ptr;\n  int iVar1;\n  tries **local_20;\n  TRIES *to_free;\n  \n  if ((string != (char *)0x0) && (local_20 = tree, *string != '\\0')) {\n    for (; *local_20 != (tries *)0x0; local_20 = &(*local_20)->sibling) {\n      if ((*local_20)->ch == *string) {\n        if (string[1] != '\\0') {\n          iVar1 = _nc_remove_string(&(*local_20)->child,string + 1);\n          return iVar1;\n        }\n        if ((*local_20)->child != (tries *)0x0) {\n          return 0;\n        }\n        __ptr = *local_20;\n        *local_20 = (*local_20)->sibling;\n        free(__ptr);\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is _nc_remove_string"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](WINDOW *z)\n\n{\n  _Bool _Var1;\n  \n  if ((z == (WINDOW *)0x0) || (z->_sync == false)) {\n    _Var1 = false;\n  }\n  else {\n    _Var1 = true;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is is_syncok"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  colorpair_t *pcVar1;\n  _Bool _Var2;\n  uint uVar3;\n  int iVar4;\n  color_t *pcVar5;\n  int result;\n  int maxpairs;\n  int maxcolors;\n  \n  result = -1;\n  if (sp == (SCREEN *)0x0) {\n    result = -1;\n  }\n  else if (sp->_coloron == 0) {\n    maxpairs = (int)(cur_term->type).Numbers[0xe];\n    uVar3 = (uint)(cur_term->type).Numbers[0xd];\n    _Var2 = reset_color_pair(sp);\n    if (_Var2 != true) {\n      iVar4 = default_fg(sp);\n      set_foreground_color(sp,iVar4,_nc_outch_sp);\n      iVar4 = default_bg(sp);\n      set_background_color(sp,iVar4,_nc_outch_sp);\n    }\n    if (0x100 < maxpairs) {\n      maxpairs = 0x100;\n    }\n    if ((maxpairs < 1) || ((int)uVar3 < 1)) {\n      result = 0;\n    }\n    else {\n      sp->_pair_limit = maxpairs;\n      sp->_pair_limit = uVar3 * 2 + 1 + sp->_pair_limit;\n      if (sp->_pair_limit < 0x8000) {\n        if (sp->_pair_limit < -0x7fff) {\n          iVar4 = -0x7fff;\n        }\n        else {\n          iVar4 = (int)(short)sp->_pair_limit;\n        }\n      }\n      else {\n        iVar4 = 0x7fff;\n      }\n      sp->_pair_limit = iVar4;\n      sp->_pair_count = maxpairs;\n      sp->_color_count = uVar3;\n      COLOR_PAIRS = maxpairs;\n      COLORS = uVar3;\n      if ((sp->_color_pairs == (colorpair_t *)0x0) || (sp->_pair_alloc < 0x11)) {\n        _nc_reserve_pairs(sp,0x10);\n      }\n      if (sp->_color_pairs != (colorpair_t *)0x0) {\n        _Var2 = init_direct_colors(sp);\n        if (_Var2 == false) {\n          pcVar5 = (color_t *)calloc((ulong)uVar3,0x1c);\n          sp->_color_table = pcVar5;\n          if (sp->_color_table != (color_t *)0x0) {\n            pcVar1 = sp->_color_pairs;\n            iVar4 = default_fg(sp);\n            pcVar1->fg = iVar4;\n            pcVar1 = sp->_color_pairs;\n            iVar4 = default_bg(sp);\n            pcVar1->bg = iVar4;\n            init_color_table(sp);\n            result = 0;\n          }\n        }\n        else {\n          result = 0;\n        }\n        if (result == 0) {\n          sp->_coloron = 1;\n        }\n        else if (sp->_color_pairs != (colorpair_t *)0x0) {\n          free(sp->_color_pairs);\n          sp->_color_pairs = (colorpair_t *)0x0;\n        }\n      }\n    }\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is start_color_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchtype [MASK](WINDOW *z)\n\n{\n  chtype cVar1;\n  \n  if (z == (WINDOW *)0x0) {\n    cVar1 = 0;\n  }\n  else {\n    cVar1 = z->_bkgd;\n  }\n  return cVar1;\n}\n\n",
        "output": "The predicted function name is getbkgd"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *z)\n\n{\n  int iVar1;\n  \n  if (z == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    z->_attrs = 0;\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is wstandend"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win)\n\n{\n  short sVar1;\n  short sVar2;\n  chtype cVar3;\n  chtype *pcVar4;\n  ldat *plVar5;\n  short y;\n  short x;\n  int code;\n  chtype blank;\n  chtype *ptr;\n  ldat *line;\n  chtype *end;\n  \n  code = -1;\n  if (win != (WINDOW *)0x0) {\n    sVar1 = win->_cury;\n    sVar2 = win->_curx;\n    if (((win->_flags & 0x40U) != 0) && (sVar1 < win->_maxy)) {\n      win->_flags = win->_flags & 0xffbf;\n    }\n    if ((((win->_flags & 0x40U) == 0) && (sVar1 <= win->_maxy)) && (sVar2 <= win->_maxx)) {\n      cVar3 = win->_bkgd;\n      plVar5 = win->_line + sVar1;\n      if ((plVar5->firstchar == -1) || (sVar2 < plVar5->firstchar)) {\n        plVar5->firstchar = sVar2;\n      }\n      plVar5->lastchar = win->_maxx;\n      pcVar4 = plVar5->text;\n      sVar1 = win->_maxx;\n      ptr = plVar5->text + sVar2;\n      while (ptr <= pcVar4 + sVar1) {\n        *ptr = cVar3;\n        ptr = ptr + 1;\n      }\n      _nc_synchook(win);\n      code = 0;\n    }\n    else {\n      code = -1;\n    }\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is wclrtoeol"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *a1,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = waddnstr(stdscr,a1,z);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is addnstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](void)\n\n{\n  _Bool _Var1;\n  \n  _Var1 = _nc_reset_colors_sp(SP);\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is _nc_reset_colors"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = get_escdelay_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is get_escdelay"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int a1,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(stdscr,a1,z);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = wdelch(stdscr);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvdelch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nint [MASK](SCREEN *sp,char *cap,int affcnt)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  ushort **ppuVar4;\n  float cum_cost;\n  float number;\n  char *cp;\n  \n  if (cap == (char *)0x0) {\n    iVar2 = 1000000;\n  }\n  else {\n    cum_cost = 0.0;\n    for (cp = cap; *cp != '\\0'; cp = cp + 1) {\n      if (((*cp == '$') && (cp[1] == '<')) && (pcVar3 = strchr(cp,0x3e), pcVar3 != (char *)0x0)) {\n        number = 0.0;\n        for (cp = cp + 2; *cp != '>'; cp = cp + 1) {\n          ppuVar4 = __ctype_b_loc();\n          if (((*ppuVar4)[(byte)*cp] & 0x800) == 0) {\n            if (*cp == '*') {\n              number = (float)affcnt * number;\n            }\n            else if (((*cp == '.') && (cp = cp + 1, *cp != 0x3e)) &&\n                    (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)*cp] & 0x800) != 0)) {\n              number = (float)((double)(*cp + -0x30) / _DAT_00032038) + number;\n            }\n          }\n          else {\n            number = (float)(*cp + -0x30) + number * DAT_00032030;\n          }\n        }\n        cVar1 = _nc_prescreen._no_padding;\n        if (sp != (SCREEN *)0x0) {\n          cVar1 = sp->_no_padding;\n        }\n        if (cVar1 != '\\x01') {\n          cum_cost = DAT_00032030 * number + cum_cost;\n        }\n      }\n      else if (sp != (SCREEN *)0x0) {\n        cum_cost = (float)sp->_char_padding + cum_cost;\n      }\n    }\n    iVar2 = (int)cum_cost;\n  }\n  return iVar2;\n}\n\n",
        "output": "The predicted function name is _nc_msec_cost_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = winsdelln(stdscr,-1);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is deleteln"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](SCREEN *sp,chtype ch)\n\n{\n  _Bool _Var1;\n  int iVar2;\n  long in_FS_OFFSET;\n  short fg;\n  short bg;\n  int pair;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (((cur_term->type).Booleans[0x1c] == '\\0') && (sp->_coloron != 0)) {\n    if (sp->_default_color != true) {\n      _Var1 = false;\n      goto LAB_00019fe7;\n    }\n    if ((-1 < sp->_default_fg) || (-1 < sp->_default_bg)) {\n      _Var1 = false;\n      goto LAB_00019fe7;\n    }\n    pair = ch >> 8 & 0xff;\n    if ((pair != 0) &&\n       (((iVar2 = pair_content_sp(sp,(short)pair,&fg,&bg), iVar2 == -1 || (-1 < fg)) || (-1 < bg))))\n    {\n      _Var1 = false;\n      goto LAB_00019fe7;\n    }\n  }\n  if (((ch & 0xff) == 0x20) && ((ch & 0x7fc70000) == 0)) {\n    _Var1 = true;\n  }\n  else {\n    _Var1 = false;\n  }\nLAB_00019fe7:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return _Var1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is can_clear_with"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,int ToLines,int ToCols)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  chtype cVar6;\n  ldat *data;\n  _Bool valid;\n  int col;\n  int row;\n  int size_x;\n  int size_y;\n  int begin;\n  int end;\n  ldat *pline;\n  chtype *s;\n  ldat *new_lines;\n  \n  if (((win == (WINDOW *)0x0) || (iVar5 = ToLines + -1, iVar5 < 0)) ||\n     (iVar1 = ToCols + -1, iVar1 < 0)) {\n    iVar5 = -1;\n  }\n  else {\n    iVar2 = (int)win->_maxx;\n    iVar3 = (int)win->_maxy;\n    if ((iVar5 == iVar3) && (iVar1 == iVar2)) {\n      iVar5 = 0;\n    }\n    else {\n      if ((win->_flags & 1U) == 0) {\n        pline = (ldat *)0x0;\n      }\n      else {\n        if (((int)win->_parent->_maxy < win->_pary + iVar5) ||\n           ((int)win->_parent->_maxx < win->_parx + iVar1)) {\n          return -1;\n        }\n        pline = win->_parent->_line;\n      }\n      data = (ldat *)calloc((ulong)(uint)ToLines,0x10);\n      if (data == (ldat *)0x0) {\n        iVar5 = -1;\n      }\n      else {\n        for (row = 0; row <= iVar5; row = row + 1) {\n          if (iVar3 < row) {\n            iVar4 = 0;\n          }\n          else {\n            iVar4 = iVar2 + 1;\n          }\n          if ((win->_flags & 1U) == 0) {\n            if (iVar3 < row) {\n              s = (chtype *)malloc((ulong)(uint)ToCols << 2);\n              if (s == (chtype *)0x0) {\n                iVar5 = cleanup_lines(data,row);\n                return iVar5;\n              }\n              for (col = 0; col <= iVar1; col = col + 1) {\n                s[col] = win->_bkgd;\n              }\n            }\n            else if (iVar1 == iVar2) {\n              s = win->_line[row].text;\n            }\n            else {\n              s = (chtype *)malloc((ulong)(uint)ToCols << 2);\n              if (s == (chtype *)0x0) {\n                iVar5 = cleanup_lines(data,row);\n                return iVar5;\n              }\n              for (col = 0; col <= iVar1; col = col + 1) {\n                if (iVar2 < col) {\n                  cVar6 = win->_bkgd;\n                }\n                else {\n                  cVar6 = win->_line[row].text[col];\n                }\n                s[col] = cVar6;\n              }\n            }\n          }\n          else if ((pline == (ldat *)0x0) || (pline[row + win->_pary].text == (chtype *)0x0)) {\n            s = (chtype *)0x0;\n          }\n          else {\n            s = pline[row + win->_pary].text + win->_parx;\n          }\n          if (row <= iVar3) {\n            data[row].firstchar = win->_line[row].firstchar;\n            data[row].lastchar = win->_line[row].lastchar;\n          }\n          if ((iVar1 != iVar2) || (iVar3 < row)) {\n            if (iVar1 < iVar4) {\n              data[row].firstchar = 0;\n            }\n            else if (data[row].firstchar < iVar4) {\n              data[row].firstchar = (short)iVar4;\n            }\n            data[row].lastchar = (short)iVar1;\n          }\n          data[row].text = s;\n        }\n        if ((win->_flags & 1U) == 0) {\n          row = ToLines;\n          if (iVar1 == iVar2) {\n            for (; row <= iVar3; row = row + 1) {\n              free(win->_line[row].text);\n              win->_line[row].text = (chtype *)0x0;\n            }\n          }\n          else {\n            for (row = 0; row <= iVar3; row = row + 1) {\n              free(win->_line[row].text);\n              win->_line[row].text = (chtype *)0x0;\n            }\n          }\n        }\n        free(win->_line);\n        win->_line = (ldat *)0x0;\n        win->_line = data;\n        win->_maxx = (short)iVar1;\n        win->_maxy = (short)iVar5;\n        if (win->_maxy < win->_regtop) {\n          win->_regtop = win->_maxy;\n        }\n        if ((win->_maxy < win->_regbottom) || (iVar3 == win->_regbottom)) {\n          win->_regbottom = win->_maxy;\n        }\n        if (win->_maxx < win->_curx) {\n          win->_curx = win->_maxx;\n        }\n        if (win->_maxy < win->_cury) {\n          win->_cury = win->_maxy;\n        }\n        repair_subwindows(win);\n        iVar5 = 0;\n      }\n    }\n  }\n  return iVar5;\n}\n\n",
        "output": "The predicted function name is wresize"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,TERMINAL_conflict *termp)\n\n{\n  term_conflict *ptVar1;\n  int rc;\n  TERMINAL_conflict *cur;\n  \n  ptVar1 = cur_term;\n  rc = -1;\n  if (termp != (TERMINAL_conflict *)0x0) {\n    _nc_free_termtype(&termp->type);\n    if (termp == ptVar1) {\n      set_curterm_sp(sp,(TERMINAL_conflict *)0x0);\n    }\n    if (termp->_termname != (char *)0x0) {\n      free(termp->_termname);\n    }\n    if (_nc_globals.home_terminfo != (char *)0x0) {\n      free(_nc_globals.home_terminfo);\n      _nc_globals.home_terminfo = (char *)0x0;\n    }\n    free(termp);\n    rc = 0;\n  }\n  return rc;\n}\n\n",
        "output": "The predicted function name is del_curterm_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = slk_clear_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is slk_clear"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int value)\n\n{\n  int iVar1;\n  int code;\n  \n  code = 0;\n  iVar1 = value;\n  if (value < 1) {\n    code = -1;\n    iVar1 = TABSIZE;\n  }\n  TABSIZE = iVar1;\n  return code;\n}\n\n",
        "output": "The predicted function name is set_tabsize_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wscrl(stdscr,z);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is scrl"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *name)\n\n{\n  char *__src;\n  \n  if (name != (char *)0x0) {\n    __src = _nc_globals.comp_termtype;\n    if (_nc_globals.comp_termtype == (char *)0x0) {\n      __src = \"\";\n    }\n    strcpy(name,__src);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_get_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *target,char *source)\n\n{\n  long lVar1;\n  byte *pbVar2;\n  int iVar3;\n  long in_FS_OFFSET;\n  char *local_58;\n  byte *local_50;\n  int result;\n  int ch_1;\n  int ch;\n  char *base;\n  int bits [4];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  result = 0;\n  local_58 = source;\n  local_50 = (byte *)target;\n  base = target;\n  iVar3 = strncmp(source,\"b64:\",4);\n  if (iVar3 == 0) {\n    local_58 = local_58 + 4;\n    pbVar2 = local_50;\n    while (local_50 = pbVar2, *local_58 != '\\0') {\n      ch = lookup_b64(bits,&local_58);\n      if ((ch < 0) || (0xfff < (long)(local_50 + ((long)ch - (long)base)))) {\n        result = 0;\n        break;\n      }\n      result = result + ch;\n      *local_50 = (byte)(bits[0] << 2) | (byte)(bits[1] >> 4);\n      pbVar2 = local_50 + 1;\n      if (bits[2] < 0x40) {\n        local_50[1] = (byte)(bits[1] << 4) | (byte)(bits[2] >> 2);\n        pbVar2 = local_50 + 2;\n        if (bits[3] < 0x40) {\n          local_50[2] = (byte)(bits[2] << 6) | (byte)bits[3];\n          pbVar2 = local_50 + 3;\n        }\n      }\n    }\n  }\n  else {\n    iVar3 = strncmp(local_58,\"hex:\",4);\n    if (iVar3 == 0) {\n      local_58 = local_58 + 4;\n      while (*local_58 != '\\0') {\n        ch_1 = decode_hex(&local_58);\n        if ((ch_1 < 0) || (0xfff < (long)local_50 - (long)base)) {\n          result = 0;\n          break;\n        }\n        *local_50 = (byte)ch_1;\n        result = result + 1;\n        local_50 = local_50 + 1;\n      }\n    }\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return result;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is decode_quickdump"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,_Bool forever)\n\n{\n  int iVar1;\n  int iVar2;\n  int ch;\n  int timeleft;\n  int rc;\n  TRIES *ptr;\n  \n  iVar2 = ESCDELAY;\n  if (forever != false) {\n    iVar2 = 9999999;\n  }\n  ptr = sp->_keytry;\n  do {\n    if (((-1 < sp->_fifohead) && (sp->_fifopeek != sp->_fifohead)) &&\n       (0x100 < sp->_fifo[(int)sp->_fifohead])) break;\n    if (((sp->_fifohead < 0) || (sp->_fifopeek == sp->_fifotail)) &&\n       (iVar1 = fifo_push(sp), iVar1 == -1)) {\n      sp->_fifopeek = sp->_fifohead;\n      return -1;\n    }\n    iVar1 = fifo_peek(sp);\n    if (0x100 < iVar1) {\n      sp->_fifopeek = sp->_fifohead;\n      if (sp->_fifotail < 1) {\n        sp->_fifotail = 0x88;\n      }\n      else {\n        sp->_fifotail = sp->_fifotail + -1;\n      }\n      if (sp->_fifohead != sp->_fifotail) {\n        return iVar1;\n      }\n      fifo_clear(sp);\n      return iVar1;\n    }\n    for (; (ptr != (TRIES *)0x0 && (ptr->ch != (uchar)iVar1)); ptr = ptr->sibling) {\n    }\n    if (ptr == (TRIES *)0x0) break;\n    if (ptr->value != 0) {\n      if (sp->_fifopeek == sp->_fifotail) {\n        fifo_clear(sp);\n      }\n      else {\n        sp->_fifohead = sp->_fifopeek;\n      }\n      return (uint)ptr->value;\n    }\n    ptr = ptr->child;\n  } while (((-1 < sp->_fifohead) && (sp->_fifopeek != sp->_fifotail)) ||\n          (iVar1 = check_mouse_activity(sp,iVar2), iVar1 != 0));\n  iVar2 = fifo_pull(sp);\n  sp->_fifopeek = sp->_fifohead;\n  return iVar2;\n}\n\n",
        "output": "The predicted function name is kgetch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int y,int x,char *fmt,...)\n\n{\n  long lVar1;\n  char in_AL;\n  undefined8 in_RCX;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  int code;\n  va_list argp;\n  undefined local_b8 [24];\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  local_a0 = in_RCX;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  code = wmove(stdscr,y,x);\n  if (code != -1) {\n    argp[0].gp_offset = 0x18;\n    argp[0].fp_offset = 0x30;\n    argp[0].overflow_arg_area = &stack0x00000008;\n    argp[0].reg_save_area = local_b8;\n    code = vw_printw(stdscr,fmt,argp);\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is mvprintw"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *a1,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = winnstr(stdscr,a1,z);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is innstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int delay)\n\n{\n  int iVar1;\n  int rc;\n  \n  iVar1 = _nc_timed_wait(sp,3,delay,(int *)0x0);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is check_mouse_activity"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nalias * [MASK](alias **actual,alias_table_data *source,char *strings,size_t tablesize)\n\n{\n  alias *paVar1;\n  size_t n;\n  \n  if (*actual == (alias *)0x0) {\n    paVar1 = (alias *)calloc(tablesize + 1,0x18);\n    *actual = paVar1;\n    if (*actual != (alias *)0x0) {\n      for (n = 0; n < tablesize; n = n + 1) {\n        if (-1 < source[n].from) {\n          (*actual)[n].from = strings + source[n].from;\n        }\n        if (-1 < source[n].to) {\n          (*actual)[n].to = strings + source[n].to;\n        }\n        if (-1 < source[n].source) {\n          (*actual)[n].source = strings + source[n].source;\n        }\n      }\n    }\n  }\n  return *actual;\n}\n\n",
        "output": "The predicted function name is _nc_build_alias"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *a1,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wgetnstr(stdscr,a1,z);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is getnstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](TERMTYPE *ptr,_Bool freeStrings)\n\n{\n  if ((freeStrings != false) && (ptr->str_table != (char *)0x0)) {\n    free(ptr->str_table);\n  }\n  if (ptr->Booleans != (char *)0x0) {\n    free(ptr->Booleans);\n  }\n  if (ptr->Numbers != (short *)0x0) {\n    free(ptr->Numbers);\n  }\n  if (ptr->Strings != (char **)0x0) {\n    free(ptr->Strings);\n  }\n  if ((freeStrings != false) && (ptr->ext_str_table != (char *)0x0)) {\n    free(ptr->ext_str_table);\n  }\n  if (ptr->ext_Names != (char **)0x0) {\n    free(ptr->ext_Names);\n  }\n  memset(ptr,0,0x48);\n  _nc_free_entry(_nc_head,ptr);\n  return;\n}\n\n",
        "output": "The predicted function name is really_free_termtype"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](WINDOW *z)\n\n{\n  _Bool _Var1;\n  \n  if ((z == (WINDOW *)0x0) || (z->_leaveok == false)) {\n    _Var1 = false;\n  }\n  else {\n    _Var1 = true;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is is_leaveok"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = slk_restore_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is slk_restore"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void *p,void *q)\n\n{\n  int iVar1;\n  char *a;\n  char *b;\n  \n                    /* WARNING: Load size is inaccurate */\n                    /* WARNING: Load size is inaccurate */\n  iVar1 = strcmp(*p,*q);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is cmp_format"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](string_desc *dst,char *src)\n\n{\n  size_t sVar1;\n  size_t len;\n  \n  if (((src != (char *)0x0) && (src != (char *)0xffffffffffffffff)) &&\n     (sVar1 = strlen(src), sVar1 < dst->s_size)) {\n    if (dst->s_tail != (char *)0x0) {\n      strcpy(dst->s_tail,src);\n      dst->s_tail = dst->s_tail + sVar1;\n    }\n    dst->s_size = dst->s_size - sVar1;\n    return true;\n  }\n  return false;\n}\n\n",
        "output": "The predicted function name is _nc_safe_strcat"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int z)\n\n{\n  wtimeout(stdscr,z);\n  return;\n}\n\n",
        "output": "The predicted function name is timeout"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  _nc_screen_resume_sp(sp);\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_screen_init_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Could not reconcile some variable overlaps */\n\n_Bool [MASK](char **table,int item,int length,char *name)\n\n{\n  int iVar1;\n  int n;\n  int result;\n  \n  result._3_1_ = 0xff;\n  n = item;\n  do {\n    if (length <= n) {\nLAB_0002e2bc:\n      return (_Bool)((byte)~result._3_1_ >> 7);\n    }\n    iVar1 = strcmp(table[n],name);\n    if (iVar1 == 0) {\n      result._3_1_ = (byte)((uint)n >> 0x18);\n      goto LAB_0002e2bc;\n    }\n    n = n + 1;\n  } while( true );\n}\n\n",
        "output": "The predicted function name is find_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win)\n\n{\n  int use_meta;\n  long in_FS_OFFSET;\n  int value;\n  int code;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  use_meta = _nc_use_meta(win);\n  code = _nc_wgetch(win,&value,use_meta);\n  if (code != -1) {\n    code = value;\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is wgetch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ENTRY *headp)\n\n{\n  while (_nc_head != (ENTRY *)0x0) {\n    _nc_free_termtype(&_nc_head->tterm);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_free_entries"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,int a2,int a3,chtype a4,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(a1,a2,a3);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = whline(a1,a4,z);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvwhline"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](WINDOW *z)\n\n{\n  _Bool _Var1;\n  \n  if ((z == (WINDOW *)0x0) || ((z->_flags & 1U) == 0)) {\n    _Var1 = false;\n  }\n  else {\n    _Var1 = true;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is is_subwin"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int x,int y,int col)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(stdscr,y,x);\n  if (iVar1 != -1) {\n    waddch(stdscr,col);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is plot"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int a1,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wsetscrreg(stdscr,a1,z);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is setscrreg"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win)\n\n{\n  SCREEN *sp_00;\n  int code;\n  SCREEN *sp;\n  \n  sp_00 = _nc_screen_of(win);\n  if (win == (WINDOW *)0x0) {\n    code = -1;\n  }\n  else if (win == sp_00->_curscr) {\n    sp_00->_curscr->_clear = true;\n    code = doupdate_sp(sp_00);\n  }\n  else {\n    code = wnoutrefresh(win);\n    if (code == 0) {\n      if (win->_clear != false) {\n        sp_00->_newscr->_clear = true;\n      }\n      code = doupdate_sp(sp_00);\n      win->_clear = false;\n    }\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is wrefresh"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = doupdate_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is doupdate"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  char **ppcVar1;\n  int iVar2;\n  term_conflict *ptVar3;\n  int rc;\n  TERMINAL_conflict *termp;\n  \n  rc = -1;\n  ptVar3 = cur_term;\n  if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n    ptVar3 = sp->_term;\n  }\n  if ((ptVar3 != (term_conflict *)0x0) && (iVar2 = _nc_get_tty_mode(&ptVar3->Ottyb), iVar2 == 0)) {\n    if (((ptVar3->Ottyb).c_oflag & 0x1800) != 0) {\n      ppcVar1 = (cur_term->type).Strings;\n      *ppcVar1 = (char *)0x0;\n      (cur_term->type).Strings[0x86] = *ppcVar1;\n    }\n    rc = 0;\n  }\n  return rc;\n}\n\n",
        "output": "The predicted function name is def_shell_mode_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](TRIES *tree,char *str)\n\n{\n  int result;\n  TRIES *ptr;\n  \n  result = 0;\n  if ((str != (char *)0x0) && (ptr = tree, *str != '\\0')) {\n    for (; ptr != (TRIES *)0x0; ptr = ptr->sibling) {\n      if (*str == ptr->ch) {\n        if ((str[1] == '\\0') && (ptr->child != (tries *)0x0)) {\n          result = -1;\n        }\n        else {\n          result = find_definition(ptr->child,str + 1);\n          if (result == 0) {\n            result = (int)ptr->value;\n          }\n          else if (str[1] == '\\0') {\n            result = -1;\n          }\n        }\n      }\n      if (result != 0) {\n        return result;\n      }\n    }\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is find_definition"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](void)\n\n{\n  char *pcVar1;\n  char *env;\n  \n  pcVar1 = setlocale(0,(char *)0x0);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is _nc_get_locale"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](WINDOW *z)\n\n{\n  _Bool _Var1;\n  \n  if ((z == (WINDOW *)0x0) || (z->_scroll == false)) {\n    _Var1 = false;\n  }\n  else {\n    _Var1 = true;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is is_scrollok"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,short pair,short *f,short *b)\n\n{\n  long in_FS_OFFSET;\n  int my_f;\n  int my_b;\n  int rc;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  rc = _nc_pair_content(sp,(int)pair,&my_f,&my_b);\n  if (rc == 0) {\n    if (my_f < 0x8000) {\n      if (my_f < -0x7fff) {\n        my_f = -0x7fff;\n      }\n    }\n    else {\n      my_f = 0x7fff;\n    }\n    *f = (short)my_f;\n    if (my_b < 0x8000) {\n      if (my_b < -0x7fff) {\n        my_b = -0x7fff;\n      }\n    }\n    else {\n      my_b = 0x7fff;\n    }\n    *b = (short)my_b;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return rc;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is pair_content_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int a1,int a2,char *z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(stdscr,a1,a2);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = waddnstr(stdscr,z,-1);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvaddstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  int ch;\n  \n  if (sp->_fifohead < 0) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = sp->_fifo[(int)sp->_fifohead];\n  }\n  if (sp->_fifopeek == sp->_fifohead) {\n    if (sp->_fifohead < 0x88) {\n      sp->_fifohead = sp->_fifohead + 1;\n    }\n    else {\n      sp->_fifohead = 0;\n    }\n    if (sp->_fifohead == sp->_fifotail) {\n      sp->_fifohead = -1;\n      sp->_fifotail = 0;\n    }\n    sp->_fifopeek = sp->_fifohead;\n  }\n  else {\n    if (sp->_fifohead < 0x88) {\n      sp->_fifohead = sp->_fifohead + 1;\n    }\n    else {\n      sp->_fifohead = 0;\n    }\n    if (sp->_fifohead == sp->_fifotail) {\n      sp->_fifohead = -1;\n      sp->_fifotail = 0;\n    }\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is fifo_pull"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp,chtype ch)\n\n{\n  int iVar1;\n  int oldcol;\n  \n  if ((cur_term->type).Booleans[1] == '\\0') {\n    PutAttrChar(sp,ch);\n  }\n  else if (((cur_term->type).Strings[0x97] == (char *)0x0) ||\n          ((cur_term->type).Strings[0x98] == (char *)0x0)) {\n    if ((((cur_term->type).Strings[0x1f] != (char *)0x0) &&\n        ((cur_term->type).Strings[0x2a] != (char *)0x0)) ||\n       (((cur_term->type).Strings[0x34] != (char *)0x0 ||\n        ((cur_term->type).Strings[0x6c] != (char *)0x0)))) {\n      GoTo(sp,sp->_lines + -1,sp->_columns + -2);\n      PutAttrChar(sp,ch);\n      GoTo(sp,sp->_lines + -1,sp->_columns + -2);\n      InsStr(sp,sp->_newscr->_line[(long)sp->_lines + -1].text + (long)sp->_columns + -2,1);\n    }\n  }\n  else {\n    iVar1 = sp->_curscol;\n    _nc_putp_sp(sp,\"exit_am_mode\",(cur_term->type).Strings[0x98]);\n    PutAttrChar(sp,ch);\n    sp->_curscol = iVar1;\n    _nc_putp_sp(sp,\"enter_am_mode\",(cur_term->type).Strings[0x97]);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is PutCharLR"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = reset_shell_mode_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is reset_shell_mode"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int vis)\n\n{\n  int iVar1;\n  bool bVar2;\n  int code;\n  int cursor;\n  \n  code = -1;\n  iVar1 = code;\n  if ((((sp != (SCREEN *)0x0) && (-1 < vis)) && (vis < 3)) && (iVar1 = sp->_cursor, vis != iVar1)) {\n    if (sp == (SCREEN *)0x0) {\n      bVar2 = cur_term != (term_conflict *)0x0;\n    }\n    else if (sp->_term == (TERMINAL_conflict *)0x0) {\n      bVar2 = cur_term != (term_conflict *)0x0;\n    }\n    else {\n      bVar2 = sp->_term != (TERMINAL_conflict *)0x0;\n    }\n    if (bVar2) {\n      if (vis == 1) {\n        code = _nc_putp_flush_sp(sp,\"cursor_normal\",(cur_term->type).Strings[0x10]);\n      }\n      else if (vis == 2) {\n        code = _nc_putp_flush_sp(sp,\"cursor_visible\",(cur_term->type).Strings[0x14]);\n      }\n      else if (vis == 0) {\n        code = _nc_putp_flush_sp(sp,\"cursor_invisible\",(cur_term->type).Strings[0xd]);\n      }\n    }\n    else {\n      code = -1;\n    }\n    if ((code != -1) && (code = iVar1, iVar1 == -1)) {\n      code = 1;\n    }\n    sp->_cursor = vis;\n    iVar1 = code;\n  }\n  code = iVar1;\n  return code;\n}\n\n",
        "output": "The predicted function name is curs_set_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *filename,uint limit,char *path,char *name,TERMTYPE *tp)\n\n{\n  long lVar1;\n  _Bool _Var2;\n  int limit_00;\n  long in_FS_OFFSET;\n  int code;\n  int used;\n  char buffer [4097];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  code = 0;\n  limit_00 = decode_quickdump(buffer,path);\n  if (limit_00 != 0) {\n    code = _nc_read_termtype(tp,buffer,limit_00);\n    if (code == 1) {\n      code = _nc_name_match(tp->term_names,name,\"|\");\n      if (code == 1) {\n        *(undefined8 *)filename = 0x464e494d52455424;\n        *(undefined2 *)(filename + 8) = 0x4f;\n        goto LAB_0002aa9c;\n      }\n    }\n  }\n  _Var2 = make_dir_filename(filename,limit,path,name);\n  if (_Var2 != false) {\n    code = _nc_read_file_entry(filename,tp);\n  }\nLAB_0002aa9c:\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is _nc_read_tic_entry"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wattr_off(a1,z,(void *)0x0);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is wattroff"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = cbreak_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is cbreak"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *string,...)\n\n{\n  long lVar1;\n  char in_AL;\n  int iVar2;\n  TPARM_STATE *tps_00;\n  undefined8 in_RCX;\n  undefined8 in_RDX;\n  undefined8 in_RSI;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  char *result;\n  TPARM_STATE *tps;\n  va_list ap;\n  TPARM_DATA myData;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if (cur_term == (term_conflict *)0x0) {\n    tps_00 = &_nc_prescreen.tparm_state;\n  }\n  else {\n    tps_00 = &cur_term->tparm_state;\n  }\n  result = (char *)0x0;\n  _nc_tparm_err = 0;\n  local_b0 = in_RSI;\n  local_a8 = in_RDX;\n  local_a0 = in_RCX;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  iVar2 = tparm_setup(cur_term,string,&myData);\n  if (iVar2 == 0) {\n    ap[0].gp_offset = 8;\n    ap[0].fp_offset = 0x30;\n    ap[0].overflow_arg_area = &stack0x00000008;\n    ap[0].reg_save_area = local_b8;\n    tparm_copy_valist(&myData,1,ap);\n    result = tparam_internal(tps_00,string,&myData);\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is tparm"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp,chtype ch)\n\n{\n  if ((sp->_cursrow == sp->_lines + -1) && (sp->_curscol == sp->_columns + -1)) {\n    PutCharLR(sp,ch);\n  }\n  else {\n    PutAttrChar(sp,ch);\n  }\n  if ((int)sp->_columns <= sp->_curscol) {\n    wrap_cursor(sp);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is PutChar"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nint [MASK](char *path,int mode)\n\n{\n  long lVar1;\n  int iVar2;\n  int *piVar3;\n  size_t sVar4;\n  long in_FS_OFFSET;\n  int result;\n  char *leaf;\n  char head [4096];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if (path == (char *)0x0) {\n    result = -1;\n  }\n  else {\n    iVar2 = access(path,mode);\n    if (iVar2 < 0) {\n      if ((mode & 2U) != 0) {\n        piVar3 = __errno_location();\n        if (*piVar3 == 2) {\n          sVar4 = strlen(path);\n          if (sVar4 < 0x1000) {\n            strcpy(head,path);\n            leaf = _nc_basename(head);\n            if (leaf == (char *)0x0) {\n              leaf = head;\n            }\n            *leaf = '\\0';\n            if (leaf == head) {\n              head._0_2_ = 0x2e;\n            }\n            result = access(head,7);\n            goto LAB_0002dfcf;\n          }\n        }\n      }\n      result = -1;\n    }\n    else {\n      result = 0;\n    }\n  }\nLAB_0002dfcf:\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is _nc_access"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  char cVar2;\n  undefined uVar3;\n  long in_FS_OFFSET;\n  int red;\n  int green;\n  int blue;\n  int width;\n  int n;\n  rgb_bits_t *result;\n  char *s;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  result = &sp->_direct_color;\n  *result = 0;\n  if (COLORS < 8) goto LAB_00009e51;\n  width = 0;\n  while ((1 << ((byte)width & 0x1f)) + -1 < COLORS + -1) {\n    width = width + 1;\n  }\n  iVar1 = tigetflag(\"RGB\");\n  if (0 < iVar1) {\n    n = (width + 2) / 3;\n    cVar2 = (char)n;\n    *(char *)result = cVar2;\n    *(char *)((long)result + 1) = cVar2;\n    *(char *)((long)result + 2) = (char)width + cVar2 * -2;\n    goto LAB_00009e51;\n  }\n  n = tigetnum(\"RGB\");\n  if (0 < n) {\n    uVar3 = (undefined)n;\n    *(undefined *)result = uVar3;\n    *(undefined *)((long)result + 1) = uVar3;\n    *(undefined *)((long)result + 2) = uVar3;\n    goto LAB_00009e51;\n  }\n  s = tigetstr(\"RGB\");\n  if (((s == (char *)0x0) || (s == (char *)0xffffffffffffffff)) || (s == (char *)0x0))\n  goto LAB_00009e51;\n  red = n;\n  green = n;\n  blue = width + n * -2;\n  iVar1 = __isoc99_sscanf(s,\"%d/%d/%d\",&red,&green,&blue);\n  if (iVar1 == 2) {\nLAB_00009e27:\n    red = n;\n  }\n  else if (iVar1 != 3) {\n    if (iVar1 != 1) {\n      blue = width + n * -2;\n    }\n    green = n;\n    goto LAB_00009e27;\n  }\n  *(char *)result = (char)red;\n  *(char *)((long)result + 1) = (char)green;\n  *(char *)((long)result + 2) = (char)blue;\nLAB_00009e51:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return *result != 0;\n}\n\n",
        "output": "The predicted function name is init_direct_colors"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,int a2,int a3,chtype a4,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(a1,a2,a3);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = wvline(a1,a4,z);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvwvline"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = savetty_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is savetty"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int a1,int a2,chtype *a3,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(stdscr,a1,a2);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = winchnstr(stdscr,a3,z);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvinchnstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  ssize_t sVar1;\n  int *piVar2;\n  char *buf;\n  size_t amount;\n  ssize_t res;\n  \n  if ((sp == (SCREEN *)0x0) || (sp->_ofd < 0)) {\n    fflush(stdout);\n  }\n  else if (sp->out_inuse == 0) {\n    if (sp->out_buffer == (char *)0x0) {\n      fflush(stdout);\n    }\n  }\n  else {\n    buf = sp->out_buffer;\n    amount = SP->out_inuse;\n    SP->out_inuse = 0;\n    do {\n      while( true ) {\n        if (amount == 0) {\n          return;\n        }\n        sVar1 = write(sp->_ofd,buf,amount);\n        if (sVar1 < 1) break;\n        amount = amount - sVar1;\n        buf = buf + sVar1;\n      }\n      piVar2 = __errno_location();\n    } while ((*piVar2 == 0xb) || (piVar2 = __errno_location(), *piVar2 == 4));\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_flush_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](attr_t *a1,short *a2,void *z)\n\n{\n  int iVar1;\n  \n  if (stdscr == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    if (a1 != (attr_t *)0x0) {\n      *a1 = stdscr->_attrs;\n    }\n    if (a2 != (short *)0x0) {\n      *a2 = (ushort)(byte)(stdscr->_attrs >> 8);\n    }\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is attr_get"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *z)\n\n{\n  int iVar1;\n  \n  if (z == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = (int)z->_curx;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is getcurx"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *z)\n\n{\n  int iVar1;\n  \n  if (z == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = (int)z->_cury;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is getcury"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](_Bool f)\n\n{\n  _nc_prescreen.use_env = f;\n  return;\n}\n\n",
        "output": "The predicted function name is use_env"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = start_color_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is start_color"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,int z)\n\n{\n  int iVar1;\n  \n  if (a1 == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    a1->_attrs = z;\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is wattrset"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  _nc_screen_resume_sp(SP);\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_screen_resume"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  _nc_mvcur_resume_sp(SP);\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_mvcur_resume"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int a1,int a2,chtype *z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(stdscr,a1,a2);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = waddchnstr(stdscr,z,-1);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvaddchstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nstring_desc * [MASK](string_desc *dst,size_t len)\n\n{\n  string_desc *psVar1;\n  \n  psVar1 = _nc_str_init(dst,(char *)0x0,len);\n  return psVar1;\n}\n\n",
        "output": "The predicted function name is _nc_str_null"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](WINDOW *win)\n\n{\n  SCREEN *sp;\n  \n  sp = _nc_screen_chain;\n  while( true ) {\n    if (sp == (SCREEN *)0x0) {\n      return;\n    }\n    if (win == sp->_curscr) {\n      sp->_curscr = (WINDOW *)0x0;\n      if (win != curscr) {\n        return;\n      }\n      curscr = (WINDOW *)0x0;\n      return;\n    }\n    if (win == sp->_stdscr) {\n      sp->_stdscr = (WINDOW *)0x0;\n      if (win != stdscr) {\n        return;\n      }\n      stdscr = (WINDOW *)0x0;\n      return;\n    }\n    if (win == sp->_newscr) break;\n    sp = sp->_next_screen;\n  }\n  sp->_newscr = (WINDOW *)0x0;\n  if (win != newscr) {\n    return;\n  }\n  newscr = (WINDOW *)0x0;\n  return;\n}\n\n",
        "output": "The predicted function name is remove_window_from_screen"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,int n)\n\n{\n  int code;\n  \n  code = -1;\n  if (win != (WINDOW *)0x0) {\n    if (n != 0) {\n      _nc_scroll_window(win,-n,(int)win->_cury,(int)win->_maxy,win->_bkgd);\n      _nc_synchook(win);\n    }\n    code = 0;\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is winsdelln"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nvoid [MASK](SCREEN *sp)\n\n{\n  long lVar1;\n  int iVar2;\n  term_conflict *ptVar3;\n  long in_FS_OFFSET;\n  int result;\n  TERMINAL_conflict *termp;\n  termios buf;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  ptVar3 = cur_term;\n  if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n    ptVar3 = sp->_term;\n  }\n  if (ptVar3 != (term_conflict *)0x0) {\n    buf._0_8_ = *(undefined8 *)&ptVar3->Nttyb;\n    buf._16_8_ = *(undefined8 *)&(ptVar3->Nttyb).c_line;\n    buf.c_cc._7_8_ = *(undefined8 *)((ptVar3->Nttyb).c_cc + 7);\n    buf.c_cc._15_8_ = *(undefined8 *)((ptVar3->Nttyb).c_cc + 0xf);\n    buf.c_cc._23_8_ = *(undefined8 *)((ptVar3->Nttyb).c_cc + 0x17);\n    buf._48_8_ = *(undefined8 *)((ptVar3->Nttyb).c_cc + 0x1f);\n    buf.c_ospeed = (ptVar3->Nttyb).c_ospeed;\n    buf._8_8_ = *(ulong *)&(ptVar3->Nttyb).c_cflag | 0x8000000000;\n    iVar2 = _nc_set_tty_mode_sp(sp,&buf);\n    if (iVar2 == 0) {\n      *(undefined8 *)&ptVar3->Nttyb = buf._0_8_;\n      *(ulong *)&(ptVar3->Nttyb).c_cflag = buf._8_8_;\n      *(undefined8 *)&(ptVar3->Nttyb).c_line = buf._16_8_;\n      *(undefined8 *)((ptVar3->Nttyb).c_cc + 7) = buf.c_cc._7_8_;\n      *(undefined8 *)((ptVar3->Nttyb).c_cc + 0xf) = buf.c_cc._15_8_;\n      *(undefined8 *)((ptVar3->Nttyb).c_cc + 0x17) = buf.c_cc._23_8_;\n      *(undefined8 *)((ptVar3->Nttyb).c_cc + 0x1f) = buf._48_8_;\n      (ptVar3->Nttyb).c_ospeed = buf.c_ospeed;\n    }\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is noqiflush_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nHashData * [MASK](_Bool termcap)\n\n{\n  return hash_data + (int)(uint)termcap;\n}\n\n",
        "output": "The predicted function name is _nc_get_hash_info"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int sig)\n\n{\n  SCREEN *sp_00;\n  int iVar1;\n  bool bVar2;\n  SCREEN *scan;\n  SCREEN *sp;\n  sigaction_t act;\n  \n  sp_00 = SP;\n  iVar1 = _nc_globals.cleanup_nested + 1;\n  bVar2 = _nc_globals.cleanup_nested == 0;\n  _nc_globals.cleanup_nested = iVar1;\n  if ((bVar2) && ((sig == 2 || (sig == 0xf)))) {\n    sigemptyset((sigset_t *)&act.sa_mask);\n    act.sa_flags = 0;\n    act.__sigaction_handler = 1;\n    iVar1 = sigaction(sig,(sigaction *)&act,(sigaction *)0x0);\n    if (iVar1 == 0) {\n      for (scan = _nc_screen_chain; scan != (SCREEN *)0x0; scan = scan->_next_screen) {\n        if (scan->_ofp != (FILE *)0x0) {\n          iVar1 = fileno((FILE *)scan->_ofp);\n          iVar1 = isatty(iVar1);\n          if (iVar1 != 0) {\n            scan->_outch = _nc_outch_sp;\n          }\n        }\n        set_term(scan);\n        endwin_sp(sp_00);\n        if (sp_00 != (SCREEN *)0x0) {\n          sp_00->_endwin = 0;\n        }\n      }\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  _exit(1);\n}\n\n",
        "output": "The predicted function name is handle_SIGINT"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int ch)\n\n{\n  size_t sVar1;\n  char cVar2;\n  int iVar3;\n  FILE *__stream;\n  ssize_t sVar4;\n  long in_FS_OFFSET;\n  char tmp;\n  int rc;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  rc = 0;\n  cVar2 = (char)ch;\n  if ((sp == (SCREEN *)0x0) || (sp->_term == (TERMINAL_conflict *)0x0)) {\n    if (cur_term != (term_conflict *)0x0) goto LAB_00027d8e;\n  }\n  else if (sp->_term != (TERMINAL_conflict *)0x0) {\nLAB_00027d8e:\n    if (sp != (SCREEN *)0x0) {\n      if (sp->out_buffer == (char *)0x0) {\n        __stream = stdout;\n        if ((sp != (SCREEN *)0x0) && (sp->_ofp != (FILE *)0x0)) {\n          __stream = (FILE *)sp->_ofp;\n        }\n        tmp = cVar2;\n        iVar3 = fileno(__stream);\n        sVar4 = write(iVar3,&tmp,1);\n        if (sVar4 == -1) {\n          rc = -1;\n        }\n      }\n      else {\n        if (sp->out_limit <= sp->out_inuse + 1) {\n          _nc_flush_sp(sp);\n        }\n        sVar1 = sp->out_inuse;\n        sp->out_inuse = sVar1 + 1;\n        sp->out_buffer[sVar1] = cVar2;\n      }\n      goto LAB_00027e85;\n    }\n  }\n  tmp = cVar2;\n  iVar3 = fileno(stdout);\n  sVar4 = write(iVar3,&tmp,1);\n  if (sVar4 == -1) {\n    rc = -1;\n  }\nLAB_00027e85:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return rc;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is _nc_outch_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int color,int r,int g,int b)\n\n{\n  char *string;\n  int iVar1;\n  int result;\n  int maxcolors;\n  \n  result = -1;\n  if ((sp == (SCREEN *)0x0) || (sp->_direct_color != 0)) {\n    result = -1;\n  }\n  else if (((((((cur_term->type).Strings[299] != (char *)0x0) && (sp->_coloron != 0)) &&\n             (-1 < color)) && ((color < COLORS && (color < (cur_term->type).Numbers[0xd])))) &&\n           ((-1 < r && ((r < 0x3e9 && (-1 < g)))))) && ((g < 0x3e9 && ((-1 < b && (b < 0x3e9)))))) {\n    sp->_color_table[color].init = 1;\n    sp->_color_table[color].r = r;\n    sp->_color_table[color].g = g;\n    sp->_color_table[color].b = b;\n    if ((cur_term->type).Booleans[0x1d] == '\\0') {\n      sp->_color_table[color].red = r;\n      sp->_color_table[color].green = g;\n      sp->_color_table[color].blue = b;\n    }\n    else {\n      rgb2hls(r,g,b,&sp->_color_table[color].red,&sp->_color_table[color].green,\n              &sp->_color_table[color].blue);\n    }\n    string = _nc_tiparm(4,(cur_term->type).Strings[299],(ulong)(uint)color,(ulong)(uint)r,\n                        (ulong)(uint)g,(ulong)(uint)b);\n    _nc_putp_sp(sp,\"initialize_color\",string);\n    iVar1 = color + 1;\n    if (color + 1 < sp->_color_defs) {\n      iVar1 = sp->_color_defs;\n    }\n    sp->_color_defs = iVar1;\n    result = 0;\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is _nc_init_color"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int a1,int a2,chtype a3,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(stdscr,a1,a2);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = whline(stdscr,a3,z);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvhline"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](void)\n\n{\n  _Bool _Var1;\n  \n  _Var1 = _nc_has_mouse(SP);\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is has_mouse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](TERMINAL_conflict *termp)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  int result;\n  int value;\n  char *env_name;\n  char *env;\n  \n  result = 0;\n  pcVar2 = getenv(\"NCURSES_NO_UTF8_ACS\");\n  if (pcVar2 == (char *)0x0) {\n    iVar1 = tigetnum(\"U8\");\n    if ((iVar1 < 0) && (pcVar2 = getenv(\"TERM\"), iVar1 = result, pcVar2 != (char *)0x0)) {\n      pcVar3 = strstr(pcVar2,\"linux\");\n      if (pcVar3 == (char *)0x0) {\n        pcVar2 = strstr(pcVar2,\"screen\");\n        if (((((pcVar2 != (char *)0x0) && (pcVar2 = getenv(\"TERMCAP\"), pcVar2 != (char *)0x0)) &&\n             (pcVar3 = strstr(pcVar2,\"screen\"), pcVar3 != (char *)0x0)) &&\n            (pcVar2 = strstr(pcVar2,\"hhII00\"), pcVar2 != (char *)0x0)) &&\n           ((((((termp->type).Strings[0x19] != (char *)0x0 &&\n               (pcVar2 = strchr((termp->type).Strings[0x19],0xe), pcVar2 != (char *)0x0)) ||\n              (((termp->type).Strings[0x19] != (char *)0x0 &&\n               (pcVar2 = strchr((termp->type).Strings[0x19],0xf), pcVar2 != (char *)0x0)))) ||\n             (((termp->type).Strings[0x83] != (char *)0x0 &&\n              (pcVar2 = strchr((termp->type).Strings[0x83],0xe), pcVar2 != (char *)0x0)))) ||\n            (((termp->type).Strings[0x83] != (char *)0x0 &&\n             (pcVar2 = strchr((termp->type).Strings[0x83],0xf), pcVar2 != (char *)0x0)))))) {\n          result = 1;\n          iVar1 = result;\n        }\n      }\n      else {\n        result = 1;\n        iVar1 = result;\n      }\n    }\n  }\n  else {\n    iVar1 = _nc_getenv_num(\"NCURSES_NO_UTF8_ACS\");\n  }\n  result = iVar1;\n  return result;\n}\n\n",
        "output": "The predicted function name is _nc_locale_breaks_acs"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int ToLines,int ToCols)\n\n{\n  int iVar1;\n  \n  iVar1 = resizeterm_sp(SP,ToLines,ToCols);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is resizeterm"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  color_t *pcVar1;\n  undefined8 uVar2;\n  color_t *pcVar3;\n  color_t *pcVar4;\n  uint uVar5;\n  int n;\n  color_t *tp;\n  \n  if ((cur_term->type).Booleans[0x1d] == '\\0') {\n    pcVar3 = cga_palette;\n  }\n  else {\n    pcVar3 = hls_palette;\n  }\n  for (n = 0; n < COLORS; n = n + 1) {\n    if ((n < 0) || (7 < n)) {\n      uVar5 = (uint)(n >> 0x1f) >> 0x1d;\n      pcVar1 = pcVar3 + (int)((n + uVar5 & 7) - uVar5);\n      pcVar4 = sp->_color_table + n;\n      uVar2 = *(undefined8 *)&pcVar1->blue;\n      *(undefined8 *)pcVar4 = *(undefined8 *)pcVar1;\n      *(undefined8 *)&pcVar4->blue = uVar2;\n      *(undefined8 *)&pcVar4->g = *(undefined8 *)&pcVar1->g;\n      pcVar4->init = pcVar1->init;\n      if ((cur_term->type).Booleans[0x1d] == '\\0') {\n        if (sp->_color_table[n].red != 0) {\n          sp->_color_table[n].red = 1000;\n        }\n        if (sp->_color_table[n].green != 0) {\n          sp->_color_table[n].green = 1000;\n        }\n        if (sp->_color_table[n].blue != 0) {\n          sp->_color_table[n].blue = 1000;\n        }\n      }\n      else {\n        sp->_color_table[n].green = 100;\n      }\n    }\n    else {\n      pcVar1 = pcVar3 + n;\n      pcVar4 = sp->_color_table + n;\n      uVar2 = *(undefined8 *)&pcVar1->blue;\n      *(undefined8 *)pcVar4 = *(undefined8 *)pcVar1;\n      *(undefined8 *)&pcVar4->blue = uVar2;\n      *(undefined8 *)&pcVar4->g = *(undefined8 *)&pcVar1->g;\n      pcVar4->init = pcVar1->init;\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is init_color_table"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nSCREEN * [MASK](void)\n\n{\n  SCREEN *sp;\n  \n  sp = _nc_prescreen.allocated;\n  if (_nc_prescreen.allocated == (screen *)0x0) {\n    sp = (SCREEN *)calloc(1,0x608);\n    if (sp != (screen *)0x0) {\n      _nc_prescreen.allocated = sp;\n      sp->rsp = sp->rippedoff;\n      sp->_filtered = _nc_prescreen.filter_mode;\n      sp->_use_env = _nc_prescreen.use_env;\n      sp->_no_padding = _nc_prescreen._no_padding;\n      sp->slk_format = 0;\n      sp->_slk = (_SLK *)0x0;\n      sp->_prescreen = true;\n      sp->_cursrow = -1;\n      sp->_curscol = -1;\n      sp->_nl = 1;\n      sp->_raw = 0;\n      sp->_cbreak = 0;\n      sp->_echo = 1;\n      sp->_fifohead = -1;\n      sp->_endwin = 2;\n      sp->_cursor = -1;\n      sp->_outch = _nc_outch_sp;\n      sp->jump = (NCURSES_OUTC *)0x0;\n    }\n  }\n  return sp;\n}\n\n",
        "output": "The predicted function name is new_prescr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](chtype *z)\n\n{\n  int iVar1;\n  \n  iVar1 = waddchnstr(stdscr,z,-1);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is addchstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  _nc_screen_init_sp(SP);\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_screen_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](MEVENT *aevent)\n\n{\n  int iVar1;\n  \n  iVar1 = ungetmouse_sp(SP,aevent);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is ungetmouse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](chtype z)\n\n{\n  int iVar1;\n  \n  iVar1 = winsch(stdscr,z);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is insch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](attr_t a1,void *z)\n\n{\n  int iVar1;\n  \n  iVar1 = wattr_on(stdscr,a1,z);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is attr_on"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](SCREEN *sp,MEVENT *eventp)\n\n{\n  long lVar1;\n  _Bool _Var2;\n  ssize_t sVar3;\n  long in_FS_OFFSET;\n  _Bool result;\n  int res;\n  size_t grabbed;\n  uchar kbuf [4];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  for (grabbed = 0; grabbed < 3; grabbed = grabbed + (long)(int)sVar3) {\n    sVar3 = read(sp->_ifd,kbuf + grabbed,(long)(3 - (int)grabbed));\n    if ((int)sVar3 == -1) break;\n  }\n  kbuf[3] = '\\0';\n  eventp->id = 0;\n  _Var2 = decode_X10_bstate(sp,eventp,(uint)kbuf[0]);\n  eventp->x = kbuf[1] - 0x21;\n  eventp->y = kbuf[2] - 0x21;\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return _Var2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is decode_xterm_X10"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](TERMTYPE *to,TERMTYPE *from)\n\n{\n  ushort uVar1;\n  char *name_00;\n  _Bool _Var2;\n  int iVar3;\n  int iVar4;\n  int j;\n  int first;\n  int last;\n  int j_str;\n  int k;\n  char *name;\n  \n  iVar3 = (uint)to->ext_Numbers + (uint)to->ext_Booleans;\n  uVar1 = to->ext_Strings;\n  j = iVar3;\nLAB_0002f280:\n  do {\n    while( true ) {\n      if ((int)(iVar3 + (uint)uVar1) <= j) {\n        return;\n      }\n      name_00 = to->ext_Names[j];\n      if (to->Strings[(int)((((uint)to->num_Strings - iVar3) - (uint)to->ext_Strings) + j)] ==\n          (char *)0xffffffffffffffff) break;\n      j = j + 1;\n    }\n    iVar4 = _nc_find_ext_name(from,to->ext_Names[j],0);\n    if (-1 < iVar4) {\n      _Var2 = _nc_del_ext_name(to,name_00,2);\n      if (_Var2 == false) {\n        _Var2 = _nc_del_ext_name(to,name_00,1);\n        if (_Var2 == false) {\n          j = j + 1;\n          goto LAB_0002f280;\n        }\n      }\n      iVar4 = _nc_ins_ext_name(to,name_00,0);\n      to->Booleans[iVar4] = '\\0';\n      goto LAB_0002f280;\n    }\n    iVar4 = _nc_find_ext_name(from,to->ext_Names[j],1);\n    if (-1 < iVar4) {\n      _Var2 = _nc_del_ext_name(to,name_00,2);\n      if (_Var2 == false) {\n        _Var2 = _nc_del_ext_name(to,name_00,0);\n        if (_Var2 == false) {\n          j = j + 1;\n          goto LAB_0002f280;\n        }\n      }\n      iVar4 = _nc_ins_ext_name(to,name_00,1);\n      to->Numbers[iVar4] = -2;\n      goto LAB_0002f280;\n    }\n    iVar4 = _nc_find_ext_name(from,to->ext_Names[j],2);\n    if (-1 < iVar4) {\n      _Var2 = _nc_del_ext_name(to,name_00,1);\n      if (_Var2 == false) {\n        _Var2 = _nc_del_ext_name(to,name_00,0);\n        if (_Var2 == false) {\n          j = j + 1;\n          goto LAB_0002f280;\n        }\n      }\n      iVar4 = _nc_ins_ext_name(to,name_00,2);\n      to->Strings[iVar4] = (char *)0xffffffffffffffff;\n      goto LAB_0002f280;\n    }\n    j = j + 1;\n  } while( true );\n}\n\n",
        "output": "The predicted function name is adjust_cancels"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nripoff_t * [MASK](WINDOW *win)\n\n{\n  ripoff_t *result;\n  ripoff_t *rop;\n  \n  if (win != (WINDOW *)0x0) {\n    for (rop = _nc_prescreen.rippedoff; (long)(rop + -0x18383) < 0x61; rop = rop + 1) {\n      if ((win == rop->win) && (rop->line != 0)) {\n        return rop;\n      }\n    }\n  }\n  return (ripoff_t *)0x0;\n}\n\n",
        "output": "The predicted function name is ripped_window"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](void)\n\n{\n  return _nc_globals.comp_sourcename;\n}\n\n",
        "output": "The predicted function name is _nc_get_source"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp,int *linep,int *colp)\n\n{\n  long lVar1;\n  term_conflict *ptVar2;\n  int iVar3;\n  uint uVar4;\n  int *piVar5;\n  long in_FS_OFFSET;\n  _Bool useEnv;\n  _Bool useTioctl;\n  int my_tabsize;\n  int value;\n  TERMINAL_conflict *termp;\n  winsize size;\n  \n  ptVar2 = cur_term;\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  useEnv = _nc_prescreen.use_env;\n  useTioctl = _nc_prescreen.use_tioctl;\n  *linep = (int)(cur_term->type).Numbers[2];\n  *colp = (int)*(ptVar2->type).Numbers;\n  if (sp != (SCREEN *)0x0) {\n    useEnv = sp->_use_env;\n    useTioctl = sp->use_tioctl;\n  }\n  if ((useEnv != false) || (useTioctl != false)) {\n    iVar3 = isatty((int)cur_term->Filedes);\n    if (iVar3 != 0) {\n      piVar5 = __errno_location();\n      *piVar5 = 0;\n      do {\n        iVar3 = ioctl((int)cur_term->Filedes,0x5413,&size);\n        if (-1 < iVar3) {\n          if ((sp == (SCREEN *)0x0) || (sp->_filtered == false)) {\n            uVar4 = (uint)size.ws_row;\n          }\n          else {\n            uVar4 = 1;\n          }\n          *linep = uVar4;\n          *colp = (uint)size.ws_col;\n          break;\n        }\n        piVar5 = __errno_location();\n      } while (*piVar5 == 4);\n    }\n    if (useEnv != false) {\n      if (useTioctl != false) {\n        if ((sp == (SCREEN *)0x0) || (sp->_filtered != true)) {\n          iVar3 = _nc_getenv_num(\"LINES\");\n          if (0 < iVar3) {\n            _nc_setenv_num(\"LINES\",*linep);\n          }\n        }\n        iVar3 = _nc_getenv_num(\"COLUMNS\");\n        if (0 < iVar3) {\n          _nc_setenv_num(\"COLUMNS\",*colp);\n        }\n      }\n      iVar3 = _nc_getenv_num(\"LINES\");\n      if (0 < iVar3) {\n        *linep = iVar3;\n      }\n      iVar3 = _nc_getenv_num(\"COLUMNS\");\n      if (0 < iVar3) {\n        *colp = iVar3;\n      }\n    }\n    if (*linep < 1) {\n      *linep = (int)(ptVar2->type).Numbers[2];\n    }\n    if (*colp < 1) {\n      *colp = (int)*(ptVar2->type).Numbers;\n    }\n    if (*linep < 1) {\n      *linep = 0x18;\n    }\n    if (*colp < 1) {\n      *colp = 0x50;\n    }\n    (ptVar2->type).Numbers[2] = (short)*linep;\n    *(ptVar2->type).Numbers = (short)*colp;\n  }\n  if ((ptVar2->type).Numbers[1] < 0) {\n    my_tabsize = 8;\n  }\n  else {\n    my_tabsize = (int)(ptVar2->type).Numbers[1];\n  }\n  TABSIZE = my_tabsize;\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_get_screensize"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nWINDOW * [MASK](void)\n\n{\n  char *pcVar1;\n  SCREEN *pSVar2;\n  char *env;\n  char *name;\n  WINDOW *result;\n  \n  if (_nc_globals.init_screen != true) {\n    _nc_globals.init_screen = true;\n    pcVar1 = getenv(\"TERM\");\n    if ((pcVar1 == (char *)0x0) || (*pcVar1 == '\\0')) {\n      pcVar1 = \"unknown\";\n    }\n    pcVar1 = strdup(pcVar1);\n    if (pcVar1 == (char *)0x0) {\n      fwrite(\"Error opening allocating $TERM.\\n\",1,0x20,stderr);\n                    /* WARNING: Subroutine does not return */\n      exit(1);\n    }\n    pSVar2 = newterm(pcVar1,stdout,stdin);\n    if (pSVar2 == (SCREEN *)0x0) {\n      fprintf(stderr,\"Error opening terminal: %s.\\n\",pcVar1);\n                    /* WARNING: Subroutine does not return */\n      exit(1);\n    }\n    def_prog_mode_sp(SP);\n    free(pcVar1);\n  }\n  return stdscr;\n}\n\n",
        "output": "The predicted function name is initscr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,int beg,int num)\n\n{\n  int iVar1;\n  SCREEN *sp_00;\n  int local_34;\n  int i;\n  int end;\n  int crow;\n  size_t len;\n  SCREEN *sp;\n  \n  if (win == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    sp_00 = _nc_screen_of(win);\n    local_34 = beg;\n    if (beg < 0) {\n      local_34 = 0;\n    }\n    iVar1 = wtouchln(win,local_34,num,1);\n    if (iVar1 == -1) {\n      iVar1 = -1;\n    }\n    else {\n      iVar1 = wtouchln(sp_00->_curscr,win->_begy + local_34,num,1);\n      if (iVar1 == -1) {\n        iVar1 = -1;\n      }\n      else {\n        end = num + local_34;\n        if ((sp_00->_curscr->_maxy + 1) - (int)win->_begy < end) {\n          end = (sp_00->_curscr->_maxy + 1) - (int)win->_begy;\n        }\n        if (win->_maxy + 1 < end) {\n          end = win->_maxy + 1;\n        }\n        len = (size_t)(win->_maxx + 1);\n        if ((ulong)(long)((sp_00->_curscr->_maxx + 1) - (int)win->_begx) < len) {\n          len = (size_t)((sp_00->_curscr->_maxx + 1) - (int)win->_begx);\n        }\n        for (i = local_34; i < end; i = i + 1) {\n          iVar1 = i + win->_begy;\n          memset(sp_00->_curscr->_line[iVar1].text + win->_begx,0,len << 2);\n          _nc_make_oldhash_sp(sp_00,iVar1);\n        }\n        iVar1 = 0;\n      }\n    }\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is wredrawln"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int fg,int bg)\n\n{\n  int iVar1;\n  \n  iVar1 = assume_default_colors_sp(SP,fg,bg);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is assume_default_colors"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  TERMINAL_conflict *pTVar1;\n  char *str;\n  int iVar2;\n  term_conflict *ptVar3;\n  char *pcVar4;\n  uint n;\n  TERMTYPE *tp;\n  char *name;\n  char *value;\n  \n  if (sp != (SCREEN *)0x0) {\n    n = 0;\n    while (*(int *)(_nc_tinfo_fkeys + (ulong)n * 8 + 4) != 0) {\n      if (*(uint *)(_nc_tinfo_fkeys + (ulong)n * 8) < 0x19e) {\n        ptVar3 = cur_term;\n        if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n          ptVar3 = sp->_term;\n        }\n        _nc_add_to_try(&sp->_keytry,\n                       (ptVar3->type).Strings[*(uint *)(_nc_tinfo_fkeys + (ulong)n * 8)],\n                       *(uint *)(_nc_tinfo_fkeys + (ulong)n * 8 + 4));\n      }\n      n = n + 1;\n    }\n    pTVar1 = sp->_term;\n    for (n = 0x19e; n < (pTVar1->type).num_Strings; n = n + 1) {\n      if ((int)n < 0x19e) {\n        pcVar4 = *(char **)(strnames + (long)(int)n * 8);\n      }\n      else {\n        pcVar4 = (pTVar1->type).ext_Names\n                 [(int)((uint)(pTVar1->type).ext_Booleans + (uint)(pTVar1->type).ext_Numbers +\n                       (n - ((uint)(pTVar1->type).num_Strings - (uint)(pTVar1->type).ext_Strings)))]\n        ;\n      }\n      str = (pTVar1->type).Strings[n];\n      if ((((pcVar4 != (char *)0x0) && (*pcVar4 == 'k')) && (str != (char *)0x0)) &&\n         (iVar2 = key_defined_sp(sp,str), iVar2 == 0)) {\n        _nc_add_to_try(&sp->_keytry,str,n + 0x61);\n      }\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_init_keytry"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int pair,int f,int b)\n\n{\n  colorpair_t cVar1;\n  bool bVar2;\n  bool bVar3;\n  int iVar4;\n  color_t *pcVar5;\n  char *string;\n  int local_4c;\n  int local_48;\n  _Bool isDefault;\n  _Bool wasDefault;\n  int default_pairs;\n  int maxcolors;\n  color_t *tp;\n  colorpair_t result;\n  colorpair_t previous;\n  \n  if ((((sp == (SCREEN *)0x0) || (pair < 0)) || (sp->_pair_limit <= pair)) || (sp->_coloron == 0)) {\n    iVar4 = -1;\n  }\n  else {\n    iVar4 = (int)(cur_term->type).Numbers[0xd];\n    if ((sp->_color_pairs == (colorpair_t *)0x0) || (sp->_pair_alloc <= pair)) {\n      _nc_reserve_pairs(sp,pair);\n    }\n    cVar1 = sp->_color_pairs[pair];\n    previous.fg = SUB84(cVar1,0);\n    previous.bg = (int)((ulong)cVar1 >> 0x20);\n    local_4c = b;\n    local_48 = f;\n    if ((sp->_default_color == false) && (sp->_assumed_color == false)) {\n      if (((((f < 0) || (COLORS <= f)) || (iVar4 <= f)) || ((b < 0 || (COLORS <= b)))) ||\n         ((iVar4 <= b || (pair < 1)))) {\n        return -1;\n      }\n    }\n    else {\n      bVar2 = false;\n      bVar3 = false;\n      default_pairs = sp->_default_pairs;\n      if (f < 0) {\n        local_48 = -1;\n        bVar2 = true;\n      }\n      else if ((COLORS <= f) || (iVar4 <= f)) {\n        return -1;\n      }\n      if (b < 0) {\n        local_4c = -1;\n        bVar2 = true;\n      }\n      else if ((COLORS <= b) || (iVar4 <= b)) {\n        return -1;\n      }\n      if ((previous.fg < 0) || ((long)cVar1 < 0)) {\n        bVar3 = true;\n      }\n      if ((!bVar2) || (bVar3)) {\n        if ((bVar3) && (!bVar2)) {\n          default_pairs = default_pairs + -1;\n        }\n      }\n      else {\n        default_pairs = default_pairs + 1;\n      }\n      if (default_pairs + sp->_pair_count < pair) {\n        return -1;\n      }\n      sp->_default_pairs = default_pairs;\n    }\n    result = (colorpair_t)CONCAT44(local_4c,local_48);\n    if (((previous.fg != 0) || (previous.bg != 0)) &&\n       ((previous.fg != local_48 || (previous.bg != local_4c)))) {\n      _nc_change_pair(sp,pair);\n    }\n    sp->_color_pairs[pair] = result;\n    if (pair == (*sp->_current_attr >> 8 & 0xff)) {\n      *sp->_current_attr = *sp->_current_attr & 0xffff00ff;\n      *sp->_current_attr =\n           *sp->_current_attr & 0xffff0000 | (uint)CONCAT11(0xff,(char)*sp->_current_attr);\n    }\n    if (((((cur_term->type).Strings[300] != (char *)0x0) && (-1 < local_48)) && (local_48 < 8)) &&\n       ((-1 < local_4c && (local_4c < 8)))) {\n      if ((cur_term->type).Booleans[0x1d] == '\\0') {\n        pcVar5 = cga_palette;\n      }\n      else {\n        pcVar5 = hls_palette;\n      }\n      string = _nc_tiparm(7,(cur_term->type).Strings[300],(ulong)(uint)pair,\n                          (ulong)(uint)pcVar5[local_48].red,(ulong)(uint)pcVar5[local_48].green,\n                          (ulong)(uint)pcVar5[local_48].blue,(ulong)(uint)pcVar5[local_4c].red,\n                          (ulong)(uint)pcVar5[local_4c].green,(ulong)(uint)pcVar5[local_4c].blue);\n      _nc_putp_sp(sp,\"initialize_pair\",string);\n    }\n    iVar4 = 0;\n  }\n  return iVar4;\n}\n\n",
        "output": "The predicted function name is _nc_init_pair"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](WINDOW *z)\n\n{\n  _Bool _Var1;\n  \n  if ((z == (WINDOW *)0x0) || (z->_delay != 0)) {\n    _Var1 = false;\n  }\n  else {\n    _Var1 = true;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is is_nodelay"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,_Bool f)\n\n{\n  int iVar1;\n  \n  if (win == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    win->_notimeout = f;\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is notimeout"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](WINDOW *win,chtype ch)\n\n{\n  uint uVar1;\n  uint uVar2;\n  attr_t off;\n  attr_t on;\n  \n  if (win != (WINDOW *)0x0) {\n    uVar1 = win->_bkgd & 0xffffff00;\n    uVar2 = ch & 0xffffff00;\n    if ((char)(uVar1 >> 8) == '\\0') {\n      win->_attrs = ~uVar1 & win->_attrs;\n    }\n    else {\n      win->_attrs = ~(win->_bkgd & 0xffff0000 | 0xff00) & win->_attrs;\n    }\n    if ((char)(uVar2 >> 8) == '\\0') {\n      win->_attrs = win->_attrs | uVar2;\n    }\n    else {\n      win->_attrs = win->_attrs & 0xffff00ff | uVar2;\n    }\n    if ((ch & 0xff) == 0) {\n      win->_bkgd = ch & 0xffffff00 | 0x20;\n    }\n    else {\n      win->_bkgd = ch;\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is wbkgrndset"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](TRIES *tree,uint code,int *count,size_t len)\n\n{\n  TRIES *ptr;\n  char *result;\n  \n  result = (char *)0x0;\n  ptr = tree;\n  if (code != 0) {\n    while( true ) {\n      if ((ptr == (TRIES *)0x0) ||\n         (result = _nc_expand_try(ptr->child,code,count,len + 1), result != (char *)0x0))\n      goto LAB_000311e8;\n      if ((code == ptr->value) && (*count = *count + -1, *count == -1)) break;\n      ptr = ptr->sibling;\n    }\n    result = (char *)calloc(len + 2,1);\n  }\nLAB_000311e8:\n  if (((result != (char *)0x0) && (ptr != (TRIES *)0x0)) &&\n     (result[len] = ptr->ch, result[len] == '\\0')) {\n    result[len] = -0x80;\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is _nc_expand_try"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong [MASK](SCREEN *sp,chtype *text)\n\n{\n  chtype *local_28;\n  int i;\n  chtype ch;\n  ulong result;\n  \n  result = 0;\n  local_28 = text;\n  for (i = sp->_curscr->_maxx + 1; 0 < i; i = i + -1) {\n    result = (ulong)*local_28 + result * 0x21;\n    local_28 = local_28 + 1;\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is hash"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](TERMINAL_conflict *term,char *string,TPARM_DATA *result)\n\n{\n  int iVar1;\n  TPARM_STATE *pTVar2;\n  long *plVar3;\n  size_t sVar4;\n  char *pcVar5;\n  char **ppcVar6;\n  void *pvVar7;\n  int rc;\n  int n;\n  TPARM_STATE *tps;\n  void *ft;\n  TPARM_DATA *fs;\n  size_t len2;\n  \n  if (term == (TERMINAL_conflict *)0x0) {\n    pTVar2 = &_nc_prescreen.tparm_state;\n  }\n  else {\n    pTVar2 = &term->tparm_state;\n  }\n  rc = 0;\n  pTVar2->out_used = 0;\n  memset(result,0,0xa8);\n  if (string == (char *)0x0) {\n    rc = -1;\n  }\n  else {\n    result->format = string;\n    plVar3 = (long *)tfind(result,&_nc_globals.cached_tparm,cmp_format);\n    if (plVar3 == (long *)0x0) {\n      iVar1 = _nc_tparm_analyze(term,string,result->p_is_s,&result->num_popped);\n      result->num_parsed = iVar1;\n      if (pTVar2->fmt_buff == (char *)0x0) {\n        rc = -1;\n      }\n      else {\n        if (9 < result->num_parsed) {\n          result->num_parsed = 9;\n        }\n        if (9 < result->num_popped) {\n          result->num_popped = 9;\n        }\n        iVar1 = result->num_popped;\n        if (result->num_popped < result->num_parsed) {\n          iVar1 = result->num_parsed;\n        }\n        result->num_actual = iVar1;\n        for (n = 0; n < result->num_actual; n = n + 1) {\n          if (result->p_is_s[n] != (char *)0x0) {\n            result->tparm_type = result->tparm_type | 1 << ((byte)n & 0x1f);\n          }\n        }\n        ppcVar6 = (char **)calloc(1,0xa8);\n        if (ppcVar6 == (char **)0x0) {\n          rc = -1;\n        }\n        else {\n          pcVar5 = *(char **)&result->tparm_type;\n          *ppcVar6 = result->format;\n          ppcVar6[1] = pcVar5;\n          pcVar5 = (char *)result->param[0];\n          ppcVar6[2] = *(char **)&result->num_parsed;\n          ppcVar6[3] = pcVar5;\n          pcVar5 = (char *)result->param[2];\n          ppcVar6[4] = (char *)result->param[1];\n          ppcVar6[5] = pcVar5;\n          pcVar5 = (char *)result->param[4];\n          ppcVar6[6] = (char *)result->param[3];\n          ppcVar6[7] = pcVar5;\n          pcVar5 = (char *)result->param[6];\n          ppcVar6[8] = (char *)result->param[5];\n          ppcVar6[9] = pcVar5;\n          pcVar5 = (char *)result->param[8];\n          ppcVar6[10] = (char *)result->param[7];\n          ppcVar6[0xb] = pcVar5;\n          pcVar5 = result->p_is_s[1];\n          ppcVar6[0xc] = result->p_is_s[0];\n          ppcVar6[0xd] = pcVar5;\n          pcVar5 = result->p_is_s[3];\n          ppcVar6[0xe] = result->p_is_s[2];\n          ppcVar6[0xf] = pcVar5;\n          pcVar5 = result->p_is_s[5];\n          ppcVar6[0x10] = result->p_is_s[4];\n          ppcVar6[0x11] = pcVar5;\n          pcVar5 = result->p_is_s[7];\n          ppcVar6[0x12] = result->p_is_s[6];\n          ppcVar6[0x13] = pcVar5;\n          ppcVar6[0x14] = result->p_is_s[8];\n          pcVar5 = strdup(string);\n          *ppcVar6 = pcVar5;\n          if (*ppcVar6 == (char *)0x0) {\n            free(ppcVar6);\n            rc = -1;\n          }\n          else {\n            pvVar7 = tsearch(ppcVar6,&_nc_globals.cached_tparm,cmp_format);\n            if (pvVar7 == (void *)0x0) {\n              free(ppcVar6);\n              rc = -1;\n            }\n            else {\n              _nc_globals.count_tparm = _nc_globals.count_tparm + 1;\n            }\n          }\n        }\n      }\n    }\n    else {\n      ppcVar6 = (char **)*plVar3;\n      pcVar5 = ppcVar6[1];\n      result->format = *ppcVar6;\n      *(char **)&result->tparm_type = pcVar5;\n      pcVar5 = ppcVar6[3];\n      *(char **)&result->num_parsed = ppcVar6[2];\n      result->param[0] = (intptr_t)pcVar5;\n      pcVar5 = ppcVar6[5];\n      result->param[1] = (intptr_t)ppcVar6[4];\n      result->param[2] = (intptr_t)pcVar5;\n      pcVar5 = ppcVar6[7];\n      result->param[3] = (intptr_t)ppcVar6[6];\n      result->param[4] = (intptr_t)pcVar5;\n      pcVar5 = ppcVar6[9];\n      result->param[5] = (intptr_t)ppcVar6[8];\n      result->param[6] = (intptr_t)pcVar5;\n      pcVar5 = ppcVar6[0xb];\n      result->param[7] = (intptr_t)ppcVar6[10];\n      result->param[8] = (intptr_t)pcVar5;\n      pcVar5 = ppcVar6[0xd];\n      result->p_is_s[0] = ppcVar6[0xc];\n      result->p_is_s[1] = pcVar5;\n      pcVar5 = ppcVar6[0xf];\n      result->p_is_s[2] = ppcVar6[0xe];\n      result->p_is_s[3] = pcVar5;\n      pcVar5 = ppcVar6[0x11];\n      result->p_is_s[4] = ppcVar6[0x10];\n      result->p_is_s[5] = pcVar5;\n      pcVar5 = ppcVar6[0x13];\n      result->p_is_s[6] = ppcVar6[0x12];\n      result->p_is_s[7] = pcVar5;\n      result->p_is_s[8] = ppcVar6[0x14];\n      sVar4 = strlen(string);\n      if (pTVar2->fmt_size < sVar4 + 2) {\n        pTVar2->fmt_size = sVar4 + pTVar2->fmt_size + 2;\n        pcVar5 = (char *)_nc_doalloc(pTVar2->fmt_buff,pTVar2->fmt_size);\n        pTVar2->fmt_buff = pcVar5;\n        if (pTVar2->fmt_buff == (char *)0x0) {\n          rc = -1;\n        }\n      }\n    }\n  }\n  return rc;\n}\n\n",
        "output": "The predicted function name is tparm_setup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](chtype z)\n\n{\n  int iVar1;\n  \n  iVar1 = waddch(stdscr,z);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is addch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,chtype c)\n\n{\n  int iVar1;\n  \n  iVar1 = waddch_nosync(win,c);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is _nc_waddch_nosync"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int yold,int xold,int ynew,int xnew,NCURSES_OUTC_sp *myOutCh,int ovw)\n\n{\n  uint uVar1;\n  int local_30;\n  int local_2c;\n  int local_28;\n  int local_24;\n  int code;\n  int l;\n  chtype oldattr;\n  \n  if (sp == (SCREEN *)0x0) {\n    code = -1;\n  }\n  else if ((yold == ynew) && (xold == xnew)) {\n    code = 0;\n  }\n  else {\n    local_30 = xnew;\n    local_2c = ynew;\n    if (sp->_columns <= xnew) {\n      local_2c = ynew + xnew / (int)sp->_columns;\n      local_30 = xnew % (int)sp->_columns;\n    }\n    uVar1 = *sp->_current_attr;\n    if (((uVar1 & 0x400000) != 0) || ((uVar1 >> 8 != 0 && ((cur_term->type).Booleans[0xe] == '\\0')))\n       ) {\n      vidputs_sp(sp,0,myOutCh);\n    }\n    local_28 = xold;\n    local_24 = yold;\n    if (sp->_columns <= xold) {\n      l = (xold + 1) / (int)sp->_columns;\n      local_24 = yold + l;\n      if (sp->_lines <= local_24) {\n        l = l - ((local_24 - sp->_lines) + -1);\n      }\n      if (0 < l) {\n        if ((cur_term->type).Strings[2] == (char *)0x0) {\n          (*myOutCh)(sp,0xd);\n        }\n        else {\n          _nc_putp_sp(sp,\"carriage_return\",(cur_term->type).Strings[2]);\n        }\n        local_28 = 0;\n        for (; 0 < l; l = l + -1) {\n          if ((cur_term->type).Strings[0x67] == (char *)0x0) {\n            (*myOutCh)(sp,10);\n          }\n          else {\n            _nc_putp_sp(sp,\"newline\",(cur_term->type).Strings[0x67]);\n          }\n        }\n      }\n    }\n    if (sp->_lines + -1 < local_24) {\n      local_24 = sp->_lines + -1;\n    }\n    if (sp->_lines + -1 < local_2c) {\n      local_2c = sp->_lines + -1;\n    }\n    code = onscreen_mvcur(sp,local_24,local_28,local_2c,local_30,ovw,myOutCh);\n    if ((int3)(*sp->_current_attr >> 8) != (int3)(uVar1 >> 8)) {\n      vidputs_sp(sp,uVar1 & 0xffffff00,myOutCh);\n    }\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is _nc_real_mvcur"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  if (sp != (SCREEN *)0x0) {\n    if ((int3)(normal >> 8) != (int3)(*sp->_current_attr >> 8)) {\n      vidputs_sp(sp,normal & 0xffffff00,_nc_outch_sp);\n    }\n    if ((sp->_coloron != 0) && (sp->_default_color != true)) {\n      sp->_default_color = true;\n      _nc_do_color_sp(sp,-1,0,0,_nc_outch_sp);\n      sp->_default_color = false;\n      _nc_mvcur_sp(sp,sp->_cursrow,sp->_curscol,sp->_lines + -1,0);\n      ClrToEOL(sp,_nc_screen_wrap_sp::lexical_block_0::blank,1);\n    }\n    if (sp->_color_defs != 0) {\n      _nc_reset_colors_sp(sp);\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_screen_wrap_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int a1,int a2,int a3,attr_t a4,short a5,void *z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(stdscr,a1,a2);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = wchgat(stdscr,a3,a4,a5,z);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvchgat"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int n,int top,int bot)\n\n{\n  _nc_scroll_oldhash_sp(SP,n,top,bot);\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_scroll_oldhash"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](SCREEN *sp,MEVENT *eventp,int button,int wheel)\n\n{\n  uint uVar1;\n  mmask_t mVar2;\n  _Bool result;\n  \n  result = true;\n  uVar1 = button & 3;\n  if (uVar1 == 1) {\n    if (wheel == 0) {\n      if ((sp->_mouse_bstate & 0x40) == 0) {\n        mVar2 = 0x40;\n      }\n      else {\n        mVar2 = 0x10000000;\n      }\n      eventp->bstate = mVar2;\n      sp->_mouse_bstate = sp->_mouse_bstate | 0x40;\n    }\n    else {\n      eventp->bstate = 0x200000;\n    }\n  }\n  else if (uVar1 == 2) {\n    if ((sp->_mouse_bstate & 0x800) == 0) {\n      mVar2 = 0x800;\n    }\n    else {\n      mVar2 = 0x10000000;\n    }\n    eventp->bstate = mVar2;\n    sp->_mouse_bstate = sp->_mouse_bstate | 0x800;\n  }\n  else if (uVar1 == 0) {\n    if (wheel == 0) {\n      if ((sp->_mouse_bstate & 2) == 0) {\n        mVar2 = 2;\n      }\n      else {\n        mVar2 = 0x10000000;\n      }\n      eventp->bstate = mVar2;\n      sp->_mouse_bstate = sp->_mouse_bstate | 2;\n    }\n    else {\n      eventp->bstate = 0x10000;\n    }\n  }\n  else {\n    result = false;\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is handle_wheel"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *z)\n\n{\n  int iVar1;\n  \n  iVar1 = winsdelln(z,-1);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is wdeleteln"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nHashValue * [MASK](_Bool termcap)\n\n{\n  HashValue *pHVar1;\n  \n  if (termcap == false) {\n    pHVar1 = _nc_info_hash_table;\n  }\n  else {\n    pHVar1 = _nc_cap_hash_table;\n  }\n  return pHVar1;\n}\n\n",
        "output": "The predicted function name is _nc_get_hash_table"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win)\n\n{\n  int iVar1;\n  SCREEN *pSVar2;\n  SCREEN *sp;\n  \n  pSVar2 = _nc_screen_of(win);\n  if (pSVar2 == (SCREEN *)0x0) {\n    iVar1 = 0;\n  }\n  else {\n    iVar1 = pSVar2->_use_meta;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is _nc_use_meta"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,MEVENT *aevent)\n\n{\n  MEVENT *pMVar1;\n  undefined8 uVar2;\n  int result;\n  MEVENT *prev;\n  MEVENT *eventp;\n  \n  result = -1;\n  if ((((aevent != (MEVENT *)0x0) && (sp != (SCREEN *)0x0)) && (sp->_mouse_type != M_NONE)) &&\n     (pMVar1 = sp->_mouse_eventp, pMVar1 != (MEVENT *)0x0)) {\n    if (sp->_mouse_events < pMVar1) {\n      prev = pMVar1 + -1;\n    }\n    else {\n      prev = sp->_mouse_events + 7;\n    }\n    while ((prev->id != -1 && ((sp->_mouse_mask2 & prev->bstate) == 0))) {\n      prev->id = -1;\n      if (sp->_mouse_events < prev) {\n        prev = prev + -1;\n      }\n      else {\n        prev = sp->_mouse_events + 7;\n      }\n    }\n    if (prev->id == -1) {\n      aevent->bstate = 0;\n      aevent->id = -1;\n      aevent->x = 0;\n      aevent->y = 0;\n      aevent->z = 0;\n    }\n    else {\n      uVar2 = *(undefined8 *)&prev->y;\n      *(undefined8 *)aevent = *(undefined8 *)prev;\n      *(undefined8 *)&aevent->y = uVar2;\n      aevent->bstate = prev->bstate;\n      prev->id = -1;\n      sp->_mouse_eventp = prev;\n      result = 0;\n    }\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is getmouse_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *name,char *filename,TERMTYPE *tp)\n\n{\n  int iVar1;\n  int iVar2;\n  uint uVar3;\n  char *pcVar4;\n  long in_FS_OFFSET;\n  DBDIRS state;\n  int offset;\n  int code;\n  char *path;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  code = 0;\n  if (name == (char *)0x0) {\n    iVar1 = _nc_read_entry(\"\",filename,tp);\n  }\n  else {\n    sprintf(filename,\"%.*s\",0xfff,name);\n    iVar1 = code;\n    if ((((*name != '\\0') && (iVar2 = strcmp(name,\".\"), iVar1 = code, iVar2 != 0)) &&\n        (iVar2 = strcmp(name,\"..\"), iVar1 = code, iVar2 != 0)) &&\n       ((uVar3 = _nc_pathlast(name), iVar1 = code, uVar3 == 0 &&\n        (pcVar4 = strchr(name,0x3a), iVar1 = code, pcVar4 == (char *)0x0)))) {\n      _nc_first_db(&state,&offset);\n      code = -1;\n      do {\n        path = _nc_next_db(&state,&offset);\n        iVar1 = code;\n        if (path == (char *)0x0) goto LAB_0002ac05;\n        code = _nc_read_tic_entry(filename,0x1000,path,name,tp);\n      } while (code != 1);\n      _nc_last_db();\n      iVar1 = code;\n    }\n  }\nLAB_0002ac05:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is _nc_read_entry"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp,chtype *line,int count)\n\n{\n  char *string;\n  int local_1c;\n  chtype *local_18;\n  \n  local_1c = count;\n  local_18 = line;\n  if ((cur_term->type).Strings[0x6c] == (char *)0x0) {\n    if (((cur_term->type).Strings[0x1f] == (char *)0x0) ||\n       ((cur_term->type).Strings[0x2a] == (char *)0x0)) {\n      for (; 0 < local_1c; local_1c = local_1c + -1) {\n        _nc_putp_sp(sp,\"insert_character\",(cur_term->type).Strings[0x34]);\n        PutAttrChar(sp,*local_18);\n        if ((cur_term->type).Strings[0x36] != (char *)0x0) {\n          _nc_putp_sp(sp,\"insert_padding\",(cur_term->type).Strings[0x36]);\n        }\n        local_18 = local_18 + 1;\n      }\n    }\n    else {\n      _nc_putp_sp(sp,\"enter_insert_mode\",(cur_term->type).Strings[0x1f]);\n      for (; 0 < local_1c; local_1c = local_1c + -1) {\n        PutAttrChar(sp,*local_18);\n        if ((cur_term->type).Strings[0x36] != (char *)0x0) {\n          _nc_putp_sp(sp,\"insert_padding\",(cur_term->type).Strings[0x36]);\n        }\n        local_18 = local_18 + 1;\n      }\n      _nc_putp_sp(sp,\"exit_insert_mode\",(cur_term->type).Strings[0x2a]);\n    }\n  }\n  else {\n    string = _nc_tiparm(1,(cur_term->type).Strings[0x6c],(ulong)(uint)count);\n    tputs_sp(sp,string,1,_nc_outch_sp);\n    for (; 0 < local_1c; local_1c = local_1c + -1) {\n      PutAttrChar(sp,*local_18);\n      local_18 = local_18 + 1;\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is InsStr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](short color,short *r,short *g,short *b)\n\n{\n  int iVar1;\n  \n  iVar1 = color_content_sp(SP,color,r,g,b);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is color_content"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](WINDOW *win,chtype ch)\n\n{\n  chtype wch;\n  \n  wbkgrndset(win,ch);\n  return;\n}\n\n",
        "output": "The predicted function name is wbkgdset"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = _nc_globals.comp_sourcename;\n  if (_nc_globals.comp_sourcename == (char *)0x0) {\n    pcVar1 = \"?\";\n  }\n  fprintf(stderr,\"\\\"%s\\\"\",pcVar1);\n  if (-1 < _nc_curr_line) {\n    fprintf(stderr,\", line %d\",(ulong)(uint)_nc_curr_line);\n  }\n  if (-1 < _nc_curr_col) {\n    fprintf(stderr,\", col %d\",(ulong)(uint)_nc_curr_col);\n  }\n  if ((_nc_globals.comp_termtype != (char *)0x0) && (*_nc_globals.comp_termtype != '\\0')) {\n    fprintf(stderr,\", terminal \\'%s\\'\",_nc_globals.comp_termtype);\n  }\n  fputc(0x3a,stderr);\n  fputc(0x20,stderr);\n  return;\n}\n\n",
        "output": "The predicted function name is where_is_problem"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  int *piVar4;\n  int i;\n  int need_lines;\n  int shift;\n  int start;\n  int end;\n  int *new_oldnums;\n  \n  if ((sp->_oldnum_list == (int *)0x0) || (sp->_oldnum_size < (int)sp->_lines)) {\n    iVar2 = (int)sp->_lines;\n    if ((int)sp->_lines <= sp->_oldnum_size) {\n      iVar2 = sp->_oldnum_size;\n    }\n    piVar4 = (int *)_nc_doalloc(sp->_oldnum_list,(long)iVar2 * 4);\n    if (piVar4 == (int *)0x0) {\n      return;\n    }\n    sp->_oldnum_list = piVar4;\n    sp->_oldnum_size = iVar2;\n  }\n  _nc_hash_map_sp(sp);\n  i = 0;\n  while (i < sp->_lines) {\n    for (; (iVar2 = i, i < sp->_lines && ((sp->_oldnum_list[i] == -1 || (sp->_oldnum_list[i] <= i)))\n           ); i = i + 1) {\n    }\n    if (sp->_lines <= i) break;\n    iVar3 = sp->_oldnum_list[i] - i;\n    do {\n      iVar1 = i;\n      i = iVar1 + 1;\n      if ((sp->_lines <= i) || (sp->_oldnum_list[i] == -1)) break;\n    } while (iVar3 == sp->_oldnum_list[i] - i);\n    _nc_scrolln_sp(sp,iVar3,iVar2,iVar3 + iVar1,sp->_lines + -1);\n  }\n  i = sp->_lines + -1;\n  do {\n    if (i < 0) {\n      return;\n    }\n    for (; (iVar2 = i, -1 < i && ((sp->_oldnum_list[i] == -1 || (i <= sp->_oldnum_list[i]))));\n        i = i + -1) {\n    }\n    if (i < 0) {\n      return;\n    }\n    iVar3 = sp->_oldnum_list[i] - i;\n    do {\n      iVar1 = i;\n      i = iVar1 + -1;\n      if ((i < 0) || (sp->_oldnum_list[i] == -1)) break;\n    } while (iVar3 == sp->_oldnum_list[i] - i);\n    _nc_scrolln_sp(sp,iVar3,iVar3 + iVar1,iVar2,sp->_lines + -1);\n  } while( true );\n}\n\n",
        "output": "The predicted function name is _nc_scroll_optimize_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nuint [MASK](TERMTYPE *tp,int token_type)\n\n{\n  uint first;\n  \n  if (token_type == 1) {\n    first = (uint)tp->ext_Booleans;\n  }\n  else if (token_type == 2) {\n    first = (uint)tp->ext_Numbers + (uint)tp->ext_Booleans;\n  }\n  else if (token_type == 0) {\n    first = 0;\n  }\n  else {\n    first = 0;\n  }\n  return first;\n}\n\n",
        "output": "The predicted function name is _nc_first_ext_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nuint [MASK](char *path)\n\n{\n  char *pcVar1;\n  char *test;\n  \n  pcVar1 = strrchr(path,0x2f);\n  test = path;\n  if (pcVar1 != (char *)0x0) {\n    test = pcVar1 + 1;\n  }\n  return (int)test - (int)path;\n}\n\n",
        "output": "The predicted function name is _nc_pathlast"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  char *string;\n  \n  if ((cur_term->type).Strings[3] != (char *)0x0) {\n    string = _nc_tiparm(2,(cur_term->type).Strings[3],0,(ulong)((int)sp->_lines - 1));\n    _nc_putp_sp(sp,\"change_scroll_region\",string);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is reset_scroll_region"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = flushinp_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is flushinp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,int a2,int a3,char *a4,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(a1,a2,a3);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = winsnstr(a1,a4,z);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvwinsnstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](SCREEN *sp)\n\n{\n  return false;\n}\n\n",
        "output": "The predicted function name is no_mouse_event"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,chtype ch)\n\n{\n  int iVar1;\n  chtype wch;\n  \n  iVar1 = _nc_background(win,ch,true);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is wbkgd"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = noecho_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is noecho"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](chtype ch)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = unctrl_sp(SP,ch);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is unctrl"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *source)\n\n{\n  char *pcVar1;\n  char cVar2;\n  char *local_20;\n  char ch;\n  char *target;\n  \n  local_20 = source;\n  target = source;\n  while( true ) {\n    pcVar1 = local_20 + 1;\n    cVar2 = *local_20;\n    if (cVar2 == '\\0') break;\n    local_20 = pcVar1;\n    if ((((cVar2 != '\\\\') || (*pcVar1 != '\\n')) && (cVar2 != '\\n')) && (cVar2 != '\\t')) {\n      *target = cVar2;\n      target = target + 1;\n    }\n  }\n  *target = '\\0';\n  return;\n}\n\n",
        "output": "The predicted function name is trim_formatting"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int dummy)\n\n{\n  long lVar1;\n  SCREEN *sp_00;\n  __pid_t _Var2;\n  __pid_t _Var3;\n  int iVar4;\n  long in_FS_OFFSET;\n  int sigttou_blocked;\n  SCREEN *sp;\n  sigset_t mask;\n  sigset_t omask;\n  sigaction_t act;\n  sigaction_t oact;\n  \n  sp_00 = SP;\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  _nc_globals.have_sigtstp = 1;\n  if ((SP != (SCREEN *)0x0) && (SP->_endwin == 1)) {\n    _Var2 = tcgetpgrp(0);\n    _Var3 = getpgrp();\n    if (_Var2 == _Var3) {\n      def_prog_mode_sp(sp_00);\n    }\n  }\n  sigemptyset((sigset_t *)&mask);\n  sigaddset((sigset_t *)&mask,0xe);\n  sigaddset((sigset_t *)&mask,0x1c);\n  sigprocmask(0,(sigset_t *)&mask,(sigset_t *)&omask);\n  iVar4 = sigismember((sigset_t *)&omask,0x16);\n  if (iVar4 == 0) {\n    sigemptyset((sigset_t *)&mask);\n    sigaddset((sigset_t *)&mask,0x16);\n    sigprocmask(0,(sigset_t *)&mask,(sigset_t *)0x0);\n  }\n  endwin_sp(sp_00);\n  sigemptyset((sigset_t *)&mask);\n  sigaddset((sigset_t *)&mask,0x14);\n  if (iVar4 == 0) {\n    sigaddset((sigset_t *)&mask,0x16);\n  }\n  sigprocmask(1,(sigset_t *)&mask,(sigset_t *)0x0);\n  act.__sigaction_handler = 0;\n  sigemptyset((sigset_t *)&act.sa_mask);\n  act.sa_flags = 0x10000000;\n  sigaction(0x14,(sigaction *)&act,(sigaction *)&oact);\n  _Var2 = getpid();\n  kill(_Var2,0x14);\n  sigaction(0x14,(sigaction *)&oact,(sigaction *)0x0);\n  flushinp_sp(sp_00);\n  def_shell_mode_sp(sp_00);\n  doupdate_sp(sp_00);\n  sigprocmask(2,(sigset_t *)&omask,(sigset_t *)0x0);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is handle_SIGTSTP"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](SCREEN *sp,char *fmt,__va_list_tag *ap)\n\n{\n  int iVar1;\n  int used;\n  char *result;\n  \n  result = (char *)0x0;\n  if ((sp == (SCREEN *)0x0) || (fmt == (char *)0x0)) {\n    if (_nc_globals.safeprint_buf != (char *)0x0) {\n      free(_nc_globals.safeprint_buf);\n      _nc_globals.safeprint_buf = (char *)0x0;\n      _nc_globals.safeprint_used = 0;\n    }\n  }\n  else {\n    if ((_nc_globals.safeprint_rows < sp->_lines) || (_nc_globals.safeprint_cols < sp->_columns)) {\n      if (_nc_globals.safeprint_rows < sp->_lines) {\n        _nc_globals.safeprint_rows = (int)sp->_lines;\n      }\n      if (_nc_globals.safeprint_cols < sp->_columns) {\n        _nc_globals.safeprint_cols = (int)sp->_columns;\n      }\n      _nc_globals.safeprint_used =\n           (long)(_nc_globals.safeprint_rows * (_nc_globals.safeprint_cols + 1)) + 1;\n      if (_nc_globals.safeprint_used < 0x50) {\n        _nc_globals.safeprint_used = 0x50;\n      }\n      _nc_globals.safeprint_buf =\n           (char *)_nc_doalloc(_nc_globals.safeprint_buf,_nc_globals.safeprint_used);\n    }\n    if (_nc_globals.safeprint_buf != (char *)0x0) {\n      while (iVar1 = vsnprintf(_nc_globals.safeprint_buf,_nc_globals.safeprint_used,fmt,ap),\n            (int)_nc_globals.safeprint_used <= iVar1) {\n        _nc_globals.safeprint_used = (size_t)((iVar1 * 3) / 2);\n        _nc_globals.safeprint_buf =\n             (char *)_nc_doalloc(_nc_globals.safeprint_buf,_nc_globals.safeprint_used);\n      }\n      result = _nc_globals.safeprint_buf;\n    }\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is _nc_printf_string_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int a1,int a2,chtype *z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(stdscr,a1,a2);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = winchnstr(stdscr,z,-1);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvinchstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int ch)\n\n{\n  int iVar1;\n  \n  iVar1 = putchar(ch);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is _nc_putchar_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win)\n\n{\n  int result;\n  ripoff_t *rop;\n  \n  result = 0;\n  if (win != (WINDOW *)0x0) {\n    for (rop = _nc_prescreen.rippedoff;\n        ((long)(rop + -0x18383) < 0x61 &&\n        ((-1 < rop->line || (result = result - rop->line, win != rop->win)))); rop = rop + 1) {\n    }\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is ripped_bottom"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nENTRY * [MASK](ENTRY *headp,TERMTYPE *tterm)\n\n{\n  ENTRY *ep;\n  ENTRY *last;\n  \n  last = (ENTRY *)0x0;\n  ep = headp;\n  while( true ) {\n    if (ep == (ENTRY *)0x0) {\n      return (ENTRY *)0x0;\n    }\n    if ((ENTRY *)tterm == ep) break;\n    last = ep;\n    ep = ep->next;\n  }\n  if (last != (ENTRY *)0x0) {\n    last->next = ep->next;\n  }\n  if (ep->next != (ENTRY *)0x0) {\n    ep->next->last = last;\n  }\n  if (ep == _nc_head) {\n    _nc_head = ep->next;\n  }\n  if (ep != _nc_tail) {\n    return ep;\n  }\n  _nc_tail = last;\n  return ep;\n}\n\n",
        "output": "The predicted function name is _nc_delink_entry"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp,chtype blank)\n\n{\n  int row;\n  int col;\n  \n  row = sp->_cursrow;\n  col = sp->_curscol;\n  if (row < 0) {\n    row = 0;\n  }\n  if (col < 0) {\n    col = 0;\n  }\n  if ((int3)(*sp->_current_attr >> 8) != (int3)(blank >> 8)) {\n    vidputs_sp(sp,blank & 0xffffff00,_nc_outch_sp);\n  }\n  tputs_sp(sp,(cur_term->type).Strings[7],sp->_lines - row,_nc_outch_sp);\n  while (col < sp->_columns) {\n    sp->_curscr->_line[row].text[col] = blank;\n    col = col + 1;\n  }\n  while (row = row + 1, row < sp->_lines) {\n    for (col = 0; col < sp->_columns; col = col + 1) {\n      sp->_curscr->_line[row].text[col] = blank;\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is ClrToEOS"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  if ((sp->_mouse_type == M_XTERM) && (sp->_mouse_mask != 0)) {\n    mouse_activate(sp,1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_mouse_resume"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  _nc_init_acs_sp(SP);\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_init_acs"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = resetty_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is resetty"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  qiflush_sp(SP);\n  return;\n}\n\n",
        "output": "The predicted function name is qiflush"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](WINDOW *win,int *pY,int *pX,_Bool to_screen)\n\n{\n  _Bool _Var1;\n  _Bool result;\n  int y;\n  int x;\n  \n  result = false;\n  if (((win != (WINDOW *)0x0) && (pY != (int *)0x0)) && (pX != (int *)0x0)) {\n    y = *pY;\n    x = *pX;\n    if (to_screen == false) {\n      _Var1 = wenclose(win,y,x);\n      if (_Var1 != false) {\n        y = y - ((int)win->_yoffset + (int)win->_begy);\n        x = x - win->_begx;\n        result = true;\n      }\n    }\n    else {\n      y = y + (int)win->_yoffset + (int)win->_begy;\n      x = x + win->_begx;\n      _Var1 = wenclose(win,y,x);\n      if (_Var1 != false) {\n        result = true;\n      }\n    }\n    if (result != false) {\n      *pX = x;\n      *pY = y;\n    }\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is wmouse_trafo"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int ToLines,int ToCols)\n\n{\n  int iVar1;\n  int res;\n  \n  iVar1 = resize_term_sp(SP,ToLines,ToCols);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is resize_term"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](_Bool f)\n\n{\n  _nc_prescreen.use_tioctl = f;\n  return;\n}\n\n",
        "output": "The predicted function name is use_tioctl"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](_Bool flag)\n\n{\n  uint uVar1;\n  int oldflag;\n  \n  uVar1 = (uint)_nc_user_definable;\n  _nc_user_definable = flag;\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is use_extended_names"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int maxclick)\n\n{\n  int oldval;\n  \n  if (sp == (SCREEN *)0x0) {\n    oldval = 0xa6;\n  }\n  else {\n    oldval = sp->_maxclick;\n    if (-1 < maxclick) {\n      sp->_maxclick = maxclick;\n    }\n  }\n  return oldval;\n}\n\n",
        "output": "The predicted function name is mouseinterval_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  \n  iVar1 = assume_default_colors_sp(sp,-1,-1);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is use_default_colors_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](char *path)\n\n{\n  long lVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  _Bool result;\n  stat sb;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  result = false;\n  iVar2 = stat(path,(stat *)&sb);\n  if ((iVar2 == 0) && ((sb.st_mode & 0xf000) == 0x4000)) {\n    result = true;\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is _nc_is_dir_path"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win)\n\n{\n  short sVar1;\n  chtype cVar2;\n  chtype *pcVar3;\n  ldat *plVar4;\n  short y;\n  short startx;\n  int code;\n  chtype blank;\n  chtype *ptr;\n  ldat *line;\n  chtype *end;\n  \n  code = -1;\n  if (win != (WINDOW *)0x0) {\n    startx = win->_curx;\n    cVar2 = win->_bkgd;\n    for (y = win->_cury; y <= win->_maxy; y = y + 1) {\n      plVar4 = win->_line + y;\n      pcVar3 = plVar4->text;\n      sVar1 = win->_maxx;\n      if ((plVar4->firstchar == -1) || (startx < plVar4->firstchar)) {\n        plVar4->firstchar = startx;\n      }\n      plVar4->lastchar = win->_maxx;\n      ptr = plVar4->text + startx;\n      while (ptr <= pcVar3 + sVar1) {\n        *ptr = cVar2;\n        ptr = ptr + 1;\n      }\n      startx = 0;\n    }\n    _nc_synchook(win);\n    code = 0;\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is wclrtobot"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](WINDOW *win,int n,int top,int bottom,chtype blank)\n\n{\n  int iVar1;\n  size_t __n;\n  int line;\n  int j;\n  int limit;\n  size_t to_copy;\n  \n  __n = (long)(win->_maxx + 1) << 2;\n  if (((-1 < top) && (top <= bottom)) && (bottom <= win->_maxy)) {\n    if (n < 0) {\n      for (line = bottom;\n          ((iVar1 = top, top - n <= line && (iVar1 = top, -1 < line)) && (iVar1 = top, top <= line))\n          ; line = line + -1) {\n        memcpy(win->_line[line].text,win->_line[n + line].text,__n);\n      }\n      while (((line = iVar1, line < top - n && (line <= win->_maxy)) && (line <= bottom))) {\n        for (j = 0; j <= win->_maxx; j = j + 1) {\n          win->_line[line].text[j] = blank;\n        }\n        iVar1 = line + 1;\n      }\n    }\n    if (0 < n) {\n      for (line = top;\n          ((iVar1 = bottom, line <= bottom - n && (iVar1 = bottom, line <= win->_maxy)) &&\n          (iVar1 = bottom, line <= bottom)); line = line + 1) {\n        memcpy(win->_line[line].text,win->_line[n + line].text,__n);\n      }\n      while (((line = iVar1, bottom - n < line && (-1 < line)) && (top <= line))) {\n        for (j = 0; j <= win->_maxx; j = j + 1) {\n          win->_line[line].text[j] = blank;\n        }\n        iVar1 = line + -1;\n      }\n    }\n    wtouchln(win,top,(bottom - top) + 1,1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_scroll_window"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp,int row,int col)\n\n{\n  _nc_mvcur_sp(sp,sp->_cursrow,sp->_curscol,row,col);\n  return;\n}\n\n",
        "output": "The predicted function name is GoTo"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  if (stdscr == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    stdscr->_attrs = 0x10000;\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is standout"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  int rc;\n  \n  rc = -1;\n  if ((sp != (SCREEN *)0x0) && (sp->_slk != (_SLK *)0x0)) {\n    sp->_slk->hidden = true;\n    sp->_slk->win->_bkgd = sp->_stdscr->_bkgd;\n    sp->_slk->win->_attrs = sp->_stdscr->_attrs;\n    if (sp->_slk->win == sp->_stdscr) {\n      rc = 0;\n    }\n    else {\n      werase(sp->_slk->win);\n      rc = wrefresh(sp->_slk->win);\n    }\n  }\n  return rc;\n}\n\n",
        "output": "The predicted function name is slk_clear_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,_Bool flag)\n\n{\n  int iVar1;\n  SCREEN *sp;\n  \n  if (win == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    win->_use_keypad = flag;\n    sp = _nc_screen_of(win);\n    iVar1 = _nc_keypad(sp,(uint)flag);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is keypad"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int ch)\n\n{\n  int iVar1;\n  \n  iVar1 = ungetch_sp(SP,ch);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is ungetch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](short color,short r,short g,short b)\n\n{\n  int iVar1;\n  \n  iVar1 = init_color_sp(SP,color,r,g,b);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is init_color"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](TERMINAL_conflict *termp,int proto)\n\n{\n  char cVar1;\n  char *__s;\n  size_t sVar2;\n  char CC;\n  uint i;\n  char *tmp;\n  \n  __s = getenv(\"CC\");\n  if (__s != (char *)0x0) {\n    sVar2 = strlen(__s);\n    if (sVar2 == 1) {\n      cVar1 = *__s;\n      for (i = 0; i < (termp->type).num_Strings; i = i + 1) {\n        for (tmp = (termp->type).Strings[i]; (tmp != (char *)0x0 && (*tmp != '\\0')); tmp = tmp + 1)\n        {\n          if (proto == (uint)(byte)*tmp) {\n            *tmp = cVar1;\n          }\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_tinfo_cmdch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,short color,short *r,short *g,short *b)\n\n{\n  long in_FS_OFFSET;\n  int my_r;\n  int my_g;\n  int my_b;\n  int rc;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  rc = _nc_color_content(sp,(int)color,&my_r,&my_g,&my_b);\n  if (rc == 0) {\n    if (my_r < 0x8000) {\n      if (my_r < -0x7fff) {\n        my_r = -0x7fff;\n      }\n    }\n    else {\n      my_r = 0x7fff;\n    }\n    *r = (short)my_r;\n    if (my_g < 0x8000) {\n      if (my_g < -0x7fff) {\n        my_g = -0x7fff;\n      }\n    }\n    else {\n      my_g = 0x7fff;\n    }\n    *g = (short)my_g;\n    if (my_b < 0x8000) {\n      if (my_b < -0x7fff) {\n        my_b = -0x7fff;\n      }\n    }\n    else {\n      my_b = 0x7fff;\n    }\n    *b = (short)my_b;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return rc;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is color_content_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int a1,int a2,chtype z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(stdscr,a1,a2);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = winsch(stdscr,z);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvinsch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  _Bool _Var1;\n  int iVar2;\n  int iVar3;\n  int i;\n  int nonempty;\n  int changedlines;\n  \n  if (sp == (SCREEN *)0x0) {\n    return -1;\n  }\n  if (sp->_curscr == (WINDOW *)0x0) {\n    sp->_curscr = curscr;\n  }\n  if (sp->_curscr != curscr) {\n    curscr = sp->_curscr;\n  }\n  if (sp->_newscr == (WINDOW *)0x0) {\n    sp->_newscr = newscr;\n  }\n  if (sp->_newscr != newscr) {\n    newscr = sp->_newscr;\n  }\n  if (sp->_stdscr == (WINDOW *)0x0) {\n    sp->_stdscr = stdscr;\n  }\n  if (sp->_stdscr != stdscr) {\n    stdscr = sp->_stdscr;\n  }\n  if (((sp->_curscr == (WINDOW *)0x0) || (sp->_newscr == (WINDOW *)0x0)) ||\n     (sp->_stdscr == (WINDOW *)0x0)) {\n    return -1;\n  }\n  _nc_signal_handler(0);\n  if (sp->_fifohold != 0) {\n    sp->_fifohold = sp->_fifohold + -1;\n  }\n  if ((sp->_endwin == 2) || (iVar2 = _nc_handle_sigwinch(sp), iVar2 != 0)) {\n    _nc_update_screensize(sp);\n  }\n  if (sp->_endwin == 2) {\n    reset_prog_mode_sp(sp);\n    _nc_mvcur_resume_sp(sp);\n    _nc_screen_resume_sp(sp);\n    (*sp->_mouse_resume)(sp);\n    sp->_endwin = 1;\n  }\n  nonempty = 0;\n  if ((sp->_curscr->_clear == false) && (sp->_newscr->_clear == false)) {\n    changedlines = 5;\n    _Var1 = check_pending(sp);\n    if (_Var1 != false) goto cleanup;\n    iVar3 = sp->_newscr->_maxy + 1;\n    iVar2 = (int)sp->_lines;\n    if (iVar3 < sp->_lines) {\n      iVar2 = iVar3;\n    }\n    if (sp->_scrolling != 0) {\n      _nc_scroll_optimize_sp(sp);\n    }\n    nonempty = ClrBottom(sp,iVar2);\n    for (i = 0; i < nonempty; i = i + 1) {\n      if (changedlines == 5) {\n        _Var1 = check_pending(sp);\n        if (_Var1 != false) goto cleanup;\n        changedlines = 0;\n      }\n      if ((sp->_newscr->_line[i].firstchar != -1) || (sp->_curscr->_line[i].firstchar != -1)) {\n        TransformLine(sp,i);\n        changedlines = changedlines + 1;\n      }\n      if (i <= sp->_newscr->_maxy) {\n        sp->_newscr->_line[i].firstchar = -1;\n        sp->_newscr->_line[i].lastchar = -1;\n      }\n      if (i <= sp->_curscr->_maxy) {\n        sp->_curscr->_line[i].firstchar = -1;\n        sp->_curscr->_line[i].lastchar = -1;\n      }\n    }\n  }\n  else {\n    ClrUpdate(sp);\n    sp->_curscr->_clear = false;\n    sp->_newscr->_clear = false;\n  }\n  for (i = nonempty; i <= sp->_newscr->_maxy; i = i + 1) {\n    sp->_newscr->_line[i].firstchar = -1;\n    sp->_newscr->_line[i].lastchar = -1;\n  }\n  for (i = nonempty; i <= sp->_curscr->_maxy; i = i + 1) {\n    sp->_curscr->_line[i].firstchar = -1;\n    sp->_curscr->_line[i].lastchar = -1;\n  }\n  if (sp->_newscr->_leaveok != true) {\n    sp->_curscr->_curx = sp->_newscr->_curx;\n    sp->_curscr->_cury = sp->_newscr->_cury;\n    GoTo(sp,(int)sp->_curscr->_cury,(int)sp->_curscr->_curx);\n  }\ncleanup:\n  if ((int3)(normal >> 8) != (int3)(*sp->_current_attr >> 8)) {\n    vidputs_sp(sp,normal & 0xffffff00,_nc_outch_sp);\n  }\n  _nc_flush_sp(sp);\n  sp->_curscr->_attrs = sp->_newscr->_attrs;\n  _nc_signal_handler(1);\n  return 0;\n}\n\n",
        "output": "The predicted function name is doupdate_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](MEVENT *aevent)\n\n{\n  int iVar1;\n  \n  iVar1 = getmouse_sp(SP,aevent);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is getmouse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,int pminrow,int pmincol,int sminrow,int smincol,int smaxrow,int smaxcol\n                )\n\n{\n  ldat *plVar1;\n  ldat *plVar2;\n  short sVar3;\n  int iVar4;\n  SCREEN *pSVar5;\n  int local_64;\n  int local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  int i;\n  int j;\n  int m;\n  int n;\n  int pmaxrow;\n  int pmaxcol;\n  chtype ch;\n  SCREEN *sp;\n  \n  if (win == (WINDOW *)0x0) {\n    iVar4 = -1;\n  }\n  else if ((win->_flags & 0x10U) == 0) {\n    iVar4 = -1;\n  }\n  else {\n    pSVar5 = _nc_screen_of(win);\n    local_54 = pminrow;\n    if (pminrow < 0) {\n      local_54 = 0;\n    }\n    local_58 = pmincol;\n    if (pmincol < 0) {\n      local_58 = 0;\n    }\n    local_5c = sminrow;\n    if (sminrow < 0) {\n      local_5c = 0;\n    }\n    local_60 = smincol;\n    if (smincol < 0) {\n      local_60 = 0;\n    }\n    pmaxrow = (smaxrow + local_54) - local_5c;\n    pmaxcol = (smaxcol + local_58) - local_60;\n    local_64 = smaxrow;\n    if (win->_maxy < pmaxrow) {\n      local_64 = smaxrow - (pmaxrow - win->_maxy);\n      pmaxrow = (local_64 + local_54) - local_5c;\n    }\n    if (win->_maxx < pmaxcol) {\n      smaxcol = smaxcol - (pmaxcol - win->_maxx);\n      pmaxcol = (smaxcol + local_58) - local_60;\n    }\n    if ((((local_64 < pSVar5->_lines) && (smaxcol < pSVar5->_columns)) && (local_5c <= local_64)) &&\n       (local_60 <= smaxcol)) {\n      i = local_54;\n      for (m = local_5c + win->_yoffset; (i <= pmaxrow && (m <= pSVar5->_newscr->_maxy)); m = m + 1)\n      {\n        plVar1 = pSVar5->_newscr->_line + m;\n        plVar2 = win->_line + i;\n        n = local_60;\n        for (j = local_58; j <= pmaxcol; j = j + 1) {\n          if (plVar2->text[j] != plVar1->text[n]) {\n            plVar1->text[n] = plVar2->text[j];\n            sVar3 = (short)n;\n            if (plVar1->firstchar == -1) {\n              plVar1->lastchar = sVar3;\n              plVar1->firstchar = plVar1->lastchar;\n            }\n            else if (n < plVar1->firstchar) {\n              plVar1->firstchar = sVar3;\n            }\n            else if (plVar1->lastchar < n) {\n              plVar1->lastchar = sVar3;\n            }\n          }\n          n = n + 1;\n        }\n        plVar2->lastchar = -1;\n        plVar2->firstchar = plVar2->lastchar;\n        i = i + 1;\n      }\n      win->_begx = (short)local_60;\n      win->_begy = (short)local_5c;\n      if (win->_clear != false) {\n        win->_clear = false;\n        pSVar5->_newscr->_clear = true;\n      }\n      if (((win->_leaveok != true) && (local_54 <= win->_cury)) &&\n         ((local_58 <= win->_curx && ((win->_cury <= pmaxrow && (win->_curx <= pmaxcol)))))) {\n        pSVar5->_newscr->_cury = (win->_cury - (short)local_54) + win->_begy + win->_yoffset;\n        pSVar5->_newscr->_curx = (win->_curx - (short)local_58) + win->_begx;\n      }\n      pSVar5->_newscr->_leaveok = win->_leaveok;\n      win->_flags = win->_flags & 0xffdf;\n      (win->_pad)._pad_y = (short)local_54;\n      (win->_pad)._pad_x = (short)local_58;\n      (win->_pad)._pad_top = (short)local_5c;\n      (win->_pad)._pad_left = (short)local_60;\n      (win->_pad)._pad_bottom = (short)local_64;\n      (win->_pad)._pad_right = (short)smaxcol;\n      iVar4 = 0;\n    }\n    else {\n      iVar4 = -1;\n    }\n  }\n  return iVar4;\n}\n\n",
        "output": "The predicted function name is pnoutrefresh"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int ch)\n\n{\n  int iVar1;\n  \n  iVar1 = putchar(ch);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is _nc_putchar"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](chtype a1,chtype a2,chtype a3,chtype a4,chtype a5,chtype a6,chtype a7,chtype z)\n\n{\n  int iVar1;\n  \n  iVar1 = wborder(stdscr,a1,a2,a3,a4,a5,a6,a7,z);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is border"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](void)\n\n{\n  _Bool _Var1;\n  time_t tVar2;\n  _Bool result;\n  DBDIRS n;\n  time_t now;\n  \n  result = false;\n  tVar2 = time((time_t *)0x0);\n  if (_nc_globals.dbd_time < tVar2) {\n    result = true;\n  }\n  else {\n    for (n = dbdTIC; n < dbdLAST; n = n + dbdEnvOnce) {\n      if ((_nc_globals.dbd_vars[n].name != (char *)0x0) &&\n         (_Var1 = update_getenv(_nc_globals.dbd_vars[n].name,n), _Var1 != false)) {\n        return true;\n      }\n    }\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is cache_expired"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  term_conflict *ptVar2;\n  char *pcVar3;\n  \n  if (((cur_term->type).Strings[0x163] == (char *)0x0) || (*(cur_term->type).Strings[0x163] == '\\0')\n     ) {\n    ptVar2 = cur_term;\n    if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n      ptVar2 = sp->_term;\n    }\n    pcVar3 = strstr((ptVar2->type).term_names,\"xterm\");\n    if ((pcVar3 != (char *)0x0) && (iVar1 = _nc_add_to_try(&sp->_keytry,\"\\x1b[M\",0x199), iVar1 == 0)\n       ) {\n      init_xterm_mouse(sp);\n    }\n  }\n  else {\n    init_xterm_mouse(sp);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is initialize_mousetype"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,attr_t *a2,short *a3,void *z)\n\n{\n  int iVar1;\n  \n  if (a1 == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    if (a2 != (attr_t *)0x0) {\n      *a2 = a1->_attrs;\n    }\n    if (a3 != (short *)0x0) {\n      *a3 = (ushort)(byte)(a1->_attrs >> 8);\n    }\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is wattr_get"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *str)\n\n{\n  int iVar1;\n  \n  iVar1 = key_defined_sp(SP,str);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is key_defined"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](string_desc *target,int total,int num,int repeat,char *src)\n\n{\n  _Bool _Var1;\n  size_t sVar2;\n  int local_3c;\n  int local_34;\n  size_t need;\n  \n  sVar2 = strlen(src);\n  local_3c = repeat;\n  local_34 = total;\n  if (sVar2 * (long)repeat < target->s_size) {\n    while (0 < local_3c) {\n      _Var1 = _nc_safe_strcat(target,src);\n      if (_Var1 == false) {\n        return 1000000;\n      }\n      local_34 = local_34 + num;\n      local_3c = local_3c + -1;\n    }\n  }\n  else {\n    local_34 = 1000000;\n  }\n  return local_34;\n}\n\n",
        "output": "The predicted function name is repeated_append"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int fd)\n\n{\n  if (sp != (SCREEN *)0x0) {\n    if ((sp == (SCREEN *)0x0) || (sp->_term == (TERMINAL_conflict *)0x0)) {\n      if (cur_term != (term_conflict *)0x0) goto LAB_000210c0;\n    }\n    else if (sp->_term != (TERMINAL_conflict *)0x0) {\nLAB_000210c0:\n      sp->_checkfd = fd;\n      return 0;\n    }\n  }\n  return -1;\n}\n\n",
        "output": "The predicted function name is typeahead_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *fmt,...)\n\n{\n  char in_AL;\n  undefined8 in_RCX;\n  undefined8 in_RDX;\n  undefined8 in_RSI;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  va_list argp;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  local_b0 = in_RSI;\n  local_a8 = in_RDX;\n  local_a0 = in_RCX;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  where_is_problem();\n  argp[0].gp_offset = 8;\n  argp[0].fp_offset = 0x30;\n  argp[0].overflow_arg_area = &stack0x00000008;\n  argp[0].reg_save_area = local_b8;\n  vfprintf(stderr,fmt,argp);\n  fputc(10,stderr);\n                    /* WARNING: Subroutine does not return */\n  exit(1);\n}\n\n",
        "output": "The predicted function name is _nc_syserr_abort"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nint [MASK](char *tname,int Filedes,int *errret,int reuse)\n\n{\n  term_conflict *ptVar1;\n  int iVar2;\n  char *__s;\n  size_t sVar3;\n  long lVar4;\n  TERMTYPE *src;\n  char *pcVar5;\n  int local_44;\n  char *local_40;\n  int code;\n  int status;\n  TERMINAL_conflict *termp;\n  long limit;\n  SCREEN *sp;\n  char *myname;\n  TERMTYPE *fallback;\n  \n  ptVar1 = cur_term;\n  termp = cur_term;\n  local_40 = tname;\n  if ((tname == (char *)0x0) &&\n     ((local_40 = getenv(\"TERM\"), local_40 == (char *)0x0 || (*local_40 == '\\0')))) {\n    if (errret == (int *)0x0) {\n      fwrite(\"TERM environment variable not set.\\n\",1,0x23,stderr);\n                    /* WARNING: Subroutine does not return */\n      exit_terminfo(1);\n    }\n    *errret = -1;\n    iVar2 = -1;\n  }\n  else {\n    __s = strdup(local_40);\n    sVar3 = strlen(__s);\n    if (sVar3 < 0x201) {\n      local_44 = Filedes;\n      if ((Filedes == 1) && (iVar2 = isatty(1), iVar2 == 0)) {\n        local_44 = 2;\n      }\n      if ((((reuse == 0) || (ptVar1 == (term_conflict *)0x0)) || (local_44 != ptVar1->Filedes)) ||\n         (((ptVar1->_termname == (char *)0x0 || (iVar2 = strcmp(ptVar1->_termname,__s), iVar2 != 0))\n          || (iVar2 = _nc_name_match((ptVar1->type).term_names,__s,\"|\"), iVar2 == 0)))) {\n        termp = (TERMINAL_conflict *)calloc(1,0x2b0);\n        if (termp == (TERMINAL_conflict *)0x0) {\n          if (errret != (int *)0x0) {\n            *errret = -1;\n            free(__s);\n            return -1;\n          }\n          fprintf(stderr,\"\\'%s\\': Not enough memory to create terminal structure.\\n\",__s);\n          free(__s);\n                    /* WARNING: Subroutine does not return */\n          exit_terminfo(1);\n        }\n        limit._0_4_ = 0x800;\n        lVar4 = sysconf(0x2b);\n        if (0x800 < lVar4) {\n          lVar4 = sysconf(0x2b);\n          limit._0_4_ = (int)lVar4;\n        }\n        if (_nc_globals.getstr_limit < (int)limit) {\n          _nc_globals.getstr_limit = (int)limit;\n        }\n        status = _nc_setup_tinfo(__s,(TERMTYPE *)termp);\n        if ((status != 1) && (src = _nc_fallback(__s), src != (TERMTYPE *)0x0)) {\n          _nc_copy_termtype((TERMTYPE *)termp,src);\n          status = 1;\n        }\n        if (status != 1) {\n          del_curterm(termp);\n          if (status == -1) {\n            free(__s);\n            if (errret != (int *)0x0) {\n              *errret = -1;\n              return -1;\n            }\n            fwrite(\"terminals database is inaccessible\\n\",1,0x23,stderr);\n                    /* WARNING: Subroutine does not return */\n            exit_terminfo(1);\n          }\n          if (status != 0) {\n            free(__s);\n            if (errret != (int *)0x0) {\n              *errret = status;\n              return -1;\n            }\n            fwrite(\"unexpected return-code\\n\",1,0x17,stderr);\n                    /* WARNING: Subroutine does not return */\n            exit_terminfo(1);\n          }\n          if (errret != (int *)0x0) {\n            *errret = 0;\n            free(__s);\n            return -1;\n          }\n          fprintf(stderr,\"\\'%s\\': unknown terminal type.\\n\",__s);\n          free(__s);\n                    /* WARNING: Subroutine does not return */\n          exit_terminfo(1);\n        }\n        if ((termp->type).term_names != (char *)0x0) {\n          strncpy(ttytype,(termp->type).term_names,0xff);\n          ttytype[255] = 0;\n        }\n        termp->Filedes = (short)local_44;\n        pcVar5 = strdup(__s);\n        termp->_termname = pcVar5;\n        set_curterm(termp);\n        if ((termp->type).Strings[9] != (char *)0x0) {\n          _nc_tinfo_cmdch(termp,(uint)(byte)*(termp->type).Strings[9]);\n        }\n        iVar2 = isatty(local_44);\n        if (iVar2 != 0) {\n          def_shell_mode_sp((SCREEN *)0x0);\n          def_prog_mode_sp((SCREEN *)0x0);\n          baudrate();\n        }\n      }\n      _nc_get_screensize(SP,&LINES,&COLS);\n      if (errret != (int *)0x0) {\n        *errret = 1;\n      }\n      if ((termp->type).Booleans[6] == '\\0') {\n        if ((termp->type).Booleans[7] == '\\0') {\n          free(__s);\n          iVar2 = 0;\n        }\n        else {\n          if (errret == (int *)0x0) {\n            fprintf(stderr,\"\\'%s\\': I can\\'t handle hardcopy terminals.\\n\",__s);\n            free(__s);\n                    /* WARNING: Subroutine does not return */\n            exit_terminfo(1);\n          }\n          *errret = 1;\n          free(__s);\n          iVar2 = -1;\n        }\n      }\n      else if (((((termp->type).Strings[10] == (char *)0xffffffffffffffff) ||\n                ((termp->type).Strings[10] == (char *)0x0)) &&\n               (((termp->type).Strings[0xb] == (char *)0xffffffffffffffff ||\n                ((((termp->type).Strings[0xb] == (char *)0x0 ||\n                  ((termp->type).Strings[0xc] == (char *)0xffffffffffffffff)) ||\n                 ((termp->type).Strings[0xc] == (char *)0x0)))))) ||\n              (((termp->type).Strings[5] == (char *)0xffffffffffffffff ||\n               ((termp->type).Strings[5] == (char *)0x0)))) {\n        del_curterm(termp);\n        if (errret == (int *)0x0) {\n          fprintf(stderr,\"\\'%s\\': I need something more specific.\\n\",__s);\n          free(__s);\n                    /* WARNING: Subroutine does not return */\n          exit_terminfo(1);\n        }\n        *errret = 0;\n        free(__s);\n        iVar2 = -1;\n      }\n      else {\n        if (errret == (int *)0x0) {\n          fprintf(stderr,\"\\'%s\\': terminal is not really generic.\\n\",__s);\n          free(__s);\n                    /* WARNING: Subroutine does not return */\n          exit_terminfo(1);\n        }\n        *errret = 1;\n        free(__s);\n        iVar2 = -1;\n      }\n    }\n    else {\n      if (errret == (int *)0x0) {\n        fprintf(stderr,\"TERM environment must be <= %d characters.\\n\",0x200);\n        free(__s);\n                    /* WARNING: Subroutine does not return */\n        exit_terminfo(1);\n      }\n      *errret = -1;\n      free(__s);\n      iVar2 = -1;\n    }\n  }\n  return iVar2;\n}\n\n",
        "output": "The predicted function name is _nc_setupterm"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  noqiflush_sp(SP);\n  return;\n}\n\n",
        "output": "The predicted function name is noqiflush"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  _Bool _Var1;\n  int i;\n  \n  _Var1 = delink_screen(sp);\n  if (_Var1 != false) {\n    _nc_freewin(sp->_curscr);\n    _nc_freewin(sp->_newscr);\n    _nc_freewin(sp->_stdscr);\n    if (sp->_slk != (_SLK *)0x0) {\n      if (sp->_slk->ent != (slk_ent *)0x0) {\n        for (i = 0; i < sp->_slk->labcnt; i = i + 1) {\n          if (sp->_slk->ent[i].ent_text != (char *)0x0) {\n            free(sp->_slk->ent[i].ent_text);\n          }\n          if (sp->_slk->ent[i].form_text != (char *)0x0) {\n            free(sp->_slk->ent[i].form_text);\n          }\n        }\n        free(sp->_slk->ent);\n      }\n      free(sp->_slk);\n      sp->_slk = (_SLK *)0x0;\n    }\n    _nc_free_keytry(sp->_keytry);\n    sp->_keytry = (TRIES *)0x0;\n    _nc_free_keytry(sp->_key_ok);\n    sp->_key_ok = (TRIES *)0x0;\n    if (sp->_current_attr != (chtype *)0x0) {\n      free(sp->_current_attr);\n    }\n    if (sp->_color_table != (color_t *)0x0) {\n      free(sp->_color_table);\n    }\n    if (sp->_color_pairs != (colorpair_t *)0x0) {\n      free(sp->_color_pairs);\n    }\n    if (sp->_oldnum_list != (int *)0x0) {\n      free(sp->_oldnum_list);\n    }\n    if (sp->oldhash != (ulong *)0x0) {\n      free(sp->oldhash);\n    }\n    if (sp->newhash != (ulong *)0x0) {\n      free(sp->newhash);\n    }\n    if (sp->hashtab != (HASHMAP *)0x0) {\n      free(sp->hashtab);\n    }\n    if (sp->_acs_map != (chtype *)0x0) {\n      free(sp->_acs_map);\n    }\n    if (sp->_screen_acs_map != (_Bool *)0x0) {\n      free(sp->_screen_acs_map);\n    }\n    _nc_flush_sp(sp);\n    del_curterm_sp(sp,sp->_term);\n    if (sp->out_buffer != (char *)0x0) {\n      free(sp->out_buffer);\n    }\n    if (sp == _nc_prescreen.allocated) {\n      _nc_prescreen.allocated = (screen *)0x0;\n    }\n    free(sp);\n    if (sp == SP) {\n      curscr = (WINDOW *)0x0;\n      newscr = (WINDOW *)0x0;\n      stdscr = (WINDOW *)0x0;\n      COLORS = 0;\n      COLOR_PAIRS = 0;\n      SP = (SCREEN *)0x0;\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is delscreen"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](TPARM_STATE *tps,TPARM_DATA *data)\n\n{\n  _Bool termcap_hack;\n  int i;\n  \n  termcap_hack = false;\n  tps->stack_ptr = 0;\n  if (data->num_popped == 0) {\n    termcap_hack = true;\n    i = data->num_parsed;\n    while (i = i + -1, -1 < i) {\n      if (data->p_is_s[i] == (char *)0x0) {\n        if (tps->stack_ptr < 0x14) {\n          tps->stack[tps->stack_ptr].num_type = true;\n          *(int *)&tps->stack[tps->stack_ptr].data = (int)data->param[i];\n          tps->stack_ptr = tps->stack_ptr + 1;\n        }\n        else {\n          tparm_error(tps,\"npush: stack overflow\");\n        }\n      }\n      else if (tps->stack_ptr < 0x14) {\n        tps->stack[tps->stack_ptr].num_type = false;\n        tps->stack[tps->stack_ptr].data = data->p_is_s[i];\n        tps->stack_ptr = tps->stack_ptr + 1;\n      }\n      else {\n        tparm_error(tps,\"spush: stack overflow\");\n      }\n    }\n  }\n  return termcap_hack;\n}\n\n",
        "output": "The predicted function name is tparm_tc_compat"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = winsdelln(stdscr,1);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is insertln"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](chtype a1,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = whline(stdscr,a1,z);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is hline"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int a1,int a2,char *a3,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(stdscr,a1,a2);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = winsnstr(stdscr,a3,z);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvinsnstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nint [MASK](SCREEN *sp)\n\n{\n  long lVar1;\n  int iVar2;\n  term_conflict *ptVar3;\n  long in_FS_OFFSET;\n  int result;\n  TERMINAL_conflict *term;\n  termios buf;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  result = -1;\n  ptVar3 = cur_term;\n  if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n    ptVar3 = sp->_term;\n  }\n  iVar2 = cbreak_sp(sp);\n  if (iVar2 == 0) {\n    buf._16_8_ = *(undefined8 *)&(ptVar3->Nttyb).c_line;\n    buf.c_cc._7_8_ = *(undefined8 *)((ptVar3->Nttyb).c_cc + 7);\n    buf.c_cc._15_8_ = *(undefined8 *)((ptVar3->Nttyb).c_cc + 0xf);\n    buf.c_cc._23_8_ = *(undefined8 *)((ptVar3->Nttyb).c_cc + 0x17);\n    buf._48_8_ = *(undefined8 *)((ptVar3->Nttyb).c_cc + 0x1f);\n    buf.c_ospeed = (ptVar3->Nttyb).c_ospeed;\n    buf._8_8_ = *(ulong *)&(ptVar3->Nttyb).c_cflag & 0xffffffb7ffffffff;\n    buf._0_8_ = *(ulong *)&ptVar3->Nttyb & 0xfffffffbfffffe3f;\n    result = _nc_set_tty_mode_sp(sp,&buf);\n    if (result == 0) {\n      *(ulong *)&ptVar3->Nttyb = buf._0_8_;\n      *(ulong *)&(ptVar3->Nttyb).c_cflag = buf._8_8_;\n      *(undefined8 *)&(ptVar3->Nttyb).c_line = buf._16_8_;\n      *(undefined8 *)((ptVar3->Nttyb).c_cc + 7) = buf.c_cc._7_8_;\n      *(undefined8 *)((ptVar3->Nttyb).c_cc + 0xf) = buf.c_cc._15_8_;\n      *(undefined8 *)((ptVar3->Nttyb).c_cc + 0x17) = buf.c_cc._23_8_;\n      *(undefined8 *)((ptVar3->Nttyb).c_cc + 0x1f) = buf._48_8_;\n      (ptVar3->Nttyb).c_ospeed = buf.c_ospeed;\n    }\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return result;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is _nc_initscr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int OSpeed)\n\n{\n  uint local_1c;\n  int result;\n  uint i;\n  \n  result = -1;\n  local_1c = OSpeed;\n  if (OSpeed < 0) {\n    local_1c = (uint)(short)OSpeed;\n  }\n  if ((int)local_1c < 0) {\n    local_1c = local_1c & 0xffff;\n  }\n  if (local_1c == _nc_baudrate::last_OSpeed) {\n    result = _nc_baudrate::last_baudrate;\n  }\n  if (result == -1) {\n    if (-1 < (int)local_1c) {\n      i = 0;\n      while( true ) {\n        if ((0x1e < i) || ((int)local_1c < speeds[i].given_speed)) goto LAB_00020349;\n        if (local_1c == speeds[i].given_speed) break;\n        i = i + 1;\n      }\n      result = speeds[i].actual_speed;\n    }\nLAB_00020349:\n    if (local_1c != _nc_baudrate::last_OSpeed) {\n      _nc_baudrate::last_OSpeed = local_1c;\n      _nc_baudrate::last_baudrate = result;\n    }\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is _nc_baudrate"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nsize_t [MASK](char *buf,short *Numbers,int count)\n\n{\n  int i;\n  \n  for (i = 0; i < count; i = i + 1) {\n    if ((buf[i * 2] == -1) && (buf[(long)(i * 2) + 1] == -1)) {\n      Numbers[i] = -1;\n    }\n    else if ((buf[i * 2] == -2) && (buf[(long)(i * 2) + 1] == -1)) {\n      Numbers[i] = -2;\n    }\n    else {\n      Numbers[i] = (ushort)(byte)buf[(long)(i * 2) + 1] * 0x100 + (ushort)(byte)buf[i * 2];\n    }\n  }\n  return 2;\n}\n\n",
        "output": "The predicted function name is convert_16bits"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,chtype *otext,chtype *ntext,int row,int first,int last)\n\n{\n  int local_38;\n  int rc;\n  int j;\n  int same;\n  int i;\n  \n  if ((otext == ntext) || ((last - first) + 1 <= sp->_inline_cost)) {\n    rc = EmitRange(sp,ntext + first,(last - first) + 1);\n  }\n  else {\n    same = 0;\n    local_38 = first;\n    for (j = first; j <= last; j = j + 1) {\n      if (otext[j] == ntext[j]) {\n        same = same + 1;\n      }\n      else {\n        if (sp->_inline_cost < same) {\n          EmitRange(sp,ntext + local_38,(j - same) - local_38);\n          local_38 = j;\n          GoTo(sp,row,j);\n        }\n        same = 0;\n      }\n    }\n    rc = EmitRange(sp,ntext + local_38,(j - same) - local_38);\n    if (same != 0) {\n      rc = 1;\n    }\n  }\n  return rc;\n}\n\n",
        "output": "The predicted function name is PutRange"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,int a2,int a3,char *z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(a1,a2,a3);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = winnstr(a1,z,-1);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvwinstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  term_conflict *ptVar2;\n  TERMINAL_conflict *termp;\n  \n  ptVar2 = cur_term;\n  if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n    ptVar2 = sp->_term;\n  }\n  if (ptVar2 == (term_conflict *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    tcflush((int)ptVar2->Filedes,0);\n    if (sp != (SCREEN *)0x0) {\n      sp->_fifohead = -1;\n      sp->_fifotail = 0;\n      sp->_fifopeek = 0;\n    }\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is flushinp_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  memset(sp->_fifo,0,0x224);\n  sp->_fifohead = -1;\n  sp->_fifopeek = 0;\n  sp->_fifotail = sp->_fifopeek;\n  return;\n}\n\n",
        "output": "The predicted function name is fifo_clear"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int ms)\n\n{\n  int iVar1;\n  \n  iVar1 = napms_sp(SP,ms);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is napms"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](TERMINAL_conflict *term)\n\n{\n  TPARM_STATE *pTVar1;\n  TPARM_STATE *tps;\n  \n  if (term == (TERMINAL_conflict *)0x0) {\n    pTVar1 = &_nc_prescreen.tparm_state;\n  }\n  else {\n    pTVar1 = &term->tparm_state;\n  }\n  memset(pTVar1->static_vars,0,0x68);\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_reset_tparm"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  \n  if ((sp == (SCREEN *)0x0) || (sp->_slk == (_SLK *)0x0)) {\n    iVar1 = -1;\n  }\n  else if (sp->_slk->hidden == false) {\n    slk_intern_refresh(sp);\n    iVar1 = wrefresh(sp->_slk->win);\n  }\n  else {\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is slk_refresh_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,int a2,int a3,chtype *z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(a1,a2,a3);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = winchnstr(a1,z,-1);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvwinchstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nTERMINAL_conflict * [MASK](TERMINAL_conflict *termp)\n\n{\n  TERMINAL_conflict *pTVar1;\n  \n  pTVar1 = set_curterm_sp(SP,termp);\n  return pTVar1;\n}\n\n",
        "output": "The predicted function name is set_curterm"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,_Bool flag)\n\n{\n  _Bool _Var1;\n  SCREEN *sp_00;\n  int res;\n  SCREEN *sp;\n  \n  if (win == (WINDOW *)0x0) {\n    return -1;\n  }\n  sp_00 = _nc_screen_of(win);\n  if (sp_00 != (SCREEN *)0x0) {\n    if ((flag == false) ||\n       ((_Var1 = has_il_sp(sp_00), _Var1 == false && ((cur_term->type).Strings[3] == (char *)0x0))))\n    {\n      _Var1 = false;\n    }\n    else {\n      _Var1 = true;\n    }\n    win->_idlok = _Var1;\n    sp_00->_nc_sp_idlok = win->_idlok;\n    return 0;\n  }\n  return -1;\n}\n\n",
        "output": "The predicted function name is idlok"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,short pair,short f,short b)\n\n{\n  int iVar1;\n  \n  iVar1 = _nc_init_pair(sp,(int)pair,(int)f,(int)b);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is init_pair_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = nl_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is nl"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int yold,int xold,int ynew,int xnew)\n\n{\n  int iVar1;\n  \n  iVar1 = mvcur_sp(SP,yold,xold,ynew,xnew);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvcur"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nint [MASK](SCREEN *sp)\n\n{\n  long lVar1;\n  term_conflict *ptVar2;\n  long in_FS_OFFSET;\n  int result;\n  TERMINAL_conflict *termp;\n  termios buf;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  result = -1;\n  ptVar2 = cur_term;\n  if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n    ptVar2 = sp->_term;\n  }\n  if (ptVar2 != (term_conflict *)0x0) {\n    buf.c_cc._7_8_ = *(undefined8 *)((ptVar2->Nttyb).c_cc + 7);\n    buf.c_cc._15_8_ = *(undefined8 *)((ptVar2->Nttyb).c_cc + 0xf);\n    buf.c_cc._23_8_ = *(undefined8 *)((ptVar2->Nttyb).c_cc + 0x17);\n    buf._48_8_ = *(undefined8 *)((ptVar2->Nttyb).c_cc + 0x1f);\n    buf.c_ospeed = (ptVar2->Nttyb).c_ospeed;\n    buf._8_8_ = *(ulong *)&(ptVar2->Nttyb).c_cflag & 0xffff7ffcffffffff;\n    buf._0_8_ = *(ulong *)&ptVar2->Nttyb & 0xfffffffffffffbf5;\n    buf._16_7_ = (uint7)*(undefined8 *)&(ptVar2->Nttyb).c_line;\n    buf._16_7_ = buf._16_7_ & 0xffffffffffff;\n    buf._16_8_ = CONCAT17(1,buf._16_7_);\n    result = _nc_set_tty_mode_sp(sp,&buf);\n    if (result == 0) {\n      if (sp != (SCREEN *)0x0) {\n        sp->_raw = 1;\n        sp->_cbreak = 1;\n      }\n      *(ulong *)&ptVar2->Nttyb = buf._0_8_;\n      *(ulong *)&(ptVar2->Nttyb).c_cflag = buf._8_8_;\n      *(undefined8 *)&(ptVar2->Nttyb).c_line = buf._16_8_;\n      *(undefined8 *)((ptVar2->Nttyb).c_cc + 7) = buf.c_cc._7_8_;\n      *(undefined8 *)((ptVar2->Nttyb).c_cc + 0xf) = buf.c_cc._15_8_;\n      *(undefined8 *)((ptVar2->Nttyb).c_cc + 0x17) = buf.c_cc._23_8_;\n      *(undefined8 *)((ptVar2->Nttyb).c_cc + 0x1f) = buf._48_8_;\n      (ptVar2->Nttyb).c_ospeed = buf.c_ospeed;\n    }\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return result;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is raw_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchtype [MASK](int a1,int z)\n\n{\n  int iVar1;\n  chtype cVar2;\n  \n  iVar1 = wmove(stdscr,a1,z);\n  if (iVar1 == -1) {\n    cVar2 = 0xffffffff;\n  }\n  else {\n    cVar2 = winch(stdscr);\n  }\n  return cVar2;\n}\n\n",
        "output": "The predicted function name is mvinch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  \n  if (sp == (SCREEN *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    sp->_nl = 0;\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is nonl_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_leaks_tinfo"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int n,int del,int ins,chtype blank)\n\n{\n  int3 iVar1;\n  int iVar2;\n  char *pcVar3;\n  int i;\n  \n  if ((((cur_term->type).Strings[0x6a] == (char *)0x0) &&\n      ((cur_term->type).Strings[0x16] == (char *)0x0)) ||\n     (((cur_term->type).Strings[0x6e] == (char *)0x0 &&\n      ((cur_term->type).Strings[0x35] == (char *)0x0)))) {\n    iVar2 = -1;\n  }\n  else {\n    GoTo(sp,del,0);\n    iVar1 = (int3)(blank >> 8);\n    if ((int3)(*sp->_current_attr >> 8) != iVar1) {\n      vidputs_sp(sp,blank & 0xffffff00,_nc_outch_sp);\n    }\n    if ((n == 1) && ((cur_term->type).Strings[0x16] != (char *)0x0)) {\n      _nc_putp_sp(sp,\"delete_line\",(cur_term->type).Strings[0x16]);\n    }\n    else if ((cur_term->type).Strings[0x6a] == (char *)0x0) {\n      for (i = 0; i < n; i = i + 1) {\n        _nc_putp_sp(sp,\"delete_line\",(cur_term->type).Strings[0x16]);\n      }\n    }\n    else {\n      pcVar3 = _nc_tiparm(1,(cur_term->type).Strings[0x6a],(ulong)(uint)n);\n      tputs_sp(sp,pcVar3,n,_nc_outch_sp);\n    }\n    GoTo(sp,ins,0);\n    if ((int3)(*sp->_current_attr >> 8) != iVar1) {\n      vidputs_sp(sp,blank & 0xffffff00,_nc_outch_sp);\n    }\n    if ((n == 1) && ((cur_term->type).Strings[0x35] != (char *)0x0)) {\n      _nc_putp_sp(sp,\"insert_line\",(cur_term->type).Strings[0x35]);\n    }\n    else if ((cur_term->type).Strings[0x6e] == (char *)0x0) {\n      for (i = 0; i < n; i = i + 1) {\n        _nc_putp_sp(sp,\"insert_line\",(cur_term->type).Strings[0x35]);\n      }\n    }\n    else {\n      pcVar3 = _nc_tiparm(1,(cur_term->type).Strings[0x6e],(ulong)(uint)n);\n      tputs_sp(sp,pcVar3,n,_nc_outch_sp);\n    }\n    iVar2 = 0;\n  }\n  return iVar2;\n}\n\n",
        "output": "The predicted function name is scroll_idl"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nuint [MASK](TERMTYPE *tp,int token_type)\n\n{\n  uint last;\n  \n  if (token_type == 0) {\n    last = (uint)tp->ext_Booleans;\n  }\n  else if (token_type == 1) {\n    last = (uint)tp->ext_Numbers + (uint)tp->ext_Booleans;\n  }\n  else {\n    last = (uint)tp->ext_Strings + (uint)tp->ext_Booleans + (uint)tp->ext_Numbers;\n  }\n  return last;\n}\n\n",
        "output": "The predicted function name is _nc_last_ext_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,chtype a2,chtype z)\n\n{\n  int iVar1;\n  \n  iVar1 = wborder(a1,a2,a2,z,z,0,0,0,0);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is box"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  free(_nc_globals.dbd_blob);\n  _nc_globals.dbd_blob = (char *)0x0;\n  free(_nc_globals.dbd_list);\n  _nc_globals.dbd_list = (char **)0x0;\n  return;\n}\n\n",
        "output": "The predicted function name is free_cache"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int fd)\n\n{\n  int iVar1;\n  \n  iVar1 = typeahead_sp(SP,fd);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is typeahead"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,char *s,int n)\n\n{\n  short sVar1;\n  short sVar2;\n  SCREEN *sp_00;\n  short oy;\n  short ox;\n  int code;\n  uchar *cp;\n  uchar *str;\n  SCREEN *sp;\n  \n  code = -1;\n  if ((win != (WINDOW *)0x0) && (s != (char *)0x0)) {\n    sp_00 = _nc_screen_of(win);\n    sVar1 = win->_cury;\n    sVar2 = win->_curx;\n    for (cp = (uchar *)s; ((n < 1 || ((long)cp - (long)s < (long)n)) && (*cp != '\\0')); cp = cp + 1)\n    {\n      _nc_insert_ch(sp_00,win,(uint)*cp);\n    }\n    win->_curx = sVar2;\n    win->_cury = sVar1;\n    _nc_synchook(win);\n    code = 0;\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is winsnstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int t)\n\n{\n  int iVar1;\n  \n  iVar1 = halfdelay_sp(SP,t);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is halfdelay"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  int cursor;\n  \n  _nc_mvcur_sp(sp,-1,-1,sp->_lines + -1,0);\n  if (sp != (SCREEN *)0x0) {\n    if (sp->_cursor != -1) {\n      iVar1 = sp->_cursor;\n      curs_set_sp(sp,1);\n      sp->_cursor = iVar1;\n    }\n    if ((cur_term->type).Strings[0x28] != (char *)0x0) {\n      _nc_putp_sp(sp,\"exit_ca_mode\",(cur_term->type).Strings[0x28]);\n    }\n    _nc_outch_sp(sp,0xd);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_mvcur_wrap_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](TERMTYPE *dst,TERMTYPE *src)\n\n{\n  copy_termtype(dst,src,0);\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_copy_termtype"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](chtype newmode,NCURSES_OUTC *outc)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  SCREEN *sp;\n  screen outc_wrapper;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  sp = SP;\n  if (SP == (SCREEN *)0x0) {\n    sp = &outc_wrapper;\n    memset(sp,0,0x608);\n    outc_wrapper._outch = _nc_outc_wrapper;\n  }\n  sp->jump = outc;\n  iVar1 = vidputs_sp(SP,newmode,_nc_outc_wrapper);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is vidputs"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,char *z)\n\n{\n  int iVar1;\n  \n  iVar1 = winnstr(a1,z,-1);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is winstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ENTRY *headp,TERMTYPE *tterm)\n\n{\n  ENTRY *__ptr;\n  ENTRY *ep;\n  \n  __ptr = _nc_delink_entry(headp,tterm);\n  if (__ptr != (ENTRY *)0x0) {\n    free(__ptr);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_free_entry"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  int ch;\n  \n  if (sp->_fifopeek < 0) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = sp->_fifo[(int)sp->_fifopeek];\n  }\n  if (sp->_fifopeek < 0x88) {\n    sp->_fifopeek = sp->_fifopeek + 1;\n  }\n  else {\n    sp->_fifopeek = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is fifo_peek"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *src,int *offset,int limit,char *dst,uint want)\n\n{\n  uint uVar1;\n  uint local_30;\n  int have;\n  \n  uVar1 = limit - *offset;\n  if ((int)uVar1 < 1) {\n    local_30 = 0;\n  }\n  else {\n    local_30 = want;\n    if ((int)uVar1 < (int)want) {\n      local_30 = uVar1;\n    }\n    memcpy(dst,src + *offset,(ulong)local_30);\n    *offset = *offset + local_30;\n  }\n  return local_30;\n}\n\n",
        "output": "The predicted function name is fake_read"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = slk_noutrefresh_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is slk_noutrefresh"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int z)\n\n{\n  return (z & 0xffU) << 8;\n}\n\n",
        "output": "The predicted function name is COLOR_PAIR"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *name)\n\n{\n  if (_nc_globals.comp_termtype == (char *)0x0) {\n    _nc_globals.comp_termtype = (char *)malloc(0x201);\n  }\n  if ((_nc_globals.comp_termtype != (char *)0x0) &&\n     (*_nc_globals.comp_termtype = '\\0', name != (char *)0x0)) {\n    strncat(_nc_globals.comp_termtype,name,0x200);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_set_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](WINDOW *win,int line)\n\n{\n  _Bool _Var1;\n  \n  if (((win == (WINDOW *)0x0) || (win->_maxy < line)) || (line < 0)) {\n    _Var1 = false;\n  }\n  else {\n    _Var1 = win->_line[line].firstchar != -1;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is is_linetouched"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  chtype blank_00;\n  int iVar1;\n  int iVar2;\n  int i;\n  chtype blank;\n  int nonempty;\n  \n  if (sp != (SCREEN *)0x0) {\n    blank_00 = ClrBlank(sp,sp->_stdscr);\n    iVar2 = sp->_newscr->_maxy + 1;\n    iVar1 = (int)sp->_lines;\n    if (iVar2 < sp->_lines) {\n      iVar1 = iVar2;\n    }\n    ClearScreen(sp,blank_00);\n    iVar1 = ClrBottom(sp,iVar1);\n    for (i = 0; i < iVar1; i = i + 1) {\n      TransformLine(sp,i);\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is ClrUpdate"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wattr_on(a1,z,(void *)0x0);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is wattron"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](SCREEN *sp,int code)\n\n{\n  return true;\n}\n\n",
        "output": "The predicted function name is no_mouse_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int line,anon_subr_int_WINDOW_ptr_int *init)\n\n{\n  int code;\n  \n  code = -1;\n  if ((sp != (SCREEN *)0x0) && (sp->_prescreen != false)) {\n    if (line == 0) {\n      code = 0;\n    }\n    else {\n      if (_nc_prescreen.rsp == (ripoff_t *)0x0) {\n        _nc_prescreen.rsp = _nc_prescreen.rippedoff;\n      }\n      if (_nc_prescreen.rsp < &_nc_prescreen.rsp) {\n        (_nc_prescreen.rsp)->line = line;\n        (_nc_prescreen.rsp)->hook = (anon_subr_int_WINDOW_ptr_int_for_hook *)init;\n        _nc_prescreen.rsp = _nc_prescreen.rsp + 1;\n        code = 0;\n      }\n    }\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is _nc_ripoffline_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *a,char *b)\n\n{\n  int iVar1;\n  \n  iVar1 = strncmp(a,b,2);\n  return (int)(iVar1 == 0);\n}\n\n",
        "output": "The predicted function name is compare_tcap_names"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  int res;\n  \n  res = -1;\n  if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n    if ((cur_term->type).Strings[0x2d] == (char *)0x0) {\n      if ((cur_term->type).Strings[1] != (char *)0x0) {\n        res = _nc_putp_flush_sp(sp,\"bell\",(cur_term->type).Strings[1]);\n      }\n    }\n    else {\n      res = _nc_putp_flush_sp(sp,\"flash_screen\",(cur_term->type).Strings[0x2d]);\n    }\n  }\n  return res;\n}\n\n",
        "output": "The predicted function name is flash_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](WINDOW *z)\n\n{\n  _Bool _Var1;\n  \n  if ((z == (WINDOW *)0x0) || (z->_clear == false)) {\n    _Var1 = false;\n  }\n  else {\n    _Var1 = true;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is is_cleared"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  if ((sp != (SCREEN *)0x0) && (sp->_slk != (_SLK *)0x0)) {\n    if (sp->_slk->ent != (slk_ent *)0x0) {\n      free(sp->_slk->ent);\n    }\n    free(sp->_slk);\n    sp->_slk = (_SLK *)0x0;\n  }\n  return -1;\n}\n\n",
        "output": "The predicted function name is slk_failed"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](WINDOW *cmp)\n\n{\n  ldat *plVar1;\n  WINDOW *cmp_00;\n  int row;\n  _win_list *wp;\n  ldat *pline;\n  WINDOW *tst;\n  \n  plVar1 = cmp->_line;\n  for (wp = _nc_globals._nc_windowlist; wp != (_win_list *)0x0; wp = wp->next) {\n    cmp_00 = &wp->win;\n    if (cmp == (wp->win)._parent) {\n      if ((int)cmp->_maxy < (wp->win)._pary) {\n        (wp->win)._pary = (int)cmp->_maxy;\n      }\n      if ((int)cmp->_maxx < (wp->win)._parx) {\n        (wp->win)._parx = (int)cmp->_maxx;\n      }\n      if ((int)cmp->_maxy < (int)(wp->win)._maxy + (wp->win)._pary) {\n        (wp->win)._maxy = cmp->_maxy - (short)(wp->win)._pary;\n      }\n      if ((int)cmp->_maxx < (int)(wp->win)._maxx + (wp->win)._parx) {\n        (wp->win)._maxx = cmp->_maxx - (short)(wp->win)._parx;\n      }\n      if ((wp->win)._maxy < cmp_00->_cury) {\n        cmp_00->_cury = (wp->win)._maxy;\n      }\n      if ((wp->win)._maxx < (wp->win)._curx) {\n        (wp->win)._curx = (wp->win)._maxx;\n      }\n      if ((wp->win)._maxy < (wp->win)._regtop) {\n        (wp->win)._regtop = (wp->win)._maxy;\n      }\n      if ((wp->win)._maxy < (wp->win)._regbottom) {\n        (wp->win)._regbottom = (wp->win)._maxy;\n      }\n      for (row = 0; row <= (wp->win)._maxy; row = row + 1) {\n        (wp->win)._line[row].text = plVar1[row + (wp->win)._pary].text + (wp->win)._parx;\n      }\n      repair_subwindows(cmp_00);\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is repair_subwindows"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp,int n,int top,int bot)\n\n{\n  ulong *puVar1;\n  size_t __n;\n  ulong uVar2;\n  int i;\n  size_t size;\n  \n  if (sp->oldhash != (ulong *)0x0) {\n    __n = (long)(((bot - top) + 1) - ((n >> 0x1f ^ n) - (n >> 0x1f))) << 3;\n    if (n < 1) {\n      memmove(sp->oldhash + ((long)top - (long)n),sp->oldhash + top,__n);\n      for (i = top; i < top - n; i = i + 1) {\n        puVar1 = sp->oldhash;\n        uVar2 = hash(sp,sp->_curscr->_line[i].text);\n        puVar1[i] = uVar2;\n      }\n    }\n    else {\n      memmove(sp->oldhash + top,sp->oldhash + (long)n + (long)top,__n);\n      for (i = bot; bot - n < i; i = i + -1) {\n        puVar1 = sp->oldhash;\n        uVar2 = hash(sp,sp->_curscr->_line[i].text);\n        puVar1[i] = uVar2;\n      }\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_scroll_oldhash_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](WINDOW *z)\n\n{\n  _Bool _Var1;\n  \n  if ((z == (WINDOW *)0x0) || (z->_idcok == false)) {\n    _Var1 = false;\n  }\n  else {\n    _Var1 = true;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is is_idcok"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int a1,attr_t a2,short a3,void *z)\n\n{\n  int iVar1;\n  \n  iVar1 = wchgat(stdscr,a1,a2,a3,z);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is chgat"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *pad,chtype ch)\n\n{\n  int iVar1;\n  \n  if (pad == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else if ((pad->_flags & 0x10U) == 0) {\n    iVar1 = wechochar(pad,ch);\n  }\n  else {\n    waddch(pad,ch);\n    prefresh(pad,(int)(pad->_pad)._pad_y,(int)(pad->_pad)._pad_x,(int)(pad->_pad)._pad_top,\n             (int)(pad->_pad)._pad_left,(int)(pad->_pad)._pad_bottom,(int)(pad->_pad)._pad_right);\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is pechochar"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *a,char *b)\n\n{\n  int iVar1;\n  \n  iVar1 = strcmp(a,b);\n  return (int)(iVar1 == 0);\n}\n\n",
        "output": "The predicted function name is compare_info_names"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](SCREEN *sp,MEVENT *eventp,uint intro)\n\n{\n  _Bool _Var1;\n  _Bool result;\n  int button;\n  int b;\n  int wheel;\n  \n  eventp->bstate = 0;\n  if (intro < 0x60) {\n    button = intro & 3;\n  }\n  else if (intro < 0xa0) {\n    button = intro - 0x5c;\n  }\n  else {\n    button = intro - 0x98;\n  }\n  if (button < 6) {\n    _Var1 = handle_wheel(sp,eventp,intro,(uint)((intro & 0x60) == 0x60));\n    if (_Var1 != true) {\n      if ((sp->_mouse_bstate & 0x210842) == 0) {\n        eventp->bstate = 0x10000000;\n      }\n      else {\n        eventp->bstate = 0x108421;\n        for (b = 1; b < 6; b = b + 1) {\n          if ((2 << (((char)b + -1) * '\\x05' & 0x1fU) & sp->_mouse_bstate) == 0) {\n            eventp->bstate = eventp->bstate & ~(1 << (((char)b + -1) * '\\x05' & 0x1fU));\n          }\n        }\n        sp->_mouse_bstate = 0;\n      }\n    }\n  }\n  else {\n    eventp->bstate = 0x10000000;\n  }\n  if ((intro & 4) != 0) {\n    eventp->bstate = eventp->bstate | 0x4000000;\n  }\n  if ((intro & 8) != 0) {\n    eventp->bstate = eventp->bstate | 0x8000000;\n  }\n  if ((intro & 0x10) != 0) {\n    eventp->bstate = eventp->bstate | 0x2000000;\n  }\n  return ((long)(ulong)eventp->bstate >> 0x1c & 1U) != 0;\n}\n\n",
        "output": "The predicted function name is decode_X10_bstate"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,_Bool flag)\n\n{\n  int iVar1;\n  \n  iVar1 = intrflush_sp(SP,win,flag);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is intrflush"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int vis)\n\n{\n  int iVar1;\n  \n  iVar1 = curs_set_sp(SP,vis);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is curs_set"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nTERMINAL_conflict * [MASK](SCREEN *sp,TERMINAL_conflict *termp)\n\n{\n  term_conflict *ptVar1;\n  int iVar2;\n  TERMINAL_conflict *oldterm;\n  \n  ptVar1 = cur_term;\n  if (sp != (SCREEN *)0x0) {\n    sp->_term = termp;\n  }\n  cur_term = termp;\n  if (termp != (TERMINAL_conflict *)0x0) {\n    iVar2 = _nc_ospeed(termp->_baudrate);\n    ospeed = (short)iVar2;\n    if ((termp->type).Strings != (char **)0x0) {\n      if (((termp->type).Strings[0x68] == (char *)0xffffffffffffffff) ||\n         ((termp->type).Strings[0x68] == (char *)0x0)) {\n        PC = '\\0';\n      }\n      else {\n        PC = *(termp->type).Strings[0x68];\n      }\n    }\n    if ((termp->type).term_names != (char *)0x0) {\n      strncpy(ttytype,(termp->type).term_names,0xff);\n      ttytype[255] = 0;\n    }\n  }\n  return ptVar1;\n}\n\n",
        "output": "The predicted function name is set_curterm_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp,int i)\n\n{\n  ulong *puVar1;\n  ulong uVar2;\n  \n  if (sp->oldhash != (ulong *)0x0) {\n    puVar1 = sp->oldhash;\n    uVar2 = hash(sp,sp->_curscr->_line[i].text);\n    puVar1[i] = uVar2;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_make_oldhash_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,int y,int x)\n\n{\n  int iVar1;\n  \n  if ((((win == (WINDOW *)0x0) || (x < 0)) || (win->_maxx < x)) || ((y < 0 || (win->_maxy < y)))) {\n    iVar1 = -1;\n  }\n  else {\n    win->_curx = (short)x;\n    win->_cury = (short)y;\n    win->_flags = win->_flags & 0xffbf;\n    win->_flags = win->_flags | 0x20;\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is wmove"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = echo_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is echo"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,int a2,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wtouchln(a1,a2,z,1);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is touchline"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *path)\n\n{\n  uint uVar1;\n  \n  uVar1 = _nc_pathlast(path);\n  return path + uVar1;\n}\n\n",
        "output": "The predicted function name is _nc_basename"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nHashData * [MASK](void)\n\n{\n  return hash_data;\n}\n\n",
        "output": "The predicted function name is _nc_get_hash_user"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp,int fg,NCURSES_OUTC_sp *outc)\n\n{\n  uint uVar1;\n  char *pcVar2;\n  \n  if ((cur_term->type).Strings[0x167] == (char *)0x0) {\n    uVar1 = toggled_colors(fg);\n    pcVar2 = _nc_tiparm(1,(cur_term->type).Strings[0x12e],(ulong)uVar1);\n    tputs_sp(sp,pcVar2,1,outc);\n  }\n  else {\n    pcVar2 = _nc_tiparm(1,(cur_term->type).Strings[0x167],(ulong)(uint)fg);\n    tputs_sp(sp,pcVar2,1,outc);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is set_foreground_color"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nWINDOW * [MASK](SCREEN *sp,int num_lines,int num_columns,int begy,int begx)\n\n{\n  ldat *plVar1;\n  WINDOW *win_00;\n  chtype *pcVar2;\n  uint local_48;\n  int local_44;\n  int i;\n  chtype *ptr;\n  WINDOW *win;\n  \n  if ((((begy < 0) || (begx < 0)) || (num_lines < 0)) ||\n     ((num_columns < 0 || (sp == (SCREEN *)0x0)))) {\n    win_00 = (WINDOW *)0x0;\n  }\n  else {\n    local_44 = num_lines;\n    if (num_lines == 0) {\n      local_44 = sp->_lines_avail - begy;\n    }\n    local_48 = num_columns;\n    if (num_columns == 0) {\n      local_48 = sp->_columns - begx;\n    }\n    win_00 = _nc_makenew_sp(sp,local_44,local_48,begy,begx,0);\n    if (win_00 == (WINDOW *)0x0) {\n      win_00 = (WINDOW *)0x0;\n    }\n    else {\n      for (i = 0; i < local_44; i = i + 1) {\n        plVar1 = win_00->_line;\n        pcVar2 = (chtype *)calloc((ulong)local_48,4);\n        plVar1[i].text = pcVar2;\n        if (win_00->_line[i].text == (chtype *)0x0) {\n          _nc_freewin(win_00);\n          return (WINDOW *)0x0;\n        }\n        for (ptr = win_00->_line[i].text; ptr < win_00->_line[i].text + (int)local_48; ptr = ptr + 1\n            ) {\n          *ptr = 0x20;\n        }\n      }\n    }\n  }\n  return win_00;\n}\n\n",
        "output": "The predicted function name is newwin_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nSCREEN * [MASK](SCREEN *sp,char *name,FILE *ofp,FILE *ifp)\n\n{\n  SCREEN *pSVar1;\n  _Bool _Var2;\n  int iVar3;\n  long in_FS_OFFSET;\n  SCREEN *local_70;\n  int errret;\n  int slk_format;\n  int filter_mode;\n  int cols;\n  int value;\n  SCREEN *result;\n  FILE *_ofp;\n  FILE *_ifp;\n  TERMINAL_conflict *new_term;\n  SCREEN *current;\n  TERMINAL_conflict *its_term;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  result = (SCREEN *)0x0;\n  _ofp = (FILE *)stdout;\n  if (ofp != (FILE *)0x0) {\n    _ofp = ofp;\n  }\n  _ifp = stdin;\n  if (ifp != (FILE *)0x0) {\n    _ifp = ifp;\n  }\n  new_term = (TERMINAL_conflict *)0x0;\n  local_70 = sp;\n  if (sp != (SCREEN *)0x0) {\n    current = SP;\n    if (SP == (SCREEN *)0x0) {\n      its_term = (TERMINAL_conflict *)0x0;\n    }\n    else {\n      its_term = SP->_term;\n    }\n    iVar3 = fileno((FILE *)_ofp);\n    iVar3 = _nc_setupterm(name,iVar3,&errret,0);\n    sp = result;\n    if (iVar3 != -1) {\n      SP = (SCREEN *)0x0;\n      slk_format = local_70->slk_format;\n      filter_mode = (int)local_70->_filtered;\n      iVar3 = _nc_setupscreen_sp(&local_70,LINES,COLS,_ofp,filter_mode,slk_format);\n      if (iVar3 == -1) {\n        SP = current;\n        result = (SCREEN *)0x0;\n        sp = result;\n      }\n      else {\n        cols = COLS;\n        if (current != (SCREEN *)0x0) {\n          current->_term = its_term;\n        }\n        new_term = local_70->_term;\n        value = _nc_getenv_num(\"ESCDELAY\");\n        if (-1 < value) {\n          set_escdelay_sp(local_70,value);\n        }\n        if (((slk_format != 0) && (0 < (cur_term->type).Numbers[8])) && (slk_format < 3)) {\n          _nc_slk_initialize(local_70->_stdscr,cols);\n        }\n        pSVar1 = local_70;\n        iVar3 = fileno((FILE *)_ifp);\n        pSVar1->_ifd = iVar3;\n        iVar3 = fileno((FILE *)_ifp);\n        typeahead_sp(local_70,iVar3);\n        if ((((new_term->Ottyb).c_cflag & 0x30) == 0x30) &&\n           (((new_term->Ottyb).c_iflag & 0x20) == 0)) {\n          iVar3 = 1;\n        }\n        else {\n          iVar3 = 0;\n        }\n        local_70->_use_meta = iVar3;\n        local_70->_endwin = 0;\n        if ((((cur_term->type).Strings[0x81] == (char *)0x0) ||\n            ((cur_term->type).Strings[0x82] == (char *)0x0)) &&\n           ((((cur_term->type).Strings[0x71] == (char *)0x0 &&\n             (((cur_term->type).Strings[0x6e] == (char *)0x0 &&\n              ((cur_term->type).Strings[0x35] == (char *)0x0)))) ||\n            (((cur_term->type).Strings[0x6d] == (char *)0x0 &&\n             (((cur_term->type).Strings[0x6a] == (char *)0x0 &&\n              ((cur_term->type).Strings[0x16] == (char *)0x0)))))))) {\n          iVar3 = 0;\n        }\n        else {\n          iVar3 = 1;\n        }\n        local_70->_scrolling = iVar3;\n        baudrate_sp(local_70);\n        local_70->_keytry = (TRIES *)0x0;\n        if (((cur_term->type).Strings[0x2b] == (char *)0x0) ||\n           (((cur_term->type).Strings[0x27] != (char *)0x0 &&\n            (iVar3 = strcmp((cur_term->type).Strings[0x2b],(cur_term->type).Strings[0x27]),\n            iVar3 == 0)))) {\n          _Var2 = false;\n        }\n        else {\n          _Var2 = true;\n        }\n        local_70->_use_rmso = _Var2;\n        if (((cur_term->type).Strings[0x2c] == (char *)0x0) ||\n           (((cur_term->type).Strings[0x27] != (char *)0x0 &&\n            (iVar3 = strcmp((cur_term->type).Strings[0x2c],(cur_term->type).Strings[0x27]),\n            iVar3 == 0)))) {\n          _Var2 = false;\n        }\n        else {\n          _Var2 = true;\n        }\n        local_70->_use_rmul = _Var2;\n        if (((cur_term->type).Strings[0x141] == (char *)0x0) ||\n           (((cur_term->type).Strings[0x27] != (char *)0x0 &&\n            (iVar3 = strcmp((cur_term->type).Strings[0x141],(cur_term->type).Strings[0x27]),\n            iVar3 == 0)))) {\n          _Var2 = false;\n        }\n        else {\n          _Var2 = true;\n        }\n        local_70->_use_ritm = _Var2;\n        _nc_mvcur_init();\n        _nc_screen_init();\n        _nc_initscr(local_70);\n        _nc_signal_handler(1);\n        result = local_70;\n        sp = local_70;\n      }\n    }\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return sp;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is newterm_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](int value)\n\n{\n  _Bool _Var1;\n  short test;\n  \n  if ((value == (short)value) && (0 < value)) {\n    _Var1 = true;\n  }\n  else {\n    _Var1 = false;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is dimension_limit"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int code)\n\n{\n                    /* WARNING: Subroutine does not return */\n  exit(code);\n}\n\n",
        "output": "The predicted function name is exit_terminfo"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](SCREEN *sp)\n\n{\n  _Bool _Var1;\n  \n  if ((sp == (SCREEN *)0x0) || (sp->_mouse_type == M_NONE)) {\n    _Var1 = false;\n  }\n  else {\n    _Var1 = true;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is _nc_has_mouse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wattr_off(stdscr,z,(void *)0x0);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is attroff"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,short color,short r,short g,short b)\n\n{\n  int iVar1;\n  \n  iVar1 = _nc_init_color(sp,(int)color,(int)r,(int)g,(int)b);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is init_color_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  _nc_mvcur_wrap_sp(SP);\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_mvcur_wrap"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](SCREEN *sp,SGR_DATA *result)\n\n{\n  bool bVar1;\n  _Bool _Var2;\n  uint uVar3;\n  ssize_t sVar4;\n  long in_FS_OFFSET;\n  int grabbed;\n  int now;\n  int marker;\n  int ch;\n  int res;\n  char kbuf [80];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  grabbed = 0;\n  now = -1;\n  bVar1 = true;\n  memset(result,0,0x30);\n  do {\n    sVar4 = read(sp->_ifd,kbuf + grabbed,1);\n    if ((int)sVar4 == -1) break;\n    if (0x4f < grabbed + 3) {\n      result->nerror = result->nerror + 1;\n      break;\n    }\n    uVar3 = (uint)(byte)kbuf[grabbed];\n    kbuf[grabbed + 1] = '\\0';\n    if (uVar3 < 0x30) {\nLAB_0000fdf6:\n      if ((0x1f < uVar3) && (uVar3 < 0x7f)) {\n        if ((uVar3 < 0x40) || (0x7e < uVar3)) {\n          result->nerror = result->nerror + 1;\n        }\n        else {\n          if (bVar1) {\n            result->nparam = result->nparam + 1;\n          }\n          result->final = uVar3;\n        }\n        goto LAB_0000fe67;\n      }\n      result->nerror = result->nerror + 1;\n    }\n    else {\n      if (uVar3 < 0x3a) {\n        if (bVar1) {\n          result->nparam = now + 2;\n          now = now + 1;\n        }\n        bVar1 = false;\n        result->params[now] = result->params[now] * 10 + (uVar3 - 0x30);\n      }\n      else {\n        if (uVar3 != 0x3b) goto LAB_0000fdf6;\n        if (bVar1) {\n          result->nparam = now + 2;\n          now = now + 1;\n        }\n        bVar1 = true;\n      }\nLAB_0000fe67:\n      grabbed = grabbed + 1;\n    }\n  } while ((uVar3 < 0x40) || (0x7e < uVar3));\n  kbuf[grabbed + 1] = '\\0';\n  if ((grabbed + 1 < 1) || (result->nerror != 0)) {\n    _Var2 = false;\n  }\n  else {\n    _Var2 = true;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return _Var2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is read_SGR"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int c,_Bool flag)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  int count;\n  int code;\n  uint ch;\n  char *s;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  code = -1;\n  if (((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) && (-1 < c)) {\n    count = 0;\n    ch = c;\n    if (flag == false) {\n      do {\n        while( true ) {\n          s = _nc_expand_try(sp->_keytry,ch,&count,0);\n          if (s == (char *)0x0) goto LAB_0002b104;\n          iVar1 = _nc_remove_key(&sp->_keytry,ch);\n          if (iVar1 != 0) break;\n          free(s);\n        }\n        code = _nc_add_to_try(&sp->_key_ok,s,ch);\n        free(s);\n        count = 0;\n      } while (code == 0);\n    }\n    else {\n      do {\n        while( true ) {\n          s = _nc_expand_try(sp->_key_ok,ch,&count,0);\n          if (s == (char *)0x0) goto LAB_0002b104;\n          iVar1 = _nc_remove_key(&sp->_key_ok,ch);\n          if (iVar1 != 0) break;\n          free(s);\n        }\n        code = _nc_add_to_try(&sp->_keytry,s,ch);\n        free(s);\n        count = 0;\n      } while (code == 0);\n    }\n  }\nLAB_0002b104:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return code;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is keyok_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int n,int top,int bot,int maxy)\n\n{\n  int iVar1;\n  \n  iVar1 = _nc_scrolln_sp(SP,n,top,bot,maxy);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is _nc_scrolln"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int keycode,TRIES *tp)\n\n{\n  int iVar1;\n  \n  if (tp == (TRIES *)0x0) {\n    iVar1 = 0;\n  }\n  else if (keycode == (uint)tp->value) {\n    iVar1 = 1;\n  }\n  else {\n    iVar1 = has_key_internal(keycode,tp->child);\n    if ((iVar1 == 0) && (iVar1 = has_key_internal(keycode,tp->sibling), iVar1 == 0)) {\n      return 0;\n    }\n    iVar1 = 1;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is has_key_internal"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,termios *buf)\n\n{\n  int iVar1;\n  term_conflict *ptVar2;\n  int *piVar3;\n  int result;\n  TERMINAL_conflict *termp;\n  \n  ptVar2 = cur_term;\n  if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n    ptVar2 = sp->_term;\n  }\n  result = 0;\n  if ((buf == (termios *)0x0) || (ptVar2 == (term_conflict *)0x0)) {\n    result = -1;\n  }\n  else {\n    do {\n      iVar1 = tcgetattr((int)ptVar2->Filedes,(termios *)buf);\n      if (iVar1 == 0) goto LAB_000285b6;\n      piVar3 = __errno_location();\n    } while (*piVar3 == 4);\n    result = -1;\n  }\nLAB_000285b6:\n  if ((result == -1) && (buf != (termios *)0x0)) {\n    memset(buf,0,0x3c);\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is _nc_get_tty_mode_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchtype [MASK](SCREEN *sp)\n\n{\n  chtype attrs;\n  \n  attrs = 0;\n  if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n    if ((cur_term->type).Strings[0x19] != (char *)0x0) {\n      attrs = 0x400000;\n    }\n    if ((cur_term->type).Strings[0x1a] != (char *)0x0) {\n      attrs = attrs | 0x80000;\n    }\n    if ((cur_term->type).Strings[0x1b] != (char *)0x0) {\n      attrs = attrs | 0x200000;\n    }\n    if ((cur_term->type).Strings[0x1e] != (char *)0x0) {\n      attrs = attrs | 0x100000;\n    }\n    if ((cur_term->type).Strings[0x22] != (char *)0x0) {\n      attrs = attrs | 0x40000;\n    }\n    if ((cur_term->type).Strings[0x23] != (char *)0x0) {\n      attrs = attrs | 0x10000;\n    }\n    if ((cur_term->type).Strings[0x21] != (char *)0x0) {\n      attrs = attrs | 0x1000000;\n    }\n    if ((cur_term->type).Strings[0x20] != (char *)0x0) {\n      attrs = attrs | 0x800000;\n    }\n    if ((cur_term->type).Strings[0x24] != (char *)0x0) {\n      attrs = attrs | 0x20000;\n    }\n    if (sp->_coloron != 0) {\n      attrs = attrs | 0xff00;\n    }\n    if ((cur_term->type).Strings[0x137] != (char *)0x0) {\n      attrs = attrs | 0x80000000;\n    }\n  }\n  return attrs;\n}\n\n",
        "output": "The predicted function name is termattrs_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](WINDOW *z)\n\n{\n  _Bool _Var1;\n  \n  if ((z == (WINDOW *)0x0) || (z->_idlok == false)) {\n    _Var1 = false;\n  }\n  else {\n    _Var1 = true;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is is_idlok"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](SCREEN *sp)\n\n{\n  bool bVar1;\n  _Bool code;\n  \n  code = false;\n  if (sp == (SCREEN *)0x0) {\n    bVar1 = cur_term != (term_conflict *)0x0;\n  }\n  else if (sp->_term == (TERMINAL_conflict *)0x0) {\n    bVar1 = cur_term != (term_conflict *)0x0;\n  }\n  else {\n    bVar1 = sp->_term != (TERMINAL_conflict *)0x0;\n  }\n  if (bVar1) {\n    if (((((cur_term->type).Strings[0x34] == (char *)0x0) &&\n         ((cur_term->type).Strings[0x6c] == (char *)0x0)) &&\n        (((cur_term->type).Strings[0x1f] == (char *)0x0 ||\n         ((cur_term->type).Strings[0x2a] == (char *)0x0)))) ||\n       (((cur_term->type).Strings[0x15] == (char *)0x0 &&\n        ((cur_term->type).Strings[0x69] == (char *)0x0)))) {\n      code = false;\n    }\n    else {\n      code = true;\n    }\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is has_ic_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](string_desc *dst,char *src)\n\n{\n  size_t sVar1;\n  size_t len;\n  \n  if (((src != (char *)0x0) && (src != (char *)0xffffffffffffffff)) &&\n     (sVar1 = strlen(src), sVar1 < dst->s_size)) {\n    if (dst->s_head != (char *)0x0) {\n      strcpy(dst->s_head,src);\n      dst->s_tail = dst->s_head + sVar1;\n    }\n    dst->s_size = dst->s_init - sVar1;\n    return true;\n  }\n  return false;\n}\n\n",
        "output": "The predicted function name is _nc_safe_strcpy"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nalias * [MASK](_Bool termcap)\n\n{\n  alias *paVar1;\n  \n  if (termcap == false) {\n    paVar1 = _nc_build_alias(&_nc_infoalias_table,infoalias_data,\"font0\",6);\n  }\n  else {\n    paVar1 = _nc_build_alias(&_nc_capalias_table,capalias_data,\"sb\",0x2c);\n  }\n  return paVar1;\n}\n\n",
        "output": "The predicted function name is _nc_get_alias_table"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](SCREEN *sp)\n\n{\n  _Bool _Var1;\n  \n  _Var1 = _nc_has_mouse(sp);\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is has_mouse_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *tn,TERMTYPE *tp)\n\n{\n  long lVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  uint n;\n  int status;\n  char filename [4096];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar2 = _nc_read_entry(tn,filename,tp);\n  if (iVar2 == 1) {\n    for (n = 0; n < tp->num_Booleans; n = n + 1) {\n      if (1 < (byte)tp->Booleans[n]) {\n        tp->Booleans[n] = '\\0';\n      }\n    }\n    for (n = 0; n < tp->num_Strings; n = n + 1) {\n      if (tp->Strings[n] == (char *)0xffffffffffffffff) {\n        tp->Strings[n] = (char *)0x0;\n      }\n    }\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar2;\n}\n\n",
        "output": "The predicted function name is _nc_setup_tinfo"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](short pair,short *f,short *b)\n\n{\n  int iVar1;\n  \n  iVar1 = pair_content_sp(SP,pair,f,b);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is pair_content"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](SCREEN *sp,int ToLines,int ToCols)\n\n{\n  _Bool _Var1;\n  \n  if (((ToLines < 1) || (ToCols < 1)) || ((ToLines == sp->_lines && (ToCols == sp->_columns)))) {\n    _Var1 = false;\n  }\n  else {\n    _Var1 = true;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is is_term_resized_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,int ToLines,int ToCols,int stolen)\n\n{\n  int iVar1;\n  SCREEN *pSVar2;\n  ripoff_t *prVar3;\n  int myLines;\n  int myCols;\n  int bottom;\n  int result;\n  ripoff_t *rop;\n  \n  pSVar2 = _nc_screen_of(win);\n  iVar1 = current_lines + pSVar2->_topstolen;\n  myLines = win->_maxy + 1;\n  myCols = win->_maxx + 1;\n  prVar3 = ripped_window(win);\n  if ((prVar3 == (ripoff_t *)0x0) || (-1 < prVar3->line)) {\n    if ((int)win->_begy < iVar1 - stolen) {\n      if ((myLines == current_lines - stolen) && (ToLines != current_lines)) {\n        myLines = ToLines - stolen;\n      }\n      else if ((myLines == current_lines) && (ToLines != current_lines)) {\n        myLines = ToLines;\n      }\n    }\n    else {\n      win->_begy = ((short)ToLines - (short)current_lines) + win->_begy;\n    }\n  }\n  else {\n    iVar1 = ripped_bottom(win);\n    win->_begy = ((short)ToLines - (short)iVar1) - win->_yoffset;\n    if (prVar3->hook == _nc_slk_initialize) {\n      pSVar2 = _nc_screen_of(win);\n      _nc_format_slks(pSVar2,ToCols);\n    }\n  }\n  if (ToLines < myLines) {\n    myLines = ToLines;\n  }\n  if (ToCols < myCols) {\n    myCols = ToCols;\n  }\n  if ((myCols == current_cols) && (ToCols != current_cols)) {\n    myCols = ToCols;\n  }\n  iVar1 = wresize(win,myLines,myCols);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is adjust_window"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp,int pair)\n\n{\n  bool bVar1;\n  ldat *plVar2;\n  short sVar3;\n  _Bool changed;\n  int y;\n  int x;\n  ldat *ptr;\n  \n  if (sp->_curscr->_clear == false) {\n    for (y = 0; y <= sp->_curscr->_maxy; y = y + 1) {\n      plVar2 = sp->_curscr->_line + y;\n      bVar1 = false;\n      for (x = 0; x <= sp->_curscr->_maxx; x = x + 1) {\n        if (pair == (plVar2->text[x] >> 8 & 0xff)) {\n          plVar2->text[x] = 0;\n          sVar3 = (short)x;\n          if (plVar2->firstchar == -1) {\n            plVar2->lastchar = sVar3;\n            plVar2->firstchar = plVar2->lastchar;\n          }\n          else if (x < plVar2->firstchar) {\n            plVar2->firstchar = sVar3;\n          }\n          else if (plVar2->lastchar < x) {\n            plVar2->lastchar = sVar3;\n          }\n          bVar1 = true;\n        }\n      }\n      if (bVar1) {\n        _nc_make_oldhash_sp(sp,y);\n      }\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_change_pair"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int n,int top,int bot,int miny,int maxy,chtype blank)\n\n{\n  int3 iVar1;\n  char *pcVar2;\n  int i;\n  int j;\n  \n  iVar1 = (int3)(blank >> 8);\n  if ((((n == 1) && ((cur_term->type).Strings[0x82] != (char *)0x0)) && (top == miny)) &&\n     (bot == maxy)) {\n    GoTo(sp,top,0);\n    if ((int3)(*sp->_current_attr >> 8) != iVar1) {\n      vidputs_sp(sp,blank & 0xffffff00,_nc_outch_sp);\n    }\n    _nc_putp_sp(sp,\"scroll_reverse\",(cur_term->type).Strings[0x82]);\n  }\n  else if (((n == 1) && ((cur_term->type).Strings[0x35] != (char *)0x0)) && (bot == maxy)) {\n    GoTo(sp,top,0);\n    if ((int3)(*sp->_current_attr >> 8) != iVar1) {\n      vidputs_sp(sp,blank & 0xffffff00,_nc_outch_sp);\n    }\n    _nc_putp_sp(sp,\"insert_line\",(cur_term->type).Strings[0x35]);\n  }\n  else if ((((cur_term->type).Strings[0x71] == (char *)0x0) || (top != miny)) || (bot != maxy)) {\n    if (((cur_term->type).Strings[0x6e] == (char *)0x0) || (bot != maxy)) {\n      if (((cur_term->type).Strings[0x82] == (char *)0x0) || ((top != miny || (bot != maxy)))) {\n        if (((cur_term->type).Strings[0x35] == (char *)0x0) || (bot != maxy)) {\n          return -1;\n        }\n        GoTo(sp,top,0);\n        if ((int3)(*sp->_current_attr >> 8) != iVar1) {\n          vidputs_sp(sp,blank & 0xffffff00,_nc_outch_sp);\n        }\n        for (i = 0; i < n; i = i + 1) {\n          _nc_putp_sp(sp,\"insert_line\",(cur_term->type).Strings[0x35]);\n        }\n      }\n      else {\n        GoTo(sp,top,0);\n        if ((int3)(*sp->_current_attr >> 8) != iVar1) {\n          vidputs_sp(sp,blank & 0xffffff00,_nc_outch_sp);\n        }\n        for (i = 0; i < n; i = i + 1) {\n          _nc_putp_sp(sp,\"scroll_reverse\",(cur_term->type).Strings[0x82]);\n        }\n      }\n    }\n    else {\n      GoTo(sp,top,0);\n      if ((int3)(*sp->_current_attr >> 8) != iVar1) {\n        vidputs_sp(sp,blank & 0xffffff00,_nc_outch_sp);\n      }\n      pcVar2 = _nc_tiparm(1,(cur_term->type).Strings[0x6e],(ulong)(uint)n);\n      tputs_sp(sp,pcVar2,n,_nc_outch_sp);\n    }\n  }\n  else {\n    GoTo(sp,top,0);\n    if ((int3)(*sp->_current_attr >> 8) != iVar1) {\n      vidputs_sp(sp,blank & 0xffffff00,_nc_outch_sp);\n    }\n    pcVar2 = _nc_tiparm(1,(cur_term->type).Strings[0x71],(ulong)(uint)n);\n    tputs_sp(sp,pcVar2,n,_nc_outch_sp);\n  }\n  if (((sp->_coloron != 0) && (sp->_default_color != true)) &&\n     ((cur_term->type).Booleans[0x1c] == '\\0')) {\n    for (i = 0; i < n; i = i + 1) {\n      GoTo(sp,top + i,0);\n      for (j = 0; j < sp->_columns; j = j + 1) {\n        PutChar(sp,blank);\n      }\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is scroll_csr_backward"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  int res;\n  \n  res = -1;\n  if (cur_term == (term_conflict *)0x0) {\n    res = -1;\n  }\n  else if ((cur_term->type).Strings[1] == (char *)0x0) {\n    if ((cur_term->type).Strings[0x2d] != (char *)0x0) {\n      res = _nc_putp_flush_sp(sp,\"flash_screen\",(cur_term->type).Strings[0x2d]);\n      _nc_flush();\n    }\n  }\n  else {\n    res = _nc_putp_flush_sp(sp,\"bell\",(cur_term->type).Strings[1]);\n  }\n  return res;\n}\n\n",
        "output": "The predicted function name is beep_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nuser_table_entry * [MASK](void)\n\n{\n  user_table_entry *puVar1;\n  \n  puVar1 = _nc_build_names(&_nc_user_table,user_names_data,\"CO\");\n  return puVar1;\n}\n\n",
        "output": "The predicted function name is _nc_get_userdefs_table"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](char *name,stat *sb)\n\n{\n  int iVar1;\n  _Bool result;\n  \n  iVar1 = strncmp(name,\"b64:\",4);\n  if ((iVar1 == 0) || (iVar1 = strncmp(name,\"hex:\",4), iVar1 == 0)) {\n    return true;\n  }\n  iVar1 = stat(name,(stat *)sb);\n  if (iVar1 != 0) {\n    return false;\n  }\n  if ((sb->st_mode & 0xf000) != 0x4000) {\n    if ((sb->st_mode & 0xf000) != 0x8000) {\n      return false;\n    }\n    if (sb->st_size == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n",
        "output": "The predicted function name is check_existence"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](TERMTYPE *to,char **ext_Names,int ext_Booleans,int ext_Numbers,int ext_Strings)\n\n{\n  ushort uVar1;\n  ushort uVar2;\n  _Bool _Var3;\n  uint length;\n  int iVar4;\n  int iVar5;\n  char *pcVar6;\n  short *psVar7;\n  char **ppcVar8;\n  int n;\n  int m;\n  int to_Booleans;\n  int to_Numbers;\n  int to_Strings;\n  int to1;\n  int to2;\n  int from;\n  int base;\n  \n  length = (uint)to->ext_Booleans;\n  uVar1 = to->ext_Numbers;\n  uVar2 = to->ext_Strings;\n  if (ext_Booleans != (uint)to->ext_Booleans) {\n    to->num_Booleans = to->num_Booleans + ((ushort)ext_Booleans - to->ext_Booleans);\n    pcVar6 = (char *)_nc_doalloc(to->Booleans,(ulong)to->num_Booleans);\n    to->Booleans = pcVar6;\n    if (to->Booleans == (char *)0x0) {\n                    /* WARNING: Subroutine does not return */\n      _nc_err_abort(\"Out of memory\");\n    }\n    n = to->ext_Booleans - 1;\n    iVar4 = (uint)to->num_Booleans - ext_Booleans;\n    for (m = ext_Booleans + -1; -1 < m; m = m + -1) {\n      _Var3 = find_name(to->ext_Names,0,length,ext_Names[m]);\n      if (_Var3 == false) {\n        to->Booleans[m + iVar4] = '\\0';\n      }\n      else {\n        to->Booleans[m + iVar4] = to->Booleans[n + iVar4];\n        n = n + -1;\n      }\n    }\n    to->ext_Booleans = (ushort)ext_Booleans;\n  }\n  if (ext_Numbers != (uint)to->ext_Numbers) {\n    to->num_Numbers = to->num_Numbers + ((ushort)ext_Numbers - to->ext_Numbers);\n    psVar7 = (short *)_nc_doalloc(to->Numbers,(ulong)to->num_Numbers * 2);\n    to->Numbers = psVar7;\n    if (to->Numbers == (short *)0x0) {\n                    /* WARNING: Subroutine does not return */\n      _nc_err_abort(\"Out of memory\");\n    }\n    n = to->ext_Numbers - 1;\n    iVar4 = (uint)to->num_Numbers - ext_Numbers;\n    for (m = ext_Numbers + -1; -1 < m; m = m + -1) {\n      _Var3 = find_name(to->ext_Names,length,length + uVar1,ext_Names[ext_Booleans + m]);\n      if (_Var3 == false) {\n        to->Numbers[m + iVar4] = -1;\n      }\n      else {\n        to->Numbers[m + iVar4] = to->Numbers[n + iVar4];\n        n = n + -1;\n      }\n    }\n    to->ext_Numbers = (ushort)ext_Numbers;\n  }\n  if (ext_Strings != (uint)to->ext_Strings) {\n    iVar4 = uVar1 + length;\n    to->num_Strings = to->num_Strings + ((ushort)ext_Strings - to->ext_Strings);\n    ppcVar8 = (char **)_nc_doalloc(to->Strings,(ulong)to->num_Strings * 8);\n    to->Strings = ppcVar8;\n    if (to->Strings == (char **)0x0) {\n                    /* WARNING: Subroutine does not return */\n      _nc_err_abort(\"Out of memory\");\n    }\n    n = to->ext_Strings - 1;\n    iVar5 = (uint)to->num_Strings - ext_Strings;\n    for (m = ext_Strings + -1; -1 < m; m = m + -1) {\n      _Var3 = find_name(to->ext_Names,iVar4,iVar4 + (uint)uVar2,\n                        ext_Names[ext_Numbers + ext_Booleans + m]);\n      if (_Var3 == false) {\n        to->Strings[m + iVar5] = (char *)0x0;\n      }\n      else {\n        to->Strings[m + iVar5] = to->Strings[n + iVar5];\n        n = n + -1;\n      }\n    }\n    to->ext_Strings = (ushort)ext_Strings;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is realign_data"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](SCREEN *sp)\n\n{\n  bool bVar1;\n  _Bool result;\n  \n  bVar1 = (cur_term->type).Strings[0x129] != (char *)0x0;\n  if (bVar1) {\n    _nc_putp_sp(sp,\"orig_pair\",(cur_term->type).Strings[0x129]);\n  }\n  return bVar1;\n}\n\n",
        "output": "The predicted function name is reset_color_pair"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,_Bool flag)\n\n{\n  SCREEN *sp_00;\n  int result;\n  SCREEN *sp;\n  \n  result = -1;\n  sp_00 = SP;\n  if (win != (WINDOW *)0x0) {\n    sp_00 = _nc_screen_of(win);\n  }\n  if (sp_00 != (SCREEN *)0x0) {\n    sp_00->_use_meta = (uint)flag;\n    if (flag == false) {\n      _nc_putp_sp(sp_00,\"meta_off\",(cur_term->type).Strings[0x65]);\n    }\n    else {\n      _nc_putp_sp(sp_00,\"meta_on\",(cur_term->type).Strings[0x66]);\n    }\n    result = 0;\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is meta"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](int expected,char *string,...)\n\n{\n  long lVar1;\n  char in_AL;\n  int iVar2;\n  TPARM_STATE *tps_00;\n  undefined8 in_RCX;\n  undefined8 in_RDX;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  char *result;\n  TPARM_STATE *tps;\n  va_list ap;\n  TPARM_DATA myData;\n  undefined local_b8 [16];\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if (cur_term == (term_conflict *)0x0) {\n    tps_00 = &_nc_prescreen.tparm_state;\n  }\n  else {\n    tps_00 = &cur_term->tparm_state;\n  }\n  result = (char *)0x0;\n  _nc_tparm_err = 0;\n  local_a8 = in_RDX;\n  local_a0 = in_RCX;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  iVar2 = tparm_setup(cur_term,string,&myData);\n  if (((iVar2 == 0) && (myData.num_actual <= expected)) && (myData.tparm_type == 0)) {\n    ap[0].gp_offset = 0x10;\n    ap[0].fp_offset = 0x30;\n    ap[0].overflow_arg_area = &stack0x00000008;\n    ap[0].reg_save_area = local_b8;\n    tparm_copy_valist(&myData,0,ap);\n    result = tparam_internal(tps_00,string,&myData);\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is _nc_tiparm"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,chtype ch)\n\n{\n  int iVar1;\n  int code;\n  chtype wch;\n  \n  code = -1;\n  if (win != (WINDOW *)0x0) {\n    iVar1 = waddch_nosync(win,ch);\n    if (iVar1 != -1) {\n      _nc_synchook(win);\n      code = 0;\n    }\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is waddch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int maxclick)\n\n{\n  int iVar1;\n  \n  iVar1 = mouseinterval_sp(SP,maxclick);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mouseinterval"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  termios *buf;\n  \n  buf = saved_tty(sp);\n  iVar1 = _nc_get_tty_mode_sp(sp,buf);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is savetty_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *name,int value)\n\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  char buffer [128];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((name != (char *)0x0) && (-1 < value)) {\n    sprintf(buffer,\"%d\",(ulong)(uint)value);\n    setenv(name,buffer,1);\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_setenv_num"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](WINDOW *win)\n\n{\n  WINDOW *wp;\n  \n  for (wp = win; (wp != (WINDOW *)0x0 && (wp->_parent != (WINDOW *)0x0)); wp = wp->_parent) {\n    wmove(wp->_parent,wp->_pary + (int)wp->_cury,wp->_parx + (int)wp->_curx);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is wcursyncup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int keycode)\n\n{\n  int iVar1;\n  \n  if (SP == (SCREEN *)0x0) {\n    iVar1 = 0;\n  }\n  else {\n    iVar1 = has_key_internal(keycode,sp->_keytry);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is has_key_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,WINDOW *win,chtype ch)\n\n{\n  short sVar1;\n  chtype *pcVar2;\n  uint ch_00;\n  chtype cVar3;\n  ushort **ppuVar4;\n  ldat *plVar5;\n  int code;\n  int count;\n  int ch8;\n  int tabsize;\n  chtype wch;\n  chtype *temp1;\n  chtype *temp2;\n  char *s;\n  ldat *line;\n  chtype *end;\n  \n  code = 0;\n  ch_00 = ch & 0xff;\n  if (ch == 9) {\n    count = TABSIZE - (int)win->_curx % TABSIZE;\n    while( true ) {\n      if (count < 1) {\n        return code;\n      }\n      code = _nc_insert_ch(sp,win,0x20);\n      if (code != 0) break;\n      count = count + -1;\n    }\n    return code;\n  }\n  if (ch < 10) {\n    if (ch == 8) {\nLAB_0000f06c:\n      _nc_waddch_nosync(win,ch);\n      return 0;\n    }\n  }\n  else if ((ch == 10) || (ch == 0xd)) goto LAB_0000f06c;\n  ppuVar4 = __ctype_b_loc();\n  if (((((*ppuVar4)[(int)ch_00] & 0x4000) == 0) && ((ch & 0x400000) == 0)) &&\n     ((sp == (SCREEN *)0x0 ||\n      ((sp->_legacy_coding == 0 || (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(int)ch_00] & 2) != 0))))\n     )) {\n    ppuVar4 = __ctype_b_loc();\n    if (((*ppuVar4)[(int)ch_00] & 2) != 0) {\n      s = unctrl_sp(sp,ch_00);\n      while ((*s != '\\0' &&\n             (code = _nc_insert_ch(sp,win,ch & 0xffffff00 | (uint)(byte)*s), code == 0))) {\n        s = s + 1;\n      }\n    }\n  }\n  else if (win->_curx <= win->_maxx) {\n    plVar5 = win->_line + win->_cury;\n    pcVar2 = plVar5->text;\n    sVar1 = win->_curx;\n    temp2 = plVar5->text + win->_maxx;\n    if ((plVar5->firstchar == -1) || (win->_curx < plVar5->firstchar)) {\n      plVar5->firstchar = win->_curx;\n    }\n    plVar5->lastchar = win->_maxx;\n    temp1 = temp2;\n    while (temp2 = temp2 + -1, pcVar2 + sVar1 < temp1) {\n      *temp1 = *temp2;\n      temp1 = temp1 + -1;\n    }\n    cVar3 = _nc_render(win,ch);\n    *temp1 = cVar3;\n    win->_curx = win->_curx + 1;\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is _nc_insert_ch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,char *fmt,...)\n\n{\n  long lVar1;\n  char in_AL;\n  int iVar2;\n  undefined8 in_RCX;\n  undefined8 in_RDX;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  int code;\n  va_list argp;\n  undefined local_b8 [16];\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  argp[0].gp_offset = 0x10;\n  argp[0].fp_offset = 0x30;\n  argp[0].overflow_arg_area = &stack0x00000008;\n  argp[0].reg_save_area = local_b8;\n  local_a8 = in_RDX;\n  local_a0 = in_RCX;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  iVar2 = vw_printw(win,fmt,argp);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar2;\n}\n\n",
        "output": "The predicted function name is wprintw"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = reset_prog_mode_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is reset_prog_mode"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  \n  if (sp == (SCREEN *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    sp->_nl = 1;\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is nl_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = flash_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is flash"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,char *str,int maxlen)\n\n{\n  char *last;\n  short sVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  char cVar6;\n  char cVar7;\n  _Bool _Var8;\n  int iVar9;\n  int x_00;\n  int iVar10;\n  chtype ch_00;\n  SCREEN *sp_00;\n  long in_FS_OFFSET;\n  bool bVar11;\n  char *local_98;\n  _Bool oldnl;\n  _Bool oldecho;\n  _Bool oldraw;\n  _Bool oldcbreak;\n  char erasec;\n  char killc;\n  int y;\n  int x;\n  int ch;\n  int oldy;\n  SCREEN *sp;\n  char *oldstr;\n  termios buf;\n  \n  lVar5 = *(long *)(in_FS_OFFSET + 0x28);\n  sp_00 = _nc_screen_of(win);\n  if ((win == (WINDOW *)0x0) || (str == (char *)0x0)) {\n    ch_00 = 0xffffffff;\n  }\n  else {\n    if (maxlen < 0) {\n      iVar9 = _nc_globals.getstr_limit + -1;\n    }\n    else {\n      iVar9 = _nc_globals.getstr_limit + -1;\n      if (maxlen <= _nc_globals.getstr_limit + -1) {\n        iVar9 = maxlen;\n      }\n    }\n    _nc_get_tty_mode_sp(sp_00,&buf);\n    iVar2 = sp_00->_nl;\n    bVar11 = sp_00->_echo != 0;\n    iVar3 = sp_00->_raw;\n    iVar4 = sp_00->_cbreak;\n    nl_sp(sp_00);\n    noecho_sp(sp_00);\n    raw_sp(sp_00);\n    cVar6 = erasechar_sp(sp_00);\n    cVar7 = killchar_sp(sp_00);\n    if (win == (WINDOW *)0x0) {\n      y = -1;\n      x_00 = -1;\n    }\n    else {\n      y = (int)win->_cury;\n      x_00 = (int)win->_curx;\n    }\n    _Var8 = is_wintouched(win);\n    if ((_Var8 != false) || (local_98 = str, (win->_flags & 0x20U) != 0)) {\n      wrefresh(win);\n      local_98 = str;\n    }\n    while (ch_00 = wgetch(win), ch_00 != 0xffffffff) {\n      if ((((ch_00 == 10) || (ch_00 == 0xd)) || (ch_00 == 0x102)) || (ch_00 == 0x157)) {\n        if (((bVar11) && (win->_cury == win->_maxy)) && (win->_scroll != false)) {\n          wechochar(win,10);\n        }\n        break;\n      }\n      if (ch_00 == 0x19a) break;\n      if (((ch_00 == (int)cVar6) || (ch_00 == 0x104)) || (ch_00 == 0x107)) {\n        if (str < local_98) {\n          local_98 = WipeOut(win,y,x_00,str,local_98,(uint)bVar11);\n        }\n      }\n      else if (ch_00 == (int)cVar7) {\n        for (; str < local_98; local_98 = WipeOut(win,y,x_00,str,local_98,(uint)bVar11)) {\n        }\n      }\n      else if (((int)ch_00 < 0x101) && ((long)local_98 - (long)str < (long)iVar9)) {\n        last = local_98 + 1;\n        *local_98 = (char)ch_00;\n        local_98 = last;\n        if (bVar11) {\n          sVar1 = win->_cury;\n          iVar10 = waddch(win,ch_00);\n          if (iVar10 == -1) {\n            win->_flags = win->_flags & 0xffbf;\n            waddch(win,0x20);\n            local_98 = WipeOut(win,y,x_00,str,last,(uint)bVar11);\n          }\n          else {\n            if ((win->_flags & 0x40U) != 0) {\n              if ((((win->_scroll != false) && (sVar1 == win->_maxy)) && (win->_cury == win->_maxy))\n                 && (y = y + -1, y < 1)) {\n                y = 0;\n              }\n              win->_flags = win->_flags & 0xffbf;\n            }\n            wrefresh(win);\n          }\n        }\n      }\n      else {\n        beep_sp(sp_00);\n      }\n    }\n    win->_curx = 0;\n    win->_flags = win->_flags & 0xffbf;\n    if (win->_cury < win->_maxy) {\n      win->_cury = win->_cury + 1;\n    }\n    wrefresh(win);\n    sp_00->_nl = (uint)(iVar2 != 0);\n    sp_00->_echo = (uint)bVar11;\n    sp_00->_raw = (uint)(iVar3 != 0);\n    sp_00->_cbreak = (uint)(iVar4 != 0);\n    _nc_set_tty_mode_sp(sp_00,&buf);\n    *local_98 = '\\0';\n    if ((ch_00 != 0xffffffff) && (ch_00 != 0x19a)) {\n      ch_00 = 0;\n    }\n  }\n  if (lVar5 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return ch_00;\n}\n\n",
        "output": "The predicted function name is wgetnstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,char *str)\n\n{\n  int iVar1;\n  term_conflict *ptVar2;\n  name_table_entry *pnVar3;\n  char *__s2;\n  bool bVar4;\n  int result;\n  int j;\n  int i;\n  TERMTYPE *tp;\n  name_table_entry *entry_ptr;\n  char *capname;\n  \n  result = -1;\n  if (sp == (SCREEN *)0x0) {\n    bVar4 = cur_term != (term_conflict *)0x0;\n  }\n  else if (sp->_term == (TERMINAL_conflict *)0x0) {\n    bVar4 = cur_term != (term_conflict *)0x0;\n  }\n  else {\n    bVar4 = sp->_term != (TERMINAL_conflict *)0x0;\n  }\n  if (bVar4) {\n    ptVar2 = cur_term;\n    if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n      ptVar2 = sp->_term;\n    }\n    j = -1;\n    pnVar3 = _nc_find_type_entry(str,0,false);\n    if (pnVar3 == (name_table_entry *)0x0) {\n      for (i = 0x2c; i < (int)(uint)(ptVar2->type).num_Booleans; i = i + 1) {\n        if (i < 0x2c) {\n          __s2 = *(char **)(boolnames + (long)i * 8);\n        }\n        else {\n          __s2 = (ptVar2->type).ext_Names\n                 [(int)(i - ((uint)(ptVar2->type).num_Booleans - (uint)(ptVar2->type).ext_Booleans))\n                 ];\n        }\n        iVar1 = strcmp(str,__s2);\n        if (iVar1 == 0) {\n          j = i;\n          break;\n        }\n      }\n    }\n    else {\n      j = (int)pnVar3->nte_index;\n    }\n    if (-1 < j) {\n      result = (int)(ptVar2->type).Booleans[j];\n    }\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is tigetflag_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int yold,int xold,int ynew,int xnew,int ovw,NCURSES_OUTC_sp *myOutCh)\n\n{\n  short sVar1;\n  long lVar2;\n  _Bool _Var3;\n  int iVar4;\n  int iVar5;\n  char *src;\n  string_desc *psVar6;\n  uint uVar7;\n  uint uVar8;\n  long in_FS_OFFSET;\n  int tactic;\n  int usecost;\n  int newcost;\n  int t5_cr_cost;\n  string_desc result;\n  char buffer [512];\n  \n  lVar2 = *(long *)(in_FS_OFFSET + 0x28);\n  usecost = 1000000;\n  src = _nc_tiparm(2,sp->_address_cursor,(ulong)(uint)ynew,(ulong)(uint)xnew);\n  psVar6 = _nc_str_init(&result,buffer,0x200);\n  _Var3 = _nc_safe_strcpy(psVar6,src);\n  if ((_Var3 == false) ||\n     (((usecost = sp->_cup_cost, yold != -1 && (xold != -1)) &&\n      ((xnew < 8 ||\n       ((sp->_columns + -8 <= xnew ||\n        (uVar7 = ynew - yold >> 0x1f, uVar8 = xnew - xold >> 0x1f,\n        (int)(((xnew - xold ^ uVar8) - uVar8) + ((ynew - yold ^ uVar7) - uVar7)) < 8)))))))) {\n    tactic = 0;\n    if ((yold != -1) && (xold != -1)) {\n      psVar6 = _nc_str_null(&result,0x200);\n      iVar4 = relative_move(sp,psVar6,yold,xold,ynew,xnew,ovw);\n      if ((iVar4 != 1000000) && (iVar4 < usecost)) {\n        tactic = 1;\n        usecost = iVar4;\n      }\n    }\n    if ((yold != -1) && ((cur_term->type).Strings[2] != (char *)0x0)) {\n      psVar6 = _nc_str_null(&result,0x200);\n      iVar4 = relative_move(sp,psVar6,yold,0,ynew,xnew,ovw);\n      if ((iVar4 != 1000000) && (iVar4 + sp->_cr_cost < usecost)) {\n        tactic = 2;\n        usecost = iVar4 + sp->_cr_cost;\n      }\n    }\n    if ((cur_term->type).Strings[0xc] != (char *)0x0) {\n      psVar6 = _nc_str_null(&result,0x200);\n      iVar4 = relative_move(sp,psVar6,0,0,ynew,xnew,ovw);\n      if ((iVar4 != 1000000) && (iVar4 + sp->_home_cost < usecost)) {\n        tactic = 3;\n        usecost = iVar4 + sp->_home_cost;\n      }\n    }\n    if ((cur_term->type).Strings[0x12] != (char *)0x0) {\n      sVar1 = sp->_lines;\n      psVar6 = _nc_str_null(&result,0x200);\n      iVar4 = relative_move(sp,psVar6,sVar1 + -1,0,ynew,xnew,ovw);\n      if ((iVar4 != 1000000) && (iVar4 + sp->_ll_cost < usecost)) {\n        tactic = 4;\n        usecost = iVar4 + sp->_ll_cost;\n      }\n    }\n    if (xold < 1) {\n      iVar4 = 0;\n    }\n    else {\n      iVar4 = sp->_cr_cost;\n    }\n    if ((((*(cur_term->type).Booleans != '\\0') && ((cur_term->type).Booleans[4] == '\\0')) &&\n        (0 < yold)) && ((cur_term->type).Strings[0xe] != (char *)0x0)) {\n      sVar1 = sp->_columns;\n      psVar6 = _nc_str_null(&result,0x200);\n      iVar5 = relative_move(sp,psVar6,yold + -1,sVar1 + -1,ynew,xnew,ovw);\n      if ((iVar5 != 1000000) && (iVar5 + sp->_cub1_cost + iVar4 < usecost)) {\n        tactic = 5;\n        usecost = iVar5 + sp->_cub1_cost + iVar4;\n      }\n    }\n    if (tactic != 0) {\n      _nc_str_init(&result,buffer,0x200);\n    }\n    switch(tactic) {\n    case 1:\n      relative_move(sp,&result,yold,xold,ynew,xnew,ovw);\n      break;\n    case 2:\n      _nc_safe_strcpy(&result,(cur_term->type).Strings[2]);\n      relative_move(sp,&result,yold,0,ynew,xnew,ovw);\n      break;\n    case 3:\n      _nc_safe_strcpy(&result,(cur_term->type).Strings[0xc]);\n      relative_move(sp,&result,0,0,ynew,xnew,ovw);\n      break;\n    case 4:\n      _nc_safe_strcpy(&result,(cur_term->type).Strings[0x12]);\n      relative_move(sp,&result,sp->_lines + -1,0,ynew,xnew,ovw);\n      break;\n    case 5:\n      if (0 < xold) {\n        _nc_safe_strcat(&result,(cur_term->type).Strings[2]);\n      }\n      _nc_safe_strcat(&result,(cur_term->type).Strings[0xe]);\n      relative_move(sp,&result,yold + -1,sp->_columns + -1,ynew,xnew,ovw);\n    }\n  }\n  if (usecost == 1000000) {\n    iVar4 = -1;\n  }\n  else {\n    tputs_sp(sp,buffer,1,myOutCh);\n    sp->_cursrow = ynew;\n    sp->_curscol = xnew;\n    iVar4 = 0;\n  }\n  if (lVar2 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar4;\n}\n\n",
        "output": "The predicted function name is onscreen_mvcur"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nWINDOW * [MASK](WINDOW *orig,int num_lines,int num_columns,int begy,int begx)\n\n{\n  SCREEN *sp_00;\n  WINDOW *pWVar1;\n  int local_3c;\n  int local_38;\n  int local_34;\n  int i;\n  int flags;\n  SCREEN *sp;\n  WINDOW *win;\n  \n  flags = 1;\n  sp_00 = _nc_screen_of(orig);\n  if ((((begy < 0) || (begx < 0)) || (orig == (WINDOW *)0x0)) ||\n     ((num_lines < 0 || (num_columns < 0)))) {\n    pWVar1 = (WINDOW *)0x0;\n  }\n  else if ((orig->_maxy + 1 < begy + num_lines) || (orig->_maxx + 1 < begx + num_columns)) {\n    pWVar1 = (WINDOW *)0x0;\n  }\n  else {\n    local_34 = num_lines;\n    if (num_lines == 0) {\n      local_34 = (orig->_maxy + 1) - begy;\n    }\n    local_38 = num_columns;\n    if (num_columns == 0) {\n      local_38 = (orig->_maxx + 1) - begx;\n    }\n    if ((orig->_flags & 0x10U) != 0) {\n      flags = 0x11;\n    }\n    pWVar1 = _nc_makenew_sp(sp_00,local_34,local_38,orig->_begy + begy,orig->_begx + begx,flags);\n    if (pWVar1 == (WINDOW *)0x0) {\n      pWVar1 = (WINDOW *)0x0;\n    }\n    else {\n      pWVar1->_pary = begy;\n      pWVar1->_parx = begx;\n      pWVar1->_attrs = orig->_attrs;\n      pWVar1->_bkgd = orig->_bkgd;\n      local_3c = begy;\n      for (i = 0; i < local_34; i = i + 1) {\n        pWVar1->_line[i].text = orig->_line[local_3c].text + begx;\n        local_3c = local_3c + 1;\n      }\n      pWVar1->_parent = orig;\n    }\n  }\n  return pWVar1;\n}\n\n",
        "output": "The predicted function name is derwin"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,char *cap,int affcnt)\n\n{\n  int cost;\n  \n  cost = _nc_msec_cost_sp(sp,cap,affcnt);\n  if (cost != 1000000) {\n    cost = (cost + sp->_char_padding + -1) / sp->_char_padding;\n  }\n  return cost;\n}\n\n",
        "output": "The predicted function name is normalized_cost"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nSCREEN * [MASK](WINDOW *win)\n\n{\n  SCREEN *sp;\n  \n  sp = (SCREEN *)0x0;\n  if (win != (WINDOW *)0x0) {\n    sp = *(SCREEN **)&win[-1]._pad._pad_bottom;\n  }\n  return sp;\n}\n\n",
        "output": "The predicted function name is _nc_screen_of"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *str)\n\n{\n  int iVar1;\n  \n  iVar1 = tigetflag_sp(SP,str);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is tigetflag"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  uint uVar1;\n  int iVar2;\n  int iVar3;\n  HASHMAP *pHVar4;\n  ulong uVar5;\n  ulong *puVar6;\n  int iVar7;\n  int start;\n  int shift;\n  int size;\n  HASHMAP *hsp;\n  ulong hashval_1;\n  ulong hashval;\n  \n  if (sp->hashtab_len < (int)sp->_lines) {\n    if (sp->hashtab != (HASHMAP *)0x0) {\n      free(sp->hashtab);\n    }\n    pHVar4 = (HASHMAP *)malloc(((long)sp->_lines + 1) * 0x30);\n    sp->hashtab = pHVar4;\n    if (sp->hashtab == (HASHMAP *)0x0) {\n      if (sp->oldhash != (ulong *)0x0) {\n        free(sp->oldhash);\n        sp->oldhash = (ulong *)0x0;\n      }\n      sp->hashtab_len = 0;\n      return;\n    }\n    sp->hashtab_len = (int)sp->_lines;\n  }\n  if ((sp->oldhash == (ulong *)0x0) || (sp->newhash == (ulong *)0x0)) {\n    if (sp->oldhash == (ulong *)0x0) {\n      puVar6 = (ulong *)calloc((long)sp->_lines,8);\n      sp->oldhash = puVar6;\n    }\n    if (sp->newhash == (ulong *)0x0) {\n      puVar6 = (ulong *)calloc((long)sp->_lines,8);\n      sp->newhash = puVar6;\n    }\n    if (sp->oldhash == (ulong *)0x0) {\n      return;\n    }\n    if (sp->newhash == (ulong *)0x0) {\n      return;\n    }\n    for (iVar7 = 0; iVar7 < sp->_lines; iVar7 = iVar7 + 1) {\n      puVar6 = sp->newhash;\n      uVar5 = hash(sp,sp->_newscr->_line[iVar7].text);\n      puVar6[iVar7] = uVar5;\n      puVar6 = sp->oldhash;\n      uVar5 = hash(sp,sp->_curscr->_line[iVar7].text);\n      puVar6[iVar7] = uVar5;\n    }\n  }\n  else {\n    for (iVar7 = 0; iVar7 < sp->_lines; iVar7 = iVar7 + 1) {\n      if (sp->_newscr->_line[iVar7].firstchar != -1) {\n        puVar6 = sp->newhash;\n        uVar5 = hash(sp,sp->_newscr->_line[iVar7].text);\n        puVar6[iVar7] = uVar5;\n      }\n    }\n  }\n  memset(sp->hashtab,0,((long)sp->_lines + 1) * 0x30);\n  for (iVar7 = 0; iVar7 < sp->_lines; iVar7 = iVar7 + 1) {\n    for (hsp = sp->hashtab; (hsp->hashval != 0 && (sp->oldhash[iVar7] != hsp->hashval));\n        hsp = hsp + 1) {\n    }\n    hsp->hashval = sp->oldhash[iVar7];\n    hsp->oldcount = hsp->oldcount + 1;\n    hsp->oldindex = iVar7;\n  }\n  for (iVar7 = 0; iVar7 < sp->_lines; iVar7 = iVar7 + 1) {\n    for (hsp = sp->hashtab; (hsp->hashval != 0 && (sp->newhash[iVar7] != hsp->hashval));\n        hsp = hsp + 1) {\n    }\n    hsp->hashval = sp->newhash[iVar7];\n    hsp->newcount = hsp->newcount + 1;\n    hsp->newindex = iVar7;\n    sp->_oldnum_list[iVar7] = -1;\n  }\n  for (hsp = sp->hashtab; hsp->hashval != 0; hsp = hsp + 1) {\n    if (((hsp->oldcount == 1) && (hsp->newcount == 1)) && (hsp->oldindex != hsp->newindex)) {\n      sp->_oldnum_list[hsp->newindex] = hsp->oldindex;\n    }\n  }\n  grow_hunks(sp);\n  iVar7 = 0;\nLAB_0002c0c9:\n  start = iVar7;\n  if (start < sp->_lines) {\n    for (; (start < sp->_lines && (sp->_oldnum_list[start] == -1)); start = start + 1) {\n    }\n    if (start < sp->_lines) {\n      uVar1 = sp->_oldnum_list[start] - start;\n      iVar7 = start;\n      do {\n        iVar7 = iVar7 + 1;\n        if ((sp->_lines <= iVar7) || (sp->_oldnum_list[iVar7] == -1)) break;\n      } while (uVar1 == sp->_oldnum_list[iVar7] - iVar7);\n      iVar2 = iVar7 - start;\n      if (2 < iVar2) goto code_r0x0002c06e;\n      goto LAB_0002c0c4;\n    }\n  }\n  grow_hunks(sp);\n  return;\ncode_r0x0002c06e:\n  if (iVar2 < 0x18) {\n    iVar3 = iVar2;\n    if (iVar2 < 0) {\n      iVar3 = iVar2 + 7;\n    }\n    iVar3 = iVar3 >> 3;\n  }\n  else {\n    iVar3 = 2;\n  }\n  if (iVar3 + iVar2 < (int)(((int)uVar1 >> 0x1f ^ uVar1) - ((int)uVar1 >> 0x1f))) {\nLAB_0002c0c4:\n    for (; start < iVar7; start = start + 1) {\n      sp->_oldnum_list[start] = -1;\n    }\n  }\n  goto LAB_0002c0c9;\n}\n\n",
        "output": "The predicted function name is _nc_hash_map_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int ms)\n\n{\n  int iVar1;\n  NCURSES_OUTC_sp *pNVar2;\n  bool bVar3;\n  NCURSES_OUTC_sp *my_outch;\n  \n  if (sp == (SCREEN *)0x0) {\n    bVar3 = cur_term == (term_conflict *)0x0;\n  }\n  else if (sp->_term == (TERMINAL_conflict *)0x0) {\n    bVar3 = cur_term == (term_conflict *)0x0;\n  }\n  else {\n    bVar3 = sp->_term == (TERMINAL_conflict *)0x0;\n  }\n  if (bVar3) {\n    iVar1 = -1;\n  }\n  else {\n    if ((cur_term->type).Booleans[0x19] == '\\0') {\n      pNVar2 = _nc_prescreen._outch;\n      if (sp != (SCREEN *)0x0) {\n        pNVar2 = sp->_outch;\n      }\n      iVar1 = _nc_baudrate((int)ospeed);\n      iVar1 = (iVar1 * ms) / 9000;\n      _nc_nulls_sent = _nc_nulls_sent + iVar1;\n      for (; 0 < iVar1; iVar1 = iVar1 + -1) {\n        (*pNVar2)(sp,(int)PC);\n      }\n      if (pNVar2 == _nc_outch_sp) {\n        _nc_flush_sp(sp);\n      }\n    }\n    else {\n      _nc_flush_sp(sp);\n      napms(ms);\n    }\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is delay_output_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](WINDOW *z)\n\n{\n  _Bool _Var1;\n  \n  if ((z == (WINDOW *)0x0) || ((z->_flags & 0x10U) == 0)) {\n    _Var1 = false;\n  }\n  else {\n    _Var1 = true;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is is_pad"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  if ((sp->_mouse_type == M_XTERM) && (sp->_mouse_mask != 0)) {\n    mouse_activate(sp,0);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_mouse_wrap"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](WINDOW *win,int delay)\n\n{\n  if (win != (WINDOW *)0x0) {\n    win->_delay = delay;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is wtimeout"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,attr_t a2,short a3,void *z)\n\n{\n  int iVar1;\n  \n  if (a1 == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    a1->_attrs = a2 & 0xffff00ff | ((int)a3 & 0xffU) << 8;\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is wattr_set"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int line,anon_subr_int_WINDOW_ptr_int *init)\n\n{\n  int iVar1;\n  SCREEN *sp;\n  int rc;\n  \n  if ((SP == (SCREEN *)0x0) || (sp = SP, SP->_prescreen == false)) {\n    sp = new_prescr();\n  }\n  iVar1 = _nc_ripoffline_sp(sp,line,init);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is _nc_ripoffline"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win)\n\n{\n  int iVar1;\n  SCREEN *pSVar2;\n  ldat *plVar3;\n  ldat *plVar4;\n  short sVar5;\n  int limit_x;\n  int src_row;\n  int src_col;\n  int dst_row;\n  int dst_col;\n  int last_src;\n  int begx;\n  int begy;\n  SCREEN *sp;\n  ldat *nline;\n  ldat *oline;\n  \n  pSVar2 = _nc_screen_of(win);\n  if ((win == (WINDOW *)0x0) || ((win->_flags & 0x10U) != 0)) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = (int)win->_begx;\n    sVar5 = win->_begy;\n    pSVar2->_newscr->_bkgd = win->_bkgd;\n    pSVar2->_newscr->_attrs = win->_attrs;\n    wsyncdown(win);\n    win->_flags = win->_flags & 0xffdf;\n    limit_x = (int)win->_maxx;\n    if (pSVar2->_newscr->_maxx - iVar1 < limit_x) {\n      limit_x = pSVar2->_newscr->_maxx - iVar1;\n    }\n    src_row = 0;\n    for (dst_row = (int)sVar5 + (int)win->_yoffset;\n        (src_row <= win->_maxy && (dst_row <= pSVar2->_newscr->_maxy)); dst_row = dst_row + 1) {\n      plVar3 = pSVar2->_newscr->_line + dst_row;\n      plVar4 = win->_line + src_row;\n      if (plVar4->firstchar != -1) {\n        last_src = (int)plVar4->lastchar;\n        if (limit_x < last_src) {\n          last_src = limit_x;\n        }\n        src_col = (int)plVar4->firstchar;\n        dst_col = iVar1 + src_col;\n        for (; src_col <= last_src; src_col = src_col + 1) {\n          if (plVar4->text[src_col] != plVar3->text[dst_col]) {\n            plVar3->text[dst_col] = plVar4->text[src_col];\n            sVar5 = (short)dst_col;\n            if (plVar3->firstchar == -1) {\n              plVar3->lastchar = sVar5;\n              plVar3->firstchar = plVar3->lastchar;\n            }\n            else if (dst_col < plVar3->firstchar) {\n              plVar3->firstchar = sVar5;\n            }\n            else if (plVar3->lastchar < dst_col) {\n              plVar3->lastchar = sVar5;\n            }\n          }\n          dst_col = dst_col + 1;\n        }\n      }\n      plVar4->lastchar = -1;\n      plVar4->firstchar = plVar4->lastchar;\n      src_row = src_row + 1;\n    }\n    if (win->_clear != false) {\n      win->_clear = false;\n      pSVar2->_newscr->_clear = true;\n    }\n    if (win->_leaveok != true) {\n      pSVar2->_newscr->_cury = win->_cury + win->_begy + win->_yoffset;\n      pSVar2->_newscr->_curx = win->_curx + win->_begx;\n    }\n    pSVar2->_newscr->_leaveok = win->_leaveok;\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is wnoutrefresh"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](SCREEN *sp)\n\n{\n  _Bool _Var1;\n  bool bVar2;\n  int result;\n  \n  if (0 < sp->_color_defs) {\n    sp->_color_defs = -sp->_color_defs;\n  }\n  _Var1 = reset_color_pair(sp);\n  bVar2 = (cur_term->type).Strings[0x12a] != (char *)0x0;\n  if (bVar2) {\n    _nc_putp_sp(sp,\"orig_colors\",(cur_term->type).Strings[0x12a]);\n  }\n  return bVar2 || _Var1 != false;\n}\n\n",
        "output": "The predicted function name is _nc_reset_colors_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int code)\n\n{\n                    /* WARNING: Subroutine does not return */\n  _nc_free_and_exit_sp(SP,code);\n}\n\n",
        "output": "The predicted function name is _nc_free_and_exit"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](chtype z)\n\n{\n  int iVar1;\n  \n  iVar1 = wechochar(stdscr,z);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is echochar"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nWINDOW * [MASK](SCREEN *sp)\n\n{\n  WINDOW *pWVar1;\n  \n  if (sp == (SCREEN *)0x0) {\n    pWVar1 = (WINDOW *)0x0;\n  }\n  else {\n    pWVar1 = sp->_newscr;\n  }\n  return pWVar1;\n}\n\n",
        "output": "The predicted function name is _nc_newscr_of"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](chtype *z)\n\n{\n  int iVar1;\n  \n  iVar1 = winchnstr(stdscr,z,-1);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is inchstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = nocbreak_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is nocbreak"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR___xstat_00244ee0)(1,__file,__buf);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is stat"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](chtype *a1,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = waddchnstr(stdscr,a1,z);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is addchnstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int c,_Bool flag)\n\n{\n  int iVar1;\n  \n  iVar1 = keyok_sp(SP,c,flag);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is keyok"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = wrefresh(stdscr);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is refresh"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nWINDOW * [MASK](WINDOW *z)\n\n{\n  WINDOW *pWVar1;\n  \n  if (z == (WINDOW *)0x0) {\n    pWVar1 = (WINDOW *)0x0;\n  }\n  else {\n    pWVar1 = z->_parent;\n  }\n  return pWVar1;\n}\n\n",
        "output": "The predicted function name is wgetparent"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *name,DBDIRS which)\n\n{\n  char *result;\n  \n  result = (char *)0x0;\n  update_getenv(name,which);\n  if (which < dbdLAST) {\n    result = _nc_globals.dbd_vars[which].value;\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is cache_getenv"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,_Bool flag)\n\n{\n  int iVar1;\n  \n  if (win == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    if (flag == false) {\n      win->_delay = -1;\n    }\n    else {\n      win->_delay = 0;\n    }\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is nodelay"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp,int count)\n\n{\n  char *string;\n  int n;\n  \n  if ((cur_term->type).Strings[0x69] == (char *)0x0) {\n    for (n = 0; n < count; n = n + 1) {\n      _nc_putp_sp(sp,\"delete_character\",(cur_term->type).Strings[0x15]);\n    }\n  }\n  else {\n    string = _nc_tiparm(1,(cur_term->type).Strings[0x69],(ulong)(uint)count);\n    tputs_sp(sp,string,1,_nc_outch_sp);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is DelChar"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](WINDOW *win)\n\n{\n  _Bool _Var1;\n  \n  _Var1 = is_wintouched(win);\n  if (((_Var1 != false) || ((win->_flags & 0x20U) != 0)) && ((win->_flags & 0x10U) == 0)) {\n    wrefresh(win);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is recur_wrefresh"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int t)\n\n{\n  int iVar1;\n  \n  if (((t < 1) || (0xff < t)) || (sp == (SCREEN *)0x0)) {\nLAB_00020d17:\n    iVar1 = -1;\n  }\n  else {\n    if ((sp == (SCREEN *)0x0) || (sp->_term == (TERMINAL_conflict *)0x0)) {\n      if (cur_term == (term_conflict *)0x0) goto LAB_00020d17;\n    }\n    else if (sp->_term == (TERMINAL_conflict *)0x0) goto LAB_00020d17;\n    cbreak_sp(sp);\n    sp->_cbreak = t + 1;\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is halfdelay_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *namelst,char *name,char *delim)\n\n{\n  char cVar1;\n  bool bVar2;\n  int code;\n  int found;\n  char *s;\n  char *d;\n  char *t;\n  \n  s = namelst;\n  if (namelst != (char *)0x0) {\n    do {\n      d = name;\n      if (*s == '\\0') {\n        return 0;\n      }\n      for (; (*d != '\\0' && (*s == *d)); s = s + 1) {\n        d = d + 1;\n      }\n      bVar2 = false;\n      code = 1;\n      for (; t = delim, *s != '\\0'; s = s + 1) {\n        for (; *t != '\\0'; t = t + 1) {\n          if (*s == *t) {\n            bVar2 = true;\n            break;\n          }\n        }\n        if (bVar2) break;\n        code = 0;\n      }\n      if ((code != 0) && (*d == '\\0')) {\n        return code;\n      }\n      cVar1 = *s;\n      s = s + 1;\n    } while (cVar1 != '\\0');\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is _nc_name_match"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  speed_t sVar1;\n  term_conflict *ptVar2;\n  bool bVar3;\n  int result;\n  \n  if (sp == (SCREEN *)0x0) {\n    bVar3 = cur_term != (term_conflict *)0x0;\n  }\n  else if (sp->_term == (TERMINAL_conflict *)0x0) {\n    bVar3 = cur_term != (term_conflict *)0x0;\n  }\n  else {\n    bVar3 = sp->_term != (TERMINAL_conflict *)0x0;\n  }\n  if (bVar3) {\n    ptVar2 = cur_term;\n    if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n      ptVar2 = sp->_term;\n    }\n    sVar1 = cfgetospeed((termios *)&ptVar2->Nttyb);\n    ospeed = (short)sVar1;\n    result = _nc_baudrate((int)ospeed);\n    ptVar2 = cur_term;\n    if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n      ptVar2 = sp->_term;\n    }\n    ptVar2->_baudrate = result;\n  }\n  else {\n    result = -1;\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is baudrate_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nSCREEN * [MASK](SCREEN *screenp)\n\n{\n  SCREEN *pSVar1;\n  SCREEN *oldSP;\n  SCREEN *newSP;\n  \n  pSVar1 = SP;\n  SP = screenp;\n  if (screenp == (SCREEN *)0x0) {\n    set_curterm((TERMINAL_conflict *)0x0);\n    curscr = (WINDOW *)0x0;\n    newscr = (WINDOW *)0x0;\n    stdscr = (WINDOW *)0x0;\n    COLORS = 0;\n    COLOR_PAIRS = 0;\n  }\n  else {\n    set_curterm(screenp->_term);\n    curscr = screenp->_curscr;\n    newscr = screenp->_newscr;\n    stdscr = screenp->_stdscr;\n    COLORS = screenp->_color_count;\n    COLOR_PAIRS = screenp->_pair_count;\n  }\n  return pSVar1;\n}\n\n",
        "output": "The predicted function name is set_term"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,int a2,int a3,char *z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(a1,a2,a3);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = waddnstr(a1,z,-1);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvwaddstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  if ((sp != (SCREEN *)0x0) && (sp->_prescreen != false)) {\n    sp->_filtered = false;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is nofilter_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](TRIES **tree,char *str,uint code)\n\n{\n  uchar uVar1;\n  TRIES *pTVar2;\n  tries *ptVar3;\n  bool bVar4;\n  uchar cmp;\n  TRIES *ptr;\n  TRIES *savedptr;\n  uchar *txt;\n  \n  if (((str == (char *)0x0) || (*str == '\\0')) || (code == 0)) {\n    return -1;\n  }\n  if (*tree != (TRIES *)0x0) {\n    savedptr = *tree;\n    ptr = savedptr;\n    txt = (uchar *)str;\nLAB_0001f2b2:\n    uVar1 = *txt;\n    do {\n      if (ptr->ch == '\\0') {\n        if (uVar1 == 0x80) goto LAB_0001f2f8;\n      }\n      else if (uVar1 == ptr->ch) goto LAB_0001f2f8;\n      if (ptr->sibling == (tries *)0x0) goto LAB_0001f2f8;\n      ptr = ptr->sibling;\n    } while( true );\n  }\n  pTVar2 = (TRIES *)calloc(1,0x18);\n  *tree = pTVar2;\n  ptr = *tree;\n  if (ptr == (TRIES *)0x0) {\n    return -1;\n  }\n  txt = (uchar *)(str + 1);\n  ptr->ch = *str;\n  if (ptr->ch == 0x80) {\n    ptr->ch = '\\0';\n  }\n  ptr->value = 0;\n  savedptr = ptr;\nLAB_0001f4f6:\n  while( true ) {\n    if (*txt == '\\0') {\n      ptr->value = (ushort)code;\n      return 0;\n    }\n    ptVar3 = (tries *)calloc(1,0x18);\n    ptr->child = ptVar3;\n    ptr = ptr->child;\n    if (ptr == (tries *)0x0) break;\n    ptr->ch = *txt;\n    if (ptr->ch == 0x80) {\n      ptr->ch = '\\0';\n    }\n    ptr->value = 0;\n    txt = txt + 1;\n  }\n  while (savedptr != (TRIES *)0x0) {\n    ptVar3 = savedptr->child;\n    free(savedptr);\n    savedptr = ptVar3;\n  }\n  *tree = (TRIES *)0x0;\n  return -1;\nLAB_0001f2f8:\n  if (ptr->ch == '\\0') {\n    bVar4 = uVar1 == 0x80;\n  }\n  else {\n    bVar4 = uVar1 == ptr->ch;\n  }\n  if (bVar4) {\n    if (txt[1] == '\\0') {\n      ptr->value = (ushort)code;\n      return 0;\n    }\n    if (ptr->child == (tries *)0x0) goto LAB_0001f458;\n    ptr = ptr->child;\n    txt = txt + 1;\n    goto LAB_0001f2b2;\n  }\n  ptVar3 = (tries *)calloc(1,0x18);\n  ptr->sibling = ptVar3;\n  if (ptr->sibling == (tries *)0x0) {\n    return -1;\n  }\n  ptr = ptr->sibling;\n  ptr->ch = *txt;\n  if (ptr->ch == 0x80) {\n    ptr->ch = '\\0';\n  }\n  ptr->value = 0;\n  savedptr = ptr;\nLAB_0001f458:\n  txt = txt + 1;\n  goto LAB_0001f4f6;\n}\n\n",
        "output": "The predicted function name is _nc_add_to_try"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *s,char *format,int *len)\n\n{\n  bool bVar1;\n  bool bVar2;\n  bool bVar3;\n  bool bVar4;\n  ushort **ppuVar5;\n  byte *local_38;\n  byte *local_30;\n  _Bool done;\n  _Bool allowminus;\n  _Bool dot;\n  _Bool err;\n  int my_width;\n  int my_prec;\n  int value;\n  char *fmt;\n  \n  *len = 0;\n  local_30 = (byte *)s;\n  if (format != (char *)0x0) {\n    bVar3 = false;\n    bVar2 = false;\n    bVar1 = false;\n    bVar4 = false;\n    my_width = 0;\n    value = 0;\n    *len = 0;\n    *format = '%';\n    local_38 = (byte *)(format + 1);\n    local_30 = (byte *)s;\n    while ((*local_30 != 0 && (!bVar3))) {\n      switch(*local_30) {\n      case 0x20:\n        *local_38 = *local_30;\n        local_38 = local_38 + 1;\n        local_30 = local_30 + 1;\n        break;\n      default:\n        ppuVar5 = __ctype_b_loc();\n        if (((*ppuVar5)[*local_30] & 0x800) == 0) {\n          bVar3 = true;\n        }\n        else {\n          value = (char)*local_30 + -0x30 + value * 10;\n          if (10000 < value) {\n            bVar4 = true;\n          }\n          *local_38 = *local_30;\n          local_38 = local_38 + 1;\n          local_30 = local_30 + 1;\n        }\n        break;\n      case 0x23:\n        *local_38 = *local_30;\n        local_38 = local_38 + 1;\n        local_30 = local_30 + 1;\n        break;\n      case 0x2d:\n        if (bVar2) {\n          *local_38 = *local_30;\n          local_38 = local_38 + 1;\n          local_30 = local_30 + 1;\n        }\n        else {\n          bVar3 = true;\n        }\n        break;\n      case 0x2e:\n        *local_38 = *local_30;\n        if (bVar1) {\n          bVar4 = true;\n        }\n        else {\n          bVar1 = true;\n          my_width = value;\n        }\n        value = 0;\n        local_38 = local_38 + 1;\n        local_30 = local_30 + 1;\n        break;\n      case 0x3a:\n        bVar2 = true;\n        local_30 = local_30 + 1;\n        break;\n      case 0x58:\n      case 99:\n      case 100:\n      case 0x6f:\n      case 0x73:\n      case 0x78:\n        *local_38 = *local_30;\n        bVar3 = true;\n        local_38 = local_38 + 1;\n      }\n    }\n    if (bVar4) {\n      value = 0;\n      my_width = 0;\n      *format = '%';\n      local_38 = (byte *)(format + 2);\n      format[1] = *local_30;\n    }\n    my_prec = 0;\n    if (bVar1) {\n      my_prec = value;\n    }\n    else {\n      my_width = value;\n    }\n    *local_38 = 0;\n    if (my_width <= my_prec) {\n      my_width = my_prec;\n    }\n    *len = my_width;\n  }\n  return (char *)local_30;\n}\n\n",
        "output": "The predicted function name is parse_format"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,char *str)\n\n{\n  int iVar1;\n  term_conflict *ptVar2;\n  name_table_entry *pnVar3;\n  char *__s2;\n  bool bVar4;\n  int result;\n  int j;\n  int i;\n  TERMTYPE *tp;\n  name_table_entry *entry_ptr;\n  char *capname;\n  \n  result = -2;\n  if (sp == (SCREEN *)0x0) {\n    bVar4 = cur_term != (term_conflict *)0x0;\n  }\n  else if (sp->_term == (TERMINAL_conflict *)0x0) {\n    bVar4 = cur_term != (term_conflict *)0x0;\n  }\n  else {\n    bVar4 = sp->_term != (TERMINAL_conflict *)0x0;\n  }\n  if (bVar4) {\n    ptVar2 = cur_term;\n    if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n      ptVar2 = sp->_term;\n    }\n    j = -1;\n    pnVar3 = _nc_find_type_entry(str,1,false);\n    if (pnVar3 == (name_table_entry *)0x0) {\n      for (i = 0x27; i < (int)(uint)(ptVar2->type).num_Numbers; i = i + 1) {\n        if (i < 0x27) {\n          __s2 = *(char **)(numnames + (long)i * 8);\n        }\n        else {\n          __s2 = (ptVar2->type).ext_Names\n                 [(int)((uint)(ptVar2->type).ext_Booleans +\n                       (i - ((uint)(ptVar2->type).num_Numbers - (uint)(ptVar2->type).ext_Numbers)))]\n          ;\n        }\n        iVar1 = strcmp(str,__s2);\n        if (iVar1 == 0) {\n          j = i;\n          break;\n        }\n      }\n    }\n    else {\n      j = (int)pnVar3->nte_index;\n    }\n    if (-1 < j) {\n      if ((ptVar2->type).Numbers[j] < 0) {\n        result = -1;\n      }\n      else {\n        result = (int)(ptVar2->type).Numbers[j];\n      }\n    }\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is tigetnum_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *buf,char **Strings,int count,int size,char *table)\n\n{\n  int i;\n  char *p;\n  \n  for (i = 0; i < count; i = i + 1) {\n    if ((buf[i * 2] == -1) && (buf[(long)(i * 2) + 1] == -1)) {\n      Strings[i] = (char *)0x0;\n    }\n    else if ((buf[i * 2] == -2) && (buf[(long)(i * 2) + 1] == -1)) {\n      Strings[i] = (char *)0xffffffffffffffff;\n    }\n    else if (size < (short)((ushort)(byte)buf[i * 2] + (ushort)(byte)buf[(long)(i * 2) + 1] * 0x100)\n            ) {\n      Strings[i] = (char *)0x0;\n    }\n    else {\n      Strings[i] = table + (short)((ushort)(byte)buf[i * 2] +\n                                  (ushort)(byte)buf[(long)(i * 2) + 1] * 0x100);\n    }\n    if ((Strings[i] != (char *)0xffffffffffffffff) && (Strings[i] != (char *)0x0)) {\n      for (p = Strings[i]; (p < table + size && (*p != '\\0')); p = p + 1) {\n      }\n      if (table + size <= p) {\n        Strings[i] = (char *)0x0;\n      }\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is convert_strings"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](char *path)\n\n{\n  _Bool _Var1;\n  \n  if ((path == (char *)0x0) || (*path != '/')) {\n    _Var1 = false;\n  }\n  else {\n    _Var1 = true;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is _nc_is_abs_path"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  long in_FS_OFFSET;\n  int new_lines;\n  int new_cols;\n  int old_lines;\n  int old_cols;\n  TERMINAL_conflict *termp;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  termp = cur_term;\n  old_lines = (int)(cur_term->type).Numbers[2];\n  old_cols = (int)*(cur_term->type).Numbers;\n  if (sp != (SCREEN *)0x0) {\n    _nc_get_screensize(sp,&new_lines,&new_cols);\n    if (sp->_resize != (anon_subr_int_screen_ptr_int_int_for__resize *)0x0) {\n      if ((old_lines == new_lines) && (old_cols == new_cols)) {\n        if ((sp->_sig_winch != false) &&\n           (sp->_ungetch != (anon_subr_int_screen_ptr_int_for__ungetch *)0x0)) {\n          (*sp->_ungetch)(sp,0x19a);\n        }\n      }\n      else {\n        (*sp->_resize)(sp,new_lines,new_cols);\n      }\n      sp->_sig_winch = false;\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_update_screensize"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp,_Bool f)\n\n{\n  if ((sp != (SCREEN *)0x0) && (sp->_prescreen != false)) {\n    sp->use_tioctl = f;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is use_tioctl_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nstring_desc * [MASK](string_desc *dst,char *src,size_t len)\n\n{\n  if (dst != (string_desc *)0x0) {\n    dst->s_head = src;\n    dst->s_tail = src;\n    dst->s_size = len - 1;\n    dst->s_init = dst->s_size;\n    if (src != (char *)0x0) {\n      *src = '\\0';\n    }\n  }\n  return dst;\n}\n\n",
        "output": "The predicted function name is _nc_str_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  int code;\n  \n  code = -1;\n  if (sp != (SCREEN *)0x0) {\n    sp->_endwin = 2;\n    (*sp->_mouse_wrap)(sp);\n    _nc_screen_wrap();\n    _nc_mvcur_wrap();\n    code = reset_shell_mode_sp(sp);\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is endwin_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,int n,attr_t attr,short pair_arg,void *opts)\n\n{\n  bool bVar1;\n  ldat *plVar2;\n  short sVar3;\n  uint local_38;\n  int local_34;\n  int code;\n  int color_pair;\n  int i;\n  ldat *line;\n  \n  code = -1;\n  color_pair = (int)pair_arg;\n  if (opts != (void *)0x0) {\n    color_pair = -1;\n  }\n  if (win != (WINDOW *)0x0) {\n    plVar2 = win->_line + win->_cury;\n    if ((char)color_pair == '\\0') {\n      local_38 = attr | (color_pair & 0xffU) << 8;\n    }\n    else {\n      local_38 = (color_pair & 0xffU) << 8 | attr & 0xffff00ff;\n    }\n    i = (int)win->_curx;\n    local_34 = n;\n    while ((i <= win->_maxx &&\n           ((local_34 == -1 || (bVar1 = 0 < local_34, local_34 = local_34 + -1, bVar1))))) {\n      plVar2->text[i] = plVar2->text[i] & 0xff | local_38;\n      plVar2->text[i] = plVar2->text[i] & 0xffff00ff;\n      plVar2->text[i] = plVar2->text[i] & 0xff | (plVar2->text[i] >> 8 | color_pair & 0xffU) << 8;\n      sVar3 = (short)i;\n      if (plVar2->firstchar == -1) {\n        plVar2->lastchar = sVar3;\n        plVar2->firstchar = plVar2->lastchar;\n      }\n      else if (i < plVar2->firstchar) {\n        plVar2->firstchar = sVar3;\n      }\n      else if (plVar2->lastchar < i) {\n        plVar2->lastchar = sVar3;\n      }\n      i = i + 1;\n    }\n    code = 0;\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is wchgat"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](termios *buf)\n\n{\n  int iVar1;\n  \n  iVar1 = _nc_get_tty_mode_sp(SP,buf);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is _nc_get_tty_mode"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](WINDOW *z)\n\n{\n  _Bool _Var1;\n  \n  if ((z == (WINDOW *)0x0) || (z->_use_keypad == false)) {\n    _Var1 = false;\n  }\n  else {\n    _Var1 = true;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is is_keypad"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,chtype ch,int n)\n\n{\n  short sVar1;\n  short sVar2;\n  int iVar3;\n  chtype cVar4;\n  ldat *plVar5;\n  int code;\n  chtype wch;\n  int end;\n  int row;\n  int col;\n  ldat *line;\n  \n  code = -1;\n  if (win != (WINDOW *)0x0) {\n    sVar1 = win->_cury;\n    sVar2 = win->_curx;\n    iVar3 = (int)sVar2;\n    end = n + sVar1 + -1;\n    if (win->_maxy < end) {\n      end = (int)win->_maxy;\n    }\n    wch = ch;\n    if (ch == 0) {\n      wch = acs_map._480_4_;\n    }\n    cVar4 = _nc_render(win,wch);\n    for (; sVar1 <= end; end = end + -1) {\n      plVar5 = win->_line + end;\n      plVar5->text[iVar3] = cVar4;\n      if (plVar5->firstchar == -1) {\n        plVar5->lastchar = sVar2;\n        plVar5->firstchar = plVar5->lastchar;\n      }\n      else if (iVar3 < plVar5->firstchar) {\n        plVar5->firstchar = sVar2;\n      }\n      else if (plVar5->lastchar < iVar3) {\n        plVar5->lastchar = sVar2;\n      }\n    }\n    _nc_synchook(win);\n    code = 0;\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is wvline"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](SCREEN *sp)\n\n{\n  long lVar1;\n  bool bVar2;\n  int iVar3;\n  long in_FS_OFFSET;\n  _Bool have_pending;\n  pollfd fds [1];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  bVar2 = false;\n  if (sp->_fifohold == 0) {\n    if (-1 < sp->_checkfd) {\n      fds[0].fd = sp->_checkfd;\n      fds[0].events = 1;\n      iVar3 = poll((pollfd *)fds,1,0);\n      if (0 < iVar3) {\n        bVar2 = true;\n      }\n    }\n    if (bVar2) {\n      sp->_fifohold = 5;\n      _nc_flush_sp(sp);\n    }\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return false;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is check_pending"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *z)\n\n{\n  int iVar1;\n  \n  iVar1 = wgetnstr(stdscr,z,-1);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is getstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int c)\n\n{\n  int local_c;\n  \n  local_c = c;\n  if (c < 0x10) {\n    local_c = toggled_colors::lexical_block_0::table[c];\n  }\n  return local_c;\n}\n\n",
        "output": "The predicted function name is toggled_colors"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,char *fmt,__va_list_tag *argp)\n\n{\n  SCREEN *sp_00;\n  char *astr;\n  int code;\n  SCREEN *sp;\n  char *buf;\n  \n  code = -1;\n  sp_00 = _nc_screen_of(win);\n  astr = _nc_printf_string_sp(sp_00,fmt,argp);\n  if (astr != (char *)0x0) {\n    code = waddnstr(win,astr,-1);\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is vw_printw"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  int vis;\n  int cursor;\n  \n  if (sp != (SCREEN *)0x0) {\n    if ((cur_term->type).Strings[0x1c] != (char *)0x0) {\n      _nc_putp_sp(sp,\"enter_ca_mode\",(cur_term->type).Strings[0x1c]);\n    }\n    reset_scroll_region(sp);\n    sp->_curscol = -1;\n    sp->_cursrow = sp->_curscol;\n    if (sp->_cursor != -1) {\n      vis = sp->_cursor;\n      sp->_cursor = -1;\n      curs_set_sp(sp,vis);\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_mvcur_resume_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  int n;\n  \n  *sp->_current_attr = *sp->_current_attr & 0xff;\n  sp->_newscr->_clear = true;\n  if ((sp->_coloron != 0) || (sp->_color_defs != 0)) {\n    _nc_reset_colors_sp(sp);\n  }\n  if ((sp->_color_defs < 0) && (sp->_direct_color == 0)) {\n    sp->_color_defs = -sp->_color_defs;\n    for (n = 0; n < sp->_color_defs; n = n + 1) {\n      if (sp->_color_table[n].init != 0) {\n        _nc_init_color(sp,n,sp->_color_table[n].r,sp->_color_table[n].g,sp->_color_table[n].b);\n      }\n    }\n  }\n  if ((cur_term->type).Strings[0x27] == (char *)0x0) {\n    if ((cur_term->type).Strings[0x26] != (char *)0x0) {\n      _nc_putp_sp(sp,\"exit_alt_charset_mode\",(cur_term->type).Strings[0x26]);\n    }\n    if ((cur_term->type).Strings[0x2b] != (char *)0x0) {\n      _nc_putp_sp(sp,\"exit_standout_mode\",(cur_term->type).Strings[0x2b]);\n    }\n    if ((cur_term->type).Strings[0x2c] != (char *)0x0) {\n      _nc_putp_sp(sp,\"exit_underline_mode\",(cur_term->type).Strings[0x2c]);\n    }\n  }\n  else {\n    _nc_putp_sp(sp,\"exit_attribute_mode\",(cur_term->type).Strings[0x27]);\n  }\n  if ((cur_term->type).Strings[0x2a] != (char *)0x0) {\n    _nc_putp_sp(sp,\"exit_insert_mode\",(cur_term->type).Strings[0x2a]);\n  }\n  if (((cur_term->type).Strings[0x97] != (char *)0x0) &&\n     ((cur_term->type).Strings[0x98] != (char *)0x0)) {\n    if ((cur_term->type).Booleans[1] == '\\0') {\n      _nc_putp_sp(sp,\"exit_am_mode\",(cur_term->type).Strings[0x98]);\n    }\n    else {\n      _nc_putp_sp(sp,\"enter_am_mode\",(cur_term->type).Strings[0x97]);\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_screen_resume_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int yold,int xold,int ynew,int xnew)\n\n{\n  int iVar1;\n  int rc;\n  \n  iVar1 = _nc_real_mvcur(sp,yold,xold,ynew,xnew,_nc_outch_sp,1);\n  if ((sp != (SCREEN *)0x0) && (sp->_endwin == 0)) {\n    _nc_flush_sp(sp);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is _nc_mvcur_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](WINDOW *win,int y,int x,char *first,char *last,int echoed)\n\n{\n  short sVar1;\n  short sVar2;\n  int y_00;\n  int x_00;\n  char *local_38;\n  int y1;\n  int x1;\n  \n  local_38 = last;\n  if (first < last) {\n    local_38 = last + -1;\n    *local_38 = '\\0';\n    if (echoed != 0) {\n      sVar1 = win->_cury;\n      sVar2 = win->_curx;\n      wmove(win,y,x);\n      waddnstr(win,first,-1);\n      if (win == (WINDOW *)0x0) {\n        y_00 = -1;\n        x_00 = -1;\n      }\n      else {\n        y_00 = (int)win->_cury;\n        x_00 = (int)win->_curx;\n      }\n      while ((win->_cury < sVar1 || ((sVar1 == win->_cury && (win->_curx < sVar2))))) {\n        waddch(win,0x20);\n      }\n      wmove(win,y_00,x_00);\n    }\n  }\n  return local_38;\n}\n\n",
        "output": "The predicted function name is WipeOut"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *fmt,__va_list_tag *ap)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = _nc_printf_string_sp(SP,fmt,ap);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is _nc_printf_string"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  term_conflict *ptVar2;\n  int rc;\n  TERMINAL_conflict *termp;\n  \n  rc = -1;\n  ptVar2 = cur_term;\n  if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n    ptVar2 = sp->_term;\n  }\n  if ((ptVar2 != (term_conflict *)0x0) && (iVar1 = _nc_get_tty_mode(&ptVar2->Nttyb), iVar1 == 0)) {\n    (ptVar2->Nttyb).c_oflag = (ptVar2->Nttyb).c_oflag & 0xffffe7ff;\n    rc = 0;\n  }\n  return rc;\n}\n\n",
        "output": "The predicted function name is def_prog_mode_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchtype [MASK](SCREEN *sp,WINDOW *win)\n\n{\n  chtype blank;\n  \n  blank = 0x20;\n  if ((cur_term->type).Booleans[0x1c] != '\\0') {\n    if (win == sp->_curscr) {\n      win = sp->_stdscr;\n    }\n    blank = win->_bkgd & 0xff00 | 0x20;\n  }\n  return blank;\n}\n\n",
        "output": "The predicted function name is ClrBlank"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  short sVar1;\n  int iVar2;\n  _SLK *p_Var3;\n  int iVar4;\n  char *string;\n  int i;\n  int fmt;\n  int numlab;\n  SLK *slk;\n  \n  if (sp != (SCREEN *)0x0) {\n    p_Var3 = sp->_slk;\n    iVar2 = sp->slk_format;\n    sVar1 = (cur_term->type).Numbers[8];\n    if (p_Var3->hidden == false) {\n      for (i = 0; i < p_Var3->labcnt; i = i + 1) {\n        if ((p_Var3->dirty != false) || (p_Var3->ent[i].dirty != '\\0')) {\n          if (p_Var3->ent[i].visible != '\\0') {\n            if ((sVar1 < 1) || (2 < iVar2)) {\n              if (iVar2 == 4) {\n                slk_paint_info(p_Var3->win);\n              }\n              iVar4 = 3;\n              if (2 < iVar2) {\n                iVar4 = iVar2;\n              }\n              wmove(p_Var3->win,iVar4 + -3,p_Var3->ent[i].ent_x);\n              wattrset(p_Var3->win,p_Var3->attr & 0xffffff00);\n              waddnstr(p_Var3->win,p_Var3->ent[i].form_text,-1);\n              wattrset(p_Var3->win,sp->_stdscr->_attrs);\n            }\n            else if (i < (cur_term->type).Numbers[8]) {\n              string = tparm((cur_term->type).Strings[0x93],(long)(i + 1),p_Var3->ent[i].form_text);\n              _nc_putp_sp(sp,\"plab_norm\",string);\n            }\n          }\n          p_Var3->ent[i].dirty = '\\0';\n        }\n      }\n      p_Var3->dirty = false;\n      if (0 < sVar1) {\n        if (p_Var3->hidden == false) {\n          _nc_putp_sp(sp,\"label_on\",(cur_term->type).Strings[0x9c]);\n        }\n        else {\n          _nc_putp_sp(sp,\"label_off\",(cur_term->type).Strings[0x9d]);\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is slk_intern_refresh"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchtype [MASK](WINDOW *win,chtype ch)\n\n{\n  uint uVar1;\n  uint3 uVar2;\n  uint uVar3;\n  uint local_24;\n  int pair;\n  attr_t a;\n  \n  uVar1 = win->_attrs;\n  pair = ch >> 8 & 0xff;\n  if ((((ch & 0xff) == 0x20) && (ch >> 8 == 0)) && (pair == 0)) {\n    pair = win->_attrs >> 8 & 0xff;\n    if (pair == 0) {\n      pair = win->_bkgd >> 8 & 0xff;\n    }\n    local_24 = uVar1 & 0xff | win->_bkgd & 0xff |\n               (pair | ((win->_bkgd & 0xffffff00 | uVar1) & 0xffff00ff) >> 8) << 8;\n  }\n  else {\n    if ((uVar1 & 0xff00) == 0) {\n      uVar2 = 0xffffff;\n    }\n    else {\n      uVar2 = 0xffff00;\n    }\n    if ((pair == 0) && (pair = win->_attrs >> 8 & 0xff, pair == 0)) {\n      pair = win->_bkgd >> 8 & 0xff;\n    }\n    if ((ch & 0xff00) == 0) {\n      uVar3 = 0xffffffff;\n    }\n    else {\n      uVar3 = 0xffff00ff;\n    }\n    uVar1 = ch | uVar3 & (uVar1 | (uint)((uint3)(win->_bkgd >> 8) & uVar2) << 8);\n    local_24 = uVar1 & 0xff | (pair | (uVar1 & 0xffff00ff) >> 8) << 8;\n  }\n  return local_24;\n}\n\n",
        "output": "The predicted function name is render_char"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,int y,int n,int changed)\n\n{\n  int iVar1;\n  short sVar2;\n  int i;\n  \n  if ((((win == (WINDOW *)0x0) || (n < 0)) || (y < 0)) || (i = y, win->_maxy < y)) {\n    iVar1 = -1;\n  }\n  else {\n    for (; (i < n + y && (i <= win->_maxy)); i = i + 1) {\n      if (changed == 0) {\n        sVar2 = -1;\n      }\n      else {\n        sVar2 = 0;\n      }\n      win->_line[i].firstchar = sVar2;\n      if (changed == 0) {\n        sVar2 = -1;\n      }\n      else {\n        sVar2 = win->_maxx;\n      }\n      win->_line[i].lastchar = sVar2;\n    }\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is wtouchln"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,_Bool bf)\n\n{\n  int iVar1;\n  \n  if (win == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    win->_sync = bf;\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is syncok"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *filename,TERMTYPE *ptr)\n\n{\n  long lVar1;\n  int iVar2;\n  FILE *__stream;\n  size_t sVar3;\n  long in_FS_OFFSET;\n  int code;\n  int limit;\n  FILE *fp;\n  char buffer [4097];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar2 = _nc_access(filename,4);\n  if (-1 < iVar2) {\n    __stream = fopen(filename,\"rb\");\n    if (__stream != (FILE *)0x0) {\n      sVar3 = fread(buffer,1,0x1001,__stream);\n      if ((int)sVar3 < 1) {\n        code = 0;\n      }\n      else {\n        code = _nc_read_termtype(ptr,buffer,(int)sVar3);\n        if (code == 0) {\n          _nc_free_termtype(ptr);\n        }\n      }\n      fclose(__stream);\n      goto LAB_0002a513;\n    }\n  }\n  code = 0;\nLAB_0002a513:\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is _nc_read_file_entry"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,char *str)\n\n{\n  int code;\n  \n  code = -1;\n  if ((sp != (SCREEN *)0x0) && (str != (char *)0x0)) {\n    code = find_definition(sp->_keytry,str);\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is key_defined_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char **source)\n\n{\n  uint uVar1;\n  int result;\n  int nibble;\n  int ch;\n  \n  result = 0;\n  nibble = 0;\n  do {\n    if (1 < nibble) {\n      return result;\n    }\n    uVar1 = (uint)(byte)**source;\n    *source = *source + 1;\n    if ((uVar1 < 0x30) || (0x39 < uVar1)) {\n      if ((uVar1 < 0x41) || (0x46 < uVar1)) {\n        if ((uVar1 < 0x61) || (0x66 < uVar1)) {\n          return -1;\n        }\n        ch = uVar1 - 0x57;\n      }\n      else {\n        ch = uVar1 - 0x37;\n      }\n    }\n    else {\n      ch = uVar1 - 0x30;\n    }\n    result = result << 4 | ch;\n    nibble = nibble + 1;\n  } while( true );\n}\n\n",
        "output": "The predicted function name is decode_hex"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  _nc_scroll_optimize_sp(SP);\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_scroll_optimize"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int old_pair,int pair,int reverse,NCURSES_OUTC *outc)\n\n{\n  long in_FS_OFFSET;\n  SCREEN *sp;\n  screen outc_wrapper;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  sp = SP;\n  if (SP == (SCREEN *)0x0) {\n    sp = &outc_wrapper;\n    memset(sp,0,0x608);\n    outc_wrapper._outch = _nc_outc_wrapper;\n  }\n  sp->jump = outc;\n  _nc_do_color_sp(SP,old_pair,pair,reverse,_nc_outc_wrapper);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_do_color"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int keycode)\n\n{\n  int iVar1;\n  \n  iVar1 = has_key_sp(SP,keycode);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is has_key"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](SCREEN *sp)\n\n{\n  bool bVar1;\n  _Bool code;\n  \n  code = false;\n  if (sp == (SCREEN *)0x0) {\n    bVar1 = cur_term != (term_conflict *)0x0;\n  }\n  else if (sp->_term == (TERMINAL_conflict *)0x0) {\n    bVar1 = cur_term != (term_conflict *)0x0;\n  }\n  else {\n    bVar1 = sp->_term != (TERMINAL_conflict *)0x0;\n  }\n  if (bVar1) {\n    if ((((cur_term->type).Strings[0x35] == (char *)0x0) &&\n        ((cur_term->type).Strings[0x6e] == (char *)0x0)) ||\n       (((cur_term->type).Strings[0x16] == (char *)0x0 &&\n        ((cur_term->type).Strings[0x6a] == (char *)0x0)))) {\n      code = false;\n    }\n    else {\n      code = true;\n    }\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is has_il_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](TPARM_STATE *tps,char *message)\n\n{\n  _nc_tparm_err = _nc_tparm_err + 1;\n  return _nc_tparm_err;\n}\n\n",
        "output": "The predicted function name is tparm_error"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](SCREEN *sp,MEVENT *eventp)\n\n{\n  long lVar1;\n  _Bool _Var2;\n  uint uVar3;\n  int iVar4;\n  long in_FS_OFFSET;\n  _Bool result;\n  int b3;\n  int b;\n  int wheel;\n  mmask_t pressed;\n  mmask_t release;\n  SGR_DATA data;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  result = false;\n  _Var2 = read_SGR(sp,&data);\n  if (_Var2 != false) {\n    b3 = (data.params[0] & 3U) + 1;\n    if (data.params[0] < 0x84) {\n      if (data.params[0] < 0x80) {\n        if (0x3f < data.params[0]) {\n          b3 = data.params[0] + -0x3c;\n        }\n      }\n      else {\n        b3 = data.params[0] + -0x78;\n      }\n    }\n    else {\n      b3 = 6;\n    }\n    eventp->id = 0;\n    if (data.final == 0x4d) {\n      handle_wheel(sp,eventp,data.params[0],(uint)((data.params[0] & 0x40U) != 0));\n    }\n    else if (b3 < 6) {\n      uVar3 = (uint)(2 << (((char)b3 + -1) * '\\x05' & 0x3fU));\n      if ((sp->_mouse_bstate & uVar3) == 0) {\n        eventp->bstate = 0x10000000;\n      }\n      else {\n        eventp->bstate = (mmask_t)(1 << (((char)b3 + -1) * '\\x05' & 0x3fU));\n        sp->_mouse_bstate = ~uVar3 & sp->_mouse_bstate;\n      }\n    }\n    else {\n      eventp->bstate = 0x10000000;\n    }\n    if ((data.params[0] & 4U) != 0) {\n      eventp->bstate = eventp->bstate | 0x4000000;\n    }\n    if ((data.params[0] & 8U) != 0) {\n      eventp->bstate = eventp->bstate | 0x8000000;\n    }\n    if ((data.params[0] & 0x10U) != 0) {\n      eventp->bstate = eventp->bstate | 0x2000000;\n    }\n    result = ((long)(ulong)eventp->bstate >> 0x1c & 1U) != 0;\n    if (data.params[1] == 0) {\n      iVar4 = 0;\n    }\n    else {\n      iVar4 = data.params[1] + -1;\n    }\n    eventp->x = iVar4;\n    if (data.params[2] == 0) {\n      iVar4 = 0;\n    }\n    else {\n      iVar4 = data.params[2] + -1;\n    }\n    eventp->y = iVar4;\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is decode_xterm_SGR1006"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,chtype ch,int n)\n\n{\n  int iVar1;\n  chtype cVar2;\n  ldat *plVar3;\n  int code;\n  chtype wch;\n  int end;\n  int start;\n  ldat *line;\n  \n  code = -1;\n  if (win != (WINDOW *)0x0) {\n    plVar3 = win->_line + win->_cury;\n    iVar1 = (int)win->_curx;\n    end = n + iVar1 + -1;\n    if (win->_maxx < end) {\n      end = (int)win->_maxx;\n    }\n    if ((plVar3->firstchar == -1) || (iVar1 < plVar3->firstchar)) {\n      plVar3->firstchar = win->_curx;\n    }\n    if ((plVar3->lastchar == -1) || (plVar3->lastchar < end)) {\n      plVar3->lastchar = (short)end;\n    }\n    wch = ch;\n    if (ch == 0) {\n      wch = acs_map._452_4_;\n    }\n    cVar2 = _nc_render(win,wch);\n    for (; iVar1 <= end; end = end + -1) {\n      plVar3->text[end] = cVar2;\n    }\n    _nc_synchook(win);\n    code = 0;\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is whline"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](void)\n\n{\n  char *__s;\n  size_t sVar1;\n  char *result;\n  char *home;\n  size_t want;\n  \n  if (_nc_globals.home_terminfo == (char *)0x0) {\n    __s = getenv(\"HOME\");\n    if (__s != (char *)0x0) {\n      sVar1 = strlen(__s);\n      _nc_globals.home_terminfo = (char *)malloc(sVar1 + 0xd);\n      if (_nc_globals.home_terminfo == (char *)0x0) {\n                    /* WARNING: Subroutine does not return */\n        _nc_err_abort(\"Out of memory\");\n      }\n      sprintf(_nc_globals.home_terminfo,\"%s/.terminfo\",__s);\n    }\n  }\n  return _nc_globals.home_terminfo;\n}\n\n",
        "output": "The predicted function name is _nc_home_terminfo"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  _Bool _Var1;\n  char *pcVar2;\n  _Bool no_padding;\n  \n  pcVar2 = getenv(\"NCURSES_NO_PADDING\");\n  _Var1 = pcVar2 != (char *)0x0;\n  if (sp != (SCREEN *)0x0) {\n    sp->_no_padding = pcVar2 != (char *)0x0;\n    _Var1 = _nc_prescreen._no_padding;\n  }\n  _nc_prescreen._no_padding = _Var1;\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_set_no_padding"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *z)\n\n{\n  int iVar1;\n  \n  iVar1 = waddnstr(stdscr,z,-1);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is addstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](chtype z)\n\n{\n  int iVar1;\n  \n  iVar1 = wbkgd(stdscr,z);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is bkgd"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *fmt,...)\n\n{\n  long lVar1;\n  char in_AL;\n  undefined8 in_RCX;\n  undefined8 in_RDX;\n  undefined8 in_RSI;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  va_list argp;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  local_b0 = in_RSI;\n  local_a8 = in_RDX;\n  local_a0 = in_RCX;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  if (_nc_suppress_warnings == false) {\n    where_is_problem();\n    argp[0].gp_offset = 8;\n    argp[0].fp_offset = 0x30;\n    argp[0].overflow_arg_area = &stack0x00000008;\n    argp[0].reg_save_area = local_b8;\n    vfprintf(stderr,fmt,argp);\n    fputc(10,stderr);\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_warning"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](void *oldp,size_t amount)\n\n{\n  int *piVar1;\n  void *newp;\n  \n  if (oldp == (void *)0x0) {\n    newp = malloc(amount);\n  }\n  else if (amount == 0) {\n    free(oldp);\n    newp = (void *)0x0;\n  }\n  else {\n    newp = realloc(oldp,amount);\n    if (newp == (void *)0x0) {\n      free(oldp);\n      piVar1 = __errno_location();\n      *piVar1 = 0xc;\n    }\n  }\n  return newp;\n}\n\n",
        "output": "The predicted function name is _nc_doalloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,int *a2,int *z)\n\n{\n  int iVar1;\n  \n  if (a1 == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    *a2 = (int)a1->_regtop;\n    *z = (int)a1->_regbottom;\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is wgetscrreg"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,char *z)\n\n{\n  int iVar1;\n  \n  iVar1 = winsnstr(a1,z,-1);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is winsstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int n,int top,int bot,int maxy)\n\n{\n  bool bVar1;\n  int iVar2;\n  chtype blank_00;\n  char *pcVar3;\n  _Bool cursor_saved;\n  int i;\n  int res;\n  chtype blank;\n  \n  bVar1 = false;\n  if (((sp == (SCREEN *)0x0) || (sp->_term == (TERMINAL_conflict *)0x0)) ||\n     ((sp != (SCREEN *)0x0 && (sp->_prescreen != false)))) {\n    iVar2 = -1;\n  }\n  else {\n    blank_00 = ClrBlank(sp,sp->_stdscr);\n    if (n < 1) {\n      res = scroll_csr_backward(sp,-n,top,bot,0,maxy,blank_00);\n      if ((res == -1) && ((cur_term->type).Strings[3] != (char *)0x0)) {\n        if ((top != 0) &&\n           ((((top == sp->_cursrow || (sp->_cursrow == top + -1)) &&\n             ((cur_term->type).Strings[0x80] != (char *)0x0)) &&\n            ((cur_term->type).Strings[0x7e] != (char *)0x0)))) {\n          bVar1 = true;\n          _nc_putp_sp(sp,\"save_cursor\",(cur_term->type).Strings[0x80]);\n        }\n        pcVar3 = _nc_tiparm(2,(cur_term->type).Strings[3],(ulong)(uint)top);\n        _nc_putp_sp(sp,\"change_scroll_region\",pcVar3);\n        if (bVar1) {\n          _nc_putp_sp(sp,\"restore_cursor\",(cur_term->type).Strings[0x7e]);\n        }\n        else {\n          sp->_curscol = -1;\n          sp->_cursrow = sp->_curscol;\n        }\n        res = scroll_csr_backward(sp,-n,top,bot,top,bot,blank_00);\n        pcVar3 = _nc_tiparm(2,(cur_term->type).Strings[3],0);\n        _nc_putp_sp(sp,\"change_scroll_region\",pcVar3);\n        sp->_curscol = -1;\n        sp->_cursrow = sp->_curscol;\n      }\n      if ((res == -1) && (sp->_nc_sp_idlok != false)) {\n        res = scroll_idl(sp,-n,n + bot + 1,top,blank_00);\n      }\n      if ((res != -1) &&\n         (((cur_term->type).Booleans[0x1a] != '\\0' ||\n          (((cur_term->type).Booleans[0xb] != '\\0' && (top == 0)))))) {\n        for (i = 0; SBORROW4(i,-n) != i + n < 0; i = i + 1) {\n          GoTo(sp,i + top,0);\n          ClrToEOL(sp,_nc_scrolln_sp::lexical_block_1::blank2,0);\n        }\n      }\n    }\n    else {\n      res = scroll_csr_forward(sp,n,top,bot,0,maxy,blank_00);\n      if ((res == -1) && ((cur_term->type).Strings[3] != (char *)0x0)) {\n        if ((((n == 1) && ((cur_term->type).Strings[0x81] != (char *)0x0)) ||\n            ((cur_term->type).Strings[0x6d] != (char *)0x0)) &&\n           ((((bot == sp->_cursrow || (sp->_cursrow == bot + -1)) &&\n             ((cur_term->type).Strings[0x80] != (char *)0x0)) &&\n            ((cur_term->type).Strings[0x7e] != (char *)0x0)))) {\n          bVar1 = true;\n          _nc_putp_sp(sp,\"save_cursor\",(cur_term->type).Strings[0x80]);\n        }\n        pcVar3 = _nc_tiparm(2,(cur_term->type).Strings[3],(ulong)(uint)top);\n        _nc_putp_sp(sp,\"change_scroll_region\",pcVar3);\n        if (bVar1) {\n          _nc_putp_sp(sp,\"restore_cursor\",(cur_term->type).Strings[0x7e]);\n        }\n        else {\n          sp->_curscol = -1;\n          sp->_cursrow = sp->_curscol;\n        }\n        res = scroll_csr_forward(sp,n,top,bot,top,bot,blank_00);\n        pcVar3 = _nc_tiparm(2,(cur_term->type).Strings[3],0);\n        _nc_putp_sp(sp,\"change_scroll_region\",pcVar3);\n        sp->_curscol = -1;\n        sp->_cursrow = sp->_curscol;\n      }\n      if ((res == -1) && (sp->_nc_sp_idlok != false)) {\n        res = scroll_idl(sp,n,top,(bot - n) + 1,blank_00);\n      }\n      if ((res != -1) &&\n         (((cur_term->type).Booleans[0x1a] != '\\0' ||\n          (((cur_term->type).Booleans[0xc] != '\\0' && (bot == maxy)))))) {\n        if ((bot == maxy) && ((cur_term->type).Strings[7] != (char *)0x0)) {\n          GoTo(sp,(bot - n) + 1,0);\n          ClrToEOS(sp,_nc_scrolln_sp::lexical_block_0::blank2);\n        }\n        else {\n          for (i = 0; i < n; i = i + 1) {\n            GoTo(sp,bot - i,0);\n            ClrToEOL(sp,_nc_scrolln_sp::lexical_block_0::blank2,0);\n          }\n        }\n      }\n    }\n    if (res == -1) {\n      iVar2 = -1;\n    }\n    else {\n      _nc_scroll_window(sp->_curscr,n,(int)(short)top,(int)(short)bot,blank_00);\n      _nc_scroll_oldhash_sp(sp,n,top,bot);\n      iVar2 = 0;\n    }\n  }\n  return iVar2;\n}\n\n",
        "output": "The predicted function name is _nc_scrolln_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  \n  if (sp == (SCREEN *)0x0) {\n    iVar1 = -1;\n  }\n  else if (sp->_slk == (_SLK *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    sp->_slk->hidden = false;\n    sp->_slk->dirty = true;\n    iVar1 = slk_refresh_sp(sp);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is slk_restore_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *z)\n\n{\n  int iVar1;\n  \n  if (z == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = z->_maxy + 1;\n  }\n  iVar1 = wredrawln(z,0,iVar1);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is redrawwin"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,chtype *to)\n\n{\n  chtype *local_28;\n  int cost;\n  int i;\n  chtype blank;\n  \n  cost = 0;\n  blank = 0x20;\n  if ((cur_term->type).Booleans[0x1c] != '\\0') {\n    blank = (stdscr->_bkgd >> 8 & 0xff) << 8 | 0x20;\n  }\n  local_28 = to;\n  for (i = sp->_curscr->_maxx + 1; 0 < i; i = i + -1) {\n    if (blank != *local_28) {\n      cost = cost + 1;\n    }\n    local_28 = local_28 + 1;\n  }\n  return cost;\n}\n\n",
        "output": "The predicted function name is update_cost_from_blank"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,short pair_arg,void *opts)\n\n{\n  int code;\n  int color_pair;\n  \n  code = -1;\n  color_pair = (int)pair_arg;\n  if (opts != (void *)0x0) {\n    color_pair = -1;\n  }\n  if ((((win != (WINDOW *)0x0) && (SP != (SCREEN *)0x0)) && (-1 < color_pair)) &&\n     (color_pair < SP->_pair_limit)) {\n    win->_attrs = win->_attrs & 0xffff00ff;\n    win->_attrs = win->_attrs | (color_pair & 0xffU) << 8;\n    code = 0;\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is wcolor_set"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  uint uVar1;\n  SCREEN *scan;\n  \n  if (_nc_globals.have_sigwinch != 0) {\n    _nc_globals.have_sigwinch = 0;\n    for (scan = _nc_screen_chain; scan != (SCREEN *)0x0; scan = scan->_next_screen) {\n      scan->_sig_winch = true;\n    }\n  }\n  if (sp == (SCREEN *)0x0) {\n    uVar1 = 0;\n  }\n  else {\n    uVar1 = (uint)sp->_sig_winch;\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is _nc_handle_sigwinch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *str)\n\n{\n  int iVar1;\n  \n  iVar1 = tigetnum_sp(SP,str);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is tigetnum"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,char *z)\n\n{\n  int iVar1;\n  \n  iVar1 = wgetnstr(a1,z,-1);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is wgetstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *stwin,int cols)\n\n{\n  short sVar1;\n  short sVar2;\n  int iVar3;\n  SCREEN *sp_00;\n  _SLK *p_Var4;\n  slk_ent *psVar5;\n  size_t __n;\n  size_t amount;\n  char *pcVar6;\n  int i;\n  int res;\n  int numlab;\n  SCREEN *sp;\n  size_t max_length;\n  size_t used;\n  \n  sp_00 = _nc_screen_of(stwin);\n  if (sp_00 == (SCREEN *)0x0) {\n    iVar3 = -1;\n  }\n  else {\n    sVar2 = (cur_term->type).Numbers[8];\n    if (sp_00->_slk == (_SLK *)0x0) {\n      p_Var4 = (_SLK *)calloc(1,0x28);\n      sp_00->_slk = p_Var4;\n      if (sp_00->_slk == (_SLK *)0x0) {\n        iVar3 = -1;\n      }\n      else {\n        if (sp_00->slk_format == 0) {\n          sp_00->slk_format = _nc_globals.slk_format;\n        }\n        if (((cur_term->type).Numbers[0xf] & 1U) == 0) {\n          sp_00->_slk->attr = sp_00->_slk->attr & 0xff | 0x10000;\n        }\n        else {\n          sp_00->_slk->attr = sp_00->_slk->attr & 0xff | 0x40000;\n        }\n        sVar1 = sVar2;\n        if (sVar2 < 1) {\n          if (sp_00->slk_format < 3) {\n            sVar1 = 8;\n          }\n          else {\n            sVar1 = 0xc;\n          }\n        }\n        sp_00->_slk->maxlab = sVar1;\n        if (sVar2 < 1) {\n          if (sp_00->slk_format < 3) {\n            sVar2 = 8;\n          }\n          else {\n            sVar2 = 5;\n          }\n        }\n        else {\n          sVar2 = (cur_term->type).Numbers[9] * (cur_term->type).Numbers[10];\n        }\n        sp_00->_slk->maxlen = sVar2;\n        if (sp_00->slk_format < 3) {\n          sVar2 = 8;\n        }\n        else {\n          sVar2 = 0xc;\n        }\n        if (sp_00->_slk->maxlab < sVar2) {\n          if (sp_00->slk_format < 3) {\n            sVar2 = 8;\n          }\n          else {\n            sVar2 = 0xc;\n          }\n        }\n        else {\n          sVar2 = sp_00->_slk->maxlab;\n        }\n        sp_00->_slk->labcnt = sVar2;\n        if ((0 < sp_00->_slk->maxlen) && (0 < sp_00->_slk->labcnt)) {\n          p_Var4 = sp_00->_slk;\n          psVar5 = (slk_ent *)calloc((long)sp_00->_slk->labcnt,0x18);\n          p_Var4->ent = psVar5;\n          if (p_Var4->ent != (slk_ent *)0x0) {\n            __n = (size_t)sp_00->_slk->maxlen;\n            i = 0;\n            while( true ) {\n              if (sp_00->_slk->labcnt <= i) {\n                iVar3 = _nc_format_slks(sp_00,cols);\n                p_Var4 = sp_00->_slk;\n                p_Var4->win = stwin;\n                if (p_Var4->win == (WINDOW *)0x0) {\n                  iVar3 = slk_failed(sp_00);\n                  return iVar3;\n                }\n                _nc_globals.slk_format = 0;\n                return iVar3;\n              }\n              amount = __n + 1;\n              psVar5 = sp_00->_slk->ent;\n              pcVar6 = (char *)_nc_doalloc((void *)0x0,amount);\n              psVar5[i].ent_text = pcVar6;\n              if (sp_00->_slk->ent[i].ent_text == (char *)0x0) {\n                iVar3 = slk_failed(sp_00);\n                return iVar3;\n              }\n              memset(sp_00->_slk->ent[i].ent_text,0,amount);\n              psVar5 = sp_00->_slk->ent;\n              pcVar6 = (char *)_nc_doalloc((void *)0x0,amount);\n              psVar5[i].form_text = pcVar6;\n              if (sp_00->_slk->ent[i].form_text == (char *)0x0) break;\n              if (1 < amount) {\n                memset(sp_00->_slk->ent[i].form_text,0x20,__n);\n              }\n              sp_00->_slk->ent[i].form_text[__n] = '\\0';\n              sp_00->_slk->ent[i].visible = i < sp_00->_slk->maxlab;\n              i = i + 1;\n            }\n            iVar3 = slk_failed(sp_00);\n            return iVar3;\n          }\n        }\n        iVar3 = slk_failed(sp_00);\n      }\n    }\n    else {\n      iVar3 = 0;\n    }\n  }\n  return iVar3;\n}\n\n",
        "output": "The predicted function name is _nc_slk_initialize"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,chtype *astr,int n)\n\n{\n  short sVar1;\n  int iVar2;\n  ldat *plVar3;\n  int local_3c;\n  short y;\n  short x;\n  int i;\n  int code;\n  chtype *str;\n  ldat *line;\n  \n  if ((win == (WINDOW *)0x0) || (astr == (chtype *)0x0)) {\n    iVar2 = -1;\n  }\n  else {\n    sVar1 = win->_curx;\n    local_3c = n;\n    if (n < 0) {\n      local_3c = 0;\n      for (str = astr; *str != 0; str = str + 1) {\n        local_3c = local_3c + 1;\n      }\n    }\n    if (((int)win->_maxx - (int)sVar1) + 1 < local_3c) {\n      local_3c = ((int)win->_maxx - (int)sVar1) + 1;\n    }\n    if (local_3c == 0) {\n      iVar2 = 0;\n    }\n    else {\n      plVar3 = win->_line + win->_cury;\n      i = 0;\n      while ((i < local_3c && ((astr[i] & 0xff) != 0))) {\n        plVar3->text[i + sVar1] = astr[i];\n        i = i + 1;\n      }\n      if ((plVar3->firstchar == -1) || (sVar1 < plVar3->firstchar)) {\n        plVar3->firstchar = sVar1;\n      }\n      if ((plVar3->lastchar == -1) || (plVar3->lastchar < (short)(sVar1 + (short)local_3c + -1))) {\n        plVar3->lastchar = sVar1 + (short)local_3c + -1;\n      }\n      _nc_synchook(win);\n      iVar2 = 0;\n    }\n  }\n  return iVar2;\n}\n\n",
        "output": "The predicted function name is waddchnstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *z)\n\n{\n  attr_t aVar1;\n  \n  if (z == (WINDOW *)0x0) {\n    aVar1 = 0;\n  }\n  else {\n    aVar1 = z->_attrs;\n  }\n  return aVar1;\n}\n\n",
        "output": "The predicted function name is getattrs"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,termios *buf)\n\n{\n  int iVar1;\n  term_conflict *ptVar2;\n  int *piVar3;\n  int result;\n  TERMINAL_conflict *termp;\n  \n  if ((buf != (termios *)0x0) && (sp != (SCREEN *)0x0)) {\n    ptVar2 = cur_term;\n    if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n      ptVar2 = sp->_term;\n    }\n    if (ptVar2 != (term_conflict *)0x0) {\n      do {\n        iVar1 = tcsetattr((int)ptVar2->Filedes,1,(termios *)buf);\n        if (iVar1 == 0) {\n          return 0;\n        }\n        piVar3 = __errno_location();\n      } while (*piVar3 == 4);\n      piVar3 = __errno_location();\n      if ((*piVar3 == 0x19) && (sp != (SCREEN *)0x0)) {\n        sp->_notty = true;\n      }\n    }\n  }\n  return -1;\n}\n\n",
        "output": "The predicted function name is _nc_set_tty_mode_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *path)\n\n{\n  char *pcVar1;\n  char *envp;\n  \n  if (_nc_globals.keep_tic_directory != true) {\n    if (path == (char *)0x0) {\n      if ((_nc_globals.have_tic_directory != true) &&\n         (pcVar1 = getenv(\"TERMINFO\"), pcVar1 != (char *)0x0)) {\n        pcVar1 = _nc_tic_dir(pcVar1);\n        return pcVar1;\n      }\n    }\n    else {\n      _nc_globals.have_tic_directory = true;\n      _nc_globals.tic_directory = path;\n    }\n  }\n  pcVar1 = _nc_globals.tic_directory;\n  if (_nc_globals.tic_directory == (char *)0x0) {\n    pcVar1 = \n    \"/home/xin/Downloads/gnu_projects/compilation/x86_64/O0/compile_projects_copy/ncurses-6.3/build/share/terminfo\"\n    ;\n  }\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is _nc_tic_dir"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](SCREEN *sp)\n\n{\n  MEVENT *eventp_00;\n  MEVENT *pMVar1;\n  _Bool result;\n  int b;\n  MEVENT *eventp;\n  \n  result = false;\n  eventp_00 = sp->_mouse_eventp;\n  if (sp->_mouse_type == M_XTERM) {\n    if (sp->_mouse_format == MF_X10) {\n      result = decode_xterm_X10(sp,eventp_00);\n    }\n    else if (sp->_mouse_format == MF_SGR1006) {\n      result = decode_xterm_SGR1006(sp,eventp_00);\n    }\n    if (eventp_00 < sp->_mouse_events + 7) {\n      pMVar1 = eventp_00 + 1;\n    }\n    else {\n      pMVar1 = sp->_mouse_events;\n    }\n    sp->_mouse_eventp = pMVar1;\n    if ((result != true) && ((eventp_00->bstate & 0x210842) != 0)) {\n      for (b = 4; b < 6; b = b + 1) {\n        if ((2 << (((char)b + -1) * '\\x05' & 0x1fU) & eventp_00->bstate) != 0) {\n          return true;\n        }\n      }\n    }\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is _nc_mouse_inline"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  _nc_prescreen.filter_mode = false;\n  return;\n}\n\n",
        "output": "The predicted function name is nofilter"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](SCREEN *sp)\n\n{\n  _Bool _Var1;\n  int result;\n  \n  _Var1 = false;\n  if (((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) &&\n     ((cur_term->type).Booleans[0x1b] != '\\0')) {\n    _Var1 = true;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is can_change_color_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,int a2,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(a1,a2,z);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = wgetch(a1);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvwgetch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp,int old_pair,int pair,int reverse,NCURSES_OUTC_sp *outc)\n\n{\n  int iVar1;\n  char *string;\n  long in_FS_OFFSET;\n  int fg;\n  int bg;\n  int old_fg;\n  int old_bg;\n  int xx;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  fg = -1;\n  bg = -1;\n  old_fg = -1;\n  old_bg = -1;\n  if ((((sp == (SCREEN *)0x0) || (pair < 0)) || (sp->_pair_limit <= pair)) || (sp->_coloron == 0))\n  goto LAB_0000b84c;\n  if (pair != 0) {\n    if ((cur_term->type).Strings[0x12d] != (char *)0x0) {\n      string = _nc_tiparm(1,(cur_term->type).Strings[0x12d],(ulong)(uint)pair);\n      tputs_sp(sp,string,1,outc);\n      goto LAB_0000b84c;\n    }\n    if ((sp != (SCREEN *)0x0) && (iVar1 = _nc_pair_content(sp,pair,&fg,&bg), iVar1 == -1))\n    goto LAB_0000b84c;\n  }\n  if ((old_pair < 0) ||\n     ((sp == (SCREEN *)0x0 || (iVar1 = _nc_pair_content(sp,old_pair,&old_fg,&old_bg), iVar1 == -1)))\n     ) {\n    reset_color_pair(sp);\n    if ((old_pair < 0) && (pair < 1)) goto LAB_0000b84c;\n  }\n  else if (((fg < 0) && (-1 < old_fg)) || ((bg < 0 && (-1 < old_bg)))) {\n    if (((sp->_has_sgr_39_49 == false) || (-1 < old_bg)) || (old_fg < 0)) {\n      if (((sp->_has_sgr_39_49 == false) || (-1 < old_fg)) || (old_bg < 0)) {\n        reset_color_pair(sp);\n      }\n      else {\n        tputs_sp(sp,\"\\x1b[49m\",1,outc);\n      }\n    }\n    else {\n      tputs_sp(sp,\"\\x1b[39m\",1,outc);\n    }\n  }\n  if (fg < 0) {\n    fg = default_fg(sp);\n  }\n  if (bg < 0) {\n    bg = default_bg(sp);\n  }\n  iVar1 = fg;\n  if (reverse != 0) {\n    xx = fg;\n    fg = bg;\n    bg = iVar1;\n  }\n  if (-1 < fg) {\n    set_foreground_color(sp,fg,outc);\n  }\n  if (-1 < bg) {\n    set_background_color(sp,bg,outc);\n  }\nLAB_0000b84c:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is _nc_do_color_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,char *string)\n\n{\n  int iVar1;\n  \n  iVar1 = tputs_sp(sp,string,1,_nc_putchar_sp);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is putp_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *path)\n\n{\n  char *pcVar1;\n  char *result;\n  \n  pcVar1 = _nc_basename(path);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is _nc_rootname"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int ToLines,int ToCols,int stolen)\n\n{\n  bool bVar1;\n  int iVar2;\n  _Bool found;\n  int depth;\n  _win_list *wp;\n  WINDOW *win;\n  \n  depth = 0;\n  do {\n    bVar1 = false;\n    for (wp = _nc_globals._nc_windowlist; wp != (_win_list *)0x0; wp = wp->next) {\n      if ((((wp->win)._flags & 0x10U) == 0) && (iVar2 = child_depth(&wp->win), depth == iVar2)) {\n        bVar1 = true;\n        iVar2 = adjust_window(&wp->win,ToLines,ToCols,stolen);\n        if (iVar2 != 0) {\n          return -1;\n        }\n      }\n    }\n    depth = depth + 1;\n  } while (bVar1);\n  return 0;\n}\n\n",
        "output": "The predicted function name is decrease_size"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *z)\n\n{\n  int iVar1;\n  \n  iVar1 = winsnstr(stdscr,z,-1);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is insstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *cmp)\n\n{\n  int iVar1;\n  int depth;\n  _win_list *wp;\n  WINDOW *tst;\n  \n  if (cmp != (WINDOW *)0x0) {\n    for (wp = _nc_globals._nc_windowlist; wp != (_win_list *)0x0; wp = wp->next) {\n      if (cmp == (wp->win)._parent) {\n        iVar1 = child_depth(&wp->win);\n        return iVar1 + 1;\n      }\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is child_depth"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int total)\n\n{\n  chtype ch;\n  _Bool _Var1;\n  int iVar2;\n  int iVar3;\n  bool bVar4;\n  _Bool ok;\n  int top;\n  int row;\n  int col;\n  int last;\n  chtype blank;\n  \n  iVar3 = sp->_newscr->_maxx + 1;\n  iVar2 = (int)sp->_columns;\n  if (iVar3 < sp->_columns) {\n    iVar2 = iVar3;\n  }\n  ch = sp->_newscr->_line[(long)total + -1].text[(long)iVar2 + -1];\n  top = total;\n  if (((cur_term->type).Strings[7] != (char *)0x0) &&\n     (_Var1 = can_clear_with(sp,ch), _Var1 != false)) {\n    for (row = total + -1; -1 < row; row = row + -1) {\n      bVar4 = true;\n      for (col = 0; (bVar4 && (col < iVar2)); col = col + 1) {\n        bVar4 = ch == sp->_newscr->_line[row].text[col];\n      }\n      if (!bVar4) break;\n      for (col = 0; (bVar4 && (col < iVar2)); col = col + 1) {\n        bVar4 = ch == sp->_curscr->_line[row].text[col];\n      }\n      if (!bVar4) {\n        top = row;\n      }\n    }\n    if (top < total) {\n      GoTo(sp,top,0);\n      ClrToEOS(sp,ch);\n      if ((sp->oldhash != (ulong *)0x0) && (sp->newhash != (ulong *)0x0)) {\n        for (row = top; row < sp->_lines; row = row + 1) {\n          sp->oldhash[row] = sp->newhash[row];\n        }\n      }\n    }\n  }\n  return top;\n}\n\n",
        "output": "The predicted function name is ClrBottom"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *fmt,...)\n\n{\n  long lVar1;\n  char in_AL;\n  int iVar2;\n  undefined8 in_RCX;\n  undefined8 in_RDX;\n  undefined8 in_RSI;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  int code;\n  va_list argp;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  argp[0].gp_offset = 8;\n  argp[0].fp_offset = 0x30;\n  argp[0].overflow_arg_area = &stack0x00000008;\n  argp[0].reg_save_area = local_b8;\n  local_b0 = in_RSI;\n  local_a8 = in_RDX;\n  local_a0 = in_RCX;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  iVar2 = vw_printw(stdscr,fmt,argp);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar2;\n}\n\n",
        "output": "The predicted function name is printw"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int a1,int a2,char *a3,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(stdscr,a1,a2);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = winnstr(stdscr,a3,z);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvinnstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp,chtype blank)\n\n{\n  int3 iVar1;\n  bool bVar2;\n  _Bool fast_clear;\n  int i;\n  int j;\n  \n  if ((((cur_term->type).Strings[5] == (char *)0x0) && ((cur_term->type).Strings[7] == (char *)0x0))\n     && ((cur_term->type).Strings[6] == (char *)0x0)) {\n    bVar2 = false;\n  }\n  else {\n    bVar2 = true;\n  }\n  if ((sp->_coloron != 0) && (sp->_default_color != true)) {\n    _nc_do_color_sp(sp,(int)(short)(*sp->_current_attr >> 8) & 0xff,0,0,_nc_outch_sp);\n    if ((cur_term->type).Booleans[0x1c] == '\\0') {\n      bVar2 = false;\n    }\n  }\n  iVar1 = (int3)(blank >> 8);\n  if (bVar2) {\n    if ((cur_term->type).Strings[5] == (char *)0x0) {\n      if ((cur_term->type).Strings[7] == (char *)0x0) {\n        if ((cur_term->type).Strings[6] != (char *)0x0) {\n          sp->_curscol = -1;\n          sp->_cursrow = sp->_curscol;\n          if ((int3)(*sp->_current_attr >> 8) != iVar1) {\n            vidputs_sp(sp,blank & 0xffffff00,_nc_outch_sp);\n          }\n          for (i = 0; i < sp->_lines; i = i + 1) {\n            GoTo(sp,i,0);\n            _nc_putp_sp(sp,\"clr_eol\",(cur_term->type).Strings[6]);\n          }\n          GoTo(sp,0,0);\n        }\n      }\n      else {\n        sp->_curscol = -1;\n        sp->_cursrow = sp->_curscol;\n        GoTo(sp,0,0);\n        if ((int3)(*sp->_current_attr >> 8) != iVar1) {\n          vidputs_sp(sp,blank & 0xffffff00,_nc_outch_sp);\n        }\n        tputs_sp(sp,(cur_term->type).Strings[7],(int)sp->_lines,_nc_outch_sp);\n      }\n    }\n    else {\n      if ((int3)(*sp->_current_attr >> 8) != iVar1) {\n        vidputs_sp(sp,blank & 0xffffff00,_nc_outch_sp);\n      }\n      _nc_putp_sp(sp,\"clear_screen\",(cur_term->type).Strings[5]);\n      sp->_curscol = 0;\n      sp->_cursrow = sp->_curscol;\n    }\n  }\n  else {\n    if ((int3)(*sp->_current_attr >> 8) != iVar1) {\n      vidputs_sp(sp,blank & 0xffffff00,_nc_outch_sp);\n    }\n    for (i = 0; i < sp->_lines; i = i + 1) {\n      GoTo(sp,i,0);\n      for (j = 0; j < sp->_columns; j = j + 1) {\n        PutChar(sp,blank);\n      }\n    }\n    GoTo(sp,0,0);\n  }\n  for (i = 0; i < sp->_lines; i = i + 1) {\n    for (j = 0; j < sp->_columns; j = j + 1) {\n      sp->_curscr->_line[i].text[j] = blank;\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is ClearScreen"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,chtype ch)\n\n{\n  short sVar1;\n  short sVar2;\n  int iVar3;\n  chtype cVar4;\n  ldat *plVar5;\n  int x;\n  int y;\n  ldat *line;\n  \n  sVar1 = win->_curx;\n  iVar3 = (int)sVar1;\n  sVar2 = win->_cury;\n  cVar4 = render_char(win,ch);\n  plVar5 = win->_line + (int)sVar2;\n  if (plVar5->firstchar == -1) {\n    plVar5->lastchar = sVar1;\n    plVar5->firstchar = plVar5->lastchar;\n  }\n  else if (iVar3 < plVar5->firstchar) {\n    plVar5->firstchar = sVar1;\n  }\n  else if (plVar5->lastchar < iVar3) {\n    plVar5->lastchar = sVar1;\n  }\n  plVar5->text[iVar3] = cVar4;\n  if ((int)win->_maxx < iVar3 + 1) {\n    iVar3 = wrap_to_next_line(win);\n  }\n  else {\n    win->_curx = (short)(iVar3 + 1);\n    iVar3 = 0;\n  }\n  return iVar3;\n}\n\n",
        "output": "The predicted function name is waddch_literal"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  return;\n}\n\n",
        "output": "The predicted function name is no_mouse_resume"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  \n  if (sp == (SCREEN *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    sp->_echo = 1;\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is echo_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nname_table_entry * [MASK](name_table_entry **actual,name_table_data *source,char *strings)\n\n{\n  name_table_entry *pnVar1;\n  long in_FS_OFFSET;\n  uint len;\n  uint n;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (*actual == (name_table_entry *)0x0) {\n    pnVar1 = (name_table_entry *)calloc(0x1f1,0x10);\n    *actual = pnVar1;\n    if (*actual != (name_table_entry *)0x0) {\n      len = 0;\n      for (n = 0; n < 0x1f1; n = n + 1) {\n        (*actual)[n].nte_name = strings + len;\n        (*actual)[n].nte_type = source[n].nte_type;\n        (*actual)[n].nte_index = source[n].nte_index;\n        (*actual)[n].nte_link = source[n].nte_link;\n        next_string(strings,&len);\n      }\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return *actual;\n}\n\n",
        "output": "The predicted function name is _nc_build_names"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](TERMTYPE *ptr)\n\n{\n  really_free_termtype(ptr,true);\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_free_termtype"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int a1,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(stdscr,a1,z);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = wgetch(stdscr);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvgetch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int r,int g,int b,int *h,int *l,int *s)\n\n{\n  int min;\n  int max;\n  int t;\n  \n  min = g;\n  if (r <= g) {\n    min = r;\n  }\n  if (b < min) {\n    min = b;\n  }\n  max = g;\n  if (g <= r) {\n    max = r;\n  }\n  if (max < b) {\n    max = b;\n  }\n  *l = (min + max) / 0x14;\n  if (min == max) {\n    *h = 0;\n    *s = 0;\n  }\n  else {\n    if (*l < 0x32) {\n      *s = ((max - min) * 100) / (min + max);\n    }\n    else {\n      *s = ((max - min) * 100) / ((2000 - max) - min);\n    }\n    if (r == max) {\n      t = ((g - b) * 0x3c) / (max - min) + 0x78;\n    }\n    else if (g == max) {\n      t = ((b - r) * 0x3c) / (max - min) + 0xf0;\n    }\n    else {\n      t = ((r - g) * 0x3c) / (max - min) + 0x168;\n    }\n    *h = t % 0x168;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is rgb2hls"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  \n  if (sp == (SCREEN *)0x0) {\n    iVar1 = 7;\n  }\n  else {\n    iVar1 = sp->_default_fg;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is default_fg"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = nonl_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is nonl"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](SCREEN *sp)\n\n{\n  _Bool result;\n  int i;\n  \n  result = false;\n  if (sp != (SCREEN *)0x0) {\n    if (sp->_mouse_initialized != true) {\n      sp->_mouse_initialized = true;\n      sp->_mouse_eventp = sp->_mouse_events;\n      for (i = 0; i < 8; i = i + 1) {\n        sp->_mouse_events[i].id = -1;\n      }\n      initialize_mousetype(sp);\n    }\n    result = sp->_mouse_initialized;\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is _nc_mouse_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,char *fmt,__va_list_tag *argp)\n\n{\n  SCREEN *sp_00;\n  char *astr;\n  int code;\n  SCREEN *sp;\n  char *buf;\n  \n  code = -1;\n  sp_00 = _nc_screen_of(win);\n  astr = _nc_printf_string_sp(sp_00,fmt,argp);\n  if (astr != (char *)0x0) {\n    code = waddnstr(win,astr,-1);\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is vwprintw"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](TRIES *kt)\n\n{\n  if (kt != (TRIES *)0x0) {\n    _nc_free_keytry(kt->child);\n    _nc_free_keytry(kt->sibling);\n    free(kt);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_free_keytry"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nname_table_entry * [MASK](char *string,int type,_Bool termcap)\n\n{\n  HashValue HVar1;\n  uint uVar2;\n  int iVar3;\n  HashData *pHVar4;\n  name_table_entry *pnVar5;\n  long lVar6;\n  int hashvalue;\n  name_table_entry *ptr;\n  HashData *data;\n  name_table_entry *table;\n  \n  pHVar4 = _nc_get_hash_info(termcap);\n  HVar1 = (*pHVar4->hash_of)(string);\n  uVar2 = (uint)HVar1;\n  if (((-1 < (int)uVar2) && (uVar2 < pHVar4->table_size)) && (-1 < pHVar4->table_data[(int)uVar2]))\n  {\n    pnVar5 = _nc_get_table(termcap);\n    lVar6 = (long)pHVar4->table_data[(int)uVar2];\n    while( true ) {\n      ptr = pnVar5 + lVar6;\n      if ((type == ptr->nte_type) &&\n         (iVar3 = (*pHVar4->compare_names)(ptr->nte_name,string), iVar3 != 0)) {\n        return ptr;\n      }\n      if (ptr->nte_link < 0) break;\n      lVar6 = (long)((int)pHVar4->table_data[pHVar4->table_size] + (int)ptr->nte_link);\n    }\n  }\n  return (name_table_entry *)0x0;\n}\n\n",
        "output": "The predicted function name is _nc_find_type_entry"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int pair,int *f,int *b)\n\n{\n  int result;\n  int fg;\n  int bg;\n  \n  if ((((sp == (SCREEN *)0x0) || (pair < 0)) || (sp->_pair_limit <= pair)) || (sp->_coloron == 0)) {\n    result = -1;\n  }\n  else {\n    if ((sp->_color_pairs == (colorpair_t *)0x0) || (sp->_pair_alloc <= pair)) {\n      _nc_reserve_pairs(sp,pair);\n    }\n    fg = sp->_color_pairs[pair].fg;\n    bg = sp->_color_pairs[pair].bg;\n    if (fg < 0) {\n      fg = -1;\n    }\n    if (bg < 0) {\n      bg = -1;\n    }\n    if (f != (int *)0x0) {\n      *f = fg;\n    }\n    if (b != (int *)0x0) {\n      *b = bg;\n    }\n    result = 0;\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is _nc_pair_content"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nHashValue [MASK](char *string)\n\n{\n  int iVar1;\n  long lVar2;\n  HashValue HVar3;\n  long in_FS_OFFSET;\n  char *local_20;\n  int limit;\n  char temp [3];\n  \n  lVar2 = *(long *)(in_FS_OFFSET + 0x28);\n  limit = 0;\n  local_20 = string;\n  do {\n    if (*local_20 == '\\0') break;\n    iVar1 = limit + 1;\n    temp[limit] = *local_20;\n    local_20 = local_20 + 1;\n    limit = iVar1;\n  } while (iVar1 < 2);\n  temp[limit] = '\\0';\n  HVar3 = info_hash(temp);\n  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return HVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is tcap_hash"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](WINDOW *win)\n\n{\n  WINDOW *win_00;\n  ldat *plVar1;\n  int y;\n  int left;\n  int right;\n  WINDOW *pp;\n  ldat *line;\n  \n  if ((win != (WINDOW *)0x0) && (win->_parent != (WINDOW *)0x0)) {\n    win_00 = win->_parent;\n    wsyncdown(win_00);\n    for (y = 0; y <= win->_maxy; y = y + 1) {\n      if (-1 < win_00->_line[y + win->_pary].firstchar) {\n        plVar1 = win->_line;\n        left = (int)win_00->_line[y + win->_pary].firstchar - win->_parx;\n        right = (int)win_00->_line[y + win->_pary].lastchar - win->_parx;\n        if (left < 0) {\n          left = 0;\n        }\n        if (win->_maxx < right) {\n          right = (int)win->_maxx;\n        }\n        if ((plVar1[y].firstchar == -1) || (left < plVar1[y].firstchar)) {\n          plVar1[y].firstchar = (short)left;\n        }\n        if ((plVar1[y].lastchar == -1) || (plVar1[y].lastchar < right)) {\n          plVar1[y].lastchar = (short)right;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is wsyncdown"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int ch)\n\n{\n  int iVar1;\n  \n  iVar1 = _nc_outch_sp(SP,ch);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is _nc_outch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *sp)\n\n{\n  char *pcVar1;\n  uint n;\n  char *src;\n  \n  if (_nc_globals.first_name == (char *)0x0) {\n    _nc_globals.first_name = (char *)malloc(0x201);\n  }\n  if (_nc_globals.first_name != (char *)0x0) {\n    for (n = 0; ((n < 0x200 &&\n                 (pcVar1 = _nc_globals.first_name + n, *pcVar1 = sp[n], *pcVar1 != '\\0')) &&\n                (_nc_globals.first_name[n] != '|')); n = n + 1) {\n    }\n    _nc_globals.first_name[n] = '\\0';\n  }\n  return _nc_globals.first_name;\n}\n\n",
        "output": "The predicted function name is _nc_first_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int z)\n\n{\n  int iVar1;\n  \n  if (stdscr == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    stdscr->_attrs = z;\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is attrset"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *z)\n\n{\n  int iVar1;\n  \n  iVar1 = winnstr(stdscr,z,-1);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is instr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char **dst,char **a,int na,char **b,int nb)\n\n{\n  int iVar1;\n  char **local_38;\n  int local_30;\n  int local_2c;\n  char **local_28;\n  int n;\n  int cmp;\n  \n  n = 0;\n  local_38 = b;\n  local_30 = nb;\n  local_2c = na;\n  local_28 = a;\n  while ((0 < local_2c && (0 < local_30))) {\n    iVar1 = strcmp(*local_28,*local_38);\n    if (iVar1 < 0) {\n      dst[n] = *local_28;\n      local_2c = local_2c + -1;\n      local_28 = local_28 + 1;\n      n = n + 1;\n    }\n    else if (iVar1 < 1) {\n      dst[n] = *local_28;\n      local_28 = local_28 + 1;\n      local_38 = local_38 + 1;\n      local_2c = local_2c + -1;\n      local_30 = local_30 + -1;\n      n = n + 1;\n    }\n    else {\n      dst[n] = *local_38;\n      local_30 = local_30 + -1;\n      local_38 = local_38 + 1;\n      n = n + 1;\n    }\n  }\n  while (0 < local_2c) {\n    dst[n] = *local_28;\n    local_2c = local_2c + -1;\n    local_28 = local_28 + 1;\n    n = n + 1;\n  }\n  while (0 < local_30) {\n    dst[n] = *local_38;\n    local_38 = local_38 + 1;\n    local_30 = local_30 + -1;\n    n = n + 1;\n  }\n  return n;\n}\n\n",
        "output": "The predicted function name is merge_names"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchtype [MASK](WINDOW *a1,int a2,int z)\n\n{\n  int iVar1;\n  chtype cVar2;\n  \n  iVar1 = wmove(a1,a2,z);\n  if (iVar1 == -1) {\n    cVar2 = 0xffffffff;\n  }\n  else {\n    cVar2 = winch(a1);\n  }\n  return cVar2;\n}\n\n",
        "output": "The predicted function name is mvwinch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int mode,int milliseconds,int *timeleft)\n\n{\n  long lVar1;\n  long lVar2;\n  long lVar3;\n  long in_FS_OFFSET;\n  bool bVar4;\n  int local_78;\n  int count;\n  int result;\n  int fd;\n  pollfd *fds;\n  long starttime;\n  long returntime;\n  timeval t0;\n  pollfd fd_list [2];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  local_78 = milliseconds;\n  while( true ) {\n    lVar2 = _nc_gettime(&t0,1);\n    memset(fd_list,0,0x10);\n    bVar4 = (mode & 1U) != 0;\n    if (bVar4) {\n      fd_list[0].fd = sp->_ifd;\n      fd_list[0].events = 1;\n    }\n    count = (int)bVar4;\n    if (((mode & 2U) != 0) && (-1 < sp->_mouse_fd)) {\n      ((pollfd *)fd_list)[count].fd = sp->_mouse_fd;\n      fd_list[count].events = 1;\n      count = count + 1;\n    }\n    result = poll((pollfd *)fd_list,(long)count,local_78);\n    lVar3 = _nc_gettime(&t0,0);\n    if (-1 < local_78) {\n      local_78 = local_78 - ((int)lVar3 - (int)lVar2);\n    }\n    if ((result != 0) || (local_78 < 0x65)) break;\n    napms(100);\n    local_78 = local_78 + -100;\n  }\n  if (timeleft != (int *)0x0) {\n    *timeleft = local_78;\n  }\n  if (result != 0) {\n    if (result < 1) {\n      result = 0;\n    }\n    else {\n      result = 0;\n      for (count = 0; count < 2; count = count + 1) {\n        if (((mode >> ((byte)count & 0x1f) & 1U) != 0) && ((fd_list[count].revents & 1U) != 0)) {\n          result = result | 1 << ((byte)count & 0x1f);\n        }\n      }\n    }\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return result;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is _nc_timed_wait"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *z)\n\n{\n  int iVar1;\n  \n  if (z == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = z->_maxy + 1;\n  }\n  iVar1 = wtouchln(z,0,iVar1,1);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is touchwin"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  char *__s1;\n  int result;\n  char *env;\n  \n  __s1 = nl_langinfo(0xe);\n  iVar1 = strcmp(__s1,\"UTF-8\");\n  return (uint)(iVar1 == 0);\n}\n\n",
        "output": "The predicted function name is _nc_unicode_locale"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,char *z)\n\n{\n  int iVar1;\n  \n  iVar1 = waddnstr(a1,z,-1);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is waddstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  _nc_mvcur_init_sp(SP);\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_mvcur_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int cols)\n\n{\n  int iVar1;\n  int iVar2;\n  int gap;\n  int i;\n  int x;\n  int max_length;\n  \n  if ((sp == (SCREEN *)0x0) || (sp->_slk == (_SLK *)0x0)) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = (int)sp->_slk->maxlen;\n    if (sp->slk_format < 3) {\n      if (sp->slk_format == 2) {\n        gap = (cols - sp->_slk->maxlab * iVar1) + -6;\n        if (gap < 1) {\n          gap = 1;\n        }\n        x = 0;\n        for (i = 0; i < sp->_slk->maxlab; i = i + 1) {\n          sp->_slk->ent[i].ent_x = x;\n          iVar2 = gap;\n          if (i != 3) {\n            iVar2 = 1;\n          }\n          x = x + iVar1 + iVar2;\n        }\n      }\n      else {\n        if (sp->slk_format != 1) {\n          iVar1 = slk_failed(sp);\n          return iVar1;\n        }\n        gap = ((cols - sp->_slk->maxlab * iVar1) + -5) / 2;\n        if (gap < 1) {\n          gap = 1;\n        }\n        x = 0;\n        for (i = 0; i < sp->_slk->maxlab; i = i + 1) {\n          sp->_slk->ent[i].ent_x = x;\n          iVar2 = gap;\n          if ((i != 2) && (i != 4)) {\n            iVar2 = 1;\n          }\n          x = x + iVar1 + iVar2;\n        }\n      }\n    }\n    else {\n      gap = (cols + (iVar1 * 4 + 3) * -3) / 2;\n      if (gap < 1) {\n        gap = 1;\n      }\n      x = 0;\n      for (i = 0; i < sp->_slk->maxlab; i = i + 1) {\n        sp->_slk->ent[i].ent_x = x;\n        iVar2 = gap;\n        if ((i != 3) && (i != 7)) {\n          iVar2 = 1;\n        }\n        x = x + iVar1 + iVar2;\n      }\n    }\n    sp->_slk->dirty = true;\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is _nc_format_slks"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *cap,int affcnt)\n\n{\n  int iVar1;\n  \n  iVar1 = _nc_msec_cost_sp(SP,cap,affcnt);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is _nc_msec_cost"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *z)\n\n{\n  int iVar1;\n  \n  if (z == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    z->_attrs = 0x10000;\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is wstandout"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nstring_desc * [MASK](string_desc *dst,string_desc *src)\n\n{\n  char *pcVar1;\n  size_t sVar2;\n  \n  pcVar1 = src->s_tail;\n  dst->s_head = src->s_head;\n  dst->s_tail = pcVar1;\n  sVar2 = src->s_init;\n  dst->s_size = src->s_size;\n  dst->s_init = sVar2;\n  return dst;\n}\n\n",
        "output": "The predicted function name is _nc_str_copy"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int n,int top,int bot,int miny,int maxy,chtype blank)\n\n{\n  int3 iVar1;\n  char *pcVar2;\n  int i;\n  int j;\n  \n  iVar1 = (int3)(blank >> 8);\n  if ((((n == 1) && ((cur_term->type).Strings[0x81] != (char *)0x0)) && (top == miny)) &&\n     (bot == maxy)) {\n    GoTo(sp,bot,0);\n    if ((int3)(*sp->_current_attr >> 8) != iVar1) {\n      vidputs_sp(sp,blank & 0xffffff00,_nc_outch_sp);\n    }\n    _nc_putp_sp(sp,\"scroll_forward\",(cur_term->type).Strings[0x81]);\n  }\n  else if (((n == 1) && ((cur_term->type).Strings[0x16] != (char *)0x0)) && (bot == maxy)) {\n    GoTo(sp,top,0);\n    if ((int3)(*sp->_current_attr >> 8) != iVar1) {\n      vidputs_sp(sp,blank & 0xffffff00,_nc_outch_sp);\n    }\n    _nc_putp_sp(sp,\"delete_line\",(cur_term->type).Strings[0x16]);\n  }\n  else if ((((cur_term->type).Strings[0x6d] == (char *)0x0) || (top != miny)) || (bot != maxy)) {\n    if (((cur_term->type).Strings[0x6a] == (char *)0x0) || (bot != maxy)) {\n      if (((cur_term->type).Strings[0x81] == (char *)0x0) || ((top != miny || (bot != maxy)))) {\n        if (((cur_term->type).Strings[0x16] == (char *)0x0) || (bot != maxy)) {\n          return -1;\n        }\n        GoTo(sp,top,0);\n        if ((int3)(*sp->_current_attr >> 8) != iVar1) {\n          vidputs_sp(sp,blank & 0xffffff00,_nc_outch_sp);\n        }\n        for (i = 0; i < n; i = i + 1) {\n          _nc_putp_sp(sp,\"delete_line\",(cur_term->type).Strings[0x16]);\n        }\n      }\n      else {\n        GoTo(sp,bot,0);\n        if ((int3)(*sp->_current_attr >> 8) != iVar1) {\n          vidputs_sp(sp,blank & 0xffffff00,_nc_outch_sp);\n        }\n        for (i = 0; i < n; i = i + 1) {\n          _nc_putp_sp(sp,\"scroll_forward\",(cur_term->type).Strings[0x81]);\n        }\n      }\n    }\n    else {\n      GoTo(sp,top,0);\n      if ((int3)(*sp->_current_attr >> 8) != iVar1) {\n        vidputs_sp(sp,blank & 0xffffff00,_nc_outch_sp);\n      }\n      pcVar2 = _nc_tiparm(1,(cur_term->type).Strings[0x6a],(ulong)(uint)n);\n      tputs_sp(sp,pcVar2,n,_nc_outch_sp);\n    }\n  }\n  else {\n    GoTo(sp,bot,0);\n    if ((int3)(*sp->_current_attr >> 8) != iVar1) {\n      vidputs_sp(sp,blank & 0xffffff00,_nc_outch_sp);\n    }\n    pcVar2 = _nc_tiparm(1,(cur_term->type).Strings[0x6d],(ulong)(uint)n);\n    tputs_sp(sp,pcVar2,n,_nc_outch_sp);\n  }\n  if (((sp->_coloron != 0) && (sp->_default_color != true)) &&\n     ((cur_term->type).Booleans[0x1c] == '\\0')) {\n    for (i = 0; i < n; i = i + 1) {\n      GoTo(sp,bot - i,0);\n      for (j = 0; j < sp->_columns; j = j + 1) {\n        PutChar(sp,blank);\n      }\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is scroll_csr_forward"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nname_table_entry * [MASK](char *string,HashValue *hash_table)\n\n{\n  HashValue HVar1;\n  uint uVar2;\n  int iVar3;\n  HashValue *pHVar4;\n  HashData *pHVar5;\n  name_table_entry *pnVar6;\n  long lVar7;\n  _Bool termcap;\n  int hashvalue;\n  name_table_entry *ptr;\n  HashData *data;\n  name_table_entry *real_table;\n  \n  pHVar4 = _nc_get_hash_table(false);\n  pHVar5 = _nc_get_hash_info(hash_table != pHVar4);\n  ptr = (name_table_entry *)0x0;\n  HVar1 = (*pHVar5->hash_of)(string);\n  uVar2 = (uint)HVar1;\n  if (((-1 < (int)uVar2) && (uVar2 < pHVar5->table_size)) && (-1 < pHVar5->table_data[(int)uVar2]))\n  {\n    pnVar6 = _nc_get_table(hash_table != pHVar4);\n    lVar7 = (long)pHVar5->table_data[(int)uVar2];\n    while( true ) {\n      ptr = pnVar6 + lVar7;\n      iVar3 = (*pHVar5->compare_names)(ptr->nte_name,string);\n      if (iVar3 != 0) break;\n      if (ptr->nte_link < 0) {\n        return (name_table_entry *)0x0;\n      }\n      lVar7 = (long)((int)pHVar5->table_data[pHVar5->table_size] + (int)ptr->nte_link);\n    }\n  }\n  return ptr;\n}\n\n",
        "output": "The predicted function name is _nc_find_entry"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *z)\n\n{\n  int iVar1;\n  \n  iVar1 = wscrl(z,1);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is scroll"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](attr_t a1,void *z)\n\n{\n  int iVar1;\n  \n  iVar1 = wattr_off(stdscr,a1,z);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is attr_off"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int slines,int scolumns,FILE *output,int filtered,int slk_format)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  int rc;\n  SCREEN *sp;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  sp = (SCREEN *)0x0;\n  iVar1 = _nc_setupscreen_sp(&sp,slines,scolumns,output,filtered,slk_format);\n  if (iVar1 != 0) {\n    SP = (SCREEN *)0x0;\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is _nc_setupscreen"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](chtype z)\n\n{\n  wbkgdset(stdscr,z);\n  return;\n}\n\n",
        "output": "The predicted function name is bkgdset"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *string,int affcnt,anon_subr_int_int *outc)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  SCREEN *sp;\n  screen outc_wrapper;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  sp = SP;\n  if (SP == (SCREEN *)0x0) {\n    sp = &outc_wrapper;\n    memset(sp,0,0x608);\n    outc_wrapper._outch = _nc_outc_wrapper;\n  }\n  sp->jump = (NCURSES_OUTC *)outc;\n  iVar1 = tputs_sp(sp,string,affcnt,_nc_outc_wrapper);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is tputs"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int yold,int xold,int ynew,int xnew)\n\n{\n  int iVar1;\n  \n  iVar1 = _nc_real_mvcur(sp,yold,xold,ynew,xnew,_nc_putchar_sp,0);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvcur_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,chtype *str,int n)\n\n{\n  short sVar1;\n  chtype *pcVar2;\n  int i;\n  int row;\n  int col;\n  chtype *text;\n  \n  i = 0;\n  if ((win == (WINDOW *)0x0) || (str == (chtype *)0x0)) {\n    i = -1;\n  }\n  else {\n    sVar1 = win->_curx;\n    pcVar2 = win->_line[(int)win->_cury].text;\n    for (; ((n < 0 || (i < n)) && (sVar1 + i <= (int)win->_maxx)); i = i + 1) {\n      str[i] = pcVar2[i + sVar1];\n    }\n    str[i] = 0;\n  }\n  return i;\n}\n\n",
        "output": "The predicted function name is winchnstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int sig)\n\n{\n  _nc_globals.have_sigwinch = 1;\n  return;\n}\n\n",
        "output": "The predicted function name is handle_SIGWINCH"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp,int bg,NCURSES_OUTC_sp *outc)\n\n{\n  uint uVar1;\n  char *pcVar2;\n  \n  if ((cur_term->type).Strings[0x168] == (char *)0x0) {\n    uVar1 = toggled_colors(bg);\n    pcVar2 = _nc_tiparm(1,(cur_term->type).Strings[0x12f],(ulong)uVar1);\n    tputs_sp(sp,pcVar2,1,outc);\n  }\n  else {\n    pcVar2 = _nc_tiparm(1,(cur_term->type).Strings[0x168],(ulong)(uint)bg);\n    tputs_sp(sp,pcVar2,1,outc);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is set_background_color"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,chtype ch,_Bool narrow)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  chtype new_bkgd;\n  chtype old_bkgd;\n  int code;\n  int y;\n  int old_pair;\n  chtype new_char;\n  int new_pair;\n  int x;\n  chtype tmp_bkgd;\n  chtype old_char;\n  attr_t old_attr;\n  attr_t new_attr;\n  int tmp_pair;\n  attr_t tmp_attr;\n  chtype *cp;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  code = -1;\n  iVar1 = code;\n  if ((SP != (SCREEN *)0x0) && (win != (WINDOW *)0x0)) {\n    new_bkgd = ch;\n    if (SP->_pair_limit == 0) {\n      new_bkgd = ch & 0xffff00ff;\n    }\n    if ((new_bkgd & 0xff) == 0) {\n      new_bkgd = (new_bkgd >> 8 & 0xff | (new_bkgd & 0xffff0000) >> 8) << 8 | 0x20;\n      tmp_bkgd = new_bkgd;\n    }\n    old_bkgd = win->_bkgd;\n    iVar1 = memcmp(&old_bkgd,&new_bkgd,4);\n    if (iVar1 == 0) {\n      iVar1 = 0;\n    }\n    else {\n      old_char = old_bkgd & 0xff;\n      old_attr = old_bkgd & 0xffffff00;\n      old_pair = old_bkgd >> 8 & 0xff;\n      if ((old_bkgd & 0xff00) == 0) {\n        old_pair = 0;\n      }\n      new_attr = new_bkgd & 0xffffff00;\n      new_pair = new_bkgd >> 8 & 0xff;\n      if ((new_bkgd < 0x20) || (new_char = new_bkgd & 0xff, 0x7e < new_bkgd)) {\n        new_char = old_char;\n      }\n      if ((new_bkgd & 0xff00) == 0) {\n        new_pair = 0;\n      }\n      wbkgrndset(win,new_bkgd);\n      if ((new_pair == 0) || (new_pair != old_pair)) {\n        win->_attrs = new_attr;\n      }\n      else {\n        win->_attrs = new_attr;\n        win->_attrs = win->_attrs & 0xffff00ff;\n        win->_attrs = win->_attrs | (new_pair & 0xffU) << 8;\n      }\n      for (y = 0; y <= win->_maxy; y = y + 1) {\n        for (x = 0; x <= win->_maxx; x = x + 1) {\n          cp = win->_line[y].text + x;\n          tmp_pair = *cp >> 8 & 0xff;\n          tmp_attr = *cp & 0xffffff00;\n          if (*cp == old_bkgd) {\n            *cp = new_char & 0xff;\n          }\n          if (tmp_pair == 0) {\n            *cp = *cp & 0xff | ~old_attr & tmp_attr | new_attr;\n            *cp = *cp & 0xffff00ff;\n            *cp = *cp & 0xff | (new_pair & 0xffU | *cp >> 8) << 8;\n          }\n          else if (tmp_pair == old_pair) {\n            *cp = *cp & 0xff | ~old_attr & tmp_attr | new_attr;\n            *cp = *cp & 0xffff00ff;\n            *cp = *cp & 0xff | (new_pair & 0xffU | *cp >> 8) << 8;\n          }\n          else {\n            *cp = (~old_attr & 0xffff0000 | (uint)CONCAT11(0xff,(char)~old_attr)) & tmp_attr |\n                  new_attr & 0xffff00ff | *cp & 0xff;\n          }\n        }\n      }\n      if (win == (WINDOW *)0x0) {\n        iVar1 = -1;\n      }\n      else {\n        iVar1 = win->_maxy + 1;\n      }\n      wtouchln(win,0,iVar1,1);\n      _nc_synchook(win);\n      code = 0;\n      iVar1 = code;\n    }\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is _nc_background"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](timeval *t0,int first)\n\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  long res;\n  timeval t1;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  gettimeofday((timeval *)&t1,(__timezone_ptr_t)0x0);\n  if (first == 0) {\n    if (t1.tv_usec < t0->tv_usec) {\n      t1.tv_usec = t1.tv_usec + 1000000;\n      t1.tv_sec = t1.tv_sec + -1;\n    }\n    res = (t1.tv_usec - t0->tv_usec) / 1000 + (t1.tv_sec - t0->tv_sec) * 1000;\n  }\n  else {\n    t0->tv_sec = t1.tv_sec;\n    t0->tv_usec = t1.tv_usec;\n    res = 0;\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return res;\n}\n\n",
        "output": "The predicted function name is _nc_gettime"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nWINDOW * [MASK](int num_lines,int num_columns,int begy,int begx)\n\n{\n  WINDOW *pWVar1;\n  WINDOW *win;\n  \n  pWVar1 = newwin_sp(SP,num_lines,num_columns,begy,begx);\n  return pWVar1;\n}\n\n",
        "output": "The predicted function name is newwin"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nWINDOW * [MASK](WINDOW *w,int l,int c,int y,int x)\n\n{\n  WINDOW *result;\n  \n  result = (WINDOW *)0x0;\n  if (w != (WINDOW *)0x0) {\n    result = derwin(w,l,c,y - w->_begy,x - w->_begx);\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is subwin"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,attr_t at,void *opts)\n\n{\n  int iVar1;\n  \n  if (win == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    if ((char)(at >> 8) == '\\0') {\n      win->_attrs = ~at & win->_attrs;\n    }\n    else {\n      win->_attrs = ~(at & 0xffff0000 | (uint)CONCAT11(0xff,(char)at)) & win->_attrs;\n    }\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is wattr_off"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,int a2,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(a1,a2,z);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = wdelch(a1);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvwdelch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,int n)\n\n{\n  int iVar1;\n  \n  if ((win == (WINDOW *)0x0) || (win->_scroll != true)) {\n    iVar1 = -1;\n  }\n  else {\n    if (n != 0) {\n      _nc_scroll_window(win,n,(int)win->_regtop,(int)win->_regbottom,win->_bkgd);\n      _nc_synchook(win);\n    }\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is wscrl"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](WINDOW *win,int y,int x)\n\n{\n  int iVar1;\n  _Bool result;\n  \n  result = false;\n  if (win != (WINDOW *)0x0) {\n    iVar1 = y - win->_yoffset;\n    if ((((iVar1 < win->_begy) || (x < win->_begx)) || ((int)win->_maxx + (int)win->_begx < x)) ||\n       ((int)win->_maxy + (int)win->_begy < iVar1)) {\n      result = false;\n    }\n    else {\n      result = true;\n    }\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is wenclose"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](TRIES **tree,uint code)\n\n{\n  TRIES *__ptr;\n  int iVar1;\n  tries **local_20;\n  TRIES *to_free;\n  \n  local_20 = tree;\n  if (code != 0) {\n    for (; *local_20 != (tries *)0x0; local_20 = &(*local_20)->sibling) {\n      iVar1 = _nc_remove_key(&(*local_20)->child,code);\n      if (iVar1 != 0) {\n        return 1;\n      }\n      if (code == (*local_20)->value) {\n        if ((*local_20)->child == (tries *)0x0) {\n          __ptr = *local_20;\n          *local_20 = (*local_20)->sibling;\n          free(__ptr);\n        }\n        else {\n          (*local_20)->value = 0;\n        }\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is _nc_remove_key"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,char *string,int affcnt,NCURSES_OUTC_sp *outc)\n\n{\n  byte *pbVar1;\n  bool bVar2;\n  NCURSES_OUTC_sp *pNVar3;\n  bool bVar4;\n  int iVar5;\n  NCURSES_OUTC_sp *pNVar6;\n  ushort **ppuVar7;\n  char *pcVar8;\n  bool bVar9;\n  byte *local_28;\n  _Bool always_delay;\n  _Bool normal_delay;\n  _Bool mandatory;\n  int number;\n  NCURSES_OUTC_sp *my_outch;\n  \n  pNVar6 = _nc_prescreen._outch;\n  if (sp != (SCREEN *)0x0) {\n    pNVar6 = sp->_outch;\n  }\n  bVar2 = false;\n  bVar4 = false;\n  if ((string == (char *)0xffffffffffffffff) || (string == (char *)0x0)) {\n    return -1;\n  }\n  if (sp == (SCREEN *)0x0) goto LAB_00028155;\n  if (sp == (SCREEN *)0x0) {\n    bVar9 = cur_term != (term_conflict *)0x0;\n  }\n  else if (sp->_term == (TERMINAL_conflict *)0x0) {\n    bVar9 = cur_term != (term_conflict *)0x0;\n  }\n  else {\n    bVar9 = sp->_term != (TERMINAL_conflict *)0x0;\n  }\n  if (!bVar9) goto LAB_00028155;\n  if ((sp != (SCREEN *)0x0) && (sp->_term == (TERMINAL_conflict *)0x0)) {\n    bVar2 = false;\n    bVar4 = true;\n    goto LAB_00028155;\n  }\n  if ((string == (cur_term->type).Strings[1]) || (string == (cur_term->type).Strings[0x2d])) {\n    bVar2 = true;\n  }\n  else {\n    bVar2 = false;\n  }\n  if (((cur_term->type).Booleans[0x14] == '\\0') && ((cur_term->type).Numbers[5] != 0)) {\n    if (sp == (SCREEN *)0x0) {\n      if (_nc_prescreen._no_padding != true) goto LAB_0002811a;\n    }\n    else if (sp->_no_padding != true) {\nLAB_0002811a:\n      iVar5 = _nc_baudrate((int)ospeed);\n      if ((cur_term->type).Numbers[5] <= iVar5) {\n        bVar4 = true;\n        goto LAB_00028155;\n      }\n    }\n  }\n  bVar4 = false;\nLAB_00028155:\n  pNVar3 = outc;\n  local_28 = (byte *)string;\n  if (sp != (SCREEN *)0x0) {\n    sp->_outch = outc;\n    pNVar3 = _nc_prescreen._outch;\n  }\n  while (_nc_prescreen._outch = pNVar3, *local_28 != 0) {\n    if (*local_28 == 0x24) {\n      pbVar1 = local_28 + 1;\n      if (*pbVar1 != 0x3c) {\n        (*outc)(sp,0x24);\n        local_28 = pbVar1;\n        if (*pbVar1 != 0) {\n          (*outc)(sp,(int)(char)*pbVar1);\n        }\n        goto LAB_000283c9;\n      }\n      local_28 = local_28 + 2;\n      ppuVar7 = __ctype_b_loc();\n      if (((((*ppuVar7)[*local_28] & 0x800) != 0) || (*local_28 == 0x2e)) &&\n         (pcVar8 = strchr((char *)local_28,0x3e), pcVar8 != (char *)0x0)) {\n        number = 0;\n        while (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[*local_28] & 0x800) != 0) {\n          number = (char)*local_28 + -0x30 + number * 10;\n          local_28 = local_28 + 1;\n        }\n        number = number * 10;\n        if (*local_28 == 0x2e) {\n          pbVar1 = local_28 + 1;\n          ppuVar7 = __ctype_b_loc();\n          if (((*ppuVar7)[*pbVar1] & 0x800) != 0) {\n            number = number + (char)*pbVar1 + -0x30;\n            pbVar1 = local_28 + 2;\n          }\n          while (local_28 = pbVar1, ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[*local_28] & 0x800) != 0)\n          {\n            pbVar1 = local_28 + 1;\n          }\n        }\n        bVar9 = false;\n        while ((*local_28 == 0x2a || (*local_28 == 0x2f))) {\n          if (*local_28 == 0x2a) {\n            number = number * affcnt;\n            local_28 = local_28 + 1;\n          }\n          else {\n            bVar9 = true;\n            local_28 = local_28 + 1;\n          }\n        }\n        if ((0 < number) && (((bVar2 || (bVar4)) || (bVar9)))) {\n          delay_output_sp(sp,number / 10);\n        }\n        goto LAB_000283c9;\n      }\n      (*outc)(sp,0x24);\n      (*outc)(sp,0x3c);\n      pNVar3 = _nc_prescreen._outch;\n    }\n    else {\n      (*outc)(sp,(int)(char)*local_28);\nLAB_000283c9:\n      if (*local_28 == 0) break;\n      local_28 = local_28 + 1;\n      pNVar3 = _nc_prescreen._outch;\n    }\n  }\n  if (sp != (SCREEN *)0x0) {\n    sp->_outch = pNVar6;\n    pNVar6 = _nc_prescreen._outch;\n  }\n  _nc_prescreen._outch = pNVar6;\n  return 0;\n}\n\n",
        "output": "The predicted function name is tputs_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *z)\n\n{\n  int iVar1;\n  \n  if (z == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = (int)z->_begx;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is getbegx"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *z)\n\n{\n  int iVar1;\n  \n  if (z == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = (int)z->_begy;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is getbegy"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  _Bool _Var4;\n  uint uVar5;\n  int back_limit;\n  int back_ref_limit;\n  int i;\n  int forward_limit;\n  int forward_ref_limit;\n  int start;\n  int shift;\n  int end;\n  int next_hunk;\n  \n  back_limit = 0;\n  back_ref_limit = 0;\n  for (i = 0; (iVar3 = i, i < sp->_lines && (sp->_oldnum_list[i] == -1)); i = i + 1) {\n  }\n  do {\n    i = iVar3;\n    iVar2 = i;\n    if (sp->_lines <= i) {\n      return;\n    }\n    uVar5 = sp->_oldnum_list[i] - i;\n    do {\n      i = i + 1;\n      iVar1 = i;\n      if ((sp->_lines <= i) || (sp->_oldnum_list[i] == -1)) break;\n    } while (uVar5 == sp->_oldnum_list[i] - i);\n    for (; (iVar3 = i, i < sp->_lines && (sp->_oldnum_list[i] == -1)); i = i + 1) {\n    }\n    forward_limit = i;\n    if ((i < sp->_lines) && (sp->_oldnum_list[i] < i)) {\n      forward_ref_limit = sp->_oldnum_list[i];\n    }\n    else {\n      forward_ref_limit = i;\n    }\n    i = iVar2 + -1;\n    if ((int)uVar5 < 0) {\n      back_limit = back_ref_limit - uVar5;\n    }\n    while ((back_limit <= i &&\n           ((sp->newhash[i] == sp->oldhash[(int)(uVar5 + i)] ||\n            (_Var4 = cost_effective(sp,i + uVar5,i,uVar5 >> 0x1f), _Var4 != false))))) {\n      sp->_oldnum_list[i] = uVar5 + i;\n      i = i + -1;\n    }\n    i = iVar1;\n    if (0 < (int)uVar5) {\n      forward_limit = forward_ref_limit - uVar5;\n    }\n    while ((i < forward_limit &&\n           ((sp->newhash[i] == sp->oldhash[(int)(uVar5 + i)] ||\n            (_Var4 = cost_effective(sp,i + uVar5,i,(uint)(0 < (int)uVar5)), _Var4 != false))))) {\n      sp->_oldnum_list[i] = uVar5 + i;\n      i = i + 1;\n    }\n    back_limit = i;\n    back_ref_limit = i;\n    if (0 < (int)uVar5) {\n      back_ref_limit = i + uVar5;\n    }\n  } while( true );\n}\n\n",
        "output": "The predicted function name is grow_hunks"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](TERMTYPE *dst,TERMTYPE *src,int mode)\n\n{\n  undefined8 uVar1;\n  uint uVar2;\n  char *pcVar3;\n  char **ppcVar4;\n  short *psVar5;\n  uint i;\n  \n  pcVar3 = src->str_table;\n  dst->term_names = src->term_names;\n  dst->str_table = pcVar3;\n  psVar5 = src->Numbers;\n  dst->Booleans = src->Booleans;\n  dst->Numbers = psVar5;\n  pcVar3 = src->ext_str_table;\n  dst->Strings = src->Strings;\n  dst->ext_str_table = pcVar3;\n  uVar1 = *(undefined8 *)&src->num_Booleans;\n  dst->ext_Names = src->ext_Names;\n  *(undefined8 *)&dst->num_Booleans = uVar1;\n  *(undefined8 *)&dst->ext_Numbers = *(undefined8 *)&src->ext_Numbers;\n  pcVar3 = (char *)malloc((ulong)dst->num_Booleans);\n  dst->Booleans = pcVar3;\n  if (dst->Booleans == (char *)0x0) {\n                    /* WARNING: Subroutine does not return */\n    _nc_err_abort(\"Out of memory\");\n  }\n  ppcVar4 = (char **)malloc((ulong)dst->num_Strings << 3);\n  dst->Strings = ppcVar4;\n  if (dst->Strings == (char **)0x0) {\n                    /* WARNING: Subroutine does not return */\n    _nc_err_abort(\"Out of memory\");\n  }\n  memcpy(dst->Booleans,src->Booleans,(ulong)dst->num_Booleans);\n  memcpy(dst->Strings,src->Strings,(ulong)dst->num_Strings * 8);\n  psVar5 = (short *)malloc((ulong)dst->num_Numbers * 2);\n  dst->Numbers = psVar5;\n  if (dst->Numbers == (short *)0x0) {\n                    /* WARNING: Subroutine does not return */\n    _nc_err_abort(\"Out of memory\");\n  }\n  memcpy(dst->Numbers,src->Numbers,(ulong)dst->num_Numbers * 2);\n  uVar2 = (uint)src->ext_Strings + (uint)src->ext_Booleans + (uint)src->ext_Numbers;\n  if (uVar2 == 0) {\n    dst->ext_Names = (char **)0x0;\n  }\n  else {\n    ppcVar4 = (char **)malloc((ulong)uVar2 << 3);\n    dst->ext_Names = ppcVar4;\n    if (dst->ext_Names == (char **)0x0) {\n                    /* WARNING: Subroutine does not return */\n      _nc_err_abort(\"Out of memory\");\n    }\n    memcpy(dst->ext_Names,src->ext_Names,(ulong)uVar2 * 8);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is copy_termtype"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = wclrtoeol(stdscr);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is clrtoeol"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  \n  if ((sp == (SCREEN *)0x0) || (sp->_slk == (_SLK *)0x0)) {\n    iVar1 = -1;\n  }\n  else {\n    sp->_slk->dirty = true;\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is slk_touch_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *name)\n\n{\n  if (_nc_globals.comp_sourcename != (char *)0x0) {\n    free(_nc_globals.comp_sourcename);\n  }\n  _nc_globals.comp_sourcename = strdup(name);\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_set_source"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](TERMTYPE *tp,char *name,int token_type)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  char **ppcVar4;\n  char *pcVar5;\n  short *psVar6;\n  uint j;\n  uint k;\n  uint first;\n  uint last;\n  uint total;\n  int cmp;\n  \n  j = _nc_first_ext_name(tp,token_type);\n  uVar2 = _nc_last_ext_name(tp,token_type);\n  k = (uint)tp->ext_Strings + (uint)tp->ext_Booleans + (uint)tp->ext_Numbers;\n  for (; j < uVar2; j = j + 1) {\n    iVar3 = strcmp(name,tp->ext_Names[j]);\n    if (iVar3 == 0) {\n      iVar3 = _nc_ext_data_index(tp,j,token_type);\n      return iVar3;\n    }\n    if (iVar3 < 0) break;\n  }\n  ppcVar4 = (char **)_nc_doalloc(tp->ext_Names,(ulong)(k + 1) * 8);\n  tp->ext_Names = ppcVar4;\n  if (tp->ext_Names == (char **)0x0) {\n                    /* WARNING: Subroutine does not return */\n    _nc_err_abort(\"Out of memory\");\n  }\n  for (; j < k; k = k - 1) {\n    tp->ext_Names[k] = tp->ext_Names[k - 1];\n  }\n  tp->ext_Names[j] = name;\n  uVar2 = _nc_ext_data_index(tp,j,token_type);\n  if (token_type == 1) {\n    tp->ext_Numbers = tp->ext_Numbers + 1;\n    tp->num_Numbers = tp->num_Numbers + 1;\n    psVar6 = (short *)_nc_doalloc(tp->Numbers,(ulong)tp->num_Numbers * 2);\n    tp->Numbers = psVar6;\n    if (tp->Numbers == (short *)0x0) {\n                    /* WARNING: Subroutine does not return */\n      _nc_err_abort(\"Out of memory\");\n    }\n    uVar1 = (uint)tp->num_Numbers;\n    while (k = uVar1 - 1, uVar2 < k) {\n      tp->Numbers[k] = tp->Numbers[uVar1 - 2];\n      uVar1 = k;\n    }\n  }\n  else if (token_type == 2) {\n    tp->ext_Strings = tp->ext_Strings + 1;\n    tp->num_Strings = tp->num_Strings + 1;\n    ppcVar4 = (char **)_nc_doalloc(tp->Strings,(ulong)tp->num_Strings * 8);\n    tp->Strings = ppcVar4;\n    if (tp->Strings == (char **)0x0) {\n                    /* WARNING: Subroutine does not return */\n      _nc_err_abort(\"Out of memory\");\n    }\n    uVar1 = (uint)tp->num_Strings;\n    while (k = uVar1 - 1, uVar2 < k) {\n      tp->Strings[k] = tp->Strings[uVar1 - 2];\n      uVar1 = k;\n    }\n  }\n  else if (token_type == 0) {\n    tp->ext_Booleans = tp->ext_Booleans + 1;\n    tp->num_Booleans = tp->num_Booleans + 1;\n    pcVar5 = (char *)_nc_doalloc(tp->Booleans,(ulong)tp->num_Booleans);\n    tp->Booleans = pcVar5;\n    if (tp->Booleans == (char *)0x0) {\n                    /* WARNING: Subroutine does not return */\n      _nc_err_abort(\"Out of memory\");\n    }\n    uVar1 = (uint)tp->num_Booleans;\n    while (k = uVar1 - 1, uVar2 < k) {\n      tp->Booleans[k] = tp->Booleans[uVar1 - 2];\n      uVar1 = k;\n    }\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is _nc_ins_ext_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,int y,int x,char *fmt,...)\n\n{\n  long lVar1;\n  char in_AL;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  int code;\n  va_list argp;\n  undefined local_b8 [32];\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  local_98 = in_R8;\n  local_90 = in_R9;\n  code = wmove(win,y,x);\n  if (code != -1) {\n    argp[0].gp_offset = 0x20;\n    argp[0].fp_offset = 0x30;\n    argp[0].overflow_arg_area = &stack0x00000008;\n    argp[0].reg_save_area = local_b8;\n    code = vw_printw(win,fmt,argp);\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is mvwprintw"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int z)\n\n{\n  return (int)(byte)((ulong)(long)z >> 8);\n}\n\n",
        "output": "The predicted function name is PAIR_NUMBER"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  termios *buf;\n  \n  buf = saved_tty(sp);\n  iVar1 = _nc_set_tty_mode_sp(sp,buf);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is resetty_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int color,int *r,int *g,int *b)\n\n{\n  byte bVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  int result;\n  int c_r;\n  int c_g;\n  int c_b;\n  int maxcolors;\n  int max_r;\n  int max_g;\n  int max_b;\n  int bitoff;\n  rgb_bits_t *work;\n  \n  result = -1;\n  if ((((sp != (SCREEN *)0x0) && (-1 < color)) && (color < COLORS)) &&\n     ((color < (cur_term->type).Numbers[0xd] && (sp->_coloron != 0)))) {\n    if (sp->_direct_color == 0) {\n      c_r = sp->_color_table[color].red;\n      c_g = sp->_color_table[color].green;\n      c_b = sp->_color_table[color].blue;\n    }\n    else {\n      uVar2 = (1 << (*(byte *)&sp->_direct_color & 0x1f)) - 1;\n      uVar3 = (1 << (*(byte *)((long)&sp->_direct_color + 1) & 0x1f)) - 1;\n      uVar4 = (1 << (*(byte *)((long)&sp->_direct_color + 2) & 0x1f)) - 1;\n      c_b = (int)((color & uVar4) * 1000) / (int)uVar4;\n      bVar1 = *(byte *)((long)&sp->_direct_color + 2);\n      c_g = (int)((color >> (bVar1 & 0x1f) & uVar3) * 1000) / (int)uVar3;\n      c_r = (int)((color >> (bVar1 + *(char *)((long)&sp->_direct_color + 1) & 0x1f) & uVar2) * 1000\n                 ) / (int)uVar2;\n    }\n    if (r != (int *)0x0) {\n      *r = c_r;\n    }\n    if (g != (int *)0x0) {\n      *g = c_g;\n    }\n    if (b != (int *)0x0) {\n      *b = c_b;\n    }\n    result = 0;\n  }\n  if (result != 0) {\n    if (r != (int *)0x0) {\n      *r = 0;\n    }\n    if (g != (int *)0x0) {\n      *g = 0;\n    }\n    if (b != (int *)0x0) {\n      *b = 0;\n    }\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is _nc_color_content"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Removing unreachable block (ram,0x000208ff) */\n/* WARNING: Removing unreachable block (ram,0x00020917) */\n\nint [MASK](void)\n\n{\n  int value;\n  \n  return 0;\n}\n\n",
        "output": "The predicted function name is _nc_vdisable"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win)\n\n{\n  short sVar1;\n  short sVar2;\n  chtype cVar3;\n  chtype *pcVar4;\n  ldat *plVar5;\n  int code;\n  chtype blank;\n  chtype *temp2;\n  chtype *temp1;\n  ldat *line;\n  chtype *end;\n  \n  code = -1;\n  if (win != (WINDOW *)0x0) {\n    cVar3 = win->_bkgd;\n    plVar5 = win->_line + win->_cury;\n    pcVar4 = plVar5->text;\n    sVar1 = win->_maxx;\n    sVar2 = win->_curx;\n    if ((plVar5->firstchar == -1) || (win->_curx < plVar5->firstchar)) {\n      plVar5->firstchar = win->_curx;\n    }\n    plVar5->lastchar = win->_maxx;\n    temp2 = plVar5->text + (long)sVar2 + 1;\n    temp1 = plVar5->text + (long)sVar2 + 1 + -1;\n    while (temp1 < pcVar4 + sVar1) {\n      *temp1 = *temp2;\n      temp2 = temp2 + 1;\n      temp1 = temp1 + 1;\n    }\n    *temp1 = cVar3;\n    _nc_synchook(win);\n    code = 0;\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is wdelch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = slk_touch_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is slk_touch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *a1,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = winsnstr(stdscr,a1,z);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is insnstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = slk_refresh_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is slk_refresh"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  \n  if ((sp == (SCREEN *)0x0) || (sp->_slk == (_SLK *)0x0)) {\n    iVar1 = -1;\n  }\n  else if (sp->_slk->hidden == false) {\n    slk_intern_refresh(sp);\n    iVar1 = wnoutrefresh(sp->_slk->win);\n  }\n  else {\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is slk_noutrefresh_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchtype [MASK](void)\n\n{\n  chtype cVar1;\n  \n  cVar1 = termattrs_sp(SP);\n  return cVar1;\n}\n\n",
        "output": "The predicted function name is termattrs"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,char *name,char *string)\n\n{\n  int rc;\n  \n  rc = -1;\n  if (string != (char *)0x0) {\n    rc = tputs_sp(sp,string,1,_nc_outch_sp);\n  }\n  return rc;\n}\n\n",
        "output": "The predicted function name is _nc_putp_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nWINDOW * [MASK](SCREEN *sp,int num_lines,int num_columns,int begy,int begx,int flags)\n\n{\n  _Bool _Var1;\n  WINDOW *pWVar2;\n  _win_list *__ptr;\n  ldat *plVar3;\n  bool bVar4;\n  _Bool is_padwin;\n  int i;\n  _win_list *wp;\n  WINDOW *win;\n  \n  bVar4 = (flags & 0x10U) == 0;\n  if (sp == (SCREEN *)0x0) {\n    pWVar2 = (WINDOW *)0x0;\n  }\n  else {\n    _Var1 = dimension_limit(num_lines);\n    if ((_Var1 == true) && (_Var1 = dimension_limit(num_columns), _Var1 == true)) {\n      __ptr = (_win_list *)calloc(1,0x68);\n      if (__ptr == (_win_list *)0x0) {\n        pWVar2 = (WINDOW *)0x0;\n      }\n      else {\n        pWVar2 = &__ptr->win;\n        plVar3 = (ldat *)calloc((ulong)(uint)num_lines,0x10);\n        (__ptr->win)._line = plVar3;\n        if ((__ptr->win)._line == (ldat *)0x0) {\n          free(__ptr);\n          pWVar2 = (WINDOW *)0x0;\n        }\n        else {\n          (__ptr->win)._curx = 0;\n          pWVar2->_cury = 0;\n          (__ptr->win)._maxy = (short)num_lines + -1;\n          (__ptr->win)._maxx = (short)num_columns + -1;\n          (__ptr->win)._begy = (short)begy;\n          (__ptr->win)._begx = (short)begx;\n          (__ptr->win)._yoffset = sp->_topstolen;\n          (__ptr->win)._flags = (short)flags;\n          (__ptr->win)._attrs = 0;\n          (__ptr->win)._bkgd = 0x20;\n          if (bVar4) {\n            if ((num_lines == sp->_lines) && (num_columns == sp->_columns)) {\n              _Var1 = true;\n            }\n            else {\n              _Var1 = false;\n            }\n          }\n          else {\n            _Var1 = false;\n          }\n          (__ptr->win)._clear = _Var1;\n          (__ptr->win)._idlok = false;\n          (__ptr->win)._idcok = true;\n          (__ptr->win)._scroll = false;\n          (__ptr->win)._leaveok = false;\n          (__ptr->win)._use_keypad = false;\n          (__ptr->win)._delay = -1;\n          (__ptr->win)._immed = false;\n          (__ptr->win)._sync = false;\n          (__ptr->win)._parx = -1;\n          (__ptr->win)._pary = -1;\n          (__ptr->win)._parent = (WINDOW *)0x0;\n          (__ptr->win)._regtop = 0;\n          (__ptr->win)._regbottom = (short)num_lines + -1;\n          (__ptr->win)._pad._pad_y = -1;\n          (__ptr->win)._pad._pad_x = -1;\n          (__ptr->win)._pad._pad_top = -1;\n          (__ptr->win)._pad._pad_bottom = -1;\n          (__ptr->win)._pad._pad_left = -1;\n          (__ptr->win)._pad._pad_right = -1;\n          for (i = 0; i < num_lines; i = i + 1) {\n            (__ptr->win)._line[i].firstchar = 0;\n            (__ptr->win)._line[i].lastchar = (short)num_columns + -1;\n          }\n          if ((bVar4) && (begx + num_columns == (int)sp->_columns)) {\n            (__ptr->win)._flags = (__ptr->win)._flags | 2;\n            if ((begx == 0) && ((num_lines == sp->_lines && (begy == 0)))) {\n              (__ptr->win)._flags = (__ptr->win)._flags | 4;\n            }\n            if (begy + num_lines == (int)sp->_lines) {\n              (__ptr->win)._flags = (__ptr->win)._flags | 8;\n            }\n          }\n          __ptr->next = _nc_globals._nc_windowlist;\n          __ptr->screen = sp;\n          _nc_globals._nc_windowlist = __ptr;\n        }\n      }\n    }\n    else {\n      pWVar2 = (WINDOW *)0x0;\n    }\n  }\n  return pWVar2;\n}\n\n",
        "output": "The predicted function name is _nc_makenew_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,int pminrow,int pmincol,int sminrow,int smincol,int smaxrow,int smaxcol)\n\n{\n  int iVar1;\n  SCREEN *sp_00;\n  SCREEN *sp;\n  \n  sp_00 = _nc_screen_of(win);\n  iVar1 = pnoutrefresh(win,pminrow,pmincol,sminrow,smincol,smaxrow,smaxcol);\n  if ((iVar1 != -1) && (iVar1 = doupdate_sp(sp_00), iVar1 != -1)) {\n    return 0;\n  }\n  return -1;\n}\n\n",
        "output": "The predicted function name is prefresh"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](TERMTYPE *to,TERMTYPE *from)\n\n{\n  bool bVar1;\n  bool bVar2;\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  int ext_Numbers_00;\n  int ext_Strings_00;\n  char **dst;\n  char **ppcVar6;\n  _Bool used_ext_Names;\n  _Bool same;\n  int n;\n  int na;\n  int nb;\n  int ext_Booleans;\n  int ext_Numbers;\n  int ext_Strings;\n  char **ext_Names;\n  \n  if (to == (TERMTYPE *)0x0) {\n    iVar3 = 0;\n  }\n  else {\n    iVar3 = (uint)to->ext_Strings + (uint)to->ext_Booleans + (uint)to->ext_Numbers;\n  }\n  if (from == (TERMTYPE *)0x0) {\n    iVar4 = 0;\n  }\n  else {\n    iVar4 = (uint)from->ext_Strings + (uint)from->ext_Booleans + (uint)from->ext_Numbers;\n  }\n  if (((to != (TERMTYPE *)0x0) && (from != (TERMTYPE *)0x0)) && ((iVar3 != 0 || (iVar4 != 0)))) {\n    bVar2 = false;\n    if ((((iVar3 == iVar4) && (to->ext_Booleans == from->ext_Booleans)) &&\n        (to->ext_Numbers == from->ext_Numbers)) && (to->ext_Strings == from->ext_Strings)) {\n      bVar1 = true;\n      for (n = 0; n < iVar3; n = n + 1) {\n        iVar5 = strcmp(to->ext_Names[n],from->ext_Names[n]);\n        if (iVar5 != 0) {\n          bVar1 = false;\n          break;\n        }\n      }\n      if (bVar1) {\n        return;\n      }\n    }\n    dst = (char **)malloc((long)(iVar4 + iVar3) << 3);\n    if (dst == (char **)0x0) {\n                    /* WARNING: Subroutine does not return */\n      _nc_err_abort(\"Out of memory\");\n    }\n    if ((to->ext_Strings != 0) && ((uint)from->ext_Numbers + (uint)from->ext_Booleans != 0)) {\n      adjust_cancels(to,from);\n    }\n    if ((from->ext_Strings != 0) && ((uint)to->ext_Numbers + (uint)to->ext_Booleans != 0)) {\n      adjust_cancels(from,to);\n    }\n    iVar5 = merge_names(dst,to->ext_Names,(uint)to->ext_Booleans,from->ext_Names,\n                        (uint)from->ext_Booleans);\n    ext_Numbers_00 =\n         merge_names(dst + iVar5,to->ext_Names + to->ext_Booleans,(uint)to->ext_Numbers,\n                     from->ext_Names + from->ext_Booleans,(uint)from->ext_Numbers);\n    ext_Strings_00 =\n         merge_names(dst + (long)iVar5 + (long)ext_Numbers_00,\n                     to->ext_Names + (ulong)to->ext_Numbers + (ulong)to->ext_Booleans,\n                     (uint)to->ext_Strings,\n                     from->ext_Names + (ulong)from->ext_Numbers + (ulong)from->ext_Booleans,\n                     (uint)from->ext_Strings);\n    if (iVar3 != ext_Strings_00 + iVar5 + ext_Numbers_00) {\n      realign_data(to,dst,iVar5,ext_Numbers_00,ext_Strings_00);\n      if (to->ext_Names != (char **)0x0) {\n        free(to->ext_Names);\n      }\n      to->ext_Names = dst;\n      bVar2 = true;\n    }\n    if (iVar4 != ext_Strings_00 + iVar5 + ext_Numbers_00) {\n      iVar3 = ext_Strings_00 + iVar5 + ext_Numbers_00;\n      realign_data(from,dst,iVar5,ext_Numbers_00,ext_Strings_00);\n      ppcVar6 = (char **)_nc_doalloc(from->ext_Names,(long)iVar3 * 8);\n      from->ext_Names = ppcVar6;\n      if (from->ext_Names == (char **)0x0) {\n                    /* WARNING: Subroutine does not return */\n        _nc_err_abort(\"Out of memory\");\n      }\n      memcpy(from->ext_Names,dst,(long)iVar3 * 8);\n    }\n    if (!bVar2) {\n      free(dst);\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_align_termtype"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int enable)\n\n{\n  int iVar1;\n  \n  if (_nc_signal_handler::lexical_block_0::ignore_tstp != true) {\n    if (enable == 0) {\n      _nc_signal_handler::lexical_block_0::lexical_block_0_0::new_sigaction.__sigaction_handler =\n           (code *)0x1;\n      sigaction(0x14,(sigaction *)\n                     &_nc_signal_handler::lexical_block_0::lexical_block_0_0::new_sigaction,\n                (sigaction *)&_nc_signal_handler::lexical_block_0::lexical_block_0_0::old_sigaction)\n      ;\n    }\n    else if (_nc_signal_handler::lexical_block_0::lexical_block_0_0::new_sigaction.\n             __sigaction_handler == (code *)0x0) {\n      iVar1 = sigaction(0x14,(sigaction *)0x0,\n                        (sigaction *)\n                        &_nc_signal_handler::lexical_block_0::lexical_block_0_0::old_sigaction);\n      if ((iVar1 == 0) &&\n         (_nc_signal_handler::lexical_block_0::lexical_block_0_0::old_sigaction.__sigaction_handler\n          == 0)) {\n        sigemptyset((sigset_t *)\n                    &_nc_signal_handler::lexical_block_0::lexical_block_0_0::new_sigaction.sa_mask);\n        _nc_signal_handler::lexical_block_0::lexical_block_0_0::new_sigaction.sa_flags =\n             _nc_signal_handler::lexical_block_0::lexical_block_0_0::new_sigaction.sa_flags |\n             0x10000000;\n        _nc_signal_handler::lexical_block_0::lexical_block_0_0::new_sigaction.__sigaction_handler =\n             handle_SIGTSTP;\n        sigaction(0x14,(sigaction *)\n                       &_nc_signal_handler::lexical_block_0::lexical_block_0_0::new_sigaction,\n                  (sigaction *)0x0);\n      }\n      else {\n        _nc_signal_handler::lexical_block_0::ignore_tstp = true;\n      }\n    }\n    else {\n      sigaction(0x14,(sigaction *)\n                     &_nc_signal_handler::lexical_block_0::lexical_block_0_0::old_sigaction,\n                (sigaction *)0x0);\n    }\n  }\n  if ((_nc_globals.init_signals != true) && (enable != 0)) {\n    CatchIfDefault(2,handle_SIGINT);\n    CatchIfDefault(0xf,handle_SIGINT);\n    CatchIfDefault(0x1c,handle_SIGWINCH);\n    _nc_globals.init_signals = true;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_signal_handler"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = werase(stdscr);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is erase"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nuser_table_entry * [MASK](char *string)\n\n{\n  HashValue HVar1;\n  uint uVar2;\n  int iVar3;\n  HashData *pHVar4;\n  user_table_entry *puVar5;\n  long lVar6;\n  int hashvalue;\n  user_table_entry *ptr;\n  HashData *data;\n  user_table_entry *real_table;\n  \n  pHVar4 = _nc_get_hash_user();\n  ptr = (user_table_entry *)0x0;\n  HVar1 = (*pHVar4->hash_of)(string);\n  uVar2 = (uint)HVar1;\n  if (((-1 < (int)uVar2) && (uVar2 < pHVar4->table_size)) && (-1 < pHVar4->table_data[(int)uVar2]))\n  {\n    puVar5 = _nc_get_userdefs_table();\n    lVar6 = (long)pHVar4->table_data[(int)uVar2];\n    while( true ) {\n      ptr = puVar5 + lVar6;\n      iVar3 = (*pHVar4->compare_names)(ptr->ute_name,string);\n      if (iVar3 != 0) break;\n      if (ptr->ute_link < 0) {\n        return (user_table_entry *)0x0;\n      }\n      lVar6 = (long)((int)pHVar4->table_data[pHVar4->table_size] + (int)ptr->ute_link);\n    }\n  }\n  return ptr;\n}\n\n",
        "output": "The predicted function name is _nc_find_user_entry"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,int a2,int a3,char *a4,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(a1,a2,a3);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = waddnstr(a1,a4,z);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvwaddnstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,string_desc *target,int from_y,int from_x,int to_y,int to_x,int ovw)\n\n{\n  long lVar1;\n  _Bool _Var2;\n  uint uVar3;\n  int iVar4;\n  char *pcVar5;\n  string_desc *psVar6;\n  long in_FS_OFFSET;\n  int vcost;\n  int hcost;\n  int lhcost;\n  int i;\n  int i_1;\n  int n;\n  int lhcost_1;\n  chtype ch;\n  string_desc save;\n  string_desc check;\n  char str [512];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  vcost = 0;\n  hcost = 0;\n  _nc_str_copy(&save,target);\n  if (to_y != from_y) {\n    vcost = 1000000;\n    if ((cur_term->type).Strings[0x7f] != (char *)0x0) {\n      pcVar5 = _nc_tiparm(1,(cur_term->type).Strings[0x7f],(ulong)(uint)to_y);\n      _Var2 = _nc_safe_strcat(target,pcVar5);\n      if (_Var2 != false) {\n        vcost = sp->_vpa_cost;\n      }\n    }\n    if (from_y < to_y) {\n      uVar3 = to_y - from_y;\n      if (((cur_term->type).Strings[0x6b] != (char *)0x0) && (sp->_cud_cost < vcost)) {\n        pcVar5 = _nc_tiparm(1,(cur_term->type).Strings[0x6b],(ulong)uVar3);\n        psVar6 = _nc_str_copy(target,&save);\n        _Var2 = _nc_safe_strcat(psVar6,pcVar5);\n        if (_Var2 != false) {\n          vcost = sp->_cud_cost;\n        }\n      }\n      if ((((cur_term->type).Strings[0xb] != (char *)0x0) &&\n          (*(cur_term->type).Strings[0xb] != '\\n')) && ((int)(sp->_cud1_cost * uVar3) < vcost)) {\n        pcVar5 = (cur_term->type).Strings[0xb];\n        iVar4 = sp->_cud1_cost;\n        psVar6 = _nc_str_copy(target,&save);\n        vcost = repeated_append(psVar6,0,iVar4,uVar3,pcVar5);\n      }\n    }\n    else {\n      uVar3 = from_y - to_y;\n      if (((cur_term->type).Strings[0x72] != (char *)0x0) && (sp->_cuu_cost < vcost)) {\n        pcVar5 = _nc_tiparm(1,(cur_term->type).Strings[0x72],(ulong)uVar3);\n        psVar6 = _nc_str_copy(target,&save);\n        _Var2 = _nc_safe_strcat(psVar6,pcVar5);\n        if (_Var2 != false) {\n          vcost = sp->_cuu_cost;\n        }\n      }\n      if (((cur_term->type).Strings[0x13] != (char *)0x0) && ((int)(sp->_cuu1_cost * uVar3) < vcost)\n         ) {\n        pcVar5 = (cur_term->type).Strings[0x13];\n        iVar4 = sp->_cuu1_cost;\n        psVar6 = _nc_str_copy(target,&save);\n        vcost = repeated_append(psVar6,0,iVar4,uVar3,pcVar5);\n      }\n    }\n    if (vcost == 1000000) {\n      iVar4 = 1000000;\n      goto LAB_00012a05;\n    }\n  }\n  save.s_head = target->s_head;\n  save.s_tail = target->s_tail;\n  save.s_size = target->s_size;\n  save.s_init = target->s_init;\n  if (to_x != from_x) {\n    hcost = 1000000;\n    if ((cur_term->type).Strings[8] != (char *)0x0) {\n      pcVar5 = _nc_tiparm(1,(cur_term->type).Strings[8],(ulong)(uint)to_x);\n      psVar6 = _nc_str_copy(target,&save);\n      _Var2 = _nc_safe_strcat(psVar6,pcVar5);\n      if (_Var2 != false) {\n        hcost = sp->_hpa_cost;\n      }\n    }\n    if (from_x < to_x) {\n      uVar3 = to_x - from_x;\n      if (((cur_term->type).Strings[0x70] != (char *)0x0) && (sp->_cuf_cost < hcost)) {\n        pcVar5 = _nc_tiparm(1,(cur_term->type).Strings[0x70],(ulong)uVar3);\n        psVar6 = _nc_str_copy(target,&save);\n        _Var2 = _nc_safe_strcat(psVar6,pcVar5);\n        if (_Var2 != false) {\n          hcost = sp->_cuf_cost;\n        }\n      }\n      if ((cur_term->type).Strings[0x11] != (char *)0x0) {\n        _nc_str_init(&check,str,0x200);\n        if (((int)uVar3 < 1) || ((int)check.s_size <= (int)uVar3)) {\n          ovw = 0;\n        }\n        if (ovw != 0) {\n          for (i = 0; i < (int)uVar3; i = i + 1) {\n            if ((int3)(*sp->_current_attr >> 8) !=\n                (int3)(sp->_newscr->_line[to_y].text[i + from_x] >> 8)) {\n              ovw = 0;\n              break;\n            }\n          }\n        }\n        if (ovw == 0) {\n          lhcost = repeated_append(&check,0,sp->_cuf1_cost,uVar3,(cur_term->type).Strings[0x11]);\n        }\n        else {\n          for (i_1 = 0; i_1 < (int)uVar3; i_1 = i_1 + 1) {\n            *check.s_tail = (char)sp->_newscr->_line[to_y].text[i_1 + from_x];\n            check.s_tail = check.s_tail + 1;\n          }\n          *check.s_tail = '\\0';\n          check.s_size = check.s_size - (long)(int)uVar3;\n          lhcost = sp->_char_padding * uVar3;\n        }\n        if (lhcost < hcost) {\n          psVar6 = _nc_str_copy(target,&save);\n          _Var2 = _nc_safe_strcat(psVar6,str);\n          if (_Var2 != false) {\n            hcost = lhcost;\n          }\n        }\n      }\n    }\n    else {\n      if (((cur_term->type).Strings[0x6f] != (char *)0x0) && (sp->_cub_cost < hcost)) {\n        pcVar5 = _nc_tiparm(1,(cur_term->type).Strings[0x6f],(ulong)(uint)(from_x - to_x));\n        psVar6 = _nc_str_copy(target,&save);\n        _Var2 = _nc_safe_strcat(psVar6,pcVar5);\n        if (_Var2 != false) {\n          hcost = sp->_cub_cost;\n        }\n      }\n      if ((cur_term->type).Strings[0xe] != (char *)0x0) {\n        _nc_str_init(&check,str,0x200);\n        iVar4 = repeated_append(&check,0,sp->_cub1_cost,from_x - to_x,(cur_term->type).Strings[0xe])\n        ;\n        if (iVar4 < hcost) {\n          psVar6 = _nc_str_copy(target,&save);\n          _Var2 = _nc_safe_strcat(psVar6,str);\n          if (_Var2 != false) {\n            hcost = iVar4;\n          }\n        }\n      }\n    }\n    if (hcost == 1000000) {\n      iVar4 = 1000000;\n      goto LAB_00012a05;\n    }\n  }\n  iVar4 = hcost + vcost;\nLAB_00012a05:\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar4;\n}\n\n",
        "output": "The predicted function name is relative_move"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](chtype *a1,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = winchnstr(stdscr,a1,z);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is inchnstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *z)\n\n{\n  int iVar1;\n  \n  iVar1 = winsdelln(z,1);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is winsertln"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nchar [MASK](SCREEN *sp)\n\n{\n  uint uVar1;\n  term_conflict *ptVar2;\n  int result;\n  TERMINAL_conflict *termp;\n  \n  result._0_1_ = 0xff;\n  ptVar2 = cur_term;\n  if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n    ptVar2 = sp->_term;\n  }\n  if (ptVar2 != (term_conflict *)0x0) {\n    result._0_1_ = (ptVar2->Ottyb).c_cc[3];\n    uVar1 = _nc_vdisable();\n    if ((byte)result == uVar1) {\n      result._0_1_ = 0xff;\n    }\n  }\n  return (byte)result;\n}\n\n",
        "output": "The predicted function name is killchar_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,chtype *ntext,int num)\n\n{\n  uint ch;\n  bool bVar1;\n  int3 iVar2;\n  _Bool _Var3;\n  char *pcVar4;\n  int local_3c;\n  chtype *local_38;\n  _Bool wrap_possible;\n  int i;\n  int runcount;\n  chtype temp;\n  int rep_count;\n  chtype ntext0;\n  \n  local_3c = num;\n  local_38 = ntext;\n  if (((cur_term->type).Strings[0x25] == (char *)0x0) &&\n     ((cur_term->type).Strings[0x79] == (char *)0x0)) {\n    for (i = 0; i < num; i = i + 1) {\n      PutChar(sp,ntext[i]);\n    }\n  }\n  else {\n    for (; 0 < local_3c; local_3c = local_3c - runcount) {\n      for (; (1 < local_3c && (*local_38 != local_38[1])); local_38 = local_38 + 1) {\n        PutChar(sp,*local_38);\n        local_3c = local_3c + -1;\n      }\n      ch = *local_38;\n      if (local_3c == 1) {\n        PutChar(sp,ch);\n        return 0;\n      }\n      for (runcount = 2; (runcount < local_3c && (ch == local_38[runcount]));\n          runcount = runcount + 1) {\n      }\n      iVar2 = (int3)(ch >> 8);\n      if ((((cur_term->type).Strings[0x25] == (char *)0x0) ||\n          (runcount <= sp->_cup_ch_cost + sp->_ech_cost)) ||\n         (_Var3 = can_clear_with(sp,ch), _Var3 == false)) {\n        if (((cur_term->type).Strings[0x79] == (char *)0x0) || (runcount <= sp->_rep_cost)) {\n          for (i = 0; i < runcount; i = i + 1) {\n            PutChar(sp,local_38[i]);\n          }\n        }\n        else {\n          bVar1 = (int)sp->_columns <= sp->_curscol + runcount;\n          rep_count = runcount;\n          if (bVar1) {\n            rep_count = runcount + -1;\n          }\n          if ((int3)(*sp->_current_attr >> 8) != iVar2) {\n            vidputs_sp(sp,ch & 0xffffff00,_nc_outch_sp);\n          }\n          temp = ch;\n          if ((((ch & 0x400000) != 0) && (sp->_acs_map != (chtype *)0x0)) &&\n             ((sp->_acs_map[ch & 0xff] & 0xff) != 0)) {\n            temp = sp->_acs_map[ch & 0xff] & 0xff;\n          }\n          pcVar4 = _nc_tiparm(2,(cur_term->type).Strings[0x79],(ulong)(temp & 0xff),\n                              (ulong)(uint)rep_count);\n          tputs_sp(sp,pcVar4,1,_nc_outch_sp);\n          sp->_curscol = sp->_curscol + rep_count;\n          if (bVar1) {\n            PutChar(sp,ch);\n          }\n        }\n      }\n      else {\n        if ((int3)(*sp->_current_attr >> 8) != iVar2) {\n          vidputs_sp(sp,ch & 0xffffff00,_nc_outch_sp);\n        }\n        pcVar4 = _nc_tiparm(1,(cur_term->type).Strings[0x25],(ulong)(uint)runcount);\n        _nc_putp_sp(sp,\"erase_chars\",pcVar4);\n        if (local_3c <= runcount) {\n          return 1;\n        }\n        GoTo(sp,sp->_cursrow,sp->_curscol + runcount);\n      }\n      local_38 = local_38 + runcount;\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is EmitRange"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](TERMTYPE *tp,char *name,int token_type)\n\n{\n  uint uVar1;\n  int iVar2;\n  uint j;\n  uint first;\n  uint last;\n  \n  j = _nc_first_ext_name(tp,token_type);\n  uVar1 = _nc_last_ext_name(tp,token_type);\n  while( true ) {\n    if (uVar1 <= j) {\n      return -1;\n    }\n    iVar2 = strcmp(name,tp->ext_Names[j]);\n    if (iVar2 == 0) break;\n    j = j + 1;\n  }\n  return j;\n}\n\n",
        "output": "The predicted function name is _nc_find_ext_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](SCREEN *sp,char *str)\n\n{\n  int iVar1;\n  term_conflict *ptVar2;\n  name_table_entry *pnVar3;\n  char *__s2;\n  bool bVar4;\n  int j;\n  int i;\n  char *result;\n  TERMTYPE *tp;\n  name_table_entry *entry_ptr;\n  char *capname;\n  \n  result = (char *)0xffffffffffffffff;\n  if (sp == (SCREEN *)0x0) {\n    bVar4 = cur_term != (term_conflict *)0x0;\n  }\n  else if (sp->_term == (TERMINAL_conflict *)0x0) {\n    bVar4 = cur_term != (term_conflict *)0x0;\n  }\n  else {\n    bVar4 = sp->_term != (TERMINAL_conflict *)0x0;\n  }\n  if (bVar4) {\n    ptVar2 = cur_term;\n    if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n      ptVar2 = sp->_term;\n    }\n    j = -1;\n    pnVar3 = _nc_find_type_entry(str,2,false);\n    if (pnVar3 == (name_table_entry *)0x0) {\n      for (i = 0x19e; i < (int)(uint)(ptVar2->type).num_Strings; i = i + 1) {\n        if (i < 0x19e) {\n          __s2 = *(char **)(strnames + (long)i * 8);\n        }\n        else {\n          __s2 = (ptVar2->type).ext_Names\n                 [(int)((uint)(ptVar2->type).ext_Booleans + (uint)(ptVar2->type).ext_Numbers +\n                       (i - ((uint)(ptVar2->type).num_Strings - (uint)(ptVar2->type).ext_Strings)))]\n          ;\n        }\n        iVar1 = strcmp(str,__s2);\n        if (iVar1 == 0) {\n          j = i;\n          break;\n        }\n      }\n    }\n    else {\n      j = (int)pnVar3->nte_index;\n    }\n    if (-1 < j) {\n      result = (ptVar2->type).Strings[j];\n    }\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is tigetstr_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  \n  if (sp == (SCREEN *)0x0) {\n    iVar1 = 0;\n  }\n  else {\n    iVar1 = sp->_default_bg;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is default_bg"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  _nc_prescreen.filter_mode = true;\n  return;\n}\n\n",
        "output": "The predicted function name is filter"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nint [MASK](SCREEN *sp)\n\n{\n  long lVar1;\n  term_conflict *ptVar2;\n  long in_FS_OFFSET;\n  int result;\n  TERMINAL_conflict *termp;\n  termios buf;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  result = -1;\n  ptVar2 = cur_term;\n  if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n    ptVar2 = sp->_term;\n  }\n  if (ptVar2 != (term_conflict *)0x0) {\n    buf._16_8_ = *(undefined8 *)&(ptVar2->Nttyb).c_line;\n    buf.c_cc._7_8_ = *(undefined8 *)((ptVar2->Nttyb).c_cc + 7);\n    buf.c_cc._15_8_ = *(undefined8 *)((ptVar2->Nttyb).c_cc + 0xf);\n    buf.c_cc._23_8_ = *(undefined8 *)((ptVar2->Nttyb).c_cc + 0x17);\n    buf._48_8_ = *(undefined8 *)((ptVar2->Nttyb).c_cc + 0x1f);\n    buf.c_ospeed = (ptVar2->Nttyb).c_ospeed;\n    buf._8_8_ = *(ulong *)&(ptVar2->Nttyb).c_cflag | 0x200000000;\n    buf._0_8_ = *(ulong *)&ptVar2->Nttyb | 0x100;\n    result = _nc_set_tty_mode_sp(sp,&buf);\n    if (result == 0) {\n      if (sp != (SCREEN *)0x0) {\n        sp->_cbreak = 0;\n      }\n      *(ulong *)&ptVar2->Nttyb = buf._0_8_;\n      *(ulong *)&(ptVar2->Nttyb).c_cflag = buf._8_8_;\n      *(undefined8 *)&(ptVar2->Nttyb).c_line = buf._16_8_;\n      *(undefined8 *)((ptVar2->Nttyb).c_cc + 7) = buf.c_cc._7_8_;\n      *(undefined8 *)((ptVar2->Nttyb).c_cc + 0xf) = buf.c_cc._15_8_;\n      *(undefined8 *)((ptVar2->Nttyb).c_cc + 0x17) = buf.c_cc._23_8_;\n      *(undefined8 *)((ptVar2->Nttyb).c_cc + 0x1f) = buf._48_8_;\n      (ptVar2->Nttyb).c_ospeed = buf.c_ospeed;\n    }\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return result;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is nocbreak_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](WINDOW *win,_Bool flag)\n\n{\n  _Bool _Var1;\n  SCREEN *sp_00;\n  SCREEN *sp;\n  \n  if (win != (WINDOW *)0x0) {\n    sp_00 = _nc_screen_of(win);\n    if ((flag == false) || (_Var1 = has_ic_sp(sp_00), _Var1 == false)) {\n      _Var1 = false;\n    }\n    else {\n      _Var1 = true;\n    }\n    win->_idcok = _Var1;\n    sp_00->_nc_sp_idcok = win->_idcok;\n    return;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is idcok"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int a1,int a2,chtype a3,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(stdscr,a1,a2);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = wvline(stdscr,a3,z);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvvline"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *string)\n\n{\n  int iVar1;\n  \n  iVar1 = putp_sp(SP,string);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is putp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,int *result,int use_meta)\n\n{\n  long lVar1;\n  _Bool _Var2;\n  int iVar3;\n  uint uVar4;\n  SCREEN *sp_00;\n  size_t sVar5;\n  long in_FS_OFFSET;\n  int ch;\n  int delay;\n  int runcount;\n  int rc;\n  chtype backup;\n  char *bufp;\n  SCREEN *sp;\n  char buf [135];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  *result = 0;\n  sp_00 = _nc_screen_of(win);\n  if ((win == (WINDOW *)0x0) || (sp_00 == (SCREEN *)0x0)) {\n    iVar3 = -1;\n    goto LAB_0000e31e;\n  }\n  if ((-1 < sp_00->_fifohead) && (sp_00->_fifopeek != sp_00->_fifohead)) {\n    recur_wrefresh(win);\n    iVar3 = fifo_pull(sp_00);\n    *result = iVar3;\n    if (*result < 0x101) {\n      iVar3 = 0;\n    }\n    else {\n      iVar3 = 0x100;\n    }\n    goto LAB_0000e31e;\n  }\n  if ((((sp_00->_fifohead == -1) && (sp_00->_notty != true)) && (sp_00->_raw == 0)) &&\n     ((sp_00->_cbreak == 0 && (sp_00->_called_wgetch != true)))) {\n    iVar3 = recur_wgetnstr(win,buf);\n    if (iVar3 != -1) {\n      ungetch_sp(sp_00,10);\n    }\n    sVar5 = strlen(buf);\n    for (bufp = buf + sVar5; buf < bufp; bufp = bufp + -1) {\n      ungetch_sp(sp_00,(int)bufp[-1]);\n    }\n    iVar3 = fifo_pull(sp_00);\n    *result = iVar3;\n    if (*result < 0x101) {\n      iVar3 = 0;\n    }\n    else {\n      iVar3 = 0x100;\n    }\n    goto LAB_0000e31e;\n  }\n  if (win->_use_keypad != sp_00->_keypad_on) {\n    _nc_keypad(sp_00,(uint)win->_use_keypad);\n  }\n  recur_wrefresh(win);\n  if ((((win->_notimeout == false) && (win->_delay < 0)) && (sp_00->_cbreak < 2)) ||\n     (sp_00->_fifohead != -1)) {\nLAB_0000dff4:\n    if (win->_use_keypad != false) {\n      runcount = 0;\n      do {\n        ch = kgetch(sp_00,win->_notimeout);\n        if (ch == 0x199) {\n          runcount = runcount + 1;\n          _Var2 = (*sp_00->_mouse_inline)(sp_00);\n          if (_Var2 != false) goto LAB_0000e0f9;\n        }\n        if (((sp_00->_maxclick < 0) || (ch != 0x199)) ||\n           (((uVar4 = check_mouse_activity(sp_00,sp_00->_maxclick), uVar4 == 0 || ((uVar4 & 4) != 0)\n             ) && (_Var2 = (*sp_00->_mouse_parse)(sp_00,runcount), _Var2 == true))))\n        goto LAB_0000e0f9;\n      } while( true );\n    }\n    if (sp_00->_fifohead == -1) {\n      fifo_push(sp_00);\n    }\n    ch = fifo_pull(sp_00);\n    goto LAB_0000e169;\n  }\n  if (sp_00->_cbreak < 2) {\n    delay = win->_delay;\n  }\n  else {\n    delay = (sp_00->_cbreak + -1) * 100;\n  }\n  iVar3 = check_mouse_activity(sp_00,delay);\n  if (iVar3 != 0) goto LAB_0000dff4;\n  goto check_sigwinch;\nLAB_0000e0f9:\n  if ((0 < runcount) && (ch != 0x199)) {\n    ungetch_sp(sp_00,ch);\n    ch = 0x199;\n  }\nLAB_0000e169:\n  if (ch != -1) {\n    if ((sp_00->_echo != 0) && ((win->_flags & 0x10U) == 0)) {\n      uVar4 = ch;\n      if (ch == 0x107) {\n        uVar4 = 8;\n      }\n      if (uVar4 < 0x101) {\n        wechochar(win,uVar4);\n      }\n    }\n    if ((ch == 0xd) && (sp_00->_nl != 0)) {\n      ch = 10;\n    }\n    if (((use_meta == 0) && (ch < 0x101)) && ((ch & 0x80U) != 0)) {\n      ch = ch & 0x7f;\n    }\n    *result = ch;\n    if (ch < 0x101) {\n      iVar3 = 0;\n    }\n    else {\n      iVar3 = 0x100;\n    }\n    goto LAB_0000e31e;\n  }\ncheck_sigwinch:\n  iVar3 = _nc_handle_sigwinch(sp_00);\n  if (((iVar3 == 0) || (_nc_update_screensize(sp_00), sp_00->_fifohead < 0)) ||\n     (sp_00->_fifopeek == sp_00->_fifohead)) {\n    iVar3 = -1;\n  }\n  else {\n    iVar3 = fifo_pull(sp_00);\n    *result = iVar3;\n    iVar3 = fifo_peek(sp_00);\n    if (iVar3 == -1) {\n      fifo_pull(sp_00);\n    }\n    if (*result < 0x101) {\n      iVar3 = 0;\n    }\n    else {\n      iVar3 = 0x100;\n    }\n  }\nLAB_0000e31e:\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is _nc_wgetch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\ntermios * [MASK](SCREEN *sp)\n\n{\n  termios *result;\n  \n  if (sp == (SCREEN *)0x0) {\n    if (_nc_prescreen.saved_tty == (termios *)0x0) {\n      _nc_prescreen.saved_tty = (termios *)calloc(1,0x3c);\n    }\n    result = _nc_prescreen.saved_tty;\n  }\n  else {\n    result = &sp->_saved_tty;\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is saved_tty"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  if (stdscr == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    stdscr->_attrs = 0;\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is standend"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](chtype newmode)\n\n{\n  int iVar1;\n  \n  iVar1 = vidattr_sp(SP,newmode);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is vidattr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  _Bool _Var1;\n  \n  if (_nc_globals.dbd_blob != (char *)0x0) {\n    _Var1 = cache_expired();\n    if (_Var1 != false) {\n      free_cache();\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_last_db"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp,int want)\n\n{\n  colorpair_t *pcVar1;\n  int have;\n  \n  have = sp->_pair_alloc;\n  if (have == 0) {\n    have = 1;\n  }\n  for (; have <= want; have = have << 1) {\n  }\n  if (sp->_pair_limit < have) {\n    have = sp->_pair_limit;\n  }\n  if (sp->_color_pairs == (colorpair_t *)0x0) {\n    pcVar1 = (colorpair_t *)calloc((ulong)(uint)have,8);\n    sp->_color_pairs = pcVar1;\n  }\n  else if (sp->_pair_alloc < have) {\n    pcVar1 = (colorpair_t *)_nc_doalloc(sp->_color_pairs,(long)have * 8);\n    sp->_color_pairs = pcVar1;\n    if (sp->_color_pairs == (colorpair_t *)0x0) {\n                    /* WARNING: Subroutine does not return */\n      _nc_err_abort(\"Out of memory\");\n    }\n    if (sp->_color_pairs != (colorpair_t *)0x0) {\n      memset(sp->_color_pairs + sp->_pair_alloc,0,(long)(have - sp->_pair_alloc) * 8);\n    }\n  }\n  if (sp->_color_pairs != (colorpair_t *)0x0) {\n    sp->_pair_alloc = have;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_reserve_pairs"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,chtype *z)\n\n{\n  int iVar1;\n  \n  iVar1 = waddchnstr(a1,z,-1);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is waddchstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *strings,uint *offset)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  \n  uVar1 = *offset;\n  sVar2 = strlen(strings + *offset);\n  *offset = (int)sVar2 + uVar1 + 1;\n  return;\n}\n\n",
        "output": "The predicted function name is next_string"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](SCREEN *sp)\n\n{\n  _Bool result;\n  SCREEN *last;\n  SCREEN *temp;\n  \n  last = (SCREEN *)0x0;\n  temp = _nc_screen_chain;\n  while( true ) {\n    if (temp == (SCREEN *)0x0) {\n      return false;\n    }\n    if (temp == sp) break;\n    last = temp;\n    temp = temp->_next_screen;\n  }\n  if (last == (SCREEN *)0x0) {\n    _nc_screen_chain = sp->_next_screen;\n  }\n  else {\n    last->_next_screen = sp->_next_screen;\n  }\n  return true;\n}\n\n",
        "output": "The predicted function name is delink_screen"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,char *astr,int n)\n\n{\n  int iVar1;\n  int local_2c;\n  int code;\n  chtype ch;\n  char *str;\n  \n  code = -1;\n  if ((win != (WINDOW *)0x0) && (astr != (char *)0x0)) {\n    code = 0;\n    local_2c = n;\n    str = astr;\n    if (n < 0) {\n      local_2c = 0x7fffffff;\n      str = astr;\n    }\n    do {\n      if ((*str == '\\0') || (local_2c < 1)) goto LAB_00008f66;\n      iVar1 = _nc_waddch_nosync(win,(uint)(byte)*str);\n      local_2c = local_2c + -1;\n      str = str + 1;\n    } while (iVar1 != -1);\n    code = -1;\nLAB_00008f66:\n    _nc_synchook(win);\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is waddnstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,int top,int bottom)\n\n{\n  int iVar1;\n  \n  if ((((win == (WINDOW *)0x0) || (top < 0)) || (win->_maxy < top)) ||\n     (((bottom < 0 || (win->_maxy < bottom)) || (bottom <= top)))) {\n    iVar1 = -1;\n  }\n  else {\n    win->_regtop = (short)top;\n    win->_regbottom = (short)bottom;\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is wsetscrreg"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nWINDOW * [MASK](SCREEN *sp)\n\n{\n  WINDOW *pWVar1;\n  \n  if (sp == (SCREEN *)0x0) {\n    pWVar1 = (WINDOW *)0x0;\n  }\n  else {\n    pWVar1 = sp->_stdscr;\n  }\n  return pWVar1;\n}\n\n",
        "output": "The predicted function name is _nc_stdscr_of"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](SCREEN *sp)\n\n{\n  _Bool _Var1;\n  int code;\n  \n  _Var1 = false;\n  if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n    if ((((cur_term->type).Numbers[0xd] < 0) || ((cur_term->type).Numbers[0xe] < 0)) ||\n       (((((cur_term->type).Strings[0x12e] == (char *)0x0 ||\n          ((cur_term->type).Strings[0x12f] == (char *)0x0)) &&\n         (((cur_term->type).Strings[0x167] == (char *)0x0 ||\n          ((cur_term->type).Strings[0x168] == (char *)0x0)))) &&\n        ((cur_term->type).Strings[0x12d] == (char *)0x0)))) {\n      _Var1 = false;\n    }\n    else {\n      _Var1 = true;\n    }\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is has_colors_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wattr_on(stdscr,z,(void *)0x0);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is attron"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nWINDOW * [MASK](int l,int c)\n\n{\n  WINDOW *pWVar1;\n  \n  pWVar1 = newpad_sp(SP,l,c);\n  return pWVar1;\n}\n\n",
        "output": "The predicted function name is newpad"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *name,char *string)\n\n{\n  int iVar1;\n  \n  iVar1 = _nc_putp_sp(SP,name,string);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is _nc_putp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](short a1,void *z)\n\n{\n  int iVar1;\n  \n  iVar1 = wcolor_set(stdscr,a1,z);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is color_set"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,int a2,int a3,char *z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(a1,a2,a3);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = winsnstr(a1,z,-1);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvwinsstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchtype [MASK](WINDOW *win,chtype ch)\n\n{\n  chtype cVar1;\n  \n  cVar1 = render_char(win,ch);\n  return cVar1;\n}\n\n",
        "output": "The predicted function name is _nc_render"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  ssize_t sVar2;\n  long in_FS_OFFSET;\n  uchar c2;\n  int ch;\n  int mask;\n  int n;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  ch = 0;\n  mask = 0;\n  if (sp->_fifotail < 0) {\n    iVar1 = -1;\n  }\n  else {\n    c2 = '\\0';\n    sVar2 = read(sp->_ifd,&c2,1);\n    n = (int)sVar2;\n    ch = (int)c2;\n    if ((n == -1) || (n == 0)) {\n      ch = -1;\n    }\n    sp->_fifo[(int)sp->_fifotail] = ch;\n    sp->_fifohold = 0;\n    if (sp->_fifohead == -1) {\n      sp->_fifopeek = sp->_fifotail;\n      sp->_fifohead = sp->_fifopeek;\n    }\n    if (sp->_fifotail < 0x88) {\n      sp->_fifotail = sp->_fifotail + 1;\n    }\n    else {\n      sp->_fifotail = 0;\n    }\n    iVar1 = ch;\n    if (sp->_fifotail == sp->_fifohead) {\n      sp->_fifotail = -1;\n    }\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is fifo_push"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp,int on)\n\n{\n  _Bool _Var1;\n  \n  if (((on != 0) || (sp->_mouse_initialized == true)) && (_Var1 = _nc_mouse_init(sp), _Var1 == true)\n     ) {\n    if (on == 0) {\n      if (sp->_mouse_type == M_XTERM) {\n        enable_xterm_mouse(sp,0);\n      }\n      else if (sp->_mouse_type == M_NONE) {\n        return;\n      }\n    }\n    else {\n      sp->_mouse_bstate = 0;\n      if (sp->_mouse_type == M_XTERM) {\n        keyok_sp(sp,0x199,on != 0);\n        enable_xterm_mouse(sp,1);\n      }\n      else if (sp->_mouse_type == M_NONE) {\n        return;\n      }\n      sp->_mouse_event = _nc_mouse_event;\n      sp->_mouse_inline = _nc_mouse_inline;\n      sp->_mouse_parse = _nc_mouse_parse;\n      sp->_mouse_resume = _nc_mouse_resume;\n      sp->_mouse_wrap = _nc_mouse_wrap;\n    }\n    _nc_flush_sp(sp);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is mouse_activate"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int BaudRate)\n\n{\n  int result;\n  uint i;\n  \n  if (-1 < BaudRate) {\n    for (i = 0; i < 0x1f; i = i + 1) {\n      if (BaudRate == speeds[i].actual_speed) {\n        return speeds[i].given_speed;\n      }\n    }\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is _nc_ospeed"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,chtype newmode)\n\n{\n  int iVar1;\n  \n  iVar1 = vidputs_sp(sp,newmode,_nc_putchar_sp);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is vidattr_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](void)\n\n{\n  _Bool _Var1;\n  \n  _Var1 = can_change_color_sp(SP);\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is can_change_color"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int code)\n\n{\n                    /* WARNING: Subroutine does not return */\n  exit(code);\n}\n\n",
        "output": "The predicted function name is exit_curses"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,int a2,int a3,char *a4,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(a1,a2,a3);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = wgetnstr(a1,a4,z);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvwgetnstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  return;\n}\n\n",
        "output": "The predicted function name is no_mouse_wrap"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int z)\n\n{\n  int iVar1;\n  \n  iVar1 = winsdelln(stdscr,z);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is insdelln"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  term_conflict *ptVar1;\n  int rc;\n  TERMINAL_conflict *termp;\n  \n  rc = -1;\n  ptVar1 = cur_term;\n  if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n    ptVar1 = sp->_term;\n  }\n  if (ptVar1 != (term_conflict *)0x0) {\n    if (sp != (SCREEN *)0x0) {\n      _nc_keypad(sp,0);\n      _nc_flush();\n    }\n    rc = _nc_set_tty_mode(&ptVar1->Ottyb);\n  }\n  return rc;\n}\n\n",
        "output": "The predicted function name is reset_shell_mode_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  int iVar1;\n  char *pcVar2;\n  int code_1;\n  char *code;\n  char *next;\n  \n  sp->_mouse_type = M_XTERM;\n  sp->_mouse_format = MF_X10;\n  pcVar2 = tigetstr(\"XM\");\n  sp->_mouse_xtermcap = pcVar2;\n  if ((sp->_mouse_xtermcap == (char *)0xffffffffffffffff) || (sp->_mouse_xtermcap == (char *)0x0)) {\n    iVar1 = tigetnum(\"XM\");\n    if (iVar1 == 0x3ee) {\n      sp->_mouse_xtermcap = \"\\x1b[?1006;1000%?%p1%{1}%=%th%el%;\";\n      sp->_mouse_format = MF_SGR1006;\n    }\n    else {\n      sp->_mouse_xtermcap = \"\\x1b[?1000%?%p1%{1}%=%th%el%;\";\n    }\n  }\n  else {\n    pcVar2 = strstr(sp->_mouse_xtermcap,\"[?\");\n    if (pcVar2 != (char *)0x0) {\n      code = pcVar2 + 2;\n      while (('/' < *code && (*code < ':'))) {\n        for (next = code; ('/' < *next && (*next < ':')); next = next + 1) {\n        }\n        iVar1 = strncmp(code,\"1006\",(long)next - (long)code);\n        if (iVar1 == 0) {\n          sp->_mouse_format = MF_SGR1006;\n        }\n        if (*next != ';') {\n          return;\n        }\n        for (; *next == ';'; next = next + 1) {\n        }\n        code = next;\n      }\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is init_xterm_mouse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,int a2,int a3,chtype z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(a1,a2,a3);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = winsch(a1,z);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvwinsch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,chtype c)\n\n{\n  short sVar1;\n  short sVar2;\n  SCREEN *sp;\n  short oy;\n  short ox;\n  int code;\n  \n  code = -1;\n  if (win != (WINDOW *)0x0) {\n    sVar1 = win->_cury;\n    sVar2 = win->_curx;\n    sp = _nc_screen_of(win);\n    code = _nc_insert_ch(sp,win,c);\n    win->_curx = sVar2;\n    win->_cury = sVar1;\n    _nc_synchook(win);\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is winsch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int line,anon_subr_int_WINDOW_ptr_int *init)\n\n{\n  int iVar1;\n  \n  if (line < 0) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = 1;\n  }\n  iVar1 = _nc_ripoffline_sp(sp,iVar1,init);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is ripoffline_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](WINDOW *win)\n\n{\n  WINDOW *pWVar1;\n  ldat *plVar2;\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  int y;\n  int left;\n  int right;\n  WINDOW *wp;\n  WINDOW *pp;\n  ldat *line;\n  \n  if ((win != (WINDOW *)0x0) && (wp = win, win->_parent != (WINDOW *)0x0)) {\n    for (; wp->_parent != (WINDOW *)0x0; wp = wp->_parent) {\n      pWVar1 = wp->_parent;\n      for (y = 0; y <= wp->_maxy; y = y + 1) {\n        iVar3 = (int)wp->_line[y].firstchar;\n        if (-1 < iVar3) {\n          plVar2 = pWVar1->_line;\n          iVar4 = y + wp->_pary;\n          iVar5 = wp->_parx + (int)wp->_line[y].lastchar;\n          iVar3 = iVar3 + wp->_parx;\n          if ((plVar2[iVar4].firstchar == -1) || (iVar3 < plVar2[iVar4].firstchar)) {\n            plVar2[iVar4].firstchar = (short)iVar3;\n          }\n          if ((plVar2[iVar4].lastchar == -1) || (plVar2[iVar4].lastchar < iVar5)) {\n            plVar2[iVar4].lastchar = (short)iVar5;\n          }\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is wsyncup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](termios *buf)\n\n{\n  int iVar1;\n  \n  iVar1 = _nc_set_tty_mode_sp(SP,buf);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is _nc_set_tty_mode"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = endwin_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is endwin"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = wclrtobot(stdscr);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is clrtobot"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](SCREEN *sp)\n\n{\n  _Bool result;\n  MEVENT *eventp;\n  \n  return false;\n}\n\n",
        "output": "The predicted function name is _nc_mouse_event"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = def_shell_mode_sp(SP);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is def_shell_mode"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_freeall"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int a1,int a2,char *z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(stdscr,a1,a2);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = winnstr(stdscr,z,-1);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvinstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](int *a1,int *a2,_Bool z)\n\n{\n  _Bool _Var1;\n  \n  _Var1 = wmouse_trafo(stdscr,a1,a2,z);\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is mouse_trafo"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *fmt,...)\n\n{\n  char in_AL;\n  undefined8 in_RCX;\n  undefined8 in_RDX;\n  undefined8 in_RSI;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  va_list argp;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  local_b0 = in_RSI;\n  local_a8 = in_RDX;\n  local_a0 = in_RCX;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  where_is_problem();\n  argp[0].gp_offset = 8;\n  argp[0].fp_offset = 0x30;\n  argp[0].overflow_arg_area = &stack0x00000008;\n  argp[0].reg_save_area = local_b8;\n  vfprintf(stderr,fmt,argp);\n  fputc(10,stderr);\n                    /* WARNING: Subroutine does not return */\n  exit(1);\n}\n\n",
        "output": "The predicted function name is _nc_err_abort"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nWINDOW * [MASK](SCREEN *sp,int l,int c)\n\n{\n  ldat *plVar1;\n  WINDOW *win_00;\n  chtype *pcVar2;\n  int i;\n  chtype *ptr;\n  WINDOW *win;\n  \n  if ((l < 1) || (c < 1)) {\n    win_00 = (WINDOW *)0x0;\n  }\n  else {\n    win_00 = _nc_makenew_sp(sp,l,c,0,0,0x10);\n    if (win_00 == (WINDOW *)0x0) {\n      win_00 = (WINDOW *)0x0;\n    }\n    else {\n      for (i = 0; i < l; i = i + 1) {\n        plVar1 = win_00->_line;\n        pcVar2 = (chtype *)calloc((long)c,4);\n        plVar1[i].text = pcVar2;\n        if (plVar1[i].text == (chtype *)0x0) {\n          _nc_freewin(win_00);\n          return (WINDOW *)0x0;\n        }\n        for (ptr = win_00->_line[i].text; ptr < win_00->_line[i].text + c; ptr = ptr + 1) {\n          *ptr = 0x20;\n        }\n      }\n    }\n  }\n  return win_00;\n}\n\n",
        "output": "The predicted function name is newpad_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nsize_t [MASK](char *buf,short *Numbers,int count)\n\n{\n  byte *local_20;\n  uchar ch;\n  int i;\n  int j;\n  int value;\n  \n  local_20 = (byte *)buf;\n  for (i = 0; i < count; i = i + 1) {\n    value = 0;\n    for (j = 0; j < 4; j = j + 1) {\n      value = value | (uint)*local_20 << ((byte)(j << 3) & 0x1f);\n      local_20 = local_20 + 1;\n    }\n    if (value == -1) {\n      Numbers[i] = -1;\n    }\n    else if (value == -2) {\n      Numbers[i] = -2;\n    }\n    else if (value < 0x8000) {\n      Numbers[i] = (short)value;\n    }\n    else {\n      Numbers[i] = 0x7fff;\n    }\n  }\n  return 2;\n}\n\n",
        "output": "The predicted function name is convert_32bits"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](char *filename,uint limit,char *path,char *name)\n\n{\n  bool bVar1;\n  size_t sVar2;\n  size_t sVar3;\n  _Bool result;\n  uint need;\n  \n  sVar2 = strlen(path);\n  sVar3 = strlen(name);\n  bVar1 = (int)sVar3 + (int)sVar2 + 4U <= limit;\n  if (bVar1) {\n    sprintf(filename,\"%s/%c/%s\",path,(ulong)(uint)(int)*name,name);\n  }\n  return bVar1;\n}\n\n",
        "output": "The predicted function name is make_dir_filename"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *z)\n\n{\n  int iVar1;\n  \n  if (z == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = z->_maxy + 1;\n  }\n  iVar1 = wtouchln(z,0,iVar1,0);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is untouchwin"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,chtype ch)\n\n{\n  _Bool _Var1;\n  int iVar2;\n  ushort **ppuVar3;\n  long in_FS_OFFSET;\n  short y;\n  short x;\n  chtype t;\n  int tabsize;\n  chtype blank;\n  chtype sch;\n  char *s;\n  SCREEN *sp;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  t = ch & 0xff;\n  sp = _nc_screen_of(win);\n  s = unctrl_sp(sp,t);\n  tabsize = 8;\n  if ((((ch & 0x400000) != 0) || (s[1] == '\\0')) ||\n     ((ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(int)t] & 0x4000) != 0 &&\n      (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(int)t] & 2) == 0)))) {\n    iVar2 = waddch_literal(win,ch);\n    goto LAB_00008ddc;\n  }\n  x = win->_curx;\n  y = win->_cury;\n  if (t == 9) {\n    tabsize = TABSIZE;\n    x = x + ((short)TABSIZE - (short)((int)x % TABSIZE));\n    if (((win->_scroll != true) && (win->_regbottom == y)) || (x <= win->_maxx)) {\n      blank = ch & 0xffffff00 | 0x20;\n      do {\n        if (x <= win->_curx) goto LAB_00008dc0;\n        iVar2 = waddch_literal(win,blank);\n      } while (iVar2 != -1);\n      iVar2 = -1;\n      goto LAB_00008ddc;\n    }\n    wclrtoeol(win);\n    win->_flags = win->_flags | 0x40;\n    _Var1 = newline_forces_scroll(win,&y);\n    if (_Var1 == false) {\n      x = 0;\n    }\n    else {\n      x = win->_maxx;\n      if (win->_scroll != false) {\n        wscrl(win,1);\n        x = 0;\n      }\n    }\n  }\n  else if (t < 10) {\n    if (t != 8) {\nLAB_00008dad:\n      do {\n        if (*s == '\\0') {\n          iVar2 = 0;\n          goto LAB_00008ddc;\n        }\n        sch = ch & 0xffffff00 | (uint)(byte)*s;\n        s = s + 1;\n        iVar2 = waddch_literal(win,sch);\n      } while (iVar2 != -1);\n      iVar2 = -1;\n      goto LAB_00008ddc;\n    }\n    if (x == 0) {\n      iVar2 = 0;\n      goto LAB_00008ddc;\n    }\n    x = x + -1;\n    win->_flags = win->_flags & 0xffbf;\n  }\n  else {\n    if (t == 10) {\n      wclrtoeol(win);\n      _Var1 = newline_forces_scroll(win,&y);\n      if (_Var1 != false) {\n        if (win->_scroll == false) {\n          iVar2 = -1;\n          goto LAB_00008ddc;\n        }\n        wscrl(win,1);\n      }\n    }\n    else if (t != 0xd) goto LAB_00008dad;\n    x = 0;\n    win->_flags = win->_flags & 0xffbf;\n  }\nLAB_00008dc0:\n  win->_curx = x;\n  win->_cury = y;\n  iVar2 = 0;\nLAB_00008ddc:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is waddch_nosync"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int ms)\n\n{\n  long lVar1;\n  int iVar2;\n  int *piVar3;\n  long in_FS_OFFSET;\n  timespec request;\n  timespec remaining;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  request.tv_sec = (__time_t)(ms / 1000);\n  request.tv_nsec = (__syscall_slong_t)((ms % 1000) * 1000000);\n  while( true ) {\n    iVar2 = nanosleep((timespec *)&request,(timespec *)&remaining);\n    if (iVar2 != -1) break;\n    piVar3 = __errno_location();\n    if (*piVar3 != 4) break;\n    request.tv_sec = remaining.tv_sec;\n    request.tv_nsec = remaining.tv_nsec;\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is napms_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp)\n\n{\n  return ESCDELAY;\n}\n\n",
        "output": "The predicted function name is get_escdelay_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int yold,int xold,int ynew,int xnew)\n\n{\n  int iVar1;\n  \n  iVar1 = _nc_mvcur_sp(SP,yold,xold,ynew,xnew);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is _nc_mvcur"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](DBDIRS *state,int *offset)\n\n{\n  int iVar1;\n  size_t sVar2;\n  void *__ptr;\n  char *pcVar3;\n  char **ppcVar4;\n  long in_FS_OFFSET;\n  _Bool cache_has_expired;\n  _Bool found;\n  int j;\n  int k;\n  size_t blobsize;\n  stat *my_stat;\n  char *values [6];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  cache_has_expired = false;\n  *state = dbdTIC;\n  *offset = 0;\n  if ((_nc_globals.dbd_blob == (char *)0x0) ||\n     (cache_has_expired = cache_expired(), cache_has_expired != false)) {\n    blobsize = 0;\n    if (cache_has_expired != false) {\n      free_cache();\n    }\n    for (j = 0; j < 6; j = j + 1) {\n      values[j] = (char *)0x0;\n    }\n    values[0] = _nc_globals.tic_directory;\n    values[4] = \n    \"/home/xin/Downloads/gnu_projects/compilation/x86_64/O0/compile_projects_copy/ncurses-6.3/build/share/terminfo\"\n    ;\n    values[5] = \n    \"/home/xin/Downloads/gnu_projects/compilation/x86_64/O0/compile_projects_copy/ncurses-6.3/build/share/terminfo\"\n    ;\n    values[1] = cache_getenv(\"TERMINFO\",dbdEnvOnce);\n    values[2] = _nc_home_terminfo();\n    cache_getenv(\"HOME\",dbdHome);\n    values[3] = cache_getenv(\"TERMINFO_DIRS\",dbdEnvList);\n    for (j = 0; j < 6; j = j + 1) {\n      if (values[j] == (char *)0x0) {\n        values[j] = \"\";\n      }\n      sVar2 = strlen(values[j]);\n      blobsize = blobsize + sVar2 + 2;\n    }\n    _nc_globals.dbd_blob = (char *)malloc(blobsize);\n    if (_nc_globals.dbd_blob != (char *)0x0) {\n      *_nc_globals.dbd_blob = '\\0';\n      for (j = 0; j < 6; j = j + 1) {\n        add_to_blob(values[j],blobsize);\n      }\n      blobsize = 2;\n      for (j = 0; _nc_globals.dbd_blob[j] != '\\0'; j = j + 1) {\n        if (_nc_globals.dbd_blob[j] == ':') {\n          blobsize = blobsize + 1;\n        }\n      }\n      _nc_globals.dbd_list = (char **)calloc(blobsize,8);\n      __ptr = calloc(blobsize,0x90);\n      if ((_nc_globals.dbd_list == (char **)0x0) || (__ptr == (void *)0x0)) {\n        free(_nc_globals.dbd_blob);\n        _nc_globals.dbd_blob = (char *)0x0;\n      }\n      else {\n        k = 1;\n        *_nc_globals.dbd_list = _nc_globals.dbd_blob;\n        for (j = 0; _nc_globals.dbd_blob[j] != '\\0'; j = j + 1) {\n          if ((_nc_globals.dbd_blob[j] == ':') &&\n             ((_nc_globals.dbd_blob + ((long)j - (long)_nc_globals.dbd_list[(long)k + -1]) !=\n               \"F\\x02\\x01\\x01\" ||\n              ((iVar1 = strncmp(_nc_globals.dbd_list[(long)k + -1],\"b64:\",4), iVar1 != 0 &&\n               (iVar1 = strncmp(_nc_globals.dbd_list[(long)k + -1],\"hex:\",4), iVar1 != 0)))))) {\n            _nc_globals.dbd_blob[j] = '\\0';\n            _nc_globals.dbd_list[k] = _nc_globals.dbd_blob + (long)j + 1;\n            k = k + 1;\n          }\n        }\n        for (j = 0; _nc_globals.dbd_list[j] != (char *)0x0; j = j + 1) {\n          if (*_nc_globals.dbd_list[j] == '\\0') {\n            ppcVar4 = _nc_globals.dbd_list + j;\n            pcVar3 = strdup(\n                           \"/home/xin/Downloads/gnu_projects/compilation/x86_64/O0/compile_projects_copy/ncurses-6.3/build/share/terminfo\"\n                           );\n            *ppcVar4 = pcVar3;\n          }\n          trim_formatting(_nc_globals.dbd_list[j]);\n          k = 0;\n          while( true ) {\n            iVar1 = j;\n            if (j <= k) goto LAB_000309e9;\n            iVar1 = strcmp(_nc_globals.dbd_list[j],_nc_globals.dbd_list[k]);\n            if (iVar1 == 0) break;\n            k = k + 1;\n          }\n          iVar1 = j + -1;\n          for (; ppcVar4 = _nc_globals.dbd_list + j, *ppcVar4 = _nc_globals.dbd_list[(long)j + 1],\n              *ppcVar4 != (char *)0x0; j = j + 1) {\n          }\nLAB_000309e9:\n          j = iVar1;\n        }\n        for (j = 0; _nc_globals.dbd_list[j] != (char *)0x0; j = j + 1) {\n          found = check_existence(_nc_globals.dbd_list[j],(stat *)((long)j * 0x90 + (long)__ptr));\n          if (found != false) {\n            for (k = 0; k < j; k = k + 1) {\n              if ((*(long *)((long)__ptr + (long)j * 0x90) ==\n                   *(long *)((long)__ptr + (long)k * 0x90)) &&\n                 (*(long *)((long)__ptr + (long)j * 0x90 + 8) ==\n                  *(long *)((long)__ptr + (long)k * 0x90 + 8))) {\n                found = false;\n                break;\n              }\n            }\n          }\n          if (found != true) {\n            for (k = j; ppcVar4 = _nc_globals.dbd_list + k,\n                *ppcVar4 = _nc_globals.dbd_list[(long)k + 1], *ppcVar4 != (char *)0x0; k = k + 1) {\n            }\n            j = j + -1;\n          }\n        }\n        _nc_globals.dbd_size = j;\n        _nc_globals.dbd_time = time((time_t *)0x0);\n      }\n      free(__ptr);\n    }\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is _nc_first_db"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](SCREEN *sp)\n\n{\n  return false;\n}\n\n",
        "output": "The predicted function name is no_mouse_inline"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,char *buf)\n\n{\n  SCREEN *pSVar1;\n  int rc;\n  SCREEN *sp;\n  \n  pSVar1 = _nc_screen_of(win);\n  if (pSVar1 == (SCREEN *)0x0) {\n    rc = -1;\n  }\n  else {\n    pSVar1->_called_wgetch = true;\n    rc = wgetnstr(win,buf,0x87);\n    pSVar1->_called_wgetch = false;\n  }\n  return rc;\n}\n\n",
        "output": "The predicted function name is recur_wgetnstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](DBDIRS *state,int *offset)\n\n{\n  char *result;\n  \n  if ((((int)*state < _nc_globals.dbd_size) && (_nc_globals.dbd_list != (char **)0x0)) &&\n     (_nc_globals.dbd_list[*state] != (char *)0x0)) {\n    result = _nc_globals.dbd_list[*state];\n    *state = *state + dbdEnvOnce;\n  }\n  else {\n    result = (char *)0x0;\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is _nc_next_db"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int a1,int a2,char *a3,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(stdscr,a1,a2);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = waddnstr(stdscr,a3,z);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvaddnstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int *target,char **source)\n\n{\n  uint uVar1;\n  int result;\n  int j;\n  int ch;\n  \n  result = 3;\n  j = 0;\n  do {\n    if (3 < j) {\n      return result;\n    }\n    uVar1 = (uint)(byte)**source;\n    *source = *source + 1;\n    if ((uVar1 < 0x41) || (0x5a < uVar1)) {\n      if ((uVar1 < 0x61) || (0x7a < uVar1)) {\n        if ((uVar1 < 0x30) || (0x39 < uVar1)) {\n          if ((uVar1 == 0x2d) || (uVar1 == 0x2b)) {\n            target[j] = 0x3e;\n          }\n          else if ((uVar1 == 0x5f) || (uVar1 == 0x2f)) {\n            target[j] = 0x3f;\n          }\n          else {\n            if (uVar1 != 0x3d) {\n              return -1;\n            }\n            target[j] = 0x40;\n            result = result + -1;\n          }\n        }\n        else {\n          target[j] = uVar1 + 4;\n        }\n      }\n      else {\n        target[j] = uVar1 - 0x47;\n      }\n    }\n    else {\n      target[j] = uVar1 - 0x41;\n    }\n    j = j + 1;\n  } while( true );\n}\n\n",
        "output": "The predicted function name is lookup_b64"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp,int enable)\n\n{\n  char *string;\n  \n  string = _nc_tiparm(1,sp->_mouse_xtermcap,(ulong)(uint)enable);\n  _nc_putp_sp(sp,\"xterm-mouse\",string);\n  sp->_mouse_active = enable != 0;\n  return;\n}\n\n",
        "output": "The predicted function name is enable_xterm_mouse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](chtype a1,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wvline(stdscr,a1,z);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is vline"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](void)\n\n{\n  _Bool _Var1;\n  \n  _Var1 = has_ic_sp(SP);\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is has_ic"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *z)\n\n{\n  int iVar1;\n  \n  if (z == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = z->_pary;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is getpary"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *z)\n\n{\n  int iVar1;\n  \n  if (z == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = z->_parx;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is getparx"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = wgetch(stdscr);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is getch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  _nc_hash_map_sp(SP);\n  return;\n}\n\n",
        "output": "The predicted function name is _nc_hash_map"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int a1,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(stdscr,a1,z);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is move"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nchar [MASK](SCREEN *sp)\n\n{\n  uint uVar1;\n  term_conflict *ptVar2;\n  int result;\n  TERMINAL_conflict *termp;\n  \n  result._0_1_ = 0xff;\n  ptVar2 = cur_term;\n  if ((sp != (SCREEN *)0x0) && (sp->_term != (TERMINAL_conflict *)0x0)) {\n    ptVar2 = sp->_term;\n  }\n  if (ptVar2 != (term_conflict *)0x0) {\n    result._0_1_ = (ptVar2->Ottyb).c_cc[2];\n    uVar1 = _nc_vdisable();\n    if ((byte)result == uVar1) {\n      result._0_1_ = 0xff;\n    }\n  }\n  return (byte)result;\n}\n\n",
        "output": "The predicted function name is erasechar_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,attr_t at,void *opts)\n\n{\n  int iVar1;\n  \n  if (win == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    if ((char)(at >> 8) == '\\0') {\n      win->_attrs = win->_attrs | at;\n    }\n    else {\n      win->_attrs = win->_attrs & 0xffff00ff | at;\n    }\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is wattr_on"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](WINDOW *z)\n\n{\n  _Bool _Var1;\n  \n  if ((z == (WINDOW *)0x0) || (z->_immed == false)) {\n    _Var1 = false;\n  }\n  else {\n    _Var1 = true;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is is_immedok"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = wclear(stdscr);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is clear"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int pair,int from_x,int from_y,int x2,int y2,int ch)\n\n{\n  int iVar1;\n  int iVar2;\n  uint uVar3;\n  _Bool _Var4;\n  uint uVar5;\n  int iVar6;\n  int iVar7;\n  int x;\n  int y;\n  int d;\n  int dx;\n  int dy;\n  int ax;\n  int ay;\n  int sx;\n  int sy;\n  \n  _Var4 = has_colors();\n  if (_Var4 != false) {\n    wattrset(stdscr,(pair & 0xffU) << 8);\n  }\n  uVar3 = (x2 - from_x) * 2;\n  uVar5 = (int)uVar3 >> 0x1f;\n  iVar1 = (uVar3 ^ uVar5) - uVar5;\n  uVar3 = (y2 - from_y) * 2;\n  uVar5 = (int)uVar3 >> 0x1f;\n  iVar2 = (uVar3 ^ uVar5) - uVar5;\n  if (x2 - from_x < 0) {\n    iVar6 = -1;\n  }\n  else {\n    iVar6 = 1;\n  }\n  if (y2 - from_y < 0) {\n    iVar7 = -1;\n  }\n  else {\n    iVar7 = 1;\n  }\n  x = from_x;\n  y = from_y;\n  if (iVar2 < iVar1) {\n    d = -(iVar1 / 2);\n    while( true ) {\n      d = iVar2 + d;\n      plot(x,y,ch);\n      if (x == x2) break;\n      if (-1 < d) {\n        y = y + iVar7;\n        d = d - iVar1;\n      }\n      x = x + iVar6;\n    }\n  }\n  else {\n    d = -(iVar2 / 2);\n    while( true ) {\n      d = iVar1 + d;\n      plot(x,y,ch);\n      if (y == y2) break;\n      if (-1 < d) {\n        x = x + iVar6;\n        d = d - iVar2;\n      }\n      y = y + iVar7;\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is dline"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](void)\n\n{\n  _Bool _Var1;\n  \n  _Var1 = has_il_sp(SP);\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is has_il"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int a1,int a2,char *a3,int z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(stdscr,a1,a2);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = wgetnstr(stdscr,a3,z);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvgetnstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nmmask_t [MASK](mmask_t newmask,mmask_t *oldmask)\n\n{\n  mmask_t mVar1;\n  \n  mVar1 = mousemask_sp(SP,newmask,oldmask);\n  return mVar1;\n}\n\n",
        "output": "The predicted function name is mousemask"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,chtype ls,chtype rs,chtype ts,chtype bs,chtype tl,chtype tr,chtype bl,\n           chtype br)\n\n{\n  short sVar1;\n  short sVar2;\n  ldat *plVar3;\n  int iVar4;\n  chtype cVar5;\n  chtype cVar6;\n  chtype cVar7;\n  chtype cVar8;\n  chtype cVar9;\n  chtype cVar10;\n  chtype cVar11;\n  chtype cVar12;\n  short i;\n  short endx;\n  short endy;\n  chtype wls;\n  chtype wrs;\n  chtype wts;\n  chtype wbs;\n  chtype wtl;\n  chtype wtr;\n  chtype wbl;\n  chtype wbr;\n  \n  if (win == (WINDOW *)0x0) {\n    iVar4 = -1;\n  }\n  else {\n    if (ls == 0) {\n      ls = acs_map._480_4_;\n    }\n    cVar5 = _nc_render(win,ls);\n    if (rs == 0) {\n      rs = acs_map._480_4_;\n    }\n    cVar6 = _nc_render(win,rs);\n    if (ts == 0) {\n      ts = acs_map._452_4_;\n    }\n    cVar7 = _nc_render(win,ts);\n    if (bs == 0) {\n      bs = acs_map._452_4_;\n    }\n    cVar8 = _nc_render(win,bs);\n    if (tl == 0) {\n      tl = acs_map._432_4_;\n    }\n    cVar9 = _nc_render(win,tl);\n    if (tr == 0) {\n      tr = acs_map._428_4_;\n    }\n    cVar10 = _nc_render(win,tr);\n    if (bl == 0) {\n      bl = acs_map._436_4_;\n    }\n    cVar11 = _nc_render(win,bl);\n    if (br == 0) {\n      br = acs_map._424_4_;\n    }\n    cVar12 = _nc_render(win,br);\n    sVar1 = win->_maxx;\n    sVar2 = win->_maxy;\n    for (i = 0; i <= sVar1; i = i + 1) {\n      win->_line->text[i] = cVar7;\n      win->_line[sVar2].text[i] = cVar8;\n    }\n    plVar3 = win->_line;\n    plVar3->firstchar = 0;\n    win->_line[sVar2].firstchar = plVar3->firstchar;\n    plVar3 = win->_line;\n    plVar3->lastchar = sVar1;\n    win->_line[sVar2].lastchar = plVar3->lastchar;\n    for (i = 0; i <= sVar2; i = i + 1) {\n      *win->_line[i].text = cVar5;\n      win->_line[i].text[sVar1] = cVar6;\n      win->_line[i].firstchar = 0;\n      win->_line[i].lastchar = sVar1;\n    }\n    *win->_line->text = cVar9;\n    win->_line->text[sVar1] = cVar10;\n    *win->_line[sVar2].text = cVar11;\n    win->_line[sVar2].text[sVar1] = cVar12;\n    _nc_synchook(win);\n    iVar4 = 0;\n  }\n  return iVar4;\n}\n\n",
        "output": "The predicted function name is wborder"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int value)\n\n{\n  int code;\n  \n  if (value < 0) {\n    code = -1;\n  }\n  else {\n    code = 0;\n    ESCDELAY = value;\n  }\n  return code;\n}\n\n",
        "output": "The predicted function name is set_escdelay"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](SCREEN *sp)\n\n{\n  if ((sp != (SCREEN *)0x0) && (sp->_prescreen != false)) {\n    sp->_filtered = true;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is filter_sp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *a1,int a2,int a3,char *z)\n\n{\n  int iVar1;\n  \n  iVar1 = wmove(a1,a2,a3);\n  if (iVar1 == -1) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = wgetnstr(a1,z,-1);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is mvwgetstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](SCREEN *sp,int c)\n\n{\n  int iVar1;\n  \n  if (sp == (SCREEN *)0x0) {\n    iVar1 = fputc(c,stdout);\n  }\n  else {\n    iVar1 = (*sp->jump)(c);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is _nc_outc_wrapper"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int sig,anon_subr_void_int *handler)\n\n{\n  long lVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  int result;\n  sigaction_t old_act;\n  sigaction_t new_act;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  memset(&new_act,0,0x98);\n  sigemptyset((sigset_t *)&new_act.sa_mask);\n  if (sig != 0x1c) {\n    new_act.sa_flags = new_act.sa_flags | 0x10000000;\n  }\n  new_act.__sigaction_handler = handler;\n  iVar2 = sigaction(sig,(sigaction *)0x0,(sigaction *)&old_act);\n  if ((iVar2 == 0) &&\n     (((old_act.__sigaction_handler == (anon_subr_void_int *)0x0 ||\n       (handler == old_act.__sigaction_handler)) ||\n      ((sig == 0x1c &&\n       (old_act.__sigaction_handler == (anon_subr_void_int *)Elf64_Ehdr_00000000.e_ident_magic_str))\n      )))) {\n    sigaction(sig,(sigaction *)&new_act,(sigaction *)0x0);\n    result = 1;\n  }\n  else {\n    result = 0;\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is CatchIfDefault"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win)\n\n{\n  _Bool _Var1;\n  \n  win->_flags = win->_flags | 0x40;\n  _Var1 = newline_forces_scroll(win,&win->_cury);\n  if (_Var1 != false) {\n    win->_curx = win->_maxx;\n    if (win->_scroll != true) {\n      return -1;\n    }\n    wscrl(win,1);\n  }\n  win->_curx = 0;\n  return 0;\n}\n\n",
        "output": "The predicted function name is wrap_to_next_line"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](WINDOW *win,_Bool flag)\n\n{\n  int iVar1;\n  \n  if (win == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    win->_clear = flag;\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is clearok"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchtype [MASK](WINDOW *win)\n\n{\n  chtype cVar1;\n  \n  if (win == (WINDOW *)0x0) {\n    cVar1 = 0;\n  }\n  else {\n    cVar1 = win->_line[win->_cury].text[win->_curx];\n  }\n  return cVar1;\n}\n\n",
        "output": "The predicted function name is winch"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  long lVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  int i;\n  int nsigs;\n  sigaction act;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset((sigset_t *)&caught_signals);\n  for (i = 0; i < 6; i = i + 1) {\n    sigaction(handled_sig[i],(sigaction *)0x0,(sigaction *)&act);\n    if (act.__sigaction_handler != (code *)0x1) {\n      sigaddset((sigset_t *)&caught_signals,handled_sig[i]);\n    }\n  }\n  act.__sigaction_handler = abort_gzip_signal;\n  act.sa_mask.__val[0] = caught_signals.__val[0];\n  act.sa_mask.__val[1] = caught_signals.__val[1];\n  act.sa_mask.__val[2] = caught_signals.__val[2];\n  act.sa_mask.__val[3] = caught_signals.__val[3];\n  act.sa_mask.__val[4] = caught_signals.__val[4];\n  act.sa_mask.__val[5] = caught_signals.__val[5];\n  act.sa_mask.__val[6] = caught_signals.__val[6];\n  act.sa_mask.__val[7] = caught_signals.__val[7];\n  act.sa_mask.__val[8] = caught_signals.__val[8];\n  act.sa_mask.__val[9] = caught_signals.__val[9];\n  act.sa_mask.__val[10] = caught_signals.__val[10];\n  act.sa_mask.__val[11] = caught_signals.__val[11];\n  act.sa_mask.__val[12] = caught_signals.__val[12];\n  act.sa_mask.__val[13] = caught_signals.__val[13];\n  act.sa_mask.__val[14] = caught_signals.__val[14];\n  act.sa_mask.__val[15] = caught_signals.__val[15];\n  act.sa_flags = 0;\n  for (i = 0; i < 6; i = i + 1) {\n    iVar2 = sigismember((sigset_t *)&caught_signals,handled_sig[i]);\n    if (iVar2 != 0) {\n      if (i == 0) {\n        foreground = 1;\n      }\n      sigaction(handled_sig[i],(sigaction *)&act,(sigaction *)0x0);\n    }\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is install_signal_handlers"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int in)\n\n{\n  int iVar1;\n  ulong uVar2;\n  uch *h;\n  \n  uVar2 = (ulong)inptr;\n  inptr = inptr + (uint)*(ushort *)(inbuf + uVar2 + 0x1c) + *(ushort *)(inbuf + uVar2 + 0x1a) + 0x1e\n  ;\n  ifd = in;\n  if ((insize < inptr) ||\n     (((long)(int)(uint)*(ushort *)(inbuf + uVar2) |\n      (long)(int)(uint)*(ushort *)(inbuf + uVar2 + 2) << 0x10) != 0x4034b50)) {\n    fprintf(stderr,\"\\n%s: %s: not a valid zip file\\n\",program_name,ifname);\n    exit_code = 1;\n    iVar1 = 1;\n  }\n  else {\n    method = (int)(byte)inbuf[uVar2 + 8];\n    if ((method == 0) || (method == 8)) {\n      decrypt = (byte)inbuf[uVar2 + 6] & 1;\n      if ((inbuf[uVar2 + 6] & 1) == 0) {\n        ext_header = (int)((inbuf[uVar2 + 6] & 8) != 0);\n        pkzip = 1;\n        iVar1 = 0;\n      }\n      else {\n        fprintf(stderr,\"\\n%s: %s: encrypted file -- use unzip\\n\",program_name,ifname);\n        exit_code = 1;\n        iVar1 = 1;\n      }\n    }\n    else {\n      fprintf(stderr,\"\\n%s: %s: first entry not deflated or stored -- use unzip\\n\",program_name,\n              ifname);\n      exit_code = 1;\n      iVar1 = 1;\n    }\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is check_zipfile"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulg [MASK](uch *s,uint n)\n\n{\n  uint local_1c;\n  byte *local_18;\n  \n  if (s == (uch *)0x0) {\n    crc = 0xffffffff;\n  }\n  else {\n    local_1c = n;\n    local_18 = s;\n    if (n != 0) {\n      do {\n        crc = crc_32_tab[(int)(((uint)*local_18 ^ (uint)crc) & 0xff)] ^ crc >> 8;\n        local_1c = local_1c - 1;\n        local_18 = local_18 + 1;\n      } while (local_1c != 0);\n    }\n  }\n  return crc ^ 0xffffffff;\n}\n\n",
        "output": "The predicted function name is updcrc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  if (outcnt != 0) {\n    updcrc(window,outcnt);\n    write_buf(ofd,window,outcnt);\n    outcnt = 0;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is flush_window"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void *a,void *b)\n\n{\n  int iVar1;\n  direntry_t *dea;\n  direntry_t *deb;\n  \n                    /* WARNING: Load size is inaccurate */\n                    /* WARNING: Load size is inaccurate */\n  iVar1 = strcmp(*a,*b);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is direntry_cmp_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\ntimespec [MASK](stat *st)\n\n{\n  return st->st_atim;\n}\n\n",
        "output": "The predicted function name is get_stat_atime"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  undefined4 *s;\n  size_t sVar2;\n  char *suff;\n  \n  strcpy(ofname,ifname);\n  s = (undefined4 *)get_suffix(ofname);\n  if (decompress == 0) {\n    if ((s != (undefined4 *)0x0) && (force == 0)) {\n      if ((verbose != 0) || ((recursive == 0 && (quiet == 0)))) {\n        fprintf(stderr,\"%s: %s already has %s suffix -- unchanged\\n\",program_name,ifname,s);\n      }\n      return 2;\n    }\n    save_orig_name = 0;\n    sVar2 = strlen(ofname);\n    if (0x3ff < z_len + sVar2) {\n      if (quiet == 0) {\n        fprintf(stderr,\"%s: %s: file name too long\\n\",program_name,ifname);\n      }\n      if (exit_code == 0) {\n        exit_code = 2;\n      }\n      return 2;\n    }\n    strcat(ofname,z_suffix);\n  }\n  else {\n    if (s == (undefined4 *)0x0) {\n      if ((recursive == 0) && (test != 0)) {\n        return 0;\n      }\n      if ((verbose != 0) || ((recursive == 0 && (quiet == 0)))) {\n        if (quiet == 0) {\n          fprintf(stderr,\"%s: %s: unknown suffix -- ignored\\n\",program_name,ifname);\n        }\n        if (exit_code == 0) {\n          exit_code = 2;\n        }\n      }\n      return 2;\n    }\n    strlwr((char *)s);\n    iVar1 = strcmp((char *)s,\".tgz\");\n    if ((iVar1 == 0) || (iVar1 = strcmp((char *)s,\".taz\"), iVar1 == 0)) {\n      *s = 0x7261742e;\n      *(undefined *)(s + 1) = 0;\n    }\n    else {\n      *(undefined *)s = 0;\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is make_ofname"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\ntimespec [MASK](void)\n\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  timespec ts;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  gettime(&ts);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return (timespec)CONCAT88(ts.tv_nsec,ts.tv_sec);\n}\n\n",
        "output": "The predicted function name is current_timespec"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int fd,voidp buf,uint cnt)\n\n{\n  uint uVar1;\n  voidp local_28;\n  uint local_20;\n  uint n;\n  \n  bytes_out = bytes_out + (ulong)cnt;\n  local_28 = buf;\n  local_20 = cnt;\n  if (test == 0) {\n    for (; uVar1 = write_buffer(fd,local_28,local_20), uVar1 != local_20;\n        local_20 = local_20 - uVar1) {\n      if (uVar1 == 0xffffffff) {\n                    /* WARNING: Subroutine does not return */\n        write_error();\n      }\n      local_28 = (voidp)((long)local_28 + (ulong)uVar1);\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is write_buf"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](stat *st)\n\n{\n  return 0;\n}\n\n",
        "output": "The predicted function name is get_stat_birthtime_ns"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  license();\n  putchar(10);\n  puts(\"Written by Jean-loup Gailly.\");\n  return;\n}\n\n",
        "output": "The predicted function name is version"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  _Bool _Var1;\n  int iVar2;\n  int ok;\n  \n  if (force == 0) {\n    ok = 0;\n    fprintf(stderr,\"%s: %s already exists;\",program_name,ofname);\n    if ((foreground != 0) && ((presume_input_tty != false || (iVar2 = isatty(0), iVar2 != 0)))) {\n      fwrite(\" do you wish to overwrite (y or n)? \",1,0x24,stderr);\n      rpl_fflush((FILE *)stderr);\n      _Var1 = yesno();\n      ok = (int)_Var1;\n    }\n    if (ok == 0) {\n      fwrite(\"\\tnot overwritten\\n\",1,0x11,stderr);\n      if (exit_code == 0) {\n        exit_code = 2;\n      }\n      return 1;\n    }\n  }\n  iVar2 = xunlink(ofname);\n  if (iVar2 != 0) {\n    progerror(ofname);\n  }\n  return (uint)(iVar2 != 0);\n}\n\n",
        "output": "The predicted function name is check_ofname"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](void)\n\n{\n  _Bool _Var1;\n  _Bool yes;\n  int c;\n  \n  c = getchar();\n  if ((c == 0x79) || (c == 0x59)) {\n    _Var1 = true;\n  }\n  else {\n    _Var1 = false;\n  }\n  while ((c != 10 && (c != -1))) {\n    c = getchar();\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is yesno"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](IPos cur_match)\n\n{\n  uint uVar1;\n  int iVar2;\n  ulong uVar3;\n  char *pcVar4;\n  char *pcVar6;\n  char cVar7;\n  char cVar8;\n  IPos local_44;\n  uint chain_length;\n  int best_len;\n  IPos limit;\n  char *pcVar5;\n  \n  chain_length = max_chain_length;\n  pcVar5 = window + strstart;\n  best_len = prev_length;\n  uVar1 = strstart;\n  if (strstart < 0x7efa) {\n    uVar1 = 0x7efa;\n  }\n  cVar7 = pcVar5[(long)(int)prev_length + -1];\n  cVar8 = pcVar5[(int)prev_length];\n  local_44 = cur_match;\n  if (good_match <= prev_length) {\n    chain_length = max_chain_length >> 2;\n  }\n  do {\n    uVar3 = (ulong)local_44;\n    pcVar6 = window + uVar3;\n    if ((((cVar8 == pcVar6[best_len]) && (cVar7 == pcVar6[(long)best_len + -1])) &&\n        (*pcVar6 == *pcVar5)) && (window[uVar3 + 1] == pcVar5[1])) {\n      pcVar6 = window + uVar3 + 2;\n      pcVar5 = pcVar5 + 2;\n      while (((((pcVar4 = pcVar5 + 1, *pcVar4 == pcVar6[1] &&\n                (pcVar4 = pcVar5 + 2, *pcVar4 == pcVar6[2])) &&\n               ((pcVar4 = pcVar5 + 3, *pcVar4 == pcVar6[3] &&\n                ((pcVar4 = pcVar5 + 4, *pcVar4 == pcVar6[4] &&\n                 (pcVar4 = pcVar5 + 5, *pcVar4 == pcVar6[5])))))) &&\n              (pcVar4 = pcVar5 + 6, *pcVar4 == pcVar6[6])) &&\n             (pcVar4 = pcVar5 + 7, *pcVar4 == pcVar6[7]))) {\n        pcVar4 = pcVar5 + 8;\n        pcVar6 = pcVar6 + 8;\n        if ((*pcVar4 != *pcVar6) || (pcVar5 = pcVar4, window + (ulong)strstart + 0x102 <= pcVar4))\n        break;\n      }\n      iVar2 = 0x102 - ((int)(window + (ulong)strstart + 0x102) - (int)pcVar4);\n      pcVar5 = window + strstart;\n      if (best_len < iVar2) {\n        match_start = local_44;\n        if (nice_match <= iVar2) {\n          return iVar2;\n        }\n        cVar7 = pcVar5[(long)iVar2 + -1];\n        cVar8 = pcVar5[iVar2];\n        best_len = iVar2;\n      }\n    }\n    local_44 = (IPos)*(ushort *)(prev + (ulong)(local_44 & 0x7fff) * 2);\n    if (local_44 <= uVar1 - 0x7efa) {\n      return best_len;\n    }\n    chain_length = chain_length - 1;\n    if (chain_length == 0) {\n      return best_len;\n    }\n  } while( true );\n}\n\n",
        "output": "The predicted function name is longest_match"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ct_data *ltree,ct_data *dtree)\n\n{\n  uint uVar1;\n  byte bVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uch flag;\n  uint lx;\n  uint dx;\n  uint fx;\n  int lc;\n  uint code;\n  int extra;\n  uint dist;\n  \n  lx = 0;\n  dx = 0;\n  fx = 0;\n  flag = '\\0';\n  if (last_lit != 0) {\n    do {\n      if ((lx & 7) == 0) {\n        flag = flag_buf[fx];\n        fx = fx + 1;\n      }\n      uVar1 = lx + 1;\n      uVar3 = (uint)(byte)inbuf[lx];\n      if ((flag & 1) == 0) {\n        send_bits((uint)(ushort)ltree[(int)uVar3].fc,(uint)(ushort)ltree[(int)uVar3].dl);\n      }\n      else {\n        uVar4 = (uint)length_code[(int)uVar3];\n        send_bits((uint)(ushort)ltree[uVar4 + 0x101].fc,(uint)(ushort)ltree[uVar4 + 0x101].dl);\n        if (extra_lbits[uVar4] != 0) {\n          send_bits(uVar3 - base_length[uVar4],extra_lbits[uVar4]);\n        }\n        uVar3 = dx + 1;\n        uVar4 = (uint)*(ushort *)(d_buf + (ulong)dx * 2);\n        if (uVar4 < 0x100) {\n          bVar2 = dist_code[uVar4];\n        }\n        else {\n          bVar2 = dist_code[(*(ushort *)(d_buf + (ulong)dx * 2) >> 7) + 0x100];\n        }\n        uVar5 = (uint)bVar2;\n        send_bits((uint)(ushort)dtree[uVar5].fc,(uint)(ushort)dtree[uVar5].dl);\n        dx = uVar3;\n        if (extra_dbits[uVar5] != 0) {\n          send_bits(uVar4 - base_dist[uVar5],extra_dbits[uVar5]);\n        }\n      }\n      flag = flag >> 1;\n      lx = uVar1;\n    } while (uVar1 < last_lit);\n  }\n  send_bits((uint)(ushort)ltree[0x100].fc,(uint)(ushort)ltree[0x100].dl);\n  return;\n}\n\n",
        "output": "The predicted function name is compress_block"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](off_t num,off_t den,FILE *file)\n\n{\n  FILE *__stream;\n  \n  __stream = DAT_00012db0;\n  if (den != 0) {\n    __stream = (FILE *)(((double)num * DAT_00012da8) / (double)den);\n  }\n  fprintf(__stream,(char *)file,\"%5.1f%%\");\n  return;\n}\n\n",
        "output": "The predicted function name is display_ratio"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\noff_t [MASK](int pack_level)\n\n{\n  bool bVar1;\n  uint uVar2;\n  uint cur_match;\n  uint uVar3;\n  uint uVar4;\n  off_t oVar5;\n  char *pcVar6;\n  int flush;\n  int match_available;\n  IPos hash_head;\n  IPos prev_match;\n  \n  flush = 0;\n  bVar1 = false;\n  uVar4 = 2;\n  lm_init(pack_level);\n  if (pack_level < 4) {\n    oVar5 = deflate_fast();\n  }\n  else {\n    while (lookahead != 0) {\n      ins_h = ((uint)(byte)window[strstart + 2] ^ ins_h << 5) & 0x7fff;\n      cur_match = (uint)*(ushort *)(prev + ((ulong)ins_h + 0x8000) * 2);\n      *(ushort *)(prev + (ulong)(strstart & 0x7fff) * 2) =\n           *(ushort *)(prev + ((ulong)ins_h + 0x8000) * 2);\n      *(short *)(prev + ((ulong)ins_h + 0x8000) * 2) = (short)strstart;\n      uVar2 = match_start;\n      uVar3 = 2;\n      prev_length = uVar4;\n      if ((((cur_match != 0) && (uVar4 < max_lazy_match)) && (strstart - cur_match < 0x7efb)) &&\n         ((ulong)strstart <= window_size - 0x106)) {\n        uVar3 = longest_match(cur_match);\n        if (lookahead < uVar3) {\n          uVar3 = lookahead;\n        }\n        if ((uVar3 == 3) && (0x1000 < strstart - match_start)) {\n          uVar3 = 2;\n        }\n      }\n      uVar4 = uVar3;\n      if ((prev_length < 3) || (prev_length < uVar4)) {\n        if (bVar1) {\n          flush = ct_tally(0,(uint)(byte)window[strstart - 1]);\n          if ((rsync != 0) && (rsync_chunk_end < strstart)) {\n            rsync_chunk_end = 0xffffffff;\n            flush = 2;\n          }\n          if (flush != 0) {\n            if (block_start < 0) {\n              pcVar6 = (char *)0x0;\n            }\n            else {\n              pcVar6 = window + (block_start & 0xffffffff);\n            }\n            flush_block(pcVar6,(ulong)strstart - block_start,flush + -1,0);\n            block_start = (long)strstart;\n          }\n          if (rsync != 0) {\n            rsync_roll(strstart,1);\n          }\n          strstart = strstart + 1;\n          lookahead = lookahead - 1;\n        }\n        else {\n          if ((rsync != 0) && (rsync_chunk_end < strstart)) {\n            rsync_chunk_end = 0xffffffff;\n            flush = 2;\n            if (block_start < 0) {\n              pcVar6 = (char *)0x0;\n            }\n            else {\n              pcVar6 = window + (block_start & 0xffffffff);\n            }\n            flush_block(pcVar6,(ulong)strstart - block_start,1,0);\n            block_start = (long)strstart;\n          }\n          bVar1 = true;\n          if (rsync != 0) {\n            rsync_roll(strstart,1);\n          }\n          strstart = strstart + 1;\n          lookahead = lookahead - 1;\n        }\n      }\n      else {\n        flush = ct_tally((strstart - uVar2) + -1,prev_length - 3);\n        lookahead = (lookahead - prev_length) + 1;\n        uVar4 = prev_length - 2;\n        if (rsync != 0) {\n          uVar4 = prev_length - 1;\n          prev_length = prev_length - 2;\n          rsync_roll(strstart,uVar4);\n          uVar4 = prev_length;\n        }\n        do {\n          prev_length = uVar4;\n          uVar4 = strstart + 1;\n          ins_h = ((uint)(byte)window[strstart + 3] ^ ins_h << 5) & 0x7fff;\n          strstart = uVar4;\n          *(undefined2 *)(prev + (ulong)(uVar4 & 0x7fff) * 2) =\n               *(undefined2 *)(prev + ((ulong)ins_h + 0x8000) * 2);\n          *(short *)(prev + ((ulong)ins_h + 0x8000) * 2) = (short)strstart;\n          prev_length = prev_length - 1;\n          uVar4 = prev_length;\n        } while (prev_length != 0);\n        bVar1 = false;\n        uVar4 = 2;\n        strstart = strstart + 1;\n        if ((rsync != 0) && (rsync_chunk_end < strstart)) {\n          rsync_chunk_end = 0xffffffff;\n          flush = 2;\n        }\n        if (flush != 0) {\n          if (block_start < 0) {\n            pcVar6 = (char *)0x0;\n          }\n          else {\n            pcVar6 = window + (block_start & 0xffffffff);\n          }\n          flush_block(pcVar6,(ulong)strstart - block_start,flush + -1,0);\n          block_start = (long)strstart;\n        }\n      }\n      while ((lookahead < 0x106 && (eofile == 0))) {\n        fill_window();\n      }\n    }\n    if (bVar1) {\n      ct_tally(0,(uint)(byte)window[strstart - 1]);\n    }\n    if (block_start < 0) {\n      pcVar6 = (char *)0x0;\n    }\n    else {\n      pcVar6 = window + (block_start & 0xffffffff);\n    }\n    oVar5 = flush_block(pcVar6,(ulong)strstart - block_start,flush + -1,1);\n  }\n  return oVar5;\n}\n\n",
        "output": "The predicted function name is deflate"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  long lVar1;\n  bool bVar2;\n  int iVar3;\n  char *pcVar4;\n  int *piVar5;\n  long in_FS_OFFSET;\n  int name_shortened;\n  int atfd;\n  int flags;\n  int f;\n  int open_errno;\n  char *base;\n  char *b;\n  sigset_t oldset;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  bVar2 = false;\n  base = ofname;\n  atfd = -100;\n  if (keep == 0) {\n    pcVar4 = last_component(ofname);\n    iVar3 = atdir_set(ofname,(ptrdiff_t)(pcVar4 + -0x28c820));\n    if (-1 < iVar3) {\n      atfd = iVar3;\n      base = pcVar4;\n    }\n  }\n  do {\n    while( true ) {\n      volatile_strcpy(remove_ofname,ofname);\n      sigprocmask(0,(sigset_t *)&caught_signals,(sigset_t *)&oldset);\n      remove_ofname_fd = openat_safer(atfd,base,0xc1,0x180);\n      ofd = remove_ofname_fd;\n      piVar5 = __errno_location();\n      iVar3 = *piVar5;\n      sigprocmask(2,(sigset_t *)&oldset,(sigset_t *)0x0);\n      if (-1 < ofd) {\n        if ((bVar2) && (decompress != 0)) {\n          if (quiet == 0) {\n            fprintf(stderr,\"%s: %s: warning, name truncated\\n\",program_name,ofname);\n          }\n          if (exit_code == 0) {\n            exit_code = 2;\n          }\n        }\n        iVar3 = 0;\n        goto LAB_000054de;\n      }\n      if (iVar3 == 0x11) break;\n      if (iVar3 != 0x24) {\n        progerror(ofname);\n        close(ifd);\n        iVar3 = 1;\n        goto LAB_000054de;\n      }\n      shorten_name(ofname);\n      bVar2 = true;\n    }\n    iVar3 = check_ofname();\n  } while (iVar3 == 0);\n  close(ifd);\n  iVar3 = 1;\nLAB_000054de:\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is create_outfile"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int sig)\n\n{\n  remove_output_file(true);\n  if (sig == exiting_signal) {\n                    /* WARNING: Subroutine does not return */\n    _exit(2);\n  }\n  signal(sig,(__sighandler_t)0x0);\n  raise(sig);\n  return;\n}\n\n",
        "output": "The predicted function name is abort_gzip_signal"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,timespec *timespec)\n\n{\n  timespec *ptVar1;\n  timespec *ptVar2;\n  _Bool _Var3;\n  int iVar4;\n  int *piVar5;\n  long in_FS_OFFSET;\n  timespec tVar6;\n  int adjustment_needed;\n  int result;\n  timespec *ts;\n  timespec adjusted_timespec [2];\n  stat st;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (timespec == (timespec *)0x0) {\n    ts = (timespec *)0x0;\n  }\n  else {\n    ts = adjusted_timespec;\n  }\n  adjustment_needed = 0;\n  if (ts != (timespec *)0x0) {\n    adjusted_timespec[0].tv_nsec = timespec->tv_nsec;\n    adjusted_timespec[0].tv_sec = timespec->tv_sec;\n    adjusted_timespec[1].tv_nsec = timespec[1].tv_nsec;\n    adjusted_timespec[1].tv_sec = timespec[1].tv_sec;\n    adjustment_needed = validate_timespec(ts);\n  }\n  if (adjustment_needed < 0) {\n    iVar4 = -1;\n    goto LAB_0001051b;\n  }\n  if (lutimensat_works_really < 0) {\nLAB_0001043c:\n    lutimensat_works_really = -1;\n    if (adjustment_needed != 0) {\n      if (adjustment_needed != 3) {\n        iVar4 = lstat(file,(stat *)&st);\n        if (iVar4 != 0) {\n          iVar4 = -1;\n          goto LAB_0001051b;\n        }\n      }\n      if (ts != (timespec *)0x0) {\n        _Var3 = update_timespec(&st,&ts);\n        if (_Var3 != false) {\n          iVar4 = 0;\n          goto LAB_0001051b;\n        }\n      }\n    }\n    if (adjustment_needed == 0) {\n      iVar4 = lstat(file,(stat *)&st);\n      if (iVar4 != 0) {\n        iVar4 = -1;\n        goto LAB_0001051b;\n      }\n    }\n    if ((st.st_mode & 0xf000) == 0xa000) {\n      piVar5 = __errno_location();\n      *piVar5 = 0x26;\n      iVar4 = -1;\n    }\n    else {\n      iVar4 = fdutimens(-1,file,ts);\n    }\n  }\n  else {\n    if (adjustment_needed == 2) {\n      iVar4 = lstat(file,(stat *)&st);\n      ptVar2 = ts;\n      if (iVar4 != 0) {\n        iVar4 = -1;\n        goto LAB_0001051b;\n      }\n      if (ts->tv_nsec == 0x3ffffffe) {\n        tVar6 = get_stat_atime(&st);\n        ptVar2->tv_sec = SUB168((undefined  [16])tVar6,0);\n        ptVar2->tv_nsec = SUB168((undefined  [16])tVar6 >> 0x40,0);\n      }\n      else if (ts[1].tv_nsec == 0x3ffffffe) {\n        ptVar1 = ts + 1;\n        tVar6 = get_stat_mtime(&st);\n        ptVar1->tv_sec = SUB168((undefined  [16])tVar6,0);\n        ptVar2[1].tv_nsec = SUB168((undefined  [16])tVar6 >> 0x40,0);\n      }\n      adjustment_needed = 3;\n    }\n    iVar4 = utimensat(-100,file,(timespec *)ts,0x100);\n    if (0 < iVar4) {\n      piVar5 = __errno_location();\n      *piVar5 = 0x26;\n    }\n    if (iVar4 != 0) {\n      piVar5 = __errno_location();\n      if (*piVar5 == 0x26) goto LAB_0001043c;\n    }\n    utimensat_works_really = 1;\n    lutimensat_works_really = 1;\n  }\nLAB_0001051b:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar4;\n}\n\n",
        "output": "The predicted function name is lutimens"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](tree_desc *desc)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  ct_data *pcVar5;\n  int *piVar6;\n  ct_data *pcVar7;\n  ush f;\n  int h;\n  int n;\n  int bits;\n  int xbits;\n  int overflow;\n  int base;\n  int max_code;\n  int max_length;\n  int m;\n  ct_data *tree;\n  int *extra;\n  ct_data *stree;\n  \n  pcVar5 = desc->dyn_tree;\n  piVar6 = desc->extra_bits;\n  iVar1 = desc->extra_base;\n  iVar2 = desc->max_code;\n  iVar3 = desc->max_length;\n  pcVar7 = desc->static_tree;\n  overflow = 0;\n  for (bits = 0; bits < 0x10; bits = bits + 1) {\n    bl_count[bits] = 0;\n  }\n  pcVar5[heap[heap_max]].dl = 0;\n  h = heap_max;\n  while (h = h + 1, h < 0x23d) {\n    iVar4 = heap[h];\n    bits = (ushort)pcVar5[(ushort)pcVar5[iVar4].dl].dl + 1;\n    if (iVar3 < bits) {\n      overflow = overflow + 1;\n      bits = iVar3;\n    }\n    pcVar5[iVar4].dl = (short)bits;\n    if (iVar4 <= iVar2) {\n      bl_count[bits] = bl_count[bits] + 1;\n      xbits = 0;\n      if (iVar1 <= iVar4) {\n        xbits = piVar6[iVar4 - iVar1];\n      }\n      opt_len = opt_len + (ulong)(ushort)pcVar5[iVar4].fc * (long)(xbits + bits);\n      if (pcVar7 != (ct_data *)0x0) {\n        static_len = static_len +\n                     (ulong)(ushort)pcVar5[iVar4].fc *\n                     (long)(int)(xbits + (uint)(ushort)pcVar7[iVar4].dl);\n      }\n    }\n  }\n  bits = iVar3;\n  if (overflow != 0) {\n    do {\n      do {\n        iVar1 = bits;\n        bits = iVar1 + -1;\n      } while (bl_count[bits] == 0);\n      bl_count[bits] = bl_count[bits] - 1;\n      bl_count[iVar1] = bl_count[iVar1] + 2;\n      bl_count[iVar3] = bl_count[iVar3] - 1;\n      overflow = overflow + -2;\n      bits = iVar3;\n    } while (0 < overflow);\n    for (; bits != 0; bits = bits + -1) {\n      n = (int)bl_count[bits];\n      while (n != 0) {\n        h = h + -1;\n        iVar1 = heap[h];\n        if (iVar1 <= iVar2) {\n          if ((uint)(ushort)pcVar5[iVar1].dl != bits) {\n            opt_len = opt_len + (ulong)(ushort)pcVar5[iVar1].fc *\n                                ((long)bits - (ulong)(ushort)pcVar5[iVar1].dl);\n            pcVar5[iVar1].dl = (short)bits;\n          }\n          n = n + -1;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is gen_bitlen"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  timespec tVar1;\n  \n  ifile_size = -1;\n  time_stamp.tv_nsec = -1;\n  if (((istat.st_mode & 0xf000) == 0x8000) &&\n     ((ifile_size = istat.st_size, no_time == 0 || (list != 0)))) {\n    tVar1 = get_stat_mtime(&istat);\n    time_stamp.tv_nsec = SUB168((undefined  [16])tVar1 >> 0x40,0);\n    time_stamp.tv_sec = SUB168((undefined  [16])tVar1,0);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is get_input_size_and_time"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *dir,savedir_option option)\n\n{\n  int iVar1;\n  DIR *dirp_00;\n  char *p;\n  DIR *dirp;\n  char *name_space;\n  \n  dirp_00 = opendir_safer(dir);\n  if (dirp_00 == (DIR *)0x0) {\n    p = (char *)0x0;\n  }\n  else {\n    p = streamsavedir(dirp_00,option);\n    iVar1 = closedir((DIR *)dirp_00);\n    if (iVar1 != 0) {\n      rpl_free(p);\n      p = (char *)0x0;\n    }\n  }\n  return p;\n}\n\n",
        "output": "The predicted function name is savedir"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](_Bool signals_already_blocked)\n\n{\n  long lVar1;\n  int __fd;\n  long in_FS_OFFSET;\n  int fd;\n  sigset_t oldset;\n  char fname [1024];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if (signals_already_blocked != true) {\n    sigprocmask(0,(sigset_t *)&caught_signals,(sigset_t *)&oldset);\n  }\n  __fd = remove_ofname_fd;\n  if (-1 < remove_ofname_fd) {\n    remove_ofname_fd = -1;\n    close(__fd);\n    volatile_strcpy(fname,remove_ofname);\n    xunlink(fname);\n  }\n  if (signals_already_blocked != true) {\n    sigprocmask(2,(sigset_t *)&oldset,(sigset_t *)0x0);\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is remove_output_file"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nuint [MASK](void)\n\n{\n  ushort uVar1;\n  uint j;\n  uint mask;\n  \n  if (blocksize == 0) {\n    blocksize = getbits(0x10);\n    if (blocksize == 0) {\n      return 0x1fe;\n    }\n    read_pt_len(0x13,5,3);\n    read_c_len();\n    read_pt_len(0xe,4,-1);\n  }\n  blocksize = blocksize - 1;\n  j = (uint)*(ushort *)(d_buf + (long)(int)(uint)(bitbuf >> 4) * 2);\n  if (0x1fd < j) {\n    mask = 8;\n    do {\n      if ((bitbuf & mask) == 0) {\n        uVar1 = *(ushort *)(prev + (ulong)j * 2);\n      }\n      else {\n        uVar1 = *(ushort *)(prev + ((ulong)j + 0x8000) * 2);\n      }\n      j = (uint)uVar1;\n      mask = mask >> 1;\n    } while (0x1fd < j);\n  }\n  fillbuf((uint)(byte)outbuf[j]);\n  return j;\n}\n\n",
        "output": "The predicted function name is decode_c"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nuint [MASK](void)\n\n{\n  ushort uVar1;\n  uint uVar2;\n  uint j;\n  uint mask;\n  \n  j = (uint)pt_table[(int)(uint)(bitbuf >> 8)];\n  if (0xd < j) {\n    mask = 0x80;\n    do {\n      if ((bitbuf & mask) == 0) {\n        uVar1 = *(ushort *)(prev + (ulong)j * 2);\n      }\n      else {\n        uVar1 = *(ushort *)(prev + ((ulong)j + 0x8000) * 2);\n      }\n      j = (uint)uVar1;\n      mask = mask >> 1;\n    } while (0xd < j);\n  }\n  fillbuf((uint)pt_len[j]);\n  if (j != 0) {\n    uVar2 = getbits(j - 1);\n    j = uVar2 + (1 << ((char)j - 1U & 0x1f));\n  }\n  return j;\n}\n\n",
        "output": "The predicted function name is decode_p"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *buf,uint len,int header)\n\n{\n  uint uVar1;\n  char *pcVar2;\n  byte bVar3;\n  ulong uVar5;\n  uint local_14;\n  char *local_10;\n  byte bVar4;\n  \n  bi_windup();\n  local_14 = len;\n  local_10 = buf;\n  if (header != 0) {\n    bVar3 = (byte)len;\n    bVar4 = (byte)(len >> 8);\n    if (outcnt < 0x3fffe) {\n      uVar5 = (ulong)outcnt;\n      outcnt = outcnt + 1;\n      outbuf[uVar5] = bVar3;\n      uVar5 = (ulong)outcnt;\n      outcnt = outcnt + 1;\n      outbuf[uVar5] = bVar4;\n    }\n    else {\n      uVar5 = (ulong)outcnt;\n      outcnt = outcnt + 1;\n      outbuf[uVar5] = bVar3;\n      if (outcnt == 0x40000) {\n        flush_outbuf();\n      }\n      uVar5 = (ulong)outcnt;\n      outcnt = outcnt + 1;\n      outbuf[uVar5] = bVar4;\n      if (outcnt == 0x40000) {\n        flush_outbuf();\n      }\n    }\n    if (outcnt < 0x3fffe) {\n      uVar5 = (ulong)outcnt;\n      outcnt = outcnt + 1;\n      outbuf[uVar5] = ~bVar3;\n      uVar5 = (ulong)outcnt;\n      outcnt = outcnt + 1;\n      outbuf[uVar5] = ~bVar4;\n      local_14 = len;\n      local_10 = buf;\n    }\n    else {\n      uVar5 = (ulong)outcnt;\n      outcnt = outcnt + 1;\n      outbuf[uVar5] = ~bVar3;\n      if (outcnt == 0x40000) {\n        flush_outbuf();\n      }\n      uVar5 = (ulong)outcnt;\n      outcnt = outcnt + 1;\n      outbuf[uVar5] = ~bVar4;\n      local_14 = len;\n      local_10 = buf;\n      if (outcnt == 0x40000) {\n        flush_outbuf();\n      }\n    }\n  }\n  while (uVar1 = local_14 - 1, local_14 != 0) {\n    pcVar2 = local_10 + 1;\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar5] = *local_10;\n    local_14 = uVar1;\n    local_10 = pcVar2;\n    if (outcnt == 0x40000) {\n      flush_outbuf();\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is copy_block"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ct_data *tree,int max_code)\n\n{\n  int iVar1;\n  uint uVar2;\n  int n;\n  int prevlen;\n  int nextlen;\n  int count;\n  int max_count;\n  int min_count;\n  int curlen;\n  \n  prevlen = -1;\n  count = 0;\n  max_count = 7;\n  min_count = 4;\n  if ((ushort)tree->dl == 0) {\n    max_count = 0x8a;\n    min_count = 3;\n  }\n  nextlen = (uint)(ushort)tree->dl;\n  for (n = 0; n <= max_code; n = n + 1) {\n    uVar2 = (uint)(ushort)tree[(long)n + 1].dl;\n    iVar1 = count + 1;\n    if ((max_count <= iVar1) || (nextlen != uVar2)) {\n      if (iVar1 < min_count) {\n        do {\n          count = iVar1;\n          send_bits((uint)(ushort)bl_tree[nextlen].fc,(uint)(ushort)bl_tree[nextlen].dl);\n          iVar1 = count + -1;\n        } while (count + -1 != 0);\n      }\n      else if (nextlen == 0) {\n        if (iVar1 < 0xb) {\n          send_bits((uint)bl_tree[17].fc,(uint)bl_tree[17].dl);\n          send_bits(count + -2,3);\n        }\n        else {\n          send_bits((uint)bl_tree[18].fc,(uint)bl_tree[18].dl);\n          send_bits(count + -10,7);\n        }\n      }\n      else {\n        if (nextlen != prevlen) {\n          send_bits((uint)(ushort)bl_tree[nextlen].fc,(uint)(ushort)bl_tree[nextlen].dl);\n          iVar1 = count;\n        }\n        count = iVar1;\n        send_bits((uint)bl_tree[16].fc,(uint)bl_tree[16].dl);\n        send_bits(count + -3,2);\n      }\n      count = 0;\n      prevlen = nextlen;\n      iVar1 = count;\n      if (uVar2 == 0) {\n        max_count = 0x8a;\n        min_count = 3;\n      }\n      else if (nextlen == uVar2) {\n        max_count = 6;\n        min_count = 3;\n      }\n      else {\n        max_count = 7;\n        min_count = 4;\n      }\n    }\n    count = iVar1;\n    nextlen = uVar2;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is send_tree"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ct_data *tree,int max_code)\n\n{\n  ushort uVar1;\n  uint uVar2;\n  long in_FS_OFFSET;\n  ush code;\n  int bits;\n  int n;\n  int len;\n  ush next_code [16];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  code = 0;\n  for (bits = 1; bits < 0x10; bits = bits + 1) {\n    code = (code + bl_count[bits + -1]) * 2;\n    next_code[bits] = code;\n  }\n  for (n = 0; n <= max_code; n = n + 1) {\n    uVar2 = (uint)(ushort)tree[n].dl;\n    if (uVar2 != 0) {\n      uVar1 = next_code[(int)uVar2];\n      next_code[(int)uVar2] = uVar1 + 1;\n      uVar2 = bi_reverse((uint)uVar1,uVar2);\n      tree[n].fc = (short)uVar2;\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is gen_codes"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int __fd,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR___fxstat_00215f28)(1,__fd,__buf);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is fstat"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *name)\n\n{\n  int iVar1;\n  size_t sVar2;\n  char *pcVar3;\n  int min_part;\n  int len;\n  int plen;\n  char *trunc;\n  char *p;\n  \n  trunc = (char *)0x0;\n  min_part = 3;\n  sVar2 = strlen(name);\n  iVar1 = (int)sVar2;\n  if (decompress == 0) {\n    pcVar3 = get_suffix(name);\n    if (pcVar3 == (char *)0x0) {\n                    /* WARNING: Subroutine does not return */\n      gzip_error(\"can\\'t recover suffix\\n\");\n    }\n    *pcVar3 = '\\0';\n    save_orig_name = 1;\n    if ((iVar1 < 5) || (iVar1 = strcmp(pcVar3 + -4,\".tar\"), iVar1 != 0)) {\n      do {\n        p = last_component(name);\n        while (*p != '\\0') {\n          sVar2 = strcspn(p,\".\");\n          p = p + (int)sVar2;\n          if (min_part < (int)sVar2) {\n            trunc = p + -1;\n          }\n          if (*p != '\\0') {\n            p = p + 1;\n          }\n        }\n      } while ((trunc == (char *)0x0) && (min_part = min_part + -1, min_part != 0));\n      pcVar3 = trunc;\n      if (trunc == (char *)0x0) {\n        trunc = strrchr(name,0x2e);\n        if (trunc == (char *)0x0) {\n                    /* WARNING: Subroutine does not return */\n          gzip_error(\"internal error in shorten_name\");\n        }\n        if (trunc[1] == '\\0') {\n          trunc = trunc + -1;\n        }\n      }\n      else {\n        do {\n          trunc = pcVar3;\n          *trunc = trunc[1];\n          pcVar3 = trunc + 1;\n        } while (*trunc != '\\0');\n      }\n      strcpy(trunc,z_suffix);\n    }\n    else {\n      *(undefined4 *)(pcVar3 + -4) = 0x7a67742e;\n      *pcVar3 = '\\0';\n    }\n  }\n  else {\n    if (iVar1 < 2) {\n                    /* WARNING: Subroutine does not return */\n      gzip_error(\"name too short\");\n    }\n    name[(long)iVar1 + -1] = '\\0';\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is shorten_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  bitbuf = 0;\n  subbitbuf = 0;\n  bitcount = 0;\n  fillbuf(0x10);\n  return;\n}\n\n",
        "output": "The predicted function name is init_getbits"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  int n;\n  \n  for (n = 0; n < 0x11e; n = n + 1) {\n    dyn_ltree[n].fc = 0;\n  }\n  for (n = 0; n < 0x1e; n = n + 1) {\n    dyn_dtree[n].fc = 0;\n  }\n  for (n = 0; n < 0x13; n = n + 1) {\n    bl_tree[n].fc = 0;\n  }\n  dyn_ltree[256].fc = 1;\n  last_lit = 0;\n  last_dist = 0;\n  last_flags = 0;\n  flags = '\\0';\n  flag_bit = '\\x01';\n  opt_len = 0;\n  static_len = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is init_block"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ush *attr,int *methodp)\n\n{\n  uint uVar1;\n  int n;\n  int bits;\n  int length;\n  int code;\n  int dist;\n  \n  input_len = 0;\n  compressed_len = 0;\n  file_type = attr;\n  file_method = methodp;\n  if (static_dtree[0].dl == 0) {\n    length = 0;\n    for (code = 0; code < 0x1c; code = code + 1) {\n      base_length[code] = length;\n      for (n = 0; n < 1 << ((byte)extra_lbits[code] & 0x1f); n = n + 1) {\n        length_code[length] = (uch)code;\n        length = length + 1;\n      }\n    }\n    length_code[length + -1] = (uch)code;\n    dist = 0;\n    for (code = 0; code < 0x10; code = code + 1) {\n      base_dist[code] = dist;\n      for (n = 0; n < 1 << ((byte)extra_dbits[code] & 0x1f); n = n + 1) {\n        dist_code[dist] = (uch)code;\n        dist = dist + 1;\n      }\n    }\n    dist = dist >> 7;\n    for (; code < 0x1e; code = code + 1) {\n      base_dist[code] = dist << 7;\n      for (n = 0; n < 1 << ((char)extra_dbits[code] - 7U & 0x1f); n = n + 1) {\n        dist_code[dist + 0x100] = (uch)code;\n        dist = dist + 1;\n      }\n    }\n    for (bits = 0; bits < 0x10; bits = bits + 1) {\n      bl_count[bits] = 0;\n    }\n    n = 0;\n    while (n < 0x90) {\n      static_ltree[n].dl = 8;\n      bl_count[8] = bl_count[8] + 1;\n      n = n + 1;\n    }\n    while (n < 0x100) {\n      static_ltree[n].dl = 9;\n      bl_count[9] = bl_count[9] + 1;\n      n = n + 1;\n    }\n    while (n < 0x118) {\n      static_ltree[n].dl = 7;\n      bl_count[7] = bl_count[7] + 1;\n      n = n + 1;\n    }\n    while (n < 0x120) {\n      static_ltree[n].dl = 8;\n      bl_count[8] = bl_count[8] + 1;\n      n = n + 1;\n    }\n    gen_codes(static_ltree,0x11f);\n    for (n = 0; n < 0x1e; n = n + 1) {\n      static_dtree[n].dl = 5;\n      uVar1 = bi_reverse(n,5);\n      static_dtree[n].fc = (short)uVar1;\n    }\n    init_block();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is ct_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Removing unreachable block (ram,0x0000f417) */\n/* WARNING: Heritage AFTER dead removal. Example location: s0xffffffffffffff60 : 0x0000f429 */\n/* WARNING: Restarted to delay deadcode elimination for space: stack */\n\nint [MASK](int fd,char *file,int flags,...)\n\n{\n  long lVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  mode_t mode;\n  va_list ap;\n  mode_t local_a0;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  mode = 0;\n  if ((flags & 0x40U) != 0) {\n    mode = local_a0;\n  }\n  iVar2 = openat(fd,file,flags,(ulong)mode);\n  iVar2 = fd_safer(iVar2);\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is openat_safer"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  int iVar1;\n  int *piVar2;\n  int e;\n  \n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  fprintf(stderr,\"\\n%s: \",program_name);\n  piVar2 = __errno_location();\n  *piVar2 = iVar1;\n  perror(ofname);\n                    /* WARNING: Subroutine does not return */\n  abort_gzip();\n}\n\n",
        "output": "The predicted function name is write_error"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int lcodes,int dcodes,int blcodes)\n\n{\n  int rank;\n  \n  send_bits(lcodes + -0x101,5);\n  send_bits(dcodes + -1,5);\n  send_bits(blcodes + -4,4);\n  for (rank = 0; rank < blcodes; rank = rank + 1) {\n    send_bits((uint)(ushort)bl_tree[(int)(uint)bl_order[rank]].dl,3);\n  }\n  send_tree(dyn_ltree,lcodes + -1);\n  send_tree(dyn_dtree,dcodes + -1);\n  return;\n}\n\n",
        "output": "The predicted function name is send_all_trees"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  int iVar1;\n  char *pcVar2;\n  undefined *puVar3;\n  \n  if (((force == 0) && (list == 0)) &&\n     ((presume_input_tty != false || (iVar1 = isatty((uint)(decompress == 0)), iVar1 != 0)))) {\n    if (quiet == 0) {\n      if (decompress == 0) {\n        puVar3 = &DAT_0001163f;\n        pcVar2 = \"written to\";\n      }\n      else {\n        puVar3 = &DAT_0001163c;\n        pcVar2 = \"read from\";\n      }\n      fprintf(stderr,\n              \"%s: compressed data not %s a terminal. Use -f to force %scompression.\\nFor help, type: %s -h\\n\"\n              ,program_name,pcVar2,puVar3,program_name);\n    }\n                    /* WARNING: Subroutine does not return */\n    do_exit(1);\n  }\n  ifname._0_4_ = 0x69647473;\n  ifname._4_2_ = 0x6e;\n  ofname._0_4_ = 0x6f647473;\n  ofname._4_2_ = 0x7475;\n  ofname[6] = 0;\n  iVar1 = fstat(0,(stat *)&istat);\n  if (iVar1 != 0) {\n    progerror(\"standard input\");\n                    /* WARNING: Subroutine does not return */\n    do_exit(1);\n  }\n  get_input_size_and_time();\n  clear_bufs();\n  to_stdout = 1;\n  part_nb = 0;\n  ifd = 0;\n  stdin_was_read = true;\n  if ((decompress != 0) && (method = get_method(0), method < 0)) {\n                    /* WARNING: Subroutine does not return */\n    do_exit(exit_code);\n  }\n  while( true ) {\n    iVar1 = (*work)(0,1);\n    if (iVar1 != 0) {\n      return;\n    }\n    iVar1 = input_eof();\n    if (iVar1 != 0) break;\n    method = get_method(ifd);\n    if (method < 0) {\n      return;\n    }\n    bytes_out = 0;\n  }\n  if (list != 0) {\n    do_list(method);\n    return;\n  }\n  if (verbose == 0) {\n    return;\n  }\n  if (test != 0) {\n    fwrite(&DAT_000116c4,1,4,stderr);\n    return;\n  }\n  if (decompress != 0) {\n    return;\n  }\n  display_ratio(bytes_in - (bytes_out - header_bytes),bytes_in,(FILE *)stderr);\n  fputc(10,stderr);\n  return;\n}\n\n",
        "output": "The predicted function name is treat_stdin"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\ntimespec [MASK](stat *st)\n\n{\n  timespec t;\n  \n  return (timespec)CONCAT88(0xffffffffffffffff,0xffffffffffffffff);\n}\n\n",
        "output": "The predicted function name is get_stat_birthtime"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  if (outcnt != 0) {\n    write_buf(ofd,outbuf,outcnt);\n    outcnt = 0;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is flush_outbuf"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int exitcode)\n\n{\n  if (do_exit::in_exit != 0) {\n                    /* WARNING: Subroutine does not return */\n    exit(exitcode);\n  }\n  do_exit::in_exit = 1;\n  rpl_free(env);\n  env = (char *)0x0;\n                    /* WARNING: Subroutine does not return */\n  exit(exitcode);\n}\n\n",
        "output": "The predicted function name is do_exit"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](int *argcp,char ***argvp,char *envvar_name)\n\n{\n  char *pcVar1;\n  char cVar2;\n  char **ppcVar3;\n  char *pcVar4;\n  size_t sVar5;\n  int nargc;\n  char *p;\n  char **nargv;\n  char *env_val;\n  char **oargv;\n  \n  nargc = 0;\n  pcVar4 = getenv(envvar_name);\n  if (pcVar4 == (char *)0x0) {\n    pcVar4 = (char *)0x0;\n  }\n  else {\n    pcVar4 = xstrdup(pcVar4);\n    p = pcVar4;\n    while (*p != '\\0') {\n      sVar5 = strspn(p,\" \\t\");\n      pcVar1 = p + sVar5;\n      if (*pcVar1 == '\\0') break;\n      sVar5 = strcspn(pcVar1,\" \\t\");\n      pcVar1 = pcVar1 + sVar5;\n      p = pcVar1;\n      if (*pcVar1 != '\\0') {\n        p = pcVar1 + 1;\n        *pcVar1 = '\\0';\n      }\n      nargc = nargc + 1;\n    }\n    if (nargc == 0) {\n      rpl_free(pcVar4);\n      pcVar4 = (char *)0x0;\n    }\n    else {\n      *argcp = nargc + 1;\n      nargv = (char **)xcalloc((long)(*argcp + 1),8);\n      ppcVar3 = *argvp;\n      *argvp = nargv;\n      *nargv = *ppcVar3;\n      p = pcVar4;\n      for (; nargv = nargv + 1, 0 < nargc; nargc = nargc + -1) {\n        sVar5 = strspn(p,\" \\t\");\n        *nargv = p + sVar5;\n        p = p + sVar5;\n        do {\n          pcVar1 = p + 1;\n          cVar2 = *p;\n          p = pcVar1;\n        } while (cVar2 != '\\0');\n      }\n      *nargv = (char *)0x0;\n    }\n  }\n  return pcVar4;\n}\n\n",
        "output": "The predicted function name is add_envopt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](idx_t n,idx_t s)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = icalloc(n,s);\n  pvVar1 = nonnull(pvVar1);\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is xicalloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](idx_t s)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = xicalloc(s,1);\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is xizalloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *m)\n\n{\n  if (quiet == 0) {\n    fprintf(stderr,\"%s: %s: warning: %s\\n\",program_name,ifname,m);\n  }\n  if (exit_code == 0) {\n    exit_code = 2;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is warning"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](idx_t s)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = imalloc(s);\n  pvVar1 = nonnull(pvVar1);\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is ximalloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  uint uVar1;\n  int iVar2;\n  uint uVar3;\n  ulong uVar4;\n  uint uVar5;\n  ulong uVar6;\n  uint n;\n  uint w;\n  \n  uVar3 = outcnt;\n  w = outcnt;\n  uVar6 = bb >> (sbyte)(bk & 7);\n  for (uVar5 = bk - (bk & 7); uVar5 < 0x10; uVar5 = uVar5 + 8) {\n    if (inptr < insize) {\n      uVar4 = (ulong)(byte)inbuf[inptr];\n      inptr = inptr + 1;\n    }\n    else {\n      outcnt = uVar3;\n      uVar1 = fill_inbuf(0);\n      uVar4 = (ulong)(uVar1 & 0xff);\n    }\n    uVar6 = uVar6 | uVar4 << ((byte)uVar5 & 0x3f);\n  }\n  n = (uint)uVar6 & 0xffff;\n  uVar6 = uVar6 >> 0x10;\n  for (uVar5 = uVar5 - 0x10; uVar5 < 0x10; uVar5 = uVar5 + 8) {\n    if (inptr < insize) {\n      uVar4 = (ulong)(byte)inbuf[inptr];\n      inptr = inptr + 1;\n    }\n    else {\n      outcnt = uVar3;\n      uVar1 = fill_inbuf(0);\n      uVar4 = (ulong)(uVar1 & 0xff);\n    }\n    uVar6 = uVar6 | uVar4 << ((byte)uVar5 & 0x3f);\n  }\n  if (n == (~(uint)uVar6 & 0xffff)) {\n    uVar6 = uVar6 >> 0x10;\n    uVar5 = uVar5 - 0x10;\n    while (n != 0) {\n      for (; uVar5 < 8; uVar5 = uVar5 + 8) {\n        if (inptr < insize) {\n          uVar4 = (ulong)(byte)inbuf[inptr];\n          inptr = inptr + 1;\n        }\n        else {\n          outcnt = w;\n          uVar3 = fill_inbuf(0);\n          uVar4 = (ulong)(uVar3 & 0xff);\n        }\n        uVar6 = uVar6 | uVar4 << ((byte)uVar5 & 0x3f);\n      }\n      outcnt = w + 1;\n      window[w] = (char)uVar6;\n      w = outcnt;\n      if (outcnt == 0x8000) {\n        flush_window();\n        w = 0;\n      }\n      uVar6 = uVar6 >> 8;\n      uVar5 = uVar5 - 8;\n      n = n - 1;\n    }\n    outcnt = w;\n    iVar2 = 0;\n    bb = uVar6;\n    bk = uVar5;\n  }\n  else {\n    iVar2 = 1;\n  }\n  return iVar2;\n}\n\n",
        "output": "The predicted function name is inflate_stored"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *s)\n\n{\n  char cVar1;\n  ushort **ppuVar3;\n  char *t;\n  int iVar2;\n  \n  for (t = s; *t != '\\0'; t = t + 1) {\n    ppuVar3 = __ctype_b_loc();\n    if (((*ppuVar3)[(byte)*t] & 0x100) == 0) {\n      cVar1 = *t;\n    }\n    else {\n      iVar2 = tolower((uint)(byte)*t);\n      cVar1 = (char)iVar2;\n    }\n    *t = cVar1;\n  }\n  return s;\n}\n\n",
        "output": "The predicted function name is strlwr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nuint [MASK](uint code,int len)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  int local_18;\n  uint local_14;\n  \n  uVar1 = 0;\n  local_18 = len;\n  local_14 = code;\n  do {\n    uVar3 = uVar1;\n    uVar2 = local_14 & 1;\n    local_14 = local_14 >> 1;\n    local_18 = local_18 + -1;\n    uVar1 = (uVar3 | uVar2) * 2;\n  } while (0 < local_18);\n  return uVar3 & 0x7fffffff | uVar2;\n}\n\n",
        "output": "The predicted function name is bi_reverse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](void *p,idx_t s)\n\n{\n  void *__dest;\n  char *pcVar1;\n  char *result;\n  \n  __dest = ximalloc(s + 1);\n  *(undefined *)((long)__dest + s) = 0;\n  pcVar1 = (char *)memcpy(__dest,p,s);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is ximemdup0"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void *p)\n\n{\n  int iVar1;\n  long lVar2;\n  int *piVar3;\n  long in_FS_OFFSET;\n  int err [2];\n  \n  lVar2 = *(long *)(in_FS_OFFSET + 0x28);\n  piVar3 = __errno_location();\n  err[0] = *piVar3;\n  piVar3 = __errno_location();\n  err[1] = *piVar3;\n  piVar3 = __errno_location();\n  *piVar3 = 0;\n  free(p);\n  piVar3 = __errno_location();\n  iVar1 = *piVar3;\n  piVar3 = __errno_location();\n  *piVar3 = err[(int)(uint)(iVar1 == 0)];\n  if (lVar2 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is rpl_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *iname)\n\n{\n  long lVar1;\n  _Bool _Var2;\n  int iVar3;\n  int iVar4;\n  undefined *puVar5;\n  int *piVar6;\n  char *pcVar7;\n  long in_FS_OFFSET;\n  int ufd;\n  int res;\n  int unlink_errno;\n  int cflag;\n  char *ifbase;\n  sigset_t oldset;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar3 = strcmp(iname,\"-\");\n  iVar4 = to_stdout;\n  if (iVar3 == 0) {\n    treat_stdin();\n    to_stdout = iVar4;\n  }\n  else {\n    ifd = open_input_file(iname,&istat);\n    if (-1 < ifd) {\n      if ((istat.st_mode & 0xf000) == 0x4000) {\n        if (recursive == 0) {\n          close(ifd);\n          if (quiet == 0) {\n            fprintf(stderr,\"%s: %s is a directory -- ignored\\n\",program_name,ifname);\n          }\n          if (exit_code == 0) {\n            exit_code = 2;\n          }\n        }\n        else {\n          treat_dir(ifd,iname);\n        }\n      }\n      else {\n        if (to_stdout == 0) {\n          if ((istat.st_mode & 0xf000) != 0x8000) {\n            if (quiet == 0) {\n              fprintf(stderr,\"%s: %s is not a directory or a regular file - ignored\\n\",program_name,\n                      ifname);\n            }\n            if (exit_code == 0) {\n              exit_code = 2;\n            }\n            close(ifd);\n            goto LAB_00005283;\n          }\n          if ((istat.st_mode & 0x800) != 0) {\n            if (quiet == 0) {\n              fprintf(stderr,\"%s: %s is set-user-ID on execution - ignored\\n\",program_name,ifname);\n            }\n            if (exit_code == 0) {\n              exit_code = 2;\n            }\n            close(ifd);\n            goto LAB_00005283;\n          }\n          if ((istat.st_mode & 0x400) != 0) {\n            if (quiet == 0) {\n              fprintf(stderr,\"%s: %s is set-group-ID on execution - ignored\\n\",program_name,ifname);\n            }\n            if (exit_code == 0) {\n              exit_code = 2;\n            }\n            close(ifd);\n            goto LAB_00005283;\n          }\n          if (force == 0) {\n            if ((istat.st_mode & 0x200) != 0) {\n              if (quiet == 0) {\n                fprintf(stderr,\"%s: %s has the sticky bit set - file ignored\\n\",program_name,ifname)\n                ;\n              }\n              if (exit_code == 0) {\n                exit_code = 2;\n              }\n              close(ifd);\n              goto LAB_00005283;\n            }\n            if (1 < istat.st_nlink) {\n              if (quiet == 0) {\n                if (istat.st_nlink == 2) {\n                  puVar5 = &DAT_0001163f;\n                }\n                else {\n                  puVar5 = &DAT_000117be;\n                }\n                fprintf(stderr,\"%s: %s has %lu other link%s -- file ignored\\n\",program_name,ifname,\n                        istat.st_nlink - 1,puVar5);\n              }\n              if (exit_code == 0) {\n                exit_code = 2;\n              }\n              close(ifd);\n              goto LAB_00005283;\n            }\n          }\n        }\n        get_input_size_and_time();\n        if ((to_stdout == 0) || (test != 0)) {\n          iVar4 = make_ofname();\n          if (iVar4 != 0) {\n            close(ifd);\n            goto LAB_00005283;\n          }\n        }\n        else {\n          ofname._0_4_ = 0x6f647473;\n          ofname._4_2_ = 0x7475;\n          ofname[6] = 0;\n        }\n        clear_bufs();\n        part_nb = 0;\n        if ((decompress == 0) || (method = get_method(ifd), -1 < method)) {\n          if (to_stdout == 0) {\n            iVar4 = create_outfile();\n            if (iVar4 != 0) goto LAB_00005283;\n            if ((((decompress == 0) && (save_orig_name != 0)) && (verbose == 0)) && (quiet == 0)) {\n              fprintf(stderr,\"%s: %s compressed to %s\\n\",program_name,ifname,ofname);\n            }\n          }\n          else {\n            ofd = 1;\n          }\n          if (save_orig_name == 0) {\n            save_orig_name = (int)(no_name == 0);\n          }\n          if ((verbose != 0) && (list == 0)) {\n            fprintf(stderr,\"%s:\\t\",ifname);\n          }\n          while (iVar4 = (*work)(ifd,ofd), iVar4 == 0) {\n            iVar4 = input_eof();\n            if ((iVar4 != 0) || (method = get_method(ifd), method < 0)) goto LAB_00004f32;\n            bytes_out = 0;\n          }\n          method = -1;\nLAB_00004f32:\n          iVar4 = close(ifd);\n          if (iVar4 != 0) {\n                    /* WARNING: Subroutine does not return */\n            read_error();\n          }\n          if (list == 0) {\n            if (to_stdout == 0) {\n              copy_stat(&istat);\n              if (((synchronous != false) &&\n                  ((((-1 < dfd && (iVar4 = fdatasync(dfd), iVar4 != 0)) &&\n                    (piVar6 = __errno_location(), *piVar6 != 0x16)) ||\n                   ((iVar4 = fsync(ofd), iVar4 != 0 &&\n                    (piVar6 = __errno_location(), *piVar6 != 0x16)))))) ||\n                 (iVar4 = close(ofd), iVar4 != 0)) {\n                    /* WARNING: Subroutine does not return */\n                write_error();\n              }\n              if (keep == 0) {\n                pcVar7 = last_component(ifname);\n                _Var2 = atdir_eq(ifname,(ptrdiff_t)(pcVar7 + -0x21b000));\n                iVar4 = dfd;\n                if (_Var2 == false) {\n                  iVar4 = -1;\n                }\n                sigprocmask(0,(sigset_t *)&caught_signals,(sigset_t *)&oldset);\n                remove_ofname_fd = -1;\n                if (iVar4 < 0) {\n                  iVar4 = xunlink(ifname);\n                }\n                else {\n                  iVar4 = unlinkat(iVar4,pcVar7,0);\n                }\n                if (iVar4 == 0) {\n                  iVar4 = 0;\n                }\n                else {\n                  piVar6 = __errno_location();\n                  iVar4 = *piVar6;\n                }\n                sigprocmask(2,(sigset_t *)&oldset,(sigset_t *)0x0);\n                if (iVar4 != 0) {\n                  if (quiet == 0) {\n                    fprintf(stderr,\"%s: \",program_name);\n                  }\n                  if (exit_code == 0) {\n                    exit_code = 2;\n                  }\n                  if (quiet == 0) {\n                    piVar6 = __errno_location();\n                    *piVar6 = iVar4;\n                    perror(ifname);\n                  }\n                }\n              }\n            }\n            if (method == -1) {\n              if (to_stdout == 0) {\n                remove_output_file(false);\n              }\n            }\n            else if (verbose != 0) {\n              if (test == 0) {\n                if (decompress == 0) {\n                  display_ratio(bytes_in - (bytes_out - header_bytes),bytes_in,(FILE *)stderr);\n                }\n                else {\n                  display_ratio(bytes_out - (bytes_in - header_bytes),bytes_out,(FILE *)stderr);\n                }\n              }\n              else {\n                fwrite(&DAT_0001180b,1,3,stderr);\n              }\n              if (test == 0) {\n                if (keep == 0) {\n                  pcVar7 = \"replaced with\";\n                }\n                else {\n                  pcVar7 = \"created\";\n                }\n                fprintf(stderr,\" -- %s %s\",pcVar7,ofname);\n              }\n              fputc(10,stderr);\n            }\n          }\n          else {\n            do_list(method);\n          }\n        }\n        else {\n          close(ifd);\n        }\n      }\n    }\n  }\nLAB_00005283:\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is treat_file"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](file_t zipfile)\n\n{\n  if (zipfile != -1) {\n    read_buf = file_read;\n  }\n  zfile = zipfile;\n  bi_buf = 0;\n  bi_valid = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is bi_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](void *p,idx_t n,idx_t s)\n\n{\n  void *pvVar1;\n  idx_t local_20;\n  idx_t local_18;\n  \n  if ((n == 0) || (local_20 = s, local_18 = n, s == 0)) {\n    local_20 = 1;\n    local_18 = 1;\n  }\n  pvVar1 = (void *)reallocarray(p,local_18,local_20);\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is ireallocarray"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](stat *statbuf,timespec **ts)\n\n{\n  timespec *ts_00;\n  _Bool _Var1;\n  timespec tVar2;\n  timespec *timespec;\n  \n  ts_00 = *ts;\n  if ((ts_00->tv_nsec == 0x3ffffffe) && (ts_00[1].tv_nsec == 0x3ffffffe)) {\n    _Var1 = true;\n  }\n  else if ((ts_00->tv_nsec == 0x3fffffff) && (ts_00[1].tv_nsec == 0x3fffffff)) {\n    *ts = (timespec *)0x0;\n    _Var1 = false;\n  }\n  else {\n    if (ts_00->tv_nsec == 0x3ffffffe) {\n      tVar2 = get_stat_atime(statbuf);\n      ts_00->tv_sec = SUB168((undefined  [16])tVar2,0);\n      ts_00->tv_nsec = SUB168((undefined  [16])tVar2 >> 0x40,0);\n    }\n    else if (ts_00->tv_nsec == 0x3fffffff) {\n      gettime(ts_00);\n    }\n    if (ts_00[1].tv_nsec == 0x3ffffffe) {\n      tVar2 = get_stat_mtime(statbuf);\n      ts_00[1].tv_sec = SUB168((undefined  [16])tVar2,0);\n      ts_00[1].tv_nsec = SUB168((undefined  [16])tVar2 >> 0x40,0);\n    }\n    else if (ts_00[1].tv_nsec == 0x3fffffff) {\n      gettime(ts_00 + 1);\n    }\n    _Var1 = false;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is update_timespec"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](timespec *ts)\n\n{\n  clock_gettime(0,(timespec *)ts);\n  return;\n}\n\n",
        "output": "The predicted function name is gettime"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *name)\n\n{\n  long lVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  char *s_00;\n  long lVar6;\n  size_t sVar7;\n  long in_FS_OFFSET;\n  _Bool suffix_of_builtin;\n  int nlen;\n  int slen;\n  int s;\n  char **suf;\n  char *match;\n  size_t suflen;\n  char *z_lower;\n  char suffix [33];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  suffix_of_builtin = false;\n  suf = get_suffix::known_suffixes;\n  do {\n    suf = suf + 1;\n    if (*suf == (char *)0x0) goto LAB_00005588;\n    sVar7 = strlen(*suf);\n  } while ((sVar7 <= z_len) || (iVar2 = strcmp(z_suffix,*suf + (sVar7 - z_len)), iVar2 != 0));\n  suffix_of_builtin = true;\nLAB_00005588:\n  s_00 = xstrdup(z_suffix);\n  strlwr(s_00);\n  if (suffix_of_builtin == false) {\n    lVar6 = 0;\n  }\n  else {\n    lVar6 = 8;\n  }\n  get_suffix::known_suffixes[lVar6] = s_00;\n  suf = get_suffix::known_suffixes + suffix_of_builtin;\n  sVar7 = strlen(name);\n  iVar2 = (int)sVar7;\n  if (iVar2 < 0x21) {\n    strcpy(suffix,name);\n  }\n  else {\n    strcpy(suffix,name + (long)iVar2 + -0x20);\n  }\n  strlwr(suffix);\n  sVar7 = strlen(suffix);\n  iVar3 = (int)sVar7;\n  match = (char *)0x0;\n  while( true ) {\n    sVar7 = strlen(*suf);\n    iVar4 = (int)sVar7;\n    if (((iVar4 < iVar3) && (suffix[(iVar3 - iVar4) + -1] != '/')) &&\n       (iVar5 = strcmp(suffix + ((long)iVar3 - (long)iVar4),*suf), iVar5 == 0)) break;\n    suf = suf + 1;\n    if (*suf == (char *)0x0) {\nLAB_000056e0:\n      rpl_free(s_00);\n      if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return match;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n  }\n  match = name + ((long)iVar2 - (long)iVar4);\n  goto LAB_000056e0;\n}\n\n",
        "output": "The predicted function name is get_suffix"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](idx_t n,idx_t s)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = calloc(n,s);\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is icalloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  if ((decompress == 0) || (last_member != 0)) {\n    return 1;\n  }\n  if (inptr == insize) {\n    if ((insize != 0x40000) || (iVar1 = fill_inbuf(1), iVar1 == -1)) {\n      return 1;\n    }\n    inptr = 0;\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is input_eof"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nDIR * [MASK](char *name)\n\n{\n  int iVar1;\n  int *piVar2;\n  int e;\n  int fd;\n  int f;\n  DIR *dp;\n  DIR *newdp;\n  \n  dp = (DIR *)opendir(name);\n  if (dp != (DIR *)0x0) {\n    iVar1 = dirfd((DIR *)dp);\n    if ((-1 < iVar1) && (iVar1 < 3)) {\n      iVar1 = rpl_fcntl(iVar1,0x406,3);\n      if (iVar1 < 0) {\n        piVar2 = __errno_location();\n        e = *piVar2;\n        newdp = (DIR *)0x0;\n      }\n      else {\n        newdp = (DIR *)fdopendir(iVar1);\n        piVar2 = __errno_location();\n        e = *piVar2;\n        if (newdp == (DIR *)0x0) {\n          close(iVar1);\n        }\n      }\n      closedir((DIR *)dp);\n      piVar2 = __errno_location();\n      *piVar2 = e;\n      dp = newdp;\n    }\n  }\n  return dp;\n}\n\n",
        "output": "The predicted function name is opendir_safer"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nsize_t [MASK](char *name)\n\n{\n  size_t len;\n  size_t prefix_len;\n  \n  for (len = strlen(name); (1 < len && (name[len - 1] == '/')); len = len - 1) {\n  }\n  return len;\n}\n\n",
        "output": "The predicted function name is base_len"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nuint [MASK](int n)\n\n{\n  uint uVar1;\n  uint x;\n  \n  uVar1 = (uint)bitbuf;\n  fillbuf(n);\n  return (int)uVar1 >> (0x10U - (char)n & 0x1f);\n}\n\n",
        "output": "The predicted function name is getbits"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int value,int length)\n\n{\n  ulong uVar1;\n  \n  if (0x10 - length < bi_valid) {\n    bi_buf = bi_buf | (ushort)(value << ((byte)bi_valid & 0x1f));\n    if (outcnt < 0x3fffe) {\n      uVar1 = (ulong)outcnt;\n      outcnt = outcnt + 1;\n      outbuf[uVar1] = (char)bi_buf;\n      uVar1 = (ulong)outcnt;\n      outcnt = outcnt + 1;\n      outbuf[uVar1] = (char)((uint)bi_buf >> 8);\n    }\n    else {\n      uVar1 = (ulong)outcnt;\n      outcnt = outcnt + 1;\n      outbuf[uVar1] = (char)bi_buf;\n      if (outcnt == 0x40000) {\n        flush_outbuf();\n      }\n      uVar1 = (ulong)outcnt;\n      outcnt = outcnt + 1;\n      outbuf[uVar1] = (char)((uint)bi_buf >> 8);\n      if (outcnt == 0x40000) {\n        flush_outbuf();\n      }\n    }\n    bi_buf = (ushort)((int)(value & 0xffffU) >> (0x10U - (char)bi_valid & 0x1f));\n    bi_valid = length + bi_valid + -0x10;\n  }\n  else {\n    bi_buf = bi_buf | (ushort)(value << ((byte)bi_valid & 0x1f));\n    bi_valid = length + bi_valid;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is send_bits"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](char *dir,ptrdiff_t dirlen)\n\n{\n  _Bool _Var1;\n  int iVar2;\n  size_t local_18;\n  char *local_10;\n  \n  local_18 = dirlen;\n  local_10 = dir;\n  if (dirlen == 0) {\n    local_10 = \".-\";\n    local_18 = 1;\n  }\n  iVar2 = memcmp(dfname,local_10,local_18);\n  if ((iVar2 == 0) && (dfname[local_18] == '\\0')) {\n    _Var1 = true;\n  }\n  else {\n    _Var1 = false;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is atdir_eq"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int fd,char *dir)\n\n{\n  int iVar1;\n  DIR *dirp_00;\n  char *p;\n  size_t sVar2;\n  char *pcVar3;\n  long in_FS_OFFSET;\n  char *entry;\n  size_t len;\n  DIR *dirp;\n  char *entries;\n  size_t entrylen;\n  char nbuf [1024];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  dirp_00 = fdopendir(fd);\n  if (dirp_00 == (DIR *)0x0) {\n    progerror(dir);\n    close(fd);\n  }\n  else {\n    p = streamsavedir((DIR *)dirp_00,SAVEDIR_SORT_FASTREAD);\n    if (p == (char *)0x0) {\n      progerror(dir);\n    }\n    iVar1 = closedir(dirp_00);\n    if (iVar1 != 0) {\n      progerror(dir);\n    }\n    entry = p;\n    if (p != (char *)0x0) {\n      for (; *entry != '\\0'; entry = entry + entrylen + 1) {\n        sVar2 = strlen(dir);\n        entrylen = strlen(entry);\n        iVar1 = strcmp(entry,\".\");\n        if ((iVar1 != 0) && (iVar1 = strcmp(entry,\"..\"), iVar1 != 0)) {\n          if (entrylen + sVar2 < 0x3fe) {\n            strcpy(nbuf,dir);\n            pcVar3 = last_component(nbuf);\n            len = sVar2;\n            if ((*pcVar3 != '\\0') && (nbuf[sVar2 - 1] != '/')) {\n              len = sVar2 + 1;\n              nbuf[sVar2] = '/';\n            }\n            strcpy(nbuf + len,entry);\n            treat_file(nbuf);\n          }\n          else {\n            fprintf(stderr,\"%s: %s/%s: pathname too long\\n\",program_name,dir,entry);\n            exit_code = 1;\n          }\n        }\n      }\n      rpl_free(p);\n    }\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is treat_dir"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  int n;\n  uint ascii_freq;\n  uint bin_freq;\n  \n  ascii_freq = 0;\n  bin_freq = 0;\n  for (n = 0; n < 7; n = n + 1) {\n    bin_freq = bin_freq + (ushort)dyn_ltree[n].fc;\n  }\n  for (; n < 0x80; n = n + 1) {\n    ascii_freq = ascii_freq + (ushort)dyn_ltree[n].fc;\n  }\n  for (; n < 0x100; n = n + 1) {\n    bin_freq = bin_freq + (ushort)dyn_ltree[n].fc;\n  }\n  *file_type = (ushort)(bin_freq <= ascii_freq >> 2);\n  return;\n}\n\n",
        "output": "The predicted function name is set_file_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR___lxstat_00215e30)(1,__file,__buf);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is lstat"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](DIR *dirp,savedir_option option)\n\n{\n  direntry_t *pdVar1;\n  int *piVar2;\n  long lVar3;\n  size_t sVar4;\n  char *pcVar5;\n  long in_FS_OFFSET;\n  idx_t allocated;\n  idx_t entries_allocated;\n  char *name_space;\n  direntry_t *entries;\n  idx_t entries_used;\n  idx_t used;\n  idx_t i;\n  comparison_function *cmp;\n  dirent *dp;\n  char *entry;\n  idx_t entry_size;\n  char *dest;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  name_space = (char *)0x0;\n  allocated = 0;\n  entries = (direntry_t *)0x0;\n  entries_allocated = 0;\n  entries_used = 0;\n  used = 0;\n  cmp = comparison_function_table[option];\n  if (dirp == (DIR *)0x0) {\n    pcVar5 = (char *)0x0;\n  }\n  else {\n    while( true ) {\n      piVar2 = __errno_location();\n      *piVar2 = 0;\n      dp = (dirent *)readdir((DIR *)dirp);\n      if (dp == (dirent *)0x0) break;\n      entry = ((dirent *)dp)->d_name;\n      if (*entry == '.') {\n        if (((dirent *)dp)->d_name[1] == '.') {\n          lVar3 = 2;\n        }\n        else {\n          lVar3 = 1;\n        }\n      }\n      else {\n        lVar3 = 0;\n      }\n      if (entry[lVar3] != '\\0') {\n        sVar4 = strlen(((dirent *)dp)->d_name);\n        entry_size = sVar4 + 1;\n        if (cmp == (comparison_function *)0x0) {\n          if (allocated - used <= entry_size) {\n            name_space = (char *)xpalloc(name_space,&allocated,entry_size - (allocated - used),\n                                         0x7ffffffffffffffe,1);\n          }\n          memcpy(name_space + used,entry,entry_size);\n        }\n        else {\n          if (entries_used == entries_allocated) {\n            entries = (direntry_t *)xpalloc(entries,&entries_allocated,1,-1,8);\n          }\n          pdVar1 = entries + entries_used;\n          pcVar5 = xstrdup(entry);\n          pdVar1->name = pcVar5;\n          entries_used = entries_used + 1;\n        }\n        used = used + entry_size;\n      }\n    }\n    piVar2 = __errno_location();\n    if (*piVar2 == 0) {\n      if (cmp == (comparison_function *)0x0) {\n        if (used == allocated) {\n          name_space = (char *)xirealloc(name_space,used + 1);\n        }\n      }\n      else {\n        if (entries_used != 0) {\n          qsort(entries,entries_used,8,(__compar_fn_t)cmp);\n        }\n        name_space = (char *)ximalloc(used + 1);\n        used = 0;\n        for (i = 0; i < entries_used; i = i + 1) {\n          dest = name_space + used;\n          pcVar5 = stpcpy(dest,entries[i].name);\n          used = (idx_t)(pcVar5 + used + (1 - (long)dest));\n          rpl_free(entries[i].name);\n        }\n        rpl_free(entries);\n      }\n      name_space[used] = '\\0';\n      pcVar5 = name_space;\n    }\n    else {\n      rpl_free(entries);\n      rpl_free(name_space);\n      pcVar5 = (char *)0x0;\n    }\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return pcVar5;\n}\n\n",
        "output": "The predicted function name is streamsavedir"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int *e)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  ulong uVar4;\n  uint uVar5;\n  ulg uVar6;\n  ulong uVar7;\n  uint w;\n  uint t;\n  \n  uVar2 = outcnt;\n  uVar6 = bb;\n  uVar5 = bk;\n  while (uVar5 == 0) {\n    if (inptr < insize) {\n      uVar7 = (ulong)(byte)inbuf[inptr];\n      inptr = inptr + 1;\n    }\n    else {\n      outcnt = uVar2;\n      uVar5 = fill_inbuf(0);\n      uVar7 = (ulong)(uVar5 & 0xff);\n    }\n    uVar6 = uVar6 | uVar7;\n    uVar5 = 8;\n  }\n  *e = (uint)uVar6 & 1;\n  uVar7 = uVar6 >> 1;\n  for (uVar5 = uVar5 - 1; uVar5 < 2; uVar5 = uVar5 + 8) {\n    if (inptr < insize) {\n      uVar4 = (ulong)(byte)inbuf[inptr];\n      inptr = inptr + 1;\n    }\n    else {\n      outcnt = uVar2;\n      uVar1 = fill_inbuf(0);\n      uVar4 = (ulong)(uVar1 & 0xff);\n    }\n    uVar7 = uVar7 | uVar4 << ((byte)uVar5 & 0x3f);\n  }\n  uVar2 = (uint)uVar7 & 3;\n  bb = uVar7 >> 2;\n  bk = uVar5 - 2;\n  if (uVar2 == 2) {\n    iVar3 = inflate_dynamic();\n  }\n  else if ((uVar7 & 3) == 0) {\n    iVar3 = inflate_stored();\n  }\n  else if (uVar2 == 1) {\n    iVar3 = inflate_fixed();\n  }\n  else {\n    iVar3 = 2;\n  }\n  return iVar3;\n}\n\n",
        "output": "The predicted function name is inflate_block"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  init_getbits();\n  blocksize = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is huf_decode_start"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *m)\n\n{\n  fprintf(stderr,\"\\n%s: %s: %s\\n\",program_name,ifname,m);\n                    /* WARNING: Subroutine does not return */\n  abort_gzip();\n}\n\n",
        "output": "The predicted function name is gzip_error"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int eof_ok)\n\n{\n  int iVar1;\n  uint uVar2;\n  int *piVar3;\n  int len;\n  \n  insize = 0;\n  do {\n    iVar1 = read_buffer(ifd,inbuf + insize,0x40000 - insize);\n    if (iVar1 == 0) break;\n    if (iVar1 == -1) {\n                    /* WARNING: Subroutine does not return */\n      read_error();\n    }\n    insize = iVar1 + insize;\n  } while (insize < 0x40000);\n  if (insize == 0) {\n    if (eof_ok == 0) {\n      flush_window();\n      piVar3 = __errno_location();\n      *piVar3 = 0;\n                    /* WARNING: Subroutine does not return */\n      read_error();\n    }\n    uVar2 = 0xffffffff;\n  }\n  else {\n    bytes_in = bytes_in + (ulong)insize;\n    inptr = 1;\n    uVar2 = (uint)inbuf[0];\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is fill_inbuf"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = rpl_fclose(stdout);\n  if (iVar1 != 0) {\n                    /* WARNING: Subroutine does not return */\n    write_error();\n  }\n                    /* WARNING: Subroutine does not return */\n  do_exit(0);\n}\n\n",
        "output": "The predicted function name is finish_out"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  byte bVar1;\n  uchar uVar2;\n  ulong uVar3;\n  int len;\n  int base;\n  int n;\n  int max_leaves;\n  \n  max_leaves = 1;\n  orig_len = 0;\n  for (n = 1; n < 5; n = n + 1) {\n    uVar3 = orig_len << 8;\n    bVar1 = read_byte();\n    orig_len = bVar1 | uVar3;\n  }\n  bVar1 = read_byte();\n  max_len = (int)bVar1;\n  if ((max_len == 0) || (0x19 < (uint)max_len)) {\n                    /* WARNING: Subroutine does not return */\n    gzip_error(\"invalid compressed data -- Huffman code bit length out of range\");\n  }\n  n = 0;\n  for (len = 1; len <= max_len; len = len + 1) {\n    bVar1 = read_byte();\n    leaves[len] = (uint)bVar1;\n    if ((int)(max_leaves - (uint)(len == max_len)) < leaves[len]) {\n                    /* WARNING: Subroutine does not return */\n      gzip_error(\"too many leaves in Huffman tree\");\n    }\n    max_leaves = ((max_leaves - leaves[len]) + 1) * 2 + -1;\n    n = n + leaves[len];\n  }\n  if (0xff < n) {\n                    /* WARNING: Subroutine does not return */\n    gzip_error(\"too many leaves in Huffman tree\");\n  }\n  leaves[max_len] = leaves[max_len] + 1;\n  base = 0;\n  for (len = 1; len <= max_len; len = len + 1) {\n    lit_base[len] = base;\n    for (n = leaves[len]; 0 < n; n = n + -1) {\n      uVar2 = read_byte();\n      literal[base] = uVar2;\n      base = base + 1;\n    }\n  }\n  leaves[max_len] = leaves[max_len] + 1;\n  return;\n}\n\n",
        "output": "The predicted function name is read_tree"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *fname)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = last_component(fname);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is gzip_base_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](stat *st)\n\n{\n  return (st->st_ctim).tv_nsec;\n}\n\n",
        "output": "The predicted function name is get_stat_ctime_ns"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int fd,voidp buf,uint cnt)\n\n{\n  uint uVar1;\n  int iVar2;\n  ssize_t sVar3;\n  int *piVar4;\n  uint local_20;\n  int len;\n  int flags;\n  \n  local_20 = cnt;\n  if ((int)cnt < 0) {\n    local_20 = 0x7fffffff;\n  }\n  sVar3 = read(fd,buf,(ulong)local_20);\n  len = (int)sVar3;\n  if (len < 0) {\n    piVar4 = __errno_location();\n    if (*piVar4 == 0xb) {\n      uVar1 = rpl_fcntl(fd,3);\n      if (-1 < (int)uVar1) {\n        if ((uVar1 & 0x800) == 0) {\n          piVar4 = __errno_location();\n          *piVar4 = 0xb;\n        }\n        else {\n          iVar2 = rpl_fcntl(fd,4,(ulong)(uVar1 & 0xfffff7ff));\n          if (iVar2 != -1) {\n            sVar3 = read(fd,buf,(ulong)local_20);\n            len = (int)sVar3;\n          }\n        }\n      }\n    }\n  }\n  return len;\n}\n\n",
        "output": "The predicted function name is read_buffer"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](void *p,idx_t s)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = irealloc(p,s);\n  pvVar1 = nonnull(pvVar1);\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is xirealloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int dist,int lc)\n\n{\n  byte bVar1;\n  int iVar2;\n  ulong uVar3;\n  int dcode;\n  ulg out_length;\n  ulg in_length;\n  \n  uVar3 = (ulong)last_lit;\n  last_lit = last_lit + 1;\n  inbuf[uVar3] = (char)lc;\n  if (dist == 0) {\n    dyn_ltree[lc].fc = dyn_ltree[lc].fc + 1;\n  }\n  else {\n    iVar2 = dist + -1;\n    dyn_ltree[(int)(length_code[lc] + 0x101)].fc = dyn_ltree[(int)(length_code[lc] + 0x101)].fc + 1;\n    if (iVar2 < 0x100) {\n      bVar1 = dist_code[iVar2];\n    }\n    else {\n      bVar1 = dist_code[(iVar2 >> 7) + 0x100];\n    }\n    dyn_dtree[(int)(uint)bVar1].fc = dyn_dtree[(int)(uint)bVar1].fc + 1;\n    uVar3 = (ulong)last_dist;\n    last_dist = last_dist + 1;\n    *(short *)(d_buf + uVar3 * 2) = (short)iVar2;\n    flags = flag_bit | flags;\n  }\n  flag_bit = flag_bit * '\\x02';\n  if ((last_lit & 7) == 0) {\n    uVar3 = (ulong)last_flags;\n    last_flags = last_flags + 1;\n    flag_buf[uVar3] = flags;\n    flags = '\\0';\n    flag_bit = '\\x01';\n  }\n  if ((2 < level) && ((last_lit & 0xfff) == 0)) {\n    out_length = (ulong)last_lit << 3;\n    for (dcode = 0; dcode < 0x1e; dcode = dcode + 1) {\n      out_length = out_length + ((long)extra_dbits[dcode] + 5) * (ulong)(ushort)dyn_dtree[dcode].fc;\n    }\n    if ((last_dist < last_lit >> 1) && (out_length >> 3 < (ulong)strstart - block_start >> 1)) {\n      return 1;\n    }\n  }\n  if ((last_lit == 0x7fff) || (last_dist == 0x8000)) {\n    iVar2 = 1;\n  }\n  else {\n    iVar2 = 0;\n  }\n  return iVar2;\n}\n\n",
        "output": "The predicted function name is ct_tally"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int fd,voidp buf,uint cnt)\n\n{\n  ssize_t sVar1;\n  uint local_10;\n  \n  local_10 = cnt;\n  if ((int)cnt < 0) {\n    local_10 = 0x7fffffff;\n  }\n  sVar1 = write(fd,buf,(ulong)local_10);\n  return (int)sVar1;\n}\n\n",
        "output": "The predicted function name is write_buffer"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](stat *st)\n\n{\n  return (st->st_mtim).tv_nsec;\n}\n\n",
        "output": "The predicted function name is get_stat_mtime_ns"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int method)\n\n{\n  tm *ptVar1;\n  int positive_off_t_width;\n  ulg crc;\n  tm *tm;\n  \n  if ((do_list::first_time == 0) || (method < 0)) {\n    if (method < 0) {\n      if (total_in < 1) {\n        return;\n      }\n      if (total_out < 1) {\n        return;\n      }\n      if (verbose != 0) {\n        printf(\"                            \");\n      }\n      if ((verbose != 0) || (quiet == 0)) {\n        fprint_off(stdout,total_in,0x13);\n        putchar(0x20);\n        fprint_off(stdout,total_out,0x13);\n        putchar(0x20);\n      }\n      display_ratio(total_out - (total_in - header_bytes),total_out,stdout);\n      puts(\" (totals)\");\n      return;\n    }\n  }\n  else {\n    do_list::first_time = 0;\n    if (verbose != 0) {\n      printf(\"method  crc     date  time  \");\n    }\n    if (quiet == 0) {\n      printf(\"%*.*s %*.*s  ratio uncompressed_name\\n\",0x13,0x13,\"compressed\",0x13,0x13,\n             \"uncompressed\");\n    }\n  }\n  crc = 0xffffffffffffffff;\n  if ((method == 8) && (last_member == 0)) {\n    crc = unzip_crc;\n  }\n  if (verbose != 0) {\n    ptVar1 = localtime(&time_stamp.tv_sec);\n    printf(\"%5s %08lx \",do_list::methods[method],crc);\n    if (ptVar1 == (tm *)0x0) {\n      printf(\"??? ?? ??:?? \");\n    }\n    else {\n      printf(\"%s%3d %02d:%02d \",do_list::lexical_block_0::month_abbr[ptVar1->tm_mon],\n             (ulong)(uint)ptVar1->tm_mday,(ulong)(uint)ptVar1->tm_hour,(ulong)(uint)ptVar1->tm_min);\n    }\n  }\n  fprint_off(stdout,bytes_in,0x13);\n  putchar(0x20);\n  fprint_off(stdout,bytes_out,0x13);\n  putchar(0x20);\n  if (bytes_in == -1) {\n    total_in = -1;\n    header_bytes = 0;\n    bytes_out = 0;\n    bytes_in = 0;\n  }\n  else if (-1 < total_in) {\n    total_in = bytes_in + total_in;\n  }\n  if (bytes_out == -1) {\n    total_out = -1;\n    header_bytes = 0;\n    bytes_out = 0;\n    bytes_in = 0;\n  }\n  else if (-1 < total_out) {\n    total_out = bytes_out + total_out;\n  }\n  display_ratio(bytes_out - (bytes_in - header_bytes),bytes_out,stdout);\n  printf(\" %s\\n\",ofname);\n  return;\n}\n\n",
        "output": "The predicted function name is do_list"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ct_data *tree,int max_code)\n\n{\n  ushort uVar1;\n  uint uVar2;\n  int n;\n  int prevlen;\n  int nextlen;\n  int count;\n  int max_count;\n  int min_count;\n  int curlen;\n  \n  prevlen = -1;\n  uVar1 = tree->dl;\n  count = 0;\n  max_count = 7;\n  min_count = 4;\n  if (uVar1 == 0) {\n    max_count = 0x8a;\n    min_count = 3;\n  }\n  tree[(long)max_code + 1].dl = 0xffff;\n  nextlen = (uint)uVar1;\n  for (n = 0; n <= max_code; n = n + 1) {\n    uVar2 = (uint)(ushort)tree[(long)n + 1].dl;\n    count = count + 1;\n    if ((max_count <= count) || (nextlen != uVar2)) {\n      if (count < min_count) {\n        bl_tree[nextlen].fc = bl_tree[nextlen].fc + (short)count;\n      }\n      else if (nextlen == 0) {\n        if (count < 0xb) {\n          bl_tree[17].fc = bl_tree[17].fc + 1;\n        }\n        else {\n          bl_tree[18].fc = bl_tree[18].fc + 1;\n        }\n      }\n      else {\n        if (nextlen != prevlen) {\n          bl_tree[nextlen].fc = bl_tree[nextlen].fc + 1;\n        }\n        bl_tree[16].fc = bl_tree[16].fc + 1;\n      }\n      count = 0;\n      prevlen = nextlen;\n      if (uVar2 == 0) {\n        max_count = 0x8a;\n        min_count = 3;\n      }\n      else if (nextlen == uVar2) {\n        max_count = 6;\n        min_count = 3;\n      }\n      else {\n        max_count = 7;\n        min_count = 4;\n      }\n    }\n    nextlen = uVar2;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is scan_tree"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nint [MASK](uint *b,uint n,uint s,ush *d,ush *e,huft **t,int *m)\n\n{\n  uint uVar1;\n  int iVar2;\n  huft *phVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  uint uVar7;\n  void *pvVar8;\n  int iVar9;\n  uint uVar10;\n  ulong uVar11;\n  uint uVar12;\n  uint uVar13;\n  uint uVar14;\n  ulong uVar15;\n  uint *puVar16;\n  uint *puVar17;\n  huft *phVar18;\n  long in_FS_OFFSET;\n  uint local_65c;\n  huft **local_650;\n  uint a;\n  uint f;\n  int h;\n  int l;\n  int y;\n  uint z;\n  int g;\n  uint *xp;\n  huft r;\n  uint c [17];\n  uint x [17];\n  huft *u [16];\n  uint v [288];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  memset(c,0,0x44);\n  puVar17 = b;\n  uVar12 = n;\n  do {\n    c[*puVar17] = c[*puVar17] + 1;\n    puVar17 = puVar17 + 1;\n    uVar12 = uVar12 - 1;\n  } while (uVar12 != 0);\n  if (n == c[0]) {\n    pvVar8 = malloc(0x30);\n    if (pvVar8 == (void *)0x0) {\n      iVar9 = 3;\n    }\n    else {\n      hufts = hufts + 3;\n      *(undefined8 *)((long)pvVar8 + 8) = 0;\n      *(undefined *)((long)pvVar8 + 0x10) = 99;\n      *(undefined *)((long)pvVar8 + 0x11) = 1;\n      *(undefined *)((long)pvVar8 + 0x20) = 99;\n      *(undefined *)((long)pvVar8 + 0x21) = 1;\n      *t = (huft *)((long)pvVar8 + 0x10);\n      *m = 1;\n      iVar9 = 0;\n    }\n  }\n  else {\n    l = *m;\n    uVar11 = 1;\n    while ((local_65c = (uint)uVar11, local_65c < 0x11 && (c[uVar11] == 0))) {\n      uVar11 = (ulong)(local_65c + 1);\n    }\n    if ((uint)l < local_65c) {\n      l = local_65c;\n    }\n    uVar15 = 0x10;\n    while ((uVar12 = (uint)uVar15, uVar12 != 0 && (c[uVar15] == 0))) {\n      uVar15 = (ulong)(uVar12 - 1);\n    }\n    if (uVar12 < (uint)l) {\n      l = uVar12;\n    }\n    *m = l;\n    y = 1 << ((byte)uVar11 & 0x1f);\n    for (; (uint)uVar11 < uVar12; uVar11 = (ulong)((uint)uVar11 + 1)) {\n      if ((int)(y - c[uVar11]) < 0) {\n        iVar9 = 2;\n        goto LAB_000080b7;\n      }\n      y = (y - c[uVar11]) * 2;\n    }\n    iVar9 = y - c[uVar15];\n    if (iVar9 < 0) {\n      iVar9 = 2;\n    }\n    else {\n      c[uVar15] = c[uVar15] + iVar9;\n      uVar14 = 0;\n      x[1] = 0;\n      puVar17 = c;\n      xp = x + 2;\n      while (puVar17 = puVar17 + 1, uVar13 = (int)uVar15 - 1, uVar15 = (ulong)uVar13, uVar13 != 0) {\n        uVar14 = uVar14 + *puVar17;\n        *xp = uVar14;\n        xp = xp + 1;\n      }\n      uVar14 = 0;\n      do {\n        uVar13 = *b;\n        if (uVar13 != 0) {\n          uVar1 = x[uVar13];\n          x[uVar13] = uVar1 + 1;\n          v[uVar1] = uVar14;\n        }\n        uVar14 = uVar14 + 1;\n        b = b + 1;\n      } while (uVar14 < n);\n      uVar14 = x[(int)uVar12];\n      uVar13 = 0;\n      x[0] = 0;\n      puVar17 = v;\n      h = -1;\n      iVar5 = -l;\n      u[0] = (huft *)0x0;\n      phVar18 = (huft *)0x0;\n      z = 0;\n      local_650 = t;\n      for (; (int)local_65c <= (int)uVar12; local_65c = local_65c + 1) {\n        a = c[(int)local_65c];\n        while (uVar1 = a - 1, iVar2 = h, a != 0) {\n          while (h = iVar2, l + iVar5 < (int)local_65c) {\n            iVar2 = h + 1;\n            iVar5 = l + iVar5;\n            uVar10 = uVar12 - iVar5;\n            if ((uint)l < uVar10) {\n              uVar10 = l;\n            }\n            uVar6 = local_65c - iVar5;\n            uVar7 = 1 << ((byte)uVar6 & 0x1f);\n            if (a < uVar7) {\n              f = (uVar7 - uVar1) - 1;\n              xp = c + (int)local_65c;\n              if (uVar6 < uVar10) {\n                while (uVar6 = uVar6 + 1, uVar6 < uVar10) {\n                  xp = xp + 1;\n                  if (f * 2 <= *xp) break;\n                  f = f * 2 - *xp;\n                }\n              }\n            }\n            z = 1 << ((byte)uVar6 & 0x1f);\n            pvVar8 = malloc((ulong)(z + 1) << 4);\n            if (pvVar8 == (void *)0x0) {\n              if (iVar2 != 0) {\n                huft_free(u[0]);\n              }\n              iVar9 = 3;\n              goto LAB_000080b7;\n            }\n            hufts = z + hufts + 1;\n            *local_650 = (huft *)((long)pvVar8 + 0x10);\n            local_650 = (huft **)((long)pvVar8 + 8);\n            *local_650 = (huft *)0x0;\n            phVar18 = (huft *)((long)pvVar8 + 0x10);\n            u[iVar2] = phVar18;\n            if (iVar2 != 0) {\n              x[iVar2] = uVar13;\n              phVar3 = u[h];\n              *(ulong *)(phVar3 + (uVar13 >> ((char)iVar5 - (char)l & 0x1fU))) =\n                   CONCAT62(r._2_6_,CONCAT11((char)l,(byte)uVar6 + 0x10));\n              *(huft **)&phVar3[uVar13 >> ((char)iVar5 - (char)l & 0x1fU)].v = phVar18;\n              r._8_8_ = phVar18;\n            }\n          }\n          bVar4 = (byte)iVar5;\n          if (puVar17 < v + uVar14) {\n            if (*puVar17 < s) {\n              if (*puVar17 < 0x100) {\n                r.e = '\\x10';\n              }\n              else {\n                r.e = '\\x0f';\n              }\n              r._8_8_ = (huft *)((ulong)r._8_8_ & 0xffffffffffff0000 | (ulong)(ushort)*puVar17);\n              puVar16 = puVar17 + 1;\n            }\n            else {\n              r.e = (uch)e[*puVar17 - s];\n              puVar16 = puVar17 + 1;\n              r._8_8_ = (huft *)((ulong)r._8_8_ & 0xffffffffffff0000 | (ulong)d[*puVar17 - s]);\n            }\n          }\n          else {\n            r.e = 'c';\n            puVar16 = puVar17;\n          }\n          for (uVar10 = uVar13 >> (bVar4 & 0x1f); uVar10 < z;\n              uVar10 = (1 << ((char)local_65c - bVar4 & 0x1f)) + uVar10) {\n            *(ulong *)(phVar18 + uVar10) = CONCAT62(r._2_6_,CONCAT11((char)local_65c - bVar4,r.e));\n            *(huft **)&phVar18[uVar10].v = r._8_8_;\n          }\n          uVar10 = 1 << ((char)local_65c - 1U & 0x1f);\n          while ((uVar13 & uVar10) != 0) {\n            uVar13 = uVar13 ^ uVar10;\n            uVar10 = uVar10 >> 1;\n          }\n          uVar13 = uVar13 ^ uVar10;\n          for (; puVar17 = puVar16, a = uVar1, ((1 << ((byte)iVar5 & 0x1f)) - 1U & uVar13) != x[h];\n              h = h + -1) {\n            iVar5 = iVar5 - l;\n          }\n        }\n      }\n      if ((iVar9 == 0) || (uVar12 == 1)) {\n        iVar9 = 0;\n      }\n      else {\n        iVar9 = 1;\n      }\n    }\n  }\nLAB_000080b7:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar9;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is huft_build"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](stat *st)\n\n{\n  return (st->st_atim).tv_nsec;\n}\n\n",
        "output": "The predicted function name is get_stat_atime_ns"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *name,int flags,stat *st)\n\n{\n  int iVar1;\n  int iVar2;\n  char *pcVar3;\n  int *piVar4;\n  uint local_34;\n  int atfd;\n  int f;\n  int fd;\n  int e;\n  char *base;\n  char *b;\n  \n  atfd = -100;\n  local_34 = flags;\n  if ((to_stdout == 0) && (force == 0)) {\n    local_34 = flags | 0x20000;\n  }\n  base = name;\n  if (keep == 0) {\n    pcVar3 = last_component(name);\n    iVar1 = atdir_set(name,(long)pcVar3 - (long)name);\n    base = name;\n    if (-1 < iVar1) {\n      atfd = iVar1;\n      base = pcVar3;\n    }\n  }\n  iVar1 = openat_safer(atfd,base,local_34);\n  if ((-1 < iVar1) && (iVar2 = fstat(iVar1,(stat *)st), iVar2 != 0)) {\n    piVar4 = __errno_location();\n    iVar2 = *piVar4;\n    close(iVar1);\n    piVar4 = __errno_location();\n    *piVar4 = iVar2;\n    iVar1 = -1;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is open_and_stat"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](FILE *file,off_t offset,int width)\n\n{\n  char *pcVar1;\n  long in_FS_OFFSET;\n  int local_7c;\n  long local_78;\n  char *p;\n  char buf [64];\n  char acStack24 [8];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  p = acStack24;\n  local_78 = offset;\n  pcVar1 = p;\n  if (offset < 0) {\n    do {\n      p = pcVar1;\n      p[-1] = '0' - ((char)local_78 + (char)(local_78 / 10) * -10);\n      local_78 = local_78 / 10;\n      pcVar1 = p + -1;\n    } while (local_78 != 0);\n    p = p + -2;\n    *p = '-';\n  }\n  else {\n    do {\n      p = p + -1;\n      *p = (char)local_78 + (char)(local_78 / 10) * -10 + '0';\n      local_78 = local_78 / 10;\n    } while (local_78 != 0);\n  }\n  local_7c = width - (((int)register0x00000020 + -0x18) - (int)p);\n  while (0 < local_7c) {\n    _IO_putc(0x20,(_IO_FILE *)file);\n    local_7c = local_7c + -1;\n  }\n  for (; p < acStack24; p = p + 1) {\n    _IO_putc((int)*p,(_IO_FILE *)file);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is fprint_off"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int n)\n\n{\n  int local_c;\n  \n  bitbuf = bitbuf << ((byte)n & 0x1f);\n  local_c = n;\n  while (bitcount < local_c) {\n    local_c = local_c - bitcount;\n    bitbuf = bitbuf | (ushort)(subbitbuf << ((byte)local_c & 0x1f));\n    if (inptr < insize) {\n      subbitbuf = (uint)(byte)inbuf[inptr];\n      inptr = inptr + 1;\n    }\n    else {\n      subbitbuf = fill_inbuf(1);\n    }\n    if (subbitbuf == 0xffffffff) {\n      subbitbuf = 0;\n    }\n    bitcount = 8;\n  }\n  bitbuf = bitbuf | (ushort)(subbitbuf >> ((byte)(bitcount - local_c) & 0x1f));\n  bitcount = bitcount - local_c;\n  return;\n}\n\n",
        "output": "The predicted function name is fillbuf"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Removing unreachable block (ram,0x0000e282) */\n/* WARNING: Removing unreachable block (ram,0x0000e2b4) */\n/* WARNING: Removing unreachable block (ram,0x0000e2e2) */\n/* WARNING: Removing unreachable block (ram,0x0000e321) */\n\nint [MASK](int in,int out)\n\n{\n  char *pcVar1;\n  char cVar2;\n  ulg uVar3;\n  undefined uVar4;\n  ulong uVar5;\n  long in_FS_OFFSET;\n  uch flags;\n  ush attr;\n  ush deflate_flags;\n  ulg stamp;\n  char *p;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  flags = '\\0';\n  if (save_orig_name != 0) {\n    flags = '\\b';\n  }\n  outbuf[3] = flags;\n  outbuf[2] = 8;\n  outbuf[1] = 0x8b;\n  outbuf[0] = 0x1f;\n  deflate_flags = 0;\n  attr = 0;\n  outcnt = 4;\n  method = 8;\n  ofd = out;\n  ifd = in;\n  if (time_stamp.tv_nsec < 0) {\n    stamp = 0;\n  }\n  else if ((time_stamp.tv_sec < 1) || (0xffffffff < time_stamp.tv_sec)) {\n    warning(\"file timestamp out of range for gzip format\");\n    stamp = 0;\n  }\n  else {\n    stamp = time_stamp.tv_sec;\n  }\n  if (outcnt < 0x3fffe) {\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar5] = (char)stamp;\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar5] = (char)(stamp >> 8);\n  }\n  else {\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar5] = (char)stamp;\n    if (outcnt == 0x40000) {\n      flush_outbuf();\n    }\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar5] = (char)(stamp >> 8);\n    if (outcnt == 0x40000) {\n      flush_outbuf();\n    }\n  }\n  uVar4 = (undefined)(stamp >> 0x10);\n  if (outcnt < 0x3fffe) {\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar5] = uVar4;\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar5] = (char)(stamp >> 0x18);\n  }\n  else {\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar5] = uVar4;\n    if (outcnt == 0x40000) {\n      flush_outbuf();\n    }\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar5] = (char)(stamp >> 0x18);\n    if (outcnt == 0x40000) {\n      flush_outbuf();\n    }\n  }\n  updcrc((uch *)0x0,0);\n  bi_init(out);\n  ct_init(&attr,&method);\n  if (level == 1) {\n    deflate_flags = deflate_flags | 4;\n  }\n  else if (level == 9) {\n    deflate_flags = deflate_flags | 2;\n  }\n  uVar5 = (ulong)outcnt;\n  outcnt = outcnt + 1;\n  outbuf[uVar5] = (char)deflate_flags;\n  if (outcnt == 0x40000) {\n    flush_outbuf();\n  }\n  uVar5 = (ulong)outcnt;\n  outcnt = outcnt + 1;\n  outbuf[uVar5] = 3;\n  if (outcnt == 0x40000) {\n    flush_outbuf();\n  }\n  if (save_orig_name != 0) {\n    p = gzip_base_name(ifname);\n    do {\n      uVar5 = (ulong)outcnt;\n      outcnt = outcnt + 1;\n      outbuf[uVar5] = *p;\n      if (outcnt == 0x40000) {\n        flush_outbuf();\n      }\n      pcVar1 = p + 1;\n      cVar2 = *p;\n      p = pcVar1;\n    } while (cVar2 != '\\0');\n  }\n  header_bytes = (off_t)outcnt;\n  deflate(level);\n  if ((ifile_size != -1) && (bytes_in != ifile_size)) {\n    fprintf(stderr,\"%s: %s: file size changed while zipping\\n\",program_name,ifname);\n  }\n  if (outcnt < 0x3fffe) {\n    uVar3 = getcrc();\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar5] = (char)uVar3;\n    uVar3 = getcrc();\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar5] = (char)(uVar3 >> 8);\n  }\n  else {\n    uVar3 = getcrc();\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar5] = (char)uVar3;\n    if (outcnt == 0x40000) {\n      flush_outbuf();\n    }\n    uVar3 = getcrc();\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar5] = (char)(uVar3 >> 8);\n    if (outcnt == 0x40000) {\n      flush_outbuf();\n    }\n  }\n  if (outcnt < 0x3fffe) {\n    uVar3 = getcrc();\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar5] = (char)(uVar3 >> 0x10);\n    uVar3 = getcrc();\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar5] = (char)(uVar3 >> 0x18);\n  }\n  else {\n    uVar3 = getcrc();\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar5] = (char)(uVar3 >> 0x10);\n    if (outcnt == 0x40000) {\n      flush_outbuf();\n    }\n    uVar3 = getcrc();\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar5] = (char)(uVar3 >> 0x18);\n    if (outcnt == 0x40000) {\n      flush_outbuf();\n    }\n  }\n  if (outcnt < 0x3fffe) {\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar5] = (char)bytes_in;\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar5] = (char)((ulong)bytes_in >> 8);\n  }\n  else {\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar5] = (char)bytes_in;\n    if (outcnt == 0x40000) {\n      flush_outbuf();\n    }\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar5] = (char)((ulong)bytes_in >> 8);\n    if (outcnt == 0x40000) {\n      flush_outbuf();\n    }\n  }\n  uVar4 = (undefined)((ulong)bytes_in >> 0x10);\n  if (outcnt < 0x3fffe) {\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar5] = uVar4;\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar5] = (char)((ulong)bytes_in >> 0x18);\n  }\n  else {\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar5] = uVar4;\n    if (outcnt == 0x40000) {\n      flush_outbuf();\n    }\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar5] = (char)((ulong)bytes_in >> 0x18);\n    if (outcnt == 0x40000) {\n      flush_outbuf();\n    }\n  }\n  header_bytes = header_bytes + 8;\n  flush_outbuf();\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is zip"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,timespec *timespec)\n\n{\n  int iVar1;\n  \n  iVar1 = fdutimens(-1,file,timespec);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is utimens"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](void *p,idx_t n,idx_t s)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = ireallocarray(p,n,s);\n  pvVar1 = nonnull(pvVar1);\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is xireallocarray"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](idx_t n,idx_t s)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = xireallocarray((void *)0x0,n,s);\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is xinmalloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  fprintf(stderr,\"Try `%s --help\\' for more information.\\n\",program_name);\n                    /* WARNING: Subroutine does not return */\n  do_exit(1);\n}\n\n",
        "output": "The predicted function name is try_help"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulg [MASK](void)\n\n{\n  return crc ^ 0xffffffff;\n}\n\n",
        "output": "The predicted function name is getcrc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  int iVar1;\n  int nodes;\n  int len;\n  int prefixes;\n  uch *prefixp;\n  \n  nodes = 0;\n  for (len = max_len; iVar1 = nodes >> 1, 0 < len; len = len + -1) {\n    parents[len] = iVar1;\n    lit_base[len] = lit_base[len] - iVar1;\n    nodes = iVar1 + leaves[len];\n  }\n  if (iVar1 == 1) {\n    peek_bits = max_len;\n    if (0xc < max_len) {\n      peek_bits = 0xc;\n    }\n    prefixp = outbuf + (1 << ((byte)peek_bits & 0x1f));\n    for (len = 1; len <= peek_bits; len = len + 1) {\n      prefixes = leaves[len] << ((char)peek_bits - (uch)len & 0x1f);\n      while (prefixes != 0) {\n        prefixp = prefixp + -1;\n        *prefixp = (uch)len;\n        prefixes = prefixes + -1;\n      }\n    }\n    while (outbuf < prefixp) {\n      prefixp = prefixp + -1;\n      *prefixp = '\\0';\n    }\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  gzip_error(\"too few leaves in Huffman tree\");\n}\n\n",
        "output": "The predicted function name is build_tree"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\ntimespec [MASK](stat *st)\n\n{\n  return st->st_ctim;\n}\n\n",
        "output": "The predicted function name is get_stat_ctime"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *dst,char *src)\n\n{\n  char cVar1;\n  char *local_18;\n  char *local_10;\n  \n  local_18 = src;\n  local_10 = dst;\n  do {\n    cVar1 = *local_18;\n    *local_10 = cVar1;\n    local_18 = local_18 + 1;\n    local_10 = local_10 + 1;\n  } while (cVar1 != '\\0');\n  return;\n}\n\n",
        "output": "The predicted function name is volatile_strcpy"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](uint start,uint num)\n\n{\n  uint local_20;\n  uint local_1c;\n  uint i;\n  \n  local_20 = num;\n  local_1c = start;\n  i = start;\n  if (start < 0x1000) {\n    for (; i < 0x1000; i = i + 1) {\n      if (i == num + start) {\n        return;\n      }\n      rsync_sum = rsync_sum + (byte)window[i];\n    }\n    local_20 = (num + start) - 0x1000;\n    local_1c = 0x1000;\n  }\n  for (i = local_1c; i < local_20 + local_1c; i = i + 1) {\n    rsync_sum = (rsync_sum + (byte)window[i]) - (ulong)(byte)window[i - 0x1000];\n    if ((rsync_chunk_end == 0xffffffff) && ((rsync_sum & 0xfff) == 0)) {\n      rsync_chunk_end = (ulg)i;\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is rsync_roll"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nint [MASK](int in,int out)\n\n{\n  ulong uVar1;\n  undefined uVar2;\n  uch uVar3;\n  int iVar4;\n  ulong uVar5;\n  long lVar6;\n  ulg uVar7;\n  long in_FS_OFFSET;\n  uch c;\n  int n;\n  int err;\n  int res;\n  ulg orig_crc;\n  ulg orig_len;\n  uch buf [16];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  orig_crc = 0;\n  orig_len = 0;\n  ofd = out;\n  ifd = in;\n  updcrc((uch *)0x0,0);\n  if ((pkzip != 0) && (ext_header == 0)) {\n    orig_crc = (long)(int)(uint)CONCAT11(inbuf[15],inbuf[14]) |\n               (long)(int)(uint)CONCAT11(inbuf[17],inbuf[16]) << 0x10;\n    orig_len = (long)(int)(uint)CONCAT11(inbuf[23],inbuf[22]) |\n               (long)(int)(uint)CONCAT11(inbuf[25],inbuf[24]) << 0x10;\n  }\n  if (method == 8) {\n    iVar4 = inflate();\n    if (iVar4 == 3) {\n                    /* WARNING: Subroutine does not return */\n      xalloc_die();\n    }\n    if (iVar4 != 0) {\n                    /* WARNING: Subroutine does not return */\n      gzip_error(\"invalid compressed data--format violated\");\n    }\n  }\n  else {\n    if ((pkzip == 0) || (method != 0)) {\n                    /* WARNING: Subroutine does not return */\n      gzip_error(\"internal error, invalid method\");\n    }\n    uVar5 = (long)(int)(uint)CONCAT11(inbuf[23],inbuf[22]) |\n            (long)(int)(uint)CONCAT11(inbuf[25],inbuf[24]) << 0x10;\n    if (decrypt == 0) {\n      lVar6 = 0;\n    }\n    else {\n      lVar6 = 0xc;\n    }\n    if (uVar5 != ((long)(int)(uint)CONCAT11(inbuf[21],inbuf[20]) << 0x10 |\n                 (long)(int)(uint)CONCAT11(inbuf[19],inbuf[18])) - lVar6) {\n      fprintf(stderr,\"len %lu, siz %lu\\n\",uVar5,\n              (long)(int)(uint)CONCAT11(inbuf[21],inbuf[20]) << 0x10 |\n              (long)(int)(uint)CONCAT11(inbuf[19],inbuf[18]));\n                    /* WARNING: Subroutine does not return */\n      gzip_error(\"invalid compressed data--length mismatch\");\n    }\n    while (uVar1 = uVar5 - 1, uVar5 != 0) {\n      if (inptr < insize) {\n        uVar2 = inbuf[inptr];\n        inptr = inptr + 1;\n      }\n      else {\n        iVar4 = fill_inbuf(0);\n        uVar2 = (undefined)iVar4;\n      }\n      uVar5 = (ulong)outcnt;\n      outcnt = outcnt + 1;\n      window[uVar5] = uVar2;\n      uVar5 = uVar1;\n      if (outcnt == 0x8000) {\n        flush_window();\n      }\n    }\n    flush_window();\n  }\n  if (pkzip == 0) {\n    for (n = 0; n < 8; n = n + 1) {\n      if (inptr < insize) {\n        uVar3 = inbuf[inptr];\n        inptr = inptr + 1;\n      }\n      else {\n        iVar4 = fill_inbuf(0);\n        uVar3 = (uch)iVar4;\n      }\n      buf[n] = uVar3;\n    }\n    orig_crc = (long)(int)(uint)buf._0_2_ | (long)(int)(uint)buf._2_2_ << 0x10;\n    orig_len = (long)(int)(uint)buf._4_2_ | (long)(int)(uint)buf._6_2_ << 0x10;\n  }\n  else if (ext_header != 0) {\n    for (n = 0; n < 0x10; n = n + 1) {\n      if (inptr < insize) {\n        uVar3 = inbuf[inptr];\n        inptr = inptr + 1;\n      }\n      else {\n        iVar4 = fill_inbuf(0);\n        uVar3 = (uch)iVar4;\n      }\n      buf[n] = uVar3;\n    }\n    orig_crc = (long)(int)(uint)buf._4_2_ | (long)(int)(uint)buf._6_2_ << 0x10;\n    orig_len = (long)(int)(uint)buf._12_2_ | (long)(int)(uint)buf._14_2_ << 0x10;\n  }\n  uVar7 = updcrc(outbuf,0);\n  if (orig_crc != uVar7) {\n    fprintf(stderr,\"\\n%s: %s: invalid compressed data--crc error\\n\",program_name,ifname);\n  }\n  err = (int)(orig_crc != uVar7);\n  if (orig_len != (bytes_out & 0xffffffffU)) {\n    fprintf(stderr,\"\\n%s: %s: invalid compressed data--length error\\n\",program_name,ifname);\n    err = 1;\n  }\n  if (((pkzip != 0) && (inptr + 4 < insize)) &&\n     (((long)(int)(uint)CONCAT11(inbuf[(ulong)inptr + 1],inbuf[inptr]) |\n      (long)(int)(uint)CONCAT11(inbuf[(ulong)inptr + 3],inbuf[(ulong)inptr + 2]) << 0x10) ==\n      0x4034b50)) {\n    if (to_stdout == 0) {\n      fprintf(stderr,\"%s: %s has more than one entry -- unchanged\\n\",program_name,ifname);\n      err = 1;\n    }\n    else {\n      if (quiet == 0) {\n        fprintf(stderr,\"%s: %s has more than one entry--rest ignored\\n\",program_name,ifname);\n      }\n      if (exit_code == 0) {\n        exit_code = 2;\n      }\n    }\n  }\n  pkzip = 0;\n  ext_header = 0;\n  unzip_crc = orig_crc;\n  if (err == 0) {\n    err = 0;\n  }\n  else {\n    exit_code = 1;\n    if (test == 0) {\n                    /* WARNING: Subroutine does not return */\n      abort_gzip();\n    }\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    pkzip = 0;\n    ext_header = 0;\n    return err;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is unzip"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](void *p)\n\n{\n  if (p == (void *)0x0) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  return p;\n}\n\n",
        "output": "The predicted function name is nonnull"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](huft *tl,huft *td,int bl,int bd)\n\n{\n  ushort uVar1;\n  ushort uVar2;\n  uint uVar3;\n  ulong uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  ulg uVar8;\n  ulong uVar9;\n  uint n;\n  uint d;\n  uint w;\n  uint ml;\n  uint md;\n  huft *t;\n  \n  w = outcnt;\n  uVar1 = mask_bits[bl];\n  uVar2 = mask_bits[bd];\n  uVar8 = bb;\n  uVar5 = bk;\n  while( true ) {\n    while( true ) {\n      for (; uVar5 < (uint)bl; uVar5 = uVar5 + 8) {\n        if (inptr < insize) {\n          uVar9 = (ulong)(byte)inbuf[inptr];\n          inptr = inptr + 1;\n        }\n        else {\n          outcnt = w;\n          uVar6 = fill_inbuf(0);\n          uVar9 = (ulong)(uVar6 & 0xff);\n        }\n        uVar8 = uVar8 | uVar9 << ((byte)uVar5 & 0x3f);\n      }\n      t = tl + ((uint)uVar8 & (uint)uVar1);\n      uVar6 = (uint)t->e;\n      if (0x10 < t->e) {\n        do {\n          if (uVar6 == 99) {\n            return 1;\n          }\n          uVar8 = uVar8 >> (t->b & 0x3f);\n          for (uVar5 = uVar5 - t->b; uVar5 < uVar6 - 0x10; uVar5 = uVar5 + 8) {\n            if (inptr < insize) {\n              uVar9 = (ulong)(byte)inbuf[inptr];\n              inptr = inptr + 1;\n            }\n            else {\n              outcnt = w;\n              uVar3 = fill_inbuf(0);\n              uVar9 = (ulong)(uVar3 & 0xff);\n            }\n            uVar8 = uVar8 | uVar9 << ((byte)uVar5 & 0x3f);\n          }\n          t = (huft *)((ulong)((uint)mask_bits[uVar6 - 0x10] & (uint)uVar8) * 0x10 + *(long *)&t->v)\n          ;\n          uVar6 = (uint)t->e;\n        } while (0x10 < uVar6);\n      }\n      uVar8 = uVar8 >> (t->b & 0x3f);\n      uVar5 = uVar5 - t->b;\n      if (uVar6 != 0x10) break;\n      uVar6 = w + 1;\n      window[w] = (char)t->v;\n      w = uVar6;\n      if (uVar6 == 0x8000) {\n        outcnt = uVar6;\n        flush_window();\n        w = 0;\n      }\n    }\n    if (uVar6 == 0xf) break;\n    for (; uVar5 < uVar6; uVar5 = uVar5 + 8) {\n      if (inptr < insize) {\n        uVar9 = (ulong)(byte)inbuf[inptr];\n        inptr = inptr + 1;\n      }\n      else {\n        outcnt = w;\n        uVar3 = fill_inbuf(0);\n        uVar9 = (ulong)(uVar3 & 0xff);\n      }\n      uVar8 = uVar8 | uVar9 << ((byte)uVar5 & 0x3f);\n    }\n    n = ((uint)mask_bits[uVar6] & (uint)uVar8) + (uint)(ushort)t->v;\n    uVar9 = uVar8 >> ((byte)uVar6 & 0x3f);\n    for (uVar5 = uVar5 - uVar6; uVar5 < (uint)bd; uVar5 = uVar5 + 8) {\n      if (inptr < insize) {\n        uVar4 = (ulong)(byte)inbuf[inptr];\n        inptr = inptr + 1;\n      }\n      else {\n        outcnt = w;\n        uVar6 = fill_inbuf(0);\n        uVar4 = (ulong)(uVar6 & 0xff);\n      }\n      uVar9 = uVar9 | uVar4 << ((byte)uVar5 & 0x3f);\n    }\n    t = td + ((uint)uVar9 & (uint)uVar2);\n    uVar6 = (uint)t->e;\n    if (0x10 < t->e) {\n      do {\n        if (uVar6 == 99) {\n          return 1;\n        }\n        uVar9 = uVar9 >> (t->b & 0x3f);\n        for (uVar5 = uVar5 - t->b; uVar5 < uVar6 - 0x10; uVar5 = uVar5 + 8) {\n          if (inptr < insize) {\n            uVar4 = (ulong)(byte)inbuf[inptr];\n            inptr = inptr + 1;\n          }\n          else {\n            outcnt = w;\n            uVar3 = fill_inbuf(0);\n            uVar4 = (ulong)(uVar3 & 0xff);\n          }\n          uVar9 = uVar9 | uVar4 << ((byte)uVar5 & 0x3f);\n        }\n        t = (huft *)((ulong)((uint)mask_bits[uVar6 - 0x10] & (uint)uVar9) * 0x10 + *(long *)&t->v);\n        uVar6 = (uint)t->e;\n      } while (0x10 < uVar6);\n    }\n    uVar9 = uVar9 >> (t->b & 0x3f);\n    for (uVar5 = uVar5 - t->b; uVar5 < uVar6; uVar5 = uVar5 + 8) {\n      if (inptr < insize) {\n        uVar4 = (ulong)(byte)inbuf[inptr];\n        inptr = inptr + 1;\n      }\n      else {\n        outcnt = w;\n        uVar3 = fill_inbuf(0);\n        uVar4 = (ulong)(uVar3 & 0xff);\n      }\n      uVar9 = uVar9 | uVar4 << ((byte)uVar5 & 0x3f);\n    }\n    d = (w - (ushort)t->v) - ((uint)mask_bits[uVar6] & (uint)uVar9);\n    uVar8 = uVar9 >> ((byte)uVar6 & 0x3f);\n    uVar5 = uVar5 - uVar6;\n    do {\n      d = d & 0x7fff;\n      uVar6 = w;\n      if (w < d) {\n        uVar6 = d;\n      }\n      uVar6 = 0x8000 - uVar6;\n      if (n < uVar6) {\n        uVar6 = n;\n      }\n      uVar9 = (ulong)uVar6;\n      n = n - uVar6;\n      if (d < w) {\n        uVar3 = w - d;\n      }\n      else {\n        uVar3 = d - w;\n      }\n      if (uVar3 < uVar6) {\n        do {\n          uVar6 = d + 1;\n          uVar3 = w + 1;\n          window[w] = window[d];\n          uVar7 = (int)uVar9 - 1;\n          uVar9 = (ulong)uVar7;\n          d = uVar6;\n          w = uVar3;\n        } while (uVar7 != 0);\n      }\n      else {\n        memcpy(window + w,window + d,uVar9);\n        d = d + uVar6;\n        w = w + uVar6;\n      }\n      if (w == 0x8000) {\n        outcnt = w;\n        flush_window();\n        w = 0;\n      }\n    } while (n != 0);\n  }\n  bb = uVar8;\n  bk = uVar5;\n  outcnt = w;\n  return 0;\n}\n\n",
        "output": "The predicted function name is inflate_codes"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *iname,stat *sbuf)\n\n{\n  int iVar1;\n  size_t sVar2;\n  int *piVar3;\n  char *pcVar4;\n  size_t sVar5;\n  int z_suffix_errno;\n  int open_flags;\n  int fd;\n  int ilen;\n  char **suf;\n  char *s;\n  char *s0;\n  \n  z_suffix_errno = 0;\n  suf = open_input_file::suffixes;\n  open_input_file::suffixes[0] = z_suffix;\n  sVar2 = strlen(iname);\n  if (sVar2 < 0x3ff) {\n    strcpy(ifname,iname);\n    iVar1 = open_and_stat(ifname,0x900,sbuf);\n    if (iVar1 < 0) {\n      if ((decompress == 0) || (piVar3 = __errno_location(), *piVar3 != 2)) {\n        progerror(ifname);\n        iVar1 = -1;\n      }\n      else {\n        pcVar4 = get_suffix(ifname);\n        if (pcVar4 == (char *)0x0) {\n          sVar2 = strlen(ifname);\n          iVar1 = strcmp(z_suffix,\".gz\");\n          if (iVar1 == 0) {\n            suf = open_input_file::suffixes + 1;\n          }\n          do {\n            pcVar4 = *suf;\n            strcpy(ifname,iname);\n            sVar5 = strlen(pcVar4);\n            if (0x3ff < sVar5 + (long)(int)sVar2) goto name_too_long;\n            strcat(ifname,pcVar4);\n            iVar1 = open_and_stat(ifname,0x900,sbuf);\n            if (-1 < iVar1) {\n              return iVar1;\n            }\n            piVar3 = __errno_location();\n            if (*piVar3 != 2) {\n              progerror(ifname);\n              return -1;\n            }\n            iVar1 = strcmp(pcVar4,z_suffix);\n            if (iVar1 == 0) {\n              piVar3 = __errno_location();\n              z_suffix_errno = *piVar3;\n            }\n            suf = suf + 1;\n          } while (*suf != (char *)0x0);\n          strcpy(ifname,iname);\n          strcat(ifname,z_suffix);\n          piVar3 = __errno_location();\n          *piVar3 = z_suffix_errno;\n          progerror(ifname);\n          iVar1 = -1;\n        }\n        else {\n          progerror(ifname);\n          iVar1 = -1;\n        }\n      }\n    }\n  }\n  else {\nname_too_long:\n    fprintf(stderr,\"%s: %s: file name too long\\n\",program_name,iname);\n    exit_code = 1;\n    iVar1 = -1;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is open_input_file"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\noff_t [MASK](char *buf,ulg stored_len,int pad,int eof)\n\n{\n  int iVar1;\n  ulong uVar2;\n  int max_blindex;\n  ulg opt_lenb;\n  ulg static_lenb;\n  \n  flag_buf[last_flags] = flags;\n  if (*file_type == 0xffff) {\n    set_file_type();\n  }\n  build_tree(&l_desc);\n  build_tree(&d_desc);\n  iVar1 = build_bl_tree();\n  opt_lenb = opt_len + 10 >> 3;\n  uVar2 = static_len + 10 >> 3;\n  input_len = stored_len + input_len;\n  if (uVar2 <= opt_lenb) {\n    opt_lenb = uVar2;\n  }\n  if ((opt_lenb < stored_len + 4) || (buf == (char *)0x0)) {\n    if (uVar2 == opt_lenb) {\n      send_bits(eof + 2,3);\n      compress_block(static_ltree,static_dtree);\n      compressed_len = static_len + compressed_len + 3;\n    }\n    else {\n      send_bits(eof + 4,3);\n      send_all_trees(l_desc.max_code + 1,d_desc.max_code + 1,iVar1 + 1);\n      compress_block(dyn_ltree,dyn_dtree);\n      compressed_len = opt_len + compressed_len + 3;\n    }\n  }\n  else {\n    send_bits(eof,3);\n    compressed_len = (compressed_len + 10U & 0xfffffffffffffff8) + (stored_len + 4) * 8;\n    copy_block(buf,(uint)stored_len,1);\n  }\n  init_block();\n  if (eof == 0) {\n    if ((pad != 0) && ((compressed_len & 7U) != 0)) {\n      send_bits(0,3);\n      compressed_len = compressed_len + 10U & 0xfffffffffffffff8;\n      copy_block(buf,0,1);\n    }\n  }\n  else {\n    bi_windup();\n    compressed_len = compressed_len + 7;\n  }\n  return compressed_len >> 3;\n}\n\n",
        "output": "The predicted function name is flush_block"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  bytes_in = 0;\n  inptr = 0;\n  bytes_out = 0;\n  outcnt = 0;\n  insize = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is clear_bufs"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *filename)\n\n{\n  int iVar1;\n  int r;\n  \n  iVar1 = unlink(filename);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is xunlink"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int in,int out)\n\n{\n  uint uVar1;\n  int *piVar2;\n  int got;\n  \n  piVar2 = __errno_location();\n  *piVar2 = 0;\n  while( true ) {\n    if (insize <= inptr) {\n      return 0;\n    }\n    write_buf(out,inbuf + inptr,insize - inptr);\n    uVar1 = read_buffer(in,inbuf,0x40000);\n    if (uVar1 == 0xffffffff) break;\n    bytes_in = bytes_in + (int)uVar1;\n    inptr = 0;\n    insize = uVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  read_error();\n}\n\n",
        "output": "The predicted function name is copy"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](huft *t)\n\n{\n  huft *p;\n  \n  while (t != (huft *)0x0) {\n    p = t + -1;\n    t = *(huft **)&t[-1].v;\n    rpl_free(p);\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is huft_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](stat *ifstat)\n\n{\n  uint uVar1;\n  long lVar2;\n  bool bVar3;\n  int iVar4;\n  int *piVar5;\n  long in_FS_OFFSET;\n  _Bool restoring;\n  mode_t mode;\n  int e;\n  int r;\n  int e_1;\n  timespec timespec [2];\n  \n  lVar2 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar1 = ifstat->st_mode;\n  timespec[0] = get_stat_atime(ifstat);\n  timespec[1] = get_stat_mtime(ifstat);\n  if (((decompress == 0) || (time_stamp.tv_nsec < 0)) ||\n     (timespec[1] == (timespec)CONCAT88(time_stamp.tv_nsec,time_stamp.tv_sec))) {\n    bVar3 = false;\n  }\n  else {\n    bVar3 = true;\n  }\n  if (bVar3) {\n    timespec[1] = (timespec)CONCAT88(time_stamp.tv_nsec,time_stamp.tv_sec);\n  }\n  iVar4 = fdutimens(ofd,ofname,timespec);\n  if (iVar4 == 0) {\n    if ((bVar3) && (1 < verbose)) {\n      fprintf(stderr,\"%s: timestamp restored\\n\",ofname);\n    }\n  }\n  else {\n    piVar5 = __errno_location();\n    iVar4 = *piVar5;\n    if (quiet == 0) {\n      fprintf(stderr,\"%s: \",program_name);\n    }\n    if (exit_code == 0) {\n      exit_code = 2;\n    }\n    if (quiet == 0) {\n      piVar5 = __errno_location();\n      *piVar5 = iVar4;\n      perror(ofname);\n    }\n  }\n  do_chown(ofd,ofname,0xffffffff,ifstat->st_gid);\n  iVar4 = fchmod(ofd,uVar1 & 0x1ff);\n  if (iVar4 != 0) {\n    piVar5 = __errno_location();\n    iVar4 = *piVar5;\n    if (quiet == 0) {\n      fprintf(stderr,\"%s: \",program_name);\n    }\n    if (exit_code == 0) {\n      exit_code = 2;\n    }\n    if (quiet == 0) {\n      piVar5 = __errno_location();\n      *piVar5 = iVar4;\n      perror(ofname);\n    }\n  }\n  do_chown(ofd,ofname,ifstat->st_uid,0xffffffff);\n  if (lVar2 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is copy_stat"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](idx_t s)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(s);\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is imalloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  char **p;\n  \n  p = help::help_msg;\n  printf(\"Usage: %s [OPTION]... [FILE]...\\n\",program_name);\n  while (*p != (char *)0x0) {\n    puts(*p);\n    p = p + 1;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is help"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Removing unreachable block (ram,0x0000f124) */\n/* WARNING: Heritage AFTER dead removal. Example location: s0xffffffffffffff58 : 0x0000f136 */\n/* WARNING: Restarted to delay deadcode elimination for space: stack */\n\nint [MASK](char *file,int flags,...)\n\n{\n  long lVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  mode_t mode;\n  va_list ap;\n  mode_t local_a8;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  mode = 0;\n  if ((flags & 0x40U) != 0) {\n    mode = local_a8;\n  }\n  iVar2 = open(file,flags,(ulong)mode);\n  iVar2 = fd_safer(iVar2);\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is open_safer"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *string)\n\n{\n  int iVar1;\n  int *piVar2;\n  int e;\n  \n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  fprintf(stderr,\"%s: \",program_name);\n  piVar2 = __errno_location();\n  *piVar2 = iVar1;\n  perror(string);\n  exit_code = 1;\n  return;\n}\n\n",
        "output": "The predicted function name is progerror"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int fd)\n\n{\n  int iVar1;\n  int *piVar2;\n  int local_1c;\n  int f;\n  int e;\n  \n  local_1c = fd;\n  if ((-1 < fd) && (fd < 3)) {\n    local_1c = dup_safer(fd);\n    piVar2 = __errno_location();\n    iVar1 = *piVar2;\n    close(fd);\n    piVar2 = __errno_location();\n    *piVar2 = iVar1;\n  }\n  return local_1c;\n}\n\n",
        "output": "The predicted function name is fd_safer"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int pack_level)\n\n{\n  ulong uVar1;\n  \n  if ((0 < pack_level) && (pack_level < 10)) {\n    memset(prev + 0x10000,0,0x10000);\n    rsync_chunk_end = 0xffffffff;\n    rsync_sum = 0;\n    max_lazy_match = (uint)configuration_table[pack_level].max_lazy;\n    good_match = (uint)configuration_table[pack_level].good_length;\n    nice_match = (int)configuration_table[pack_level].nice_length;\n    max_chain_length = (uint)configuration_table[pack_level].max_chain;\n    strstart = 0;\n    block_start = 0;\n    lookahead = (*read_buf)(window,0x10000);\n    if ((lookahead == 0) || (lookahead == 0xffffffff)) {\n      eofile = 1;\n      lookahead = 0;\n    }\n    else {\n      eofile = 0;\n      while ((lookahead < 0x106 && (eofile == 0))) {\n        fill_window();\n      }\n      ins_h = 0;\n      for (uVar1 = 0; (uint)uVar1 < 2; uVar1 = (ulong)((uint)uVar1 + 1)) {\n        ins_h = ((uint)(byte)window[uVar1] ^ ins_h << 5) & 0x7fff;\n      }\n    }\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  gzip_error(\"bad pack level\");\n}\n\n",
        "output": "The predicted function name is lm_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  remove_output_file(false);\n                    /* WARNING: Subroutine does not return */\n  do_exit(1);\n}\n\n",
        "output": "The predicted function name is abort_gzip"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](void *p,idx_t s)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = ximalloc(s);\n  pvVar1 = memcpy(pvVar1,p,s);\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is ximemdup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nuchar [MASK](void)\n\n{\n  uint uVar1;\n  int b;\n  \n  if (inptr < insize) {\n    uVar1 = (uint)(byte)inbuf[inptr];\n    inptr = inptr + 1;\n  }\n  else {\n    uVar1 = fill_inbuf(0);\n  }\n  if ((int)uVar1 < 0) {\n                    /* WARNING: Subroutine does not return */\n    gzip_error(\"invalid compressed data -- unexpected end of file\");\n  }\n  return (uchar)uVar1;\n}\n\n",
        "output": "The predicted function name is read_byte"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nuint [MASK](uint count,uch *buffer)\n\n{\n  uint uVar1;\n  uint r;\n  uint c;\n  \n  r = 0;\n  do {\n    j = j + -1;\n    if (j < 0) {\n      do {\n        while( true ) {\n          uVar1 = decode_c();\n          if (uVar1 == 0x1fe) {\n            done = 1;\n            return r;\n          }\n          if (uVar1 < 0x100) break;\n          j = uVar1 - 0xfd;\n          uVar1 = decode_p();\n          decode::i = (r - uVar1) - 1 & 0x1fff;\n          while (j = j + -1, -1 < j) {\n            buffer[r] = buffer[decode::i];\n            decode::i = decode::i + 1 & 0x1fff;\n            r = r + 1;\n            if (r == count) {\n              return r;\n            }\n          }\n        }\n        buffer[r] = (uch)uVar1;\n        r = r + 1;\n      } while (r != count);\n      return r;\n    }\n    buffer[r] = buffer[decode::i];\n    decode::i = decode::i + 1 & 0x1fff;\n    r = r + 1;\n  } while (r != count);\n  return r;\n}\n\n",
        "output": "The predicted function name is decode"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  undefined uVar1;\n  ulong uVar2;\n  \n  uVar1 = (undefined)bi_buf;\n  if (bi_valid < 9) {\n    if (0 < bi_valid) {\n      uVar2 = (ulong)outcnt;\n      outcnt = outcnt + 1;\n      outbuf[uVar2] = uVar1;\n      if (outcnt == 0x40000) {\n        flush_outbuf();\n      }\n    }\n  }\n  else if (outcnt < 0x3fffe) {\n    uVar2 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar2] = uVar1;\n    uVar2 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar2] = (char)((uint)bi_buf >> 8);\n  }\n  else {\n    uVar2 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar2] = uVar1;\n    if (outcnt == 0x40000) {\n      flush_outbuf();\n    }\n    uVar2 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    outbuf[uVar2] = (char)((uint)bi_buf >> 8);\n    if (outcnt == 0x40000) {\n      flush_outbuf();\n    }\n  }\n  bi_buf = 0;\n  bi_valid = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is bi_windup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  uint uVar1;\n  int iVar2;\n  ulong uVar3;\n  uint uVar4;\n  ulg uVar5;\n  ulong uVar6;\n  long in_FS_OFFSET;\n  bool bVar7;\n  int bl;\n  int bd;\n  int i;\n  uint j;\n  uint l;\n  uint w;\n  uint nl;\n  uint nd;\n  uint nb;\n  uint n;\n  uint m;\n  int err;\n  huft *tl;\n  huft *td;\n  uint ll [316];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  w = outcnt;\n  uVar5 = bb;\n  for (uVar4 = bk; uVar4 < 5; uVar4 = uVar4 + 8) {\n    if (inptr < insize) {\n      uVar6 = (ulong)(byte)inbuf[inptr];\n      inptr = inptr + 1;\n    }\n    else {\n      outcnt = w;\n      uVar1 = fill_inbuf(0);\n      uVar6 = (ulong)(uVar1 & 0xff);\n    }\n    uVar5 = uVar5 | uVar6 << ((byte)uVar4 & 0x3f);\n  }\n  nl = ((uint)uVar5 & 0x1f) + 0x101;\n  uVar6 = uVar5 >> 5;\n  for (uVar4 = uVar4 - 5; uVar4 < 5; uVar4 = uVar4 + 8) {\n    if (inptr < insize) {\n      uVar3 = (ulong)(byte)inbuf[inptr];\n      inptr = inptr + 1;\n    }\n    else {\n      outcnt = w;\n      uVar1 = fill_inbuf(0);\n      uVar3 = (ulong)(uVar1 & 0xff);\n    }\n    uVar6 = uVar6 | uVar3 << ((byte)uVar4 & 0x3f);\n  }\n  nd = ((uint)uVar6 & 0x1f) + 1;\n  uVar6 = uVar6 >> 5;\n  for (uVar4 = uVar4 - 5; uVar4 < 4; uVar4 = uVar4 + 8) {\n    if (inptr < insize) {\n      uVar3 = (ulong)(byte)inbuf[inptr];\n      inptr = inptr + 1;\n    }\n    else {\n      outcnt = w;\n      uVar1 = fill_inbuf(0);\n      uVar3 = (ulong)(uVar1 & 0xff);\n    }\n    uVar6 = uVar6 | uVar3 << ((byte)uVar4 & 0x3f);\n  }\n  nb = ((uint)uVar6 & 0xf) + 4;\n  uVar6 = uVar6 >> 4;\n  uVar4 = uVar4 - 4;\n  if ((nl < 0x11f) && (nd < 0x1f)) {\n    for (j = 0; j < nb; j = j + 1) {\n      for (; uVar4 < 3; uVar4 = uVar4 + 8) {\n        if (inptr < insize) {\n          uVar3 = (ulong)(byte)inbuf[inptr];\n          inptr = inptr + 1;\n        }\n        else {\n          outcnt = w;\n          uVar1 = fill_inbuf(0);\n          uVar3 = (ulong)(uVar1 & 0xff);\n        }\n        uVar6 = uVar6 | uVar3 << ((byte)uVar4 & 0x3f);\n      }\n      ll[border[j]] = (uint)uVar6 & 7;\n      uVar6 = uVar6 >> 3;\n      uVar4 = uVar4 - 3;\n    }\n    for (; j < 0x13; j = j + 1) {\n      ll[border[j]] = 0;\n    }\n    bl = 7;\n    i = huft_build(ll,0x13,0x13,(ush *)0x0,(ush *)0x0,&tl,&bl);\n    if (i == 0) {\n      if (tl == (huft *)0x0) {\n        iVar2 = 2;\n      }\n      else {\n        n = nd + nl;\n        m = (uint)mask_bits[bl];\n        l = 0;\n        i = 0;\n        while ((uint)i < n) {\n          for (; uVar4 < (uint)bl; uVar4 = uVar4 + 8) {\n            if (inptr < insize) {\n              uVar3 = (ulong)(byte)inbuf[inptr];\n              inptr = inptr + 1;\n            }\n            else {\n              outcnt = w;\n              uVar1 = fill_inbuf(0);\n              uVar3 = (ulong)(uVar1 & 0xff);\n            }\n            uVar6 = uVar6 | uVar3 << ((byte)uVar4 & 0x3f);\n          }\n          td = tl + ((uint)uVar6 & m);\n          j = (uint)td->b;\n          uVar6 = uVar6 >> (td->b & 0x3f);\n          uVar4 = uVar4 - j;\n          if (td->e == 'c') {\n            huft_free(tl);\n            iVar2 = 2;\n            goto LAB_0000939b;\n          }\n          j = (uint)(ushort)td->v;\n          if (j < 0x10) {\n            ll[i] = j;\n            i = i + 1;\n            l = j;\n          }\n          else if (j == 0x10) {\n            for (; uVar4 < 2; uVar4 = uVar4 + 8) {\n              if (inptr < insize) {\n                uVar3 = (ulong)(byte)inbuf[inptr];\n                inptr = inptr + 1;\n              }\n              else {\n                outcnt = w;\n                uVar1 = fill_inbuf(0);\n                uVar3 = (ulong)(uVar1 & 0xff);\n              }\n              uVar6 = uVar6 | uVar3 << ((byte)uVar4 & 0x3f);\n            }\n            j = ((uint)uVar6 & 3) + 3;\n            uVar6 = uVar6 >> 2;\n            uVar4 = uVar4 - 2;\n            if (n < j + i) {\n              iVar2 = 1;\n              goto LAB_0000939b;\n            }\n            while (uVar1 = j - 1, bVar7 = j != 0, j = uVar1, bVar7) {\n              ll[i] = l;\n              i = i + 1;\n            }\n          }\n          else if (j == 0x11) {\n            for (; uVar4 < 3; uVar4 = uVar4 + 8) {\n              if (inptr < insize) {\n                uVar3 = (ulong)(byte)inbuf[inptr];\n                inptr = inptr + 1;\n              }\n              else {\n                outcnt = w;\n                uVar1 = fill_inbuf(0);\n                uVar3 = (ulong)(uVar1 & 0xff);\n              }\n              uVar6 = uVar6 | uVar3 << ((byte)uVar4 & 0x3f);\n            }\n            j = ((uint)uVar6 & 7) + 3;\n            uVar6 = uVar6 >> 3;\n            uVar4 = uVar4 - 3;\n            if (n < j + i) {\n              iVar2 = 1;\n              goto LAB_0000939b;\n            }\n            while (j != 0) {\n              ll[i] = 0;\n              i = i + 1;\n              j = j - 1;\n            }\n            l = 0;\n            j = j - 1;\n          }\n          else {\n            for (; uVar4 < 7; uVar4 = uVar4 + 8) {\n              if (inptr < insize) {\n                uVar3 = (ulong)(byte)inbuf[inptr];\n                inptr = inptr + 1;\n              }\n              else {\n                outcnt = w;\n                uVar1 = fill_inbuf(0);\n                uVar3 = (ulong)(uVar1 & 0xff);\n              }\n              uVar6 = uVar6 | uVar3 << ((byte)uVar4 & 0x3f);\n            }\n            j = ((uint)uVar6 & 0x7f) + 0xb;\n            uVar6 = uVar6 >> 7;\n            uVar4 = uVar4 - 7;\n            if (n < j + i) {\n              iVar2 = 1;\n              goto LAB_0000939b;\n            }\n            while (j != 0) {\n              ll[i] = 0;\n              i = i + 1;\n              j = j - 1;\n            }\n            l = 0;\n            j = j - 1;\n          }\n        }\n        huft_free(tl);\n        bl = lbits;\n        bb = uVar6;\n        bk = uVar4;\n        i = huft_build(ll,nl,0x101,cplens,cplext,&tl,&bl);\n        if (i == 0) {\n          bd = dbits;\n          i = huft_build(ll + nl,nd,0,cpdist,cpdext,&td,&bd);\n          if (i == 0) {\n            iVar2 = inflate_codes(tl,td,bl,bd);\n            err = (int)(iVar2 != 0);\n            huft_free(tl);\n            huft_free(td);\n            iVar2 = err;\n          }\n          else {\n            if (i == 1) {\n              huft_free(td);\n            }\n            huft_free(tl);\n            iVar2 = i;\n          }\n        }\n        else {\n          iVar2 = i;\n          if (i == 1) {\n            huft_free(tl);\n            iVar2 = i;\n          }\n        }\n      }\n    }\n    else {\n      iVar2 = i;\n      if (i == 1) {\n        huft_free(tl);\n        iVar2 = i;\n      }\n    }\n  }\n  else {\n    iVar2 = 1;\n  }\nLAB_0000939b:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is inflate_dynamic"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *dir,ptrdiff_t dirlen)\n\n{\n  _Bool _Var1;\n  size_t local_18;\n  char *local_10;\n  \n  _Var1 = atdir_eq(dir,dirlen);\n  if (_Var1 != true) {\n    if (-1 < dfd) {\n      close(dfd);\n    }\n    local_18 = dirlen;\n    local_10 = dir;\n    if (dirlen == 0) {\n      local_10 = \".-\";\n      local_18 = 1;\n    }\n    memcpy(dfname,local_10,local_18);\n    dfname[local_18] = '\\0';\n    dfd = open_safer(dfname,0x10000);\n  }\n  return dfd;\n}\n\n",
        "output": "The predicted function name is atdir_set"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int result,stat *st)\n\n{\n  return result;\n}\n\n",
        "output": "The predicted function name is stat_time_normalize"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](void *p,idx_t s)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = realloc(p,(ulong)(s == 0) | s);\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is irealloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](void *pa,idx_t *pn,idx_t n_incr_min,ptrdiff_t n_max,idx_t s)\n\n{\n  long lVar1;\n  long lVar2;\n  long lVar3;\n  void *pvVar4;\n  long in_FS_OFFSET;\n  idx_t n;\n  idx_t nbytes;\n  idx_t n0;\n  idx_t adjusted_nbytes;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar2 = *pn;\n  n = lVar2 + (lVar2 >> 1);\n  if (SCARRY8(lVar2,lVar2 >> 1)) {\n    n = 0x7fffffffffffffff;\n  }\n  if ((-1 < n_max) && (n_max < n)) {\n    n = n_max;\n  }\n  nbytes = n * s;\n  if (SEXT816(nbytes) == SEXT816(n) * SEXT816(s)) {\n    if (nbytes < 0x80) {\n      lVar3 = 0x80;\n    }\n    else {\n      lVar3 = 0;\n    }\n  }\n  else {\n    lVar3 = 0x7fffffffffffffff;\n  }\n  if (lVar3 != 0) {\n    n = lVar3 / s;\n    nbytes = lVar3 - lVar3 % s;\n  }\n  if (pa == (void *)0x0) {\n    *pn = 0;\n  }\n  if ((n - lVar2 < n_incr_min) &&\n     ((n = n_incr_min + lVar2, SCARRY8(n_incr_min,lVar2) ||\n      (((-1 < n_max && (n_max < n)) || (nbytes = n * s, SEXT816(nbytes) != SEXT816(n) * SEXT816(s)))\n      )))) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  pvVar4 = xrealloc(pa,nbytes);\n  *pn = n;\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return pvVar4;\n}\n\n",
        "output": "The predicted function name is xpalloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  char **p;\n  \n  p = license_msg;\n  printf(\"%s %s\\n\",program_name,Version);\n  while (*p != (char *)0x0) {\n    puts(*p);\n    p = p + 1;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is license"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  short sVar1;\n  int iVar2;\n  ulong uVar3;\n  uint more;\n  \n  more = ((int)window_size - lookahead) - strstart;\n  if (more == 0xffffffff) {\n    more = 0xfffffffe;\n  }\n  else if (0xfef9 < strstart) {\n    memcpy(window,window + 0x8000,0x8000);\n    match_start = match_start - 0x8000;\n    strstart = strstart - 0x8000;\n    if (rsync_chunk_end != 0xffffffff) {\n      rsync_chunk_end = rsync_chunk_end - 0x8000;\n    }\n    block_start = block_start + -0x8000;\n    for (uVar3 = 0; (uint)uVar3 < 0x8000; uVar3 = (ulong)((uint)uVar3 + 1)) {\n      if (*(ushort *)(prev + (uVar3 + 0x8000) * 2) < 0x8000) {\n        sVar1 = 0;\n      }\n      else {\n        sVar1 = *(ushort *)(prev + (uVar3 + 0x8000) * 2) + 0x8000;\n      }\n      *(short *)(prev + (uVar3 + 0x8000) * 2) = sVar1;\n    }\n    for (uVar3 = 0; (uint)uVar3 < 0x8000; uVar3 = (ulong)((uint)uVar3 + 1)) {\n      if (*(ushort *)(prev + uVar3 * 2) < 0x8000) {\n        sVar1 = 0;\n      }\n      else {\n        sVar1 = *(ushort *)(prev + uVar3 * 2) + 0x8000;\n      }\n      *(short *)(prev + uVar3 * 2) = sVar1;\n    }\n    more = more + 0x8000;\n  }\n  if (eofile == 0) {\n    iVar2 = (*read_buf)(window + (ulong)strstart + (ulong)lookahead,more);\n    if ((iVar2 == 0) || (iVar2 == -1)) {\n      eofile = 1;\n      memset(window + (ulong)strstart + (ulong)lookahead,0,2);\n    }\n    else {\n      lookahead = lookahead + iVar2;\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is fill_window"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int fd,char *name,uid_t uid,gid_t gid)\n\n{\n  int __x;\n  \n  fchown(fd,uid,gid);\n  return;\n}\n\n",
        "output": "The predicted function name is do_chown"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int in,int out)\n\n{\n  uint cnt;\n  uint n;\n  \n  ofd = out;\n  ifd = in;\n  decode_start();\n  while (done == 0) {\n    cnt = decode(0x2000,window);\n    if (cnt != 0) {\n      write_buf(out,window,cnt);\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is unlzh"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](timespec *timespec)\n\n{\n  int iVar1;\n  int *piVar2;\n  int result;\n  int utime_omit_count;\n  \n  result = 0;\n  utime_omit_count = 0;\n  if ((((timespec->tv_nsec == 0x3fffffff) || (timespec->tv_nsec == 0x3ffffffe)) ||\n      ((-1 < timespec->tv_nsec && (timespec->tv_nsec < 1000000000)))) &&\n     (((timespec[1].tv_nsec == 0x3fffffff || (timespec[1].tv_nsec == 0x3ffffffe)) ||\n      ((-1 < timespec[1].tv_nsec && (timespec[1].tv_nsec < 1000000000)))))) {\n    if ((timespec->tv_nsec == 0x3fffffff) || (timespec->tv_nsec == 0x3ffffffe)) {\n      timespec->tv_sec = 0;\n      result = 1;\n      if (timespec->tv_nsec == 0x3ffffffe) {\n        utime_omit_count = 1;\n      }\n    }\n    if ((timespec[1].tv_nsec == 0x3fffffff) || (timespec[1].tv_nsec == 0x3ffffffe)) {\n      timespec[1].tv_sec = 0;\n      result = 1;\n      if (timespec[1].tv_nsec == 0x3ffffffe) {\n        utime_omit_count = utime_omit_count + 1;\n      }\n    }\n    iVar1 = result + (uint)(utime_omit_count == 1);\n  }\n  else {\n    piVar2 = __errno_location();\n    *piVar2 = 0x16;\n    iVar1 = -1;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is validate_timespec"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](void)\n\n{\n  int *piVar1;\n  \n  piVar1 = __errno_location();\n  *piVar1 = 0xc;\n  return (void *)0x0;\n}\n\n",
        "output": "The predicted function name is _gl_alloc_nomem"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  int iVar1;\n  int *piVar2;\n  int e;\n  \n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  fprintf(stderr,\"\\n%s: \",program_name);\n  if (iVar1 == 0) {\n    fprintf(stderr,\"%s: unexpected end of file\\n\",ifname);\n  }\n  else {\n    piVar2 = __errno_location();\n    *piVar2 = iVar1;\n    perror(ifname);\n  }\n                    /* WARNING: Subroutine does not return */\n  abort_gzip();\n}\n\n",
        "output": "The predicted function name is read_error"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int in,int out)\n\n{\n  byte bVar1;\n  int iVar2;\n  uint uVar3;\n  long lVar4;\n  ulong uVar5;\n  char *m;\n  long lVar6;\n  int finchar;\n  int outpos;\n  uint bitmask;\n  int n_bits;\n  int rsize;\n  int i;\n  int i_1;\n  int o;\n  int e;\n  char_type *stackp;\n  code_int code;\n  code_int oldcode;\n  long posbits;\n  code_int free_ent;\n  code_int maxcode;\n  code_int maxmaxcode;\n  long inbits;\n  char_type *p;\n  code_int incode;\n  \n  if (inptr < insize) {\n    maxbits = (int)(byte)inbuf[inptr];\n    inptr = inptr + 1;\n  }\n  else {\n    maxbits = fill_inbuf(0);\n  }\n  block_mode = maxbits & 0x80;\n  if ((maxbits & 0x60U) != 0) {\n    if (quiet == 0) {\n      fprintf(stderr,\"\\n%s: %s: warning, unknown flags 0x%x\\n\",program_name,ifname,\n              (ulong)(maxbits & 0x60));\n    }\n    if (exit_code == 0) {\n      exit_code = 2;\n    }\n  }\n  maxbits = maxbits & 0x1f;\n  lVar6 = 1 << (sbyte)maxbits;\n  if ((uint)maxbits < 0x11) {\n    rsize = insize;\n    n_bits = 9;\n    maxcode = 0x1ff;\n    bitmask = 0x1ff;\n    oldcode = -1;\n    finchar = 0;\n    outpos = 0;\n    posbits = (long)(inptr << 3);\n    if (block_mode == 0) {\n      free_ent = 0x100;\n    }\n    else {\n      free_ent = 0x101;\n    }\n    memset(prev,0,0x100);\n    for (code = 0xff; -1 < code; code = code + -1) {\n      window[code] = (char)code;\n    }\nresetbuf:\n    do {\n      uVar3 = (uint)(posbits >> 3);\n      if (insize < uVar3) {\n        insize = 0;\n      }\n      else {\n        insize = insize - uVar3;\n      }\n      for (i = 0; i < (int)insize; i = i + 1) {\n        inbuf[i] = inbuf[(int)(uVar3 + i)];\n      }\n      posbits = 0;\n      if (insize < 0x40) {\n        rsize = read_buffer(in,inbuf + insize,0x40000);\n        if (rsize == -1) {\n                    /* WARNING: Subroutine does not return */\n          read_error();\n        }\n        insize = rsize + insize;\n        bytes_in = bytes_in + rsize;\n      }\n      uVar5 = oldcode;\n      if (rsize == 0) {\n        lVar4 = (ulong)insize * 8 - (long)(n_bits + -1);\n      }\n      else {\n        lVar4 = ((ulong)insize - (ulong)(insize % (uint)n_bits)) * 8;\n      }\n      while (oldcode = uVar5, posbits < lVar4) {\n        if (maxcode < free_ent) {\n          posbits = ((long)(n_bits << 3) -\n                    ((long)(n_bits << 3) + posbits + -1) % (long)(n_bits << 3)) + posbits + -1;\n          n_bits = n_bits + 1;\n          maxcode = lVar6;\n          if (n_bits != maxbits) {\n            maxcode = (1 << ((byte)n_bits & 0x3f)) + -1;\n          }\n          bitmask = (1 << ((byte)n_bits & 0x1f)) - 1;\n          goto resetbuf;\n        }\n        uVar5 = (ulong)bitmask &\n                (long)(ulong)*(uint3 *)(inbuf + (posbits >> 3)) >> ((byte)posbits & 7);\n        posbits = posbits + n_bits;\n        if (oldcode == -1) {\n          if (0xff < uVar5) {\n                    /* WARNING: Subroutine does not return */\n            gzip_error(\"corrupt input.\");\n          }\n          finchar = (int)uVar5;\n          outbuf[outpos] = (char)uVar5;\n          outpos = outpos + 1;\n        }\n        else {\n          if ((uVar5 == 0x100) && (block_mode != 0)) {\n            memset(prev,0,0x100);\n            free_ent = 0x100;\n            posbits = ((long)(n_bits << 3) -\n                      ((long)(n_bits << 3) + posbits + -1) % (long)(n_bits << 3)) + posbits + -1;\n            n_bits = 9;\n            maxcode = 0x1ff;\n            bitmask = 0x1ff;\n            goto resetbuf;\n          }\n          stackp = d_buf + 0xfffe;\n          code = uVar5;\n          if (free_ent <= (long)uVar5) {\n            if (free_ent < (long)uVar5) {\n              if (0 < outpos) {\n                write_buf(out,outbuf,outpos);\n              }\n              if (to_stdout == 0) {\n                m = \"corrupt input. Use zcat to recover some data.\";\n              }\n              else {\n                m = \"corrupt input.\";\n              }\n                    /* WARNING: Subroutine does not return */\n              gzip_error(m);\n            }\n            stackp = d_buf + 0xfffd;\n            d_buf[65533] = (undefined)finchar;\n            code = oldcode;\n          }\n          for (; 0xff < (ulong)code; code = (code_int)*(ushort *)(prev + code * 2)) {\n            stackp = stackp + -1;\n            *stackp = window[code];\n          }\n          bVar1 = window[code];\n          finchar = (int)bVar1;\n          stackp = stackp + -1;\n          *stackp = bVar1;\n          i_1 = 0x24b41e - (int)stackp;\n          if (outpos + i_1 < 0x40000) {\n            memcpy(outbuf + outpos,stackp,(long)i_1);\n            outpos = outpos + i_1;\n          }\n          else {\n            do {\n              if (0x40000 - outpos < i_1) {\n                i_1 = 0x40000 - outpos;\n              }\n              if (0 < i_1) {\n                memcpy(outbuf + outpos,stackp,(long)i_1);\n                outpos = outpos + i_1;\n              }\n              if (0x3ffff < outpos) {\n                write_buf(out,outbuf,outpos);\n                outpos = 0;\n              }\n              stackp = stackp + i_1;\n              i_1 = 0x24b41e - (int)stackp;\n            } while (0 < i_1);\n          }\n          if (free_ent < lVar6) {\n            *(short *)(prev + free_ent * 2) = (short)oldcode;\n            window[free_ent] = bVar1;\n            free_ent = free_ent + 1;\n          }\n        }\n      }\n    } while (rsize != 0);\n    if (0 < outpos) {\n      write_buf(out,outbuf,outpos);\n    }\n    iVar2 = 0;\n  }\n  else {\n    fprintf(stderr,\"\\n%s: %s: compressed with %d bits, can only handle %d bits\\n\",program_name,\n            ifname,(ulong)(uint)maxbits,0x10);\n    exit_code = 1;\n    iVar2 = 1;\n  }\n  return iVar2;\n}\n\n",
        "output": "The predicted function name is unlzw"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int fd,char *file,timespec *timespec)\n\n{\n  timespec *ptVar1;\n  bool bVar2;\n  bool bVar3;\n  timespec *ptVar4;\n  _Bool _Var5;\n  int iVar6;\n  int *piVar7;\n  long lVar8;\n  long in_FS_OFFSET;\n  timespec tVar9;\n  _Bool abig;\n  _Bool mbig;\n  int adjustment_needed;\n  int result;\n  timespec *ts;\n  timeval *t;\n  timeval *tt;\n  time_t adiff;\n  time_t mdiff;\n  timespec adjusted_timespec [2];\n  timeval timeval [2];\n  timeval truncated_timeval [2];\n  stat st;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (timespec == (timespec *)0x0) {\n    ts = (timespec *)0x0;\n  }\n  else {\n    ts = adjusted_timespec;\n  }\n  adjustment_needed = 0;\n  if (ts != (timespec *)0x0) {\n    adjusted_timespec[0].tv_nsec = timespec->tv_nsec;\n    adjusted_timespec[0].tv_sec = timespec->tv_sec;\n    adjusted_timespec[1].tv_nsec = timespec[1].tv_nsec;\n    adjusted_timespec[1].tv_sec = timespec[1].tv_sec;\n    adjustment_needed = validate_timespec(ts);\n  }\n  if (adjustment_needed < 0) {\n    iVar6 = -1;\n    goto LAB_00010217;\n  }\n  if ((fd < 0) && (file == (char *)0x0)) {\n    piVar7 = __errno_location();\n    *piVar7 = 9;\n    iVar6 = -1;\n    goto LAB_00010217;\n  }\n  if (-1 < utimensat_works_really) {\n    if (adjustment_needed == 2) {\n      if (fd < 0) {\n        iVar6 = stat(file,(stat *)&st);\n      }\n      else {\n        iVar6 = fstat(fd,(stat *)&st);\n      }\n      ptVar4 = ts;\n      if (iVar6 != 0) {\n        iVar6 = -1;\n        goto LAB_00010217;\n      }\n      if (ts->tv_nsec == 0x3ffffffe) {\n        tVar9 = get_stat_atime(&st);\n        ptVar4->tv_sec = SUB168((undefined  [16])tVar9,0);\n        ptVar4->tv_nsec = SUB168((undefined  [16])tVar9 >> 0x40,0);\n      }\n      else if (ts[1].tv_nsec == 0x3ffffffe) {\n        ptVar1 = ts + 1;\n        tVar9 = get_stat_mtime(&st);\n        ptVar1->tv_sec = SUB168((undefined  [16])tVar9,0);\n        ptVar4[1].tv_nsec = SUB168((undefined  [16])tVar9 >> 0x40,0);\n      }\n      adjustment_needed = 3;\n    }\n    if (fd < 0) {\n      iVar6 = utimensat(-100,file,(timespec *)ts,0);\n      if (0 < iVar6) {\n        piVar7 = __errno_location();\n        *piVar7 = 0x26;\n      }\n      if (iVar6 != 0) {\n        piVar7 = __errno_location();\n        if (*piVar7 == 0x26) goto LAB_0000fe26;\n      }\n      utimensat_works_really = 1;\n      goto LAB_00010217;\n    }\nLAB_0000fe26:\n    if (-1 < fd) {\n      iVar6 = futimens(fd,(timespec *)ts);\n      if (0 < iVar6) {\n        piVar7 = __errno_location();\n        *piVar7 = 0x26;\n      }\n      if (iVar6 != 0) {\n        piVar7 = __errno_location();\n        if (*piVar7 == 0x26) goto LAB_0000fe8a;\n      }\n      utimensat_works_really = 1;\n      goto LAB_00010217;\n    }\n  }\nLAB_0000fe8a:\n  utimensat_works_really = -1;\n  lutimensat_works_really = -1;\n  if (adjustment_needed != 0) {\n    if (adjustment_needed != 3) {\n      if (fd < 0) {\n        iVar6 = stat(file,(stat *)&st);\n      }\n      else {\n        iVar6 = fstat(fd,(stat *)&st);\n      }\n      if (iVar6 != 0) {\n        iVar6 = -1;\n        goto LAB_00010217;\n      }\n    }\n    if (ts != (timespec *)0x0) {\n      _Var5 = update_timespec(&st,&ts);\n      if (_Var5 != false) {\n        iVar6 = 0;\n        goto LAB_00010217;\n      }\n    }\n  }\n  if (ts == (timespec *)0x0) {\n    t = (timeval *)0x0;\n  }\n  else {\n    timeval[0].tv_sec = ts->tv_sec;\n    timeval[0].tv_usec = ts->tv_nsec / 1000;\n    timeval[1].tv_sec = ts[1].tv_sec;\n    timeval[1].tv_usec = ts[1].tv_nsec / 1000;\n    t = timeval;\n  }\n  if (fd < 0) {\n    iVar6 = futimesat(-100,file,(timeval *)t);\n  }\n  else {\n    iVar6 = futimesat(fd,(char *)0x0,(timeval *)t);\n    if (iVar6 == 0) {\n      if (t != (timeval *)0x0) {\n        bVar2 = 499999 < t->tv_usec;\n        bVar3 = 499999 < t[1].tv_usec;\n        if (bVar2 || bVar3) {\n          iVar6 = fstat(fd,(stat *)&st);\n          if (iVar6 == 0) {\n            adiff = st.st_atim.tv_sec - t->tv_sec;\n            mdiff = st.st_mtim.tv_sec - t[1].tv_sec;\n            tt = (timeval *)0x0;\n            truncated_timeval[0].tv_usec = t->tv_usec;\n            truncated_timeval[0].tv_sec = t->tv_sec;\n            truncated_timeval[1].tv_usec = t[1].tv_usec;\n            truncated_timeval[1].tv_sec = t[1].tv_sec;\n            if ((bVar2) && (adiff == 1)) {\n              lVar8 = get_stat_atime_ns(&st);\n              if (lVar8 == 0) {\n                tt = truncated_timeval;\n                truncated_timeval[0].tv_usec = 0;\n              }\n            }\n            if ((bVar3) && (mdiff == 1)) {\n              lVar8 = get_stat_mtime_ns(&st);\n              if (lVar8 == 0) {\n                tt = truncated_timeval;\n                truncated_timeval[1].tv_usec = 0;\n              }\n            }\n            if (tt != (timeval *)0x0) {\n              futimesat(fd,(char *)0x0,(timeval *)tt);\n            }\n          }\n        }\n      }\n      iVar6 = 0;\n    }\n    else if (file == (char *)0x0) {\n      iVar6 = -1;\n    }\n    else {\n      iVar6 = utimes(file,(timeval *)t);\n    }\n  }\nLAB_00010217:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar6;\n}\n\n",
        "output": "The predicted function name is fdutimens"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  long lVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  int bl;\n  int bd;\n  int i;\n  huft *tl;\n  huft *td;\n  uint l [288];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  for (i = 0; i < 0x90; i = i + 1) {\n    l[i] = 8;\n  }\n  for (; i < 0x100; i = i + 1) {\n    l[i] = 9;\n  }\n  for (; i < 0x118; i = i + 1) {\n    l[i] = 7;\n  }\n  for (; i < 0x120; i = i + 1) {\n    l[i] = 8;\n  }\n  bl = 7;\n  iVar2 = huft_build(l,0x120,0x101,cplens,cplext,&tl,&bl);\n  i = iVar2;\n  if (iVar2 == 0) {\n    for (i = 0; i < 0x1e; i = i + 1) {\n      l[i] = 5;\n    }\n    bd = 5;\n    i = huft_build(l,0x1e,0,cpdist,cpdext,&td,&bd);\n    if (i < 2) {\n      iVar2 = inflate_codes(tl,td,bl,bd);\n      if (iVar2 == 0) {\n        huft_free(tl);\n        huft_free(td);\n        iVar2 = 0;\n      }\n      else {\n        iVar2 = 1;\n      }\n    }\n    else {\n      huft_free(tl);\n      iVar2 = i;\n    }\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is inflate_fixed"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\noff_t [MASK](void)\n\n{\n  uint uVar1;\n  char *pcVar2;\n  off_t oVar3;\n  int flush;\n  uint match_length;\n  IPos hash_head;\n  \n  flush = 0;\n  match_length = 0;\n  prev_length = 2;\n  while (lookahead != 0) {\n    ins_h = ((uint)(byte)window[strstart + 2] ^ ins_h << 5) & 0x7fff;\n    uVar1 = (uint)*(ushort *)(prev + ((ulong)ins_h + 0x8000) * 2);\n    *(ushort *)(prev + (ulong)(strstart & 0x7fff) * 2) =\n         *(ushort *)(prev + ((ulong)ins_h + 0x8000) * 2);\n    *(short *)(prev + ((ulong)ins_h + 0x8000) * 2) = (short)strstart;\n    if (((uVar1 != 0) && (strstart - uVar1 < 0x7efb)) && ((ulong)strstart <= window_size - 0x106)) {\n      match_length = longest_match(uVar1);\n      if (lookahead < match_length) {\n        match_length = lookahead;\n      }\n    }\n    if (match_length < 3) {\n      flush = ct_tally(0,(uint)(byte)window[strstart]);\n      if (rsync != 0) {\n        rsync_roll(strstart,1);\n      }\n      lookahead = lookahead - 1;\n      strstart = strstart + 1;\n    }\n    else {\n      flush = ct_tally(strstart - match_start,match_length - 3);\n      lookahead = lookahead - match_length;\n      if (rsync != 0) {\n        rsync_roll(strstart,match_length);\n      }\n      if (max_lazy_match < match_length) {\n        strstart = match_length + strstart;\n        match_length = 0;\n        ins_h = (uint)(byte)window[strstart + 1] ^ (uint)(byte)window[strstart] << 5;\n      }\n      else {\n        match_length = match_length - 1;\n        do {\n          uVar1 = strstart + 1;\n          ins_h = ((uint)(byte)window[strstart + 3] ^ ins_h << 5) & 0x7fff;\n          strstart = uVar1;\n          *(undefined2 *)(prev + (ulong)(uVar1 & 0x7fff) * 2) =\n               *(undefined2 *)(prev + ((ulong)ins_h + 0x8000) * 2);\n          *(short *)(prev + ((ulong)ins_h + 0x8000) * 2) = (short)strstart;\n          match_length = match_length - 1;\n        } while (match_length != 0);\n        strstart = strstart + 1;\n      }\n    }\n    if ((rsync != 0) && (rsync_chunk_end < strstart)) {\n      rsync_chunk_end = 0xffffffff;\n      flush = 2;\n    }\n    if (flush != 0) {\n      if (block_start < 0) {\n        pcVar2 = (char *)0x0;\n      }\n      else {\n        pcVar2 = window + (block_start & 0xffffffff);\n      }\n      flush_block(pcVar2,(ulong)strstart - block_start,flush + -1,0);\n      block_start = (long)strstart;\n    }\n    while ((lookahead < 0x106 && (eofile == 0))) {\n      fill_window();\n    }\n  }\n  if (block_start < 0) {\n    pcVar2 = (char *)0x0;\n  }\n  else {\n    pcVar2 = window + (block_start & 0xffffffff);\n  }\n  oVar3 = flush_block(pcVar2,(ulong)strstart - block_start,flush + -1,1);\n  return oVar3;\n}\n\n",
        "output": "The predicted function name is deflate_fast"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\ntimespec [MASK](stat *st)\n\n{\n  return st->st_mtim;\n}\n\n",
        "output": "The predicted function name is get_stat_mtime"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int in,int out)\n\n{\n  int iVar1;\n  byte bVar2;\n  uint uVar3;\n  uint uVar4;\n  ulong uVar5;\n  int len;\n  uint peek_mask;\n  uint eob;\n  ulg mask;\n  \n  ofd = out;\n  ifd = in;\n  read_tree();\n  build_tree();\n  valid = 0;\n  bitbuf = 0;\n  uVar3 = (1 << ((byte)peek_bits & 0x1f)) - 1;\n  iVar1 = leaves[max_len];\n  while( true ) {\n    for (; valid < peek_bits; valid = valid + 8) {\n      uVar5 = bitbuf << 8;\n      bVar2 = read_byte();\n      bitbuf = bVar2 | uVar5;\n    }\n    uVar4 = (uint)(bitbuf >> ((char)valid - (char)peek_bits & 0x3fU)) & uVar3;\n    len = (int)(byte)outbuf[uVar4];\n    if (len == 0) {\n      mask = (ulg)uVar3;\n      len = peek_bits;\n      while (uVar4 < (uint)parents[len]) {\n        len = len + 1;\n        mask = mask * 2 + 1;\n        for (; valid < len; valid = valid + 8) {\n          uVar5 = bitbuf << 8;\n          bVar2 = read_byte();\n          bitbuf = bVar2 | uVar5;\n        }\n        uVar4 = (uint)(bitbuf >> ((char)valid - (char)len & 0x3fU)) & (uint)mask;\n      }\n    }\n    else {\n      uVar4 = uVar4 >> ((char)peek_bits - outbuf[uVar4] & 0x1fU);\n    }\n    if ((uVar4 == iVar1 - 1U) && (len == max_len)) break;\n    uVar5 = (ulong)outcnt;\n    outcnt = outcnt + 1;\n    window[uVar5] = literal[uVar4 + lit_base[len]];\n    if (outcnt == 0x8000) {\n      flush_window();\n    }\n    valid = valid - len;\n  }\n  flush_window();\n  if ((bytes_out & 0xffffffffU) != orig_len) {\n                    /* WARNING: Subroutine does not return */\n    gzip_error(\"invalid compressed data--length error\");\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is unpack"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](ct_data *tree,int k)\n\n{\n  int iVar1;\n  int local_24;\n  int j;\n  int v;\n  \n  iVar1 = heap[k];\n  local_24 = k;\n  for (j = k * 2; j <= heap_len; j = j << 1) {\n    if ((j < heap_len) &&\n       (((ushort)tree[heap[j + 1]].fc < (ushort)tree[heap[j]].fc ||\n        ((tree[heap[j + 1]].fc == tree[heap[j]].fc && (depth[heap[j + 1]] <= depth[heap[j]])))))) {\n      j = j + 1;\n    }\n    if (((ushort)tree[iVar1].fc < (ushort)tree[heap[j]].fc) ||\n       ((tree[iVar1].fc == tree[heap[j]].fc && (depth[iVar1] <= depth[heap[j]])))) break;\n    heap[local_24] = heap[j];\n    local_24 = j;\n  }\n  heap[local_24] = iVar1;\n  return;\n}\n\n",
        "output": "The predicted function name is pqdownheap"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *name)\n\n{\n  bool bVar1;\n  _Bool last_was_slash;\n  char *base;\n  char *p;\n  \n  bVar1 = false;\n  for (base = name; *base == '/'; base = base + 1) {\n  }\n  for (p = base; *p != '\\0'; p = p + 1) {\n    if (*p == '/') {\n      bVar1 = true;\n    }\n    else if (bVar1) {\n      base = p;\n      bVar1 = false;\n    }\n  }\n  return base;\n}\n\n",
        "output": "The predicted function name is last_component"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  ushort uVar1;\n  uint uVar2;\n  uint uVar3;\n  int i;\n  int c;\n  uint mask;\n  int n;\n  \n  uVar2 = getbits(9);\n  if (uVar2 == 0) {\n    uVar2 = getbits(9);\n    for (i = 0; i < 0x1fe; i = i + 1) {\n      outbuf[i] = 0;\n    }\n    for (i = 0; i < 0x1000; i = i + 1) {\n      *(short *)(d_buf + (long)i * 2) = (short)uVar2;\n    }\n  }\n  else {\n    i = 0;\n    while (i < (int)uVar2) {\n      c = (int)pt_table[(int)(uint)(bitbuf >> 8)];\n      if (0x12 < (uint)c) {\n        mask = 0x80;\n        do {\n          if ((bitbuf & mask) == 0) {\n            uVar1 = *(ushort *)(prev + (long)c * 2);\n          }\n          else {\n            uVar1 = *(ushort *)(prev + ((long)c + 0x8000) * 2);\n          }\n          c = (int)uVar1;\n          mask = mask >> 1;\n        } while (0x12 < (uint)c);\n      }\n      fillbuf((uint)pt_len[c]);\n      if ((uint)c < 3) {\n        if (c == 0) {\n          c = 1;\n        }\n        else if (c == 1) {\n          uVar3 = getbits(4);\n          c = uVar3 + 3;\n        }\n        else {\n          uVar3 = getbits(9);\n          c = uVar3 + 0x14;\n        }\n        while (c = c + -1, -1 < c) {\n          outbuf[i] = 0;\n          i = i + 1;\n        }\n      }\n      else {\n        outbuf[i] = (char)c + -2;\n        i = i + 1;\n      }\n    }\n    while (i < 0x1fe) {\n      outbuf[i] = 0;\n      i = i + 1;\n    }\n    make_table(0x1fe,outbuf,0xc,(ush *)d_buf);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is read_c_len"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](void *p,size_t n,size_t s)\n\n{\n  void *pvVar1;\n  void *r;\n  \n  pvVar1 = (void *)reallocarray(p,n,s);\n  if ((pvVar1 == (void *)0x0) && ((p == (void *)0x0 || ((n != 0 && (s != 0)))))) {\n                    /* WARNING: Subroutine does not return */\n    xalloc_die();\n  }\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is xreallocarray"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int max_blindex;\n  \n  scan_tree(dyn_ltree,l_desc.max_code);\n  scan_tree(dyn_dtree,d_desc.max_code);\n  build_tree(&bl_desc);\n  max_blindex = 0x12;\n  while ((2 < max_blindex && (bl_tree[(int)(uint)bl_order[max_blindex]].dl == 0))) {\n    max_blindex = max_blindex + -1;\n  }\n  opt_len = opt_len + (long)((max_blindex + 1) * 3 + 0xe);\n  return max_blindex;\n}\n\n",
        "output": "The predicted function name is build_bl_tree"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int nchar,uch *bitlen,int tablebits,ush *table)\n\n{\n  byte bVar1;\n  uint uVar2;\n  uint uVar3;\n  long lVar4;\n  byte bVar5;\n  long in_FS_OFFSET;\n  uint i;\n  uint k;\n  uint ch;\n  uint avail;\n  uint jutbits;\n  uint mask;\n  uint len;\n  uint nextcode;\n  ush *p;\n  ush count [17];\n  ush weight [17];\n  ush start [18];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  for (i = 1; i < 0x11; i = i + 1) {\n    count[i] = 0;\n  }\n  for (i = 0; i < (uint)nchar; i = i + 1) {\n    count[(int)(uint)bitlen[i]] = count[(int)(uint)bitlen[i]] + 1;\n  }\n  start[1] = 0;\n  for (i = 1; i < 0x11; i = i + 1) {\n    start[i + 1] = start[i] + (count[i] << (0x10U - (char)i & 0x1f));\n  }\n  if (start[17] != 0) {\n                    /* WARNING: Subroutine does not return */\n    gzip_error(\"Bad table\\n\");\n  }\n  bVar1 = (byte)tablebits;\n  bVar5 = 0x10 - bVar1;\n  for (i = 1; i <= (uint)tablebits; i = i + 1) {\n    start[i] = (ush)((int)(uint)start[i] >> (bVar5 & 0x1f));\n    weight[i] = (ush)(1 << (bVar1 - (char)i & 0x1f));\n  }\n  for (; i < 0x11; i = i + 1) {\n    weight[i] = (ush)(1 << (0x10U - (char)i & 0x1f));\n  }\n  i = (int)(uint)start[tablebits + 1] >> (bVar5 & 0x1f);\n  if (i != 0) {\n    while (i != 1 << (bVar1 & 0x1f)) {\n      table[i] = 0;\n      i = i + 1;\n    }\n  }\n  avail = nchar;\n  for (ch = 0; ch < (uint)nchar; ch = ch + 1) {\n    uVar2 = (uint)bitlen[ch];\n    if (uVar2 != 0) {\n      uVar3 = (uint)weight[uVar2] + (uint)start[uVar2];\n      if ((uint)tablebits < uVar2) {\n        k = (uint)start[uVar2];\n        p = table + (start[uVar2] >> (bVar5 & 0x1f));\n        for (i = uVar2 - tablebits; i != 0; i = i - 1) {\n          if (*p == 0) {\n            *(undefined2 *)(prev + (ulong)avail * 2) = 0;\n            *(undefined2 *)(prev + ((ulong)avail + 0x8000) * 2) =\n                 *(undefined2 *)(prev + (ulong)avail * 2);\n            *p = (ush)avail;\n            avail = avail + 1;\n          }\n          if ((k & 1 << (0xf - bVar1 & 0x1f)) == 0) {\n            lVar4 = (long)(int)(uint)*p;\n          }\n          else {\n            lVar4 = (ulong)*p + 0x8000;\n          }\n          p = (ush *)(prev + lVar4 * 2);\n          k = k << 1;\n        }\n        *p = (ush)ch;\n      }\n      else {\n        if ((uint)(1 << (bVar1 & 0x1f)) < uVar3) {\n                    /* WARNING: Subroutine does not return */\n          gzip_error(\"Bad table\\n\");\n        }\n        for (i = (uint)start[uVar2]; i < uVar3; i = i + 1) {\n          table[i] = (ush)ch;\n        }\n      }\n      start[uVar2] = (ush)uVar3;\n    }\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is make_table"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int nn,int nbit,int i_special)\n\n{\n  uint uVar1;\n  int iVar2;\n  int i;\n  int c;\n  uint mask;\n  int n;\n  \n  uVar1 = getbits(nbit);\n  if (uVar1 == 0) {\n    uVar1 = getbits(nbit);\n    for (i = 0; i < nn; i = i + 1) {\n      pt_len[i] = '\\0';\n    }\n    for (i = 0; i < 0x100; i = i + 1) {\n      pt_table[i] = (ush)uVar1;\n    }\n  }\n  else {\n    i = 0;\n    while (i < (int)uVar1) {\n      c = (int)(bitbuf >> 0xd);\n      if (c == 7) {\n        for (mask = 0x1000; (bitbuf & mask) != 0; mask = mask >> 1) {\n          c = c + 1;\n        }\n        if (0x10 < c) {\n                    /* WARNING: Subroutine does not return */\n          gzip_error(\"Bad table\\n\");\n        }\n      }\n      iVar2 = 6;\n      if (5 < c) {\n        iVar2 = c;\n      }\n      fillbuf(iVar2 + -3);\n      iVar2 = i + 1;\n      pt_len[i] = (uch)c;\n      i = iVar2;\n      if (iVar2 == i_special) {\n        c = getbits(2);\n        while (c = c + -1, -1 < c) {\n          pt_len[i] = '\\0';\n          i = i + 1;\n        }\n      }\n    }\n    while (i < nn) {\n      pt_len[i] = '\\0';\n      i = i + 1;\n    }\n    make_table(nn,pt_len,8,pt_table);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is read_pt_len"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *buf,uint size)\n\n{\n  uint n;\n  uint len;\n  \n  n = read_buffer(ifd,buf,size);\n  if (n != 0) {\n    if (n == 0xffffffff) {\n                    /* WARNING: Subroutine does not return */\n      read_error();\n    }\n    updcrc((uch *)buf,n);\n    bytes_in = bytes_in + (ulong)n;\n  }\n  return n;\n}\n\n",
        "output": "The predicted function name is file_read"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  int e;\n  uint h;\n  int r;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  outcnt = 0;\n  bk = 0;\n  bb = 0;\n  h = 0;\n  do {\n    hufts = 0;\n    iVar1 = inflate_block(&e);\n    r = iVar1;\n    if (iVar1 != 0) goto LAB_000095b1;\n    if (h < hufts) {\n      h = hufts;\n    }\n  } while (e == 0);\n  for (; 7 < bk; bk = bk - 8) {\n    inptr = inptr - 1;\n  }\n  flush_window();\n  iVar1 = 0;\nLAB_000095b1:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is inflate"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](size_t nbytes,uint flags)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  size_t local_20;\n  uch c;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = nbytes;\n  do {\n    while( true ) {\n      if (local_20 == 0) goto code_r0x00005d27;\n      if (inptr < insize) {\n        c = inbuf[inptr];\n        inptr = inptr + 1;\n      }\n      else {\n        iVar1 = fill_inbuf(0);\n        c = (uch)iVar1;\n      }\n      if ((flags & 2) != 0) {\n        updcrc(&c,1);\n      }\n      if (local_20 == 0xffffffffffffffff) break;\n      local_20 = local_20 - 1;\n    }\n  } while (c != '\\0');\ncode_r0x00005d27:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is discard_input_bytes"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  huf_decode_start();\n  j = 0;\n  done = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is decode_start"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK]\n               (int argc,char **argv,char *command_name,char *package,char *version,_Bool scan_all,\n               anon_subr_void_int *usage_func,...)\n\n{\n  long lVar1;\n  undefined4 uVar2;\n  char in_AL;\n  int iVar3;\n  undefined *puVar4;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  int saved_opterr;\n  int c;\n  char *optstring;\n  va_list authors;\n  undefined local_b8 [48];\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  uVar2 = opterr;\n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  opterr = 1;\n  if (scan_all == false) {\n    puVar4 = &DAT_00005ce1;\n  }\n  else {\n    puVar4 = &DAT_00005ce3;\n  }\n  iVar3 = getopt_long(argc,argv,puVar4,long_options,0);\n  if (iVar3 != -1) {\n    if (iVar3 == 0x68) {\n      (*usage_func)(0);\n    }\n    else {\n      if (iVar3 == 0x76) {\n        authors[0].gp_offset = 0x30;\n        authors[0].fp_offset = 0x30;\n        authors[0].overflow_arg_area = &stack0x00000010;\n        authors[0].reg_save_area = local_b8;\n        version_etc_va(stdout,command_name,package,version,authors);\n                    /* WARNING: Subroutine does not return */\n        exit(0);\n      }\n      (*usage_func)(exit_failure);\n    }\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n    opterr = uVar2;\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  opterr = uVar2;\n  return;\n}\n\n",
        "output": "The predicted function name is parse_gnu_standard_options_only"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](STRUCT_UTMP *ut)\n\n{\n  char *__dest;\n  size_t sVar1;\n  char *p;\n  char *trimmed_name;\n  \n  __dest = (char *)xmalloc(0x21);\n  strncpy(__dest,ut->ut_user,0x20);\n  __dest[0x20] = '\\0';\n  sVar1 = strlen(__dest);\n  p = __dest + sVar1;\n  while ((__dest < p && (p[-1] == ' '))) {\n    p = p + -1;\n    *p = '\\0';\n  }\n  return __dest;\n}\n\n",
        "output": "The predicted function name is extract_trimmed_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,size_t *n_entries,STRUCT_UTMP **utmp_buf,int options)\n\n{\n  size_t sVar1;\n  _Bool _Var2;\n  STRUCT_UTMP *pSVar3;\n  long lVar4;\n  ulong uVar5;\n  undefined8 *puVar6;\n  undefined8 *puVar7;\n  long in_FS_OFFSET;\n  byte bVar8;\n  size_t n_alloc;\n  size_t n_read;\n  STRUCT_UTMP *utmp;\n  STRUCT_UTMP *u;\n  long local_10;\n  \n  bVar8 = 0;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  n_read = 0;\n  n_alloc = 0;\n  utmp = (STRUCT_UTMP *)0x0;\n  utmpxname(file);\n  setutxent();\n  while( true ) {\n    u = (STRUCT_UTMP *)getutxent();\n    if ((utmpx *)u == (utmpx *)0x0) break;\n    _Var2 = desirable_utmp_entry(u,options);\n    if (_Var2 != false) {\n      if (n_read == n_alloc) {\n        utmp = (STRUCT_UTMP *)x2nrealloc(utmp,&n_alloc,0x180);\n      }\n      sVar1 = n_read + 1;\n      pSVar3 = utmp + n_read;\n      *(undefined8 *)pSVar3 = *(undefined8 *)u;\n      *(undefined8 *)(pSVar3->__glibc_reserved + 0xc) = *(undefined8 *)(u->__glibc_reserved + 0xc);\n      puVar7 = (undefined8 *)((ulong)pSVar3->ut_line & 0xfffffffffffffff8);\n      lVar4 = (long)pSVar3 - (long)puVar7;\n      puVar6 = (undefined8 *)((long)u - lVar4);\n      for (uVar5 = (ulong)((int)lVar4 + 0x180U >> 3); n_read = sVar1, uVar5 != 0; uVar5 = uVar5 - 1)\n      {\n        *puVar7 = *puVar6;\n        puVar6 = puVar6 + (ulong)bVar8 * -2 + 1;\n        puVar7 = puVar7 + (ulong)bVar8 * -2 + 1;\n      }\n    }\n  }\n  endutxent();\n  *n_entries = n_read;\n  *utmp_buf = utmp;\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is read_utmp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](size_t n,STRUCT_UTMP *this)\n\n{\n  char cVar1;\n  void *__base;\n  char *pcVar2;\n  STRUCT_UTMP *local_48;\n  size_t local_40;\n  char c;\n  size_t i;\n  size_t n_entries;\n  char **u;\n  char *trimmed_name;\n  \n  __base = xnmalloc(n,8);\n  n_entries = 0;\n  local_48 = this;\n  local_40 = n;\n  while (local_40 != 0) {\n    if ((local_48->ut_user[0] != '\\0') && (local_48->ut_type == 7)) {\n      pcVar2 = extract_trimmed_name(local_48);\n      *(char **)(n_entries * 8 + (long)__base) = pcVar2;\n      n_entries = n_entries + 1;\n    }\n    local_48 = local_48 + 1;\n    local_40 = local_40 - 1;\n  }\n  qsort(__base,n_entries,8,userid_compare);\n  for (i = 0; i < n_entries; i = i + 1) {\n    if (i < n_entries - 1) {\n      cVar1 = ' ';\n    }\n    else {\n      cVar1 = '\\n';\n    }\n    fputs_unlocked(*(char **)((long)__base + i * 8),stdout);\n    putchar_unlocked((int)cVar1);\n  }\n  for (i = 0; i < n_entries; i = i + 1) {\n    free(*(void **)((long)__base + i * 8));\n  }\n  free(__base);\n  return;\n}\n\n",
        "output": "The predicted function name is list_entries_users"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *filename,int options)\n\n{\n  int iVar1;\n  char *pcVar2;\n  int *piVar3;\n  long in_FS_OFFSET;\n  size_t n_users;\n  STRUCT_UTMP *utmp_buf;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = read_utmp(filename,&n_users,&utmp_buf,options);\n  if (iVar1 != 0) {\n    pcVar2 = quotearg_n_style_colon(0,shell_escape_quoting_style,filename);\n    piVar3 = __errno_location();\n    error(1,*piVar3,&DAT_00005acb,pcVar2);\n  }\n  list_entries_users(n_users,utmp_buf);\n  free(utmp_buf);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is users"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](STRUCT_UTMP *u,int options)\n\n{\n  bool bVar1;\n  _Bool _Var2;\n  int iVar3;\n  int *piVar4;\n  _Bool user_proc;\n  \n  if ((u->ut_user[0] == '\\0') || (u->ut_type != 7)) {\n    bVar1 = false;\n  }\n  else {\n    bVar1 = true;\n  }\n  if (((options & 2U) == 0) || (bVar1)) {\n    if ((((options & 1U) != 0) &&\n        (((bVar1 && (0 < u->ut_pid)) && (iVar3 = kill(u->ut_pid,0), iVar3 < 0)))) &&\n       (piVar4 = __errno_location(), *piVar4 == 3)) {\n      return false;\n    }\n    _Var2 = true;\n  }\n  else {\n    _Var2 = false;\n  }\n  return _Var2;\n}\n\n",
        "output": "The predicted function name is desirable_utmp_entry"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void *v_a,void *v_b)\n\n{\n  int iVar1;\n  char **a;\n  char **b;\n  \n                    /* WARNING: Load size is inaccurate */\n                    /* WARNING: Load size is inaccurate */\n  iVar1 = strcmp(*v_a,*v_b);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is userid_compare"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int argc,char **argv,char *command_name,char *package,char *version,\n                       anon_subr_void_int *usage_func,...)\n\n{\n  long lVar1;\n  undefined4 uVar2;\n  char in_AL;\n  int iVar3;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  int saved_opterr;\n  int c;\n  va_list authors;\n  undefined local_b8 [48];\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  uVar2 = opterr;\n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  opterr = 0;\n  if ((argc == 2) && (iVar3 = getopt_long(2,argv,&DAT_00005ce1,long_options,0), iVar3 != -1)) {\n    if (iVar3 == 0x68) {\n      (*usage_func)(0);\n    }\n    else if (iVar3 == 0x76) {\n      authors[0].gp_offset = 0x30;\n      authors[0].fp_offset = 0x30;\n      authors[0].overflow_arg_area = &stack0x00000008;\n      authors[0].reg_save_area = local_b8;\n      version_etc_va(stdout,command_name,package,version,authors);\n                    /* WARNING: Subroutine does not return */\n      exit(0);\n    }\n  }\n  optind = 0;\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    optind = 0;\n    opterr = uVar2;\n    return;\n  }\n  opterr = uVar2;\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is parse_long_options"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *st1,char *st2,char *s1,size_t n1,char *s2,size_t n2)\n\n{\n  int iVar1;\n  size_t l2;\n  size_t l1;\n  \n  if ((s1 == (char *)0x0) && (s2 == (char *)0x0)) {\n    iVar1 = 1;\n  }\n  else {\n    if ((n1 == n2) &&\n       (((s1 != (char *)0x0 && (s2 != (char *)0x0)) && (iVar1 = strncmp(s1,s2,n1), iVar1 == 0)))) {\n      return 1;\n    }\n    if (s2 == (char *)0x0) {\n      l2 = 0;\n    }\n    else {\n      l2 = OPENSSL_strnlen(s2,n2);\n    }\n    if (s1 == (char *)0x0) {\n      l1 = 0;\n    }\n    else {\n      l1 = OPENSSL_strnlen(s1,n1);\n    }\n    test_fail_string_message((char *)0x0,file,line,\"string\",st1,st2,\"==\",s1,l1,s2,l2);\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is test_strn_eq"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](int format)\n\n{\n  if (format == 0xc) {\n    return \"PVK\";\n  }\n  if (format < 0xd) {\n    if (format == 6) {\n      return \"P12\";\n    }\n    if (format < 7) {\n      if (format == 4) {\n        return \"DER\";\n      }\n    }\n    else {\n      if (format == 8) {\n        return \"ENGINE\";\n      }\n      if (format == 0xb) {\n        return \"MSBLOB\";\n      }\n    }\n  }\n  else {\n    if (format == 0x8001) {\n      return \"TEXT\";\n    }\n    if (format < 0x8002) {\n      if (format == 0xd) {\n        return \"HTTP\";\n      }\n      if (format == 0xe) {\n        return \"NSS\";\n      }\n    }\n    else {\n      if (format == 0x8005) {\n        return \"PEM\";\n      }\n      if (format == 0x8007) {\n        return \"SMIME\";\n      }\n    }\n  }\n  return \"(undefined)\";\n}\n\n",
        "output": "The predicted function name is format2str"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *name)\n\n{\n  long lVar1;\n  int iVar2;\n  uint uVar3;\n  long in_FS_OFFSET;\n  stat st;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar2 = stat(name,(stat *)&st);\n  if (iVar2 == 0) {\n    uVar3 = (uint)((st.st_mode & 0xf000) == 0x4000);\n  }\n  else {\n    uVar3 = 0xffffffff;\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is opt_isdir"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *fmt,__va_list_tag *ap)\n\n{\n  int iVar1;\n  \n  iVar1 = BIO_vprintf((BIO *)bio_err,fmt,ap);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is test_vprintf_stderr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *bns,char *ws,BIGNUM *a,ulong w)\n\n{\n  int iVar1;\n  BIGNUM *a_00;\n  BIGNUM *bw;\n  \n  if ((a != (BIGNUM *)0x0) && (iVar1 = BN_is_word(a,w), iVar1 != 0)) {\n    return 1;\n  }\n  a_00 = BN_new();\n  if (a_00 != (BIGNUM *)0x0) {\n    BN_set_word(a_00,w);\n  }\n  test_fail_bignum_message((char *)0x0,file,line,\"BIGNUM\",bns,ws,\"==\",a,(BIGNUM *)a_00);\n  BN_free(a_00);\n  return 0;\n}\n\n",
        "output": "The predicted function name is test_BN_eq_word"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int level)\n\n{\n  BIO_ctrl((BIO *)tap_out,0x50,(long)level,(void *)0x0);\n  BIO_ctrl((BIO *)tap_err,0x50,(long)level,(void *)0x0);\n  return;\n}\n\n",
        "output": "The predicted function name is test_adjust_streams_tap_level"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,size_t t1,size_t t2)\n\n{\n  if (t1 == t2) {\n    test_fail_message((char *)0x0,file,line,\"size_t\",s1,s2,\"!=\",\"[%zu] compared to [%zu]\",t1,t2);\n  }\n  return (int)(t1 != t2);\n}\n\n",
        "output": "The predicted function name is test_size_t_ne"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int format,ulong flags)\n\n{\n  char *s;\n  \n  s = format2str(format);\n  opt_format_error(s,flags);\n  return;\n}\n\n",
        "output": "The predicted function name is print_format_error"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,uint t1,uint t2)\n\n{\n  if (t2 <= t1) {\n    test_fail_message((char *)0x0,file,line,\"unsigned int\",s1,s2,\"<\",\"[%u] compared to [%u]\",\n                      (ulong)t1,(ulong)t2);\n  }\n  return (int)(t2 > t1);\n}\n\n",
        "output": "The predicted function name is test_uint_lt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,int t1,int t2)\n\n{\n  if (t1 == t2) {\n    test_fail_message((char *)0x0,file,line,\"int\",s1,s2,\"!=\",\"[%d] compared to [%d]\",(ulong)(uint)t1\n                      ,(ulong)(uint)t2);\n  }\n  return (int)(t1 != t2);\n}\n\n",
        "output": "The predicted function name is test_int_ne"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,ulong t1,ulong t2)\n\n{\n  if (t1 <= t2) {\n    test_fail_message((char *)0x0,file,line,\"unsigned long\",s1,s2,\">\",\"[%lu] compared to [%lu]\",t1,\n                      t2);\n  }\n  return (int)(t2 < t1);\n}\n\n",
        "output": "The predicted function name is test_ulong_gt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *fmt,__va_list_tag *ap)\n\n{\n  int iVar1;\n  \n  iVar1 = BIO_vprintf((BIO *)bio_out,fmt,ap);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is test_vprintf_stdout"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,uint t1,uint t2)\n\n{\n  if (t2 < t1) {\n    test_fail_message((char *)0x0,file,line,\"unsigned int\",s1,s2,\"<=\",\"[%u] compared to [%u]\",\n                      (ulong)t1,(ulong)t2);\n  }\n  return (int)(t1 <= t2);\n}\n\n",
        "output": "The predicted function name is test_uint_le"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nOPTIONS * [MASK](void)\n\n{\n  return test_get_options::options;\n}\n\n",
        "output": "The predicted function name is test_get_options"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *fmt,...)\n\n{\n  long lVar1;\n  char in_AL;\n  int iVar2;\n  undefined8 in_RCX;\n  undefined8 in_RDX;\n  undefined8 in_RSI;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  int ret;\n  va_list ap;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  ap[0].gp_offset = 8;\n  ap[0].fp_offset = 0x30;\n  ap[0].overflow_arg_area = &stack0x00000008;\n  ap[0].reg_save_area = local_b8;\n  local_b0 = in_RSI;\n  local_a8 = in_RDX;\n  local_a0 = in_RCX;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  iVar2 = test_vprintf_stdout(fmt,ap);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar2;\n}\n\n",
        "output": "The predicted function name is test_printf_stdout"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,time_t t1,time_t t2)\n\n{\n  int iVar1;\n  ASN1_TIME *t;\n  ASN1_TIME *t_00;\n  char *pcVar2;\n  char *pcVar3;\n  int r;\n  ASN1_TIME *at1;\n  ASN1_TIME *at2;\n  \n  t = ASN1_TIME_set((ASN1_TIME *)0x0,t1);\n  t_00 = ASN1_TIME_set((ASN1_TIME *)0x0,t2);\n  if ((t != (ASN1_TIME *)0x0) && (t_00 != (ASN1_TIME *)0x0)) {\n    iVar1 = ASN1_TIME_compare(t,t_00);\n    if (iVar1 != 0) {\n      iVar1 = 1;\n      goto LAB_0000b74d;\n    }\n  }\n  iVar1 = 0;\nLAB_0000b74d:\n  if (iVar1 == 0) {\n    pcVar2 = print_time((ASN1_TIME *)t_00);\n    pcVar3 = print_time((ASN1_TIME *)t);\n    test_fail_message((char *)0x0,file,line,\"time_t\",s1,s2,\"!=\",\"[%s] compared to [%s]\",pcVar3,\n                      pcVar2);\n  }\n  ASN1_STRING_free(t);\n  ASN1_STRING_free(t_00);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is test_time_t_ne"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK]\n               (char *prefix,char *file,int line,char *type,char *left,char *right,char *op,\n               uchar *m1,size_t l1,uchar *m2,size_t l2)\n\n{\n  test_fail_memory_common(prefix,file,line,type,left,right,op,m1,l1,m2,l2);\n  test_printf_stderr(\"\\n\");\n  return;\n}\n\n",
        "output": "The predicted function name is test_fail_memory_message"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  opt_index = 1;\n  arg = (char *)0x0;\n  flag = (char *)0x0;\n  return;\n}\n\n",
        "output": "The predicted function name is opt_begin"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,uchar t1,uchar t2)\n\n{\n  if (t2 < t1) {\n    test_fail_message((char *)0x0,file,line,\"unsigned char\",s1,s2,\"<=\",\"[%u] compared to [%u]\",\n                      (ulong)t1,(ulong)t2);\n  }\n  return (int)(t1 <= t2);\n}\n\n",
        "output": "The predicted function name is test_uchar_le"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK]\n               (char *prefix,char *file,int line,char *type,char *left,char *right,char *op,\n               BIGNUM *bn1,BIGNUM *bn2)\n\n{\n  long lVar1;\n  int iVar2;\n  int iVar3;\n  size_t sVar4;\n  char *pcVar5;\n  long in_FS_OFFSET;\n  int lz1;\n  int lz2;\n  uint diff;\n  uint real_diff;\n  uint cnt;\n  char *p;\n  size_t i;\n  size_t len;\n  uchar *m1;\n  uchar *m2;\n  uchar *bufp;\n  size_t bytes;\n  size_t l1;\n  size_t l2;\n  size_t n1;\n  size_t n2;\n  char b1 [81];\n  char b2 [81];\n  char bdiff [81];\n  uchar buffer [4000];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  bytes = 0x20;\n  m1 = (uchar *)0x0;\n  m2 = (uchar *)0x0;\n  lz1 = 1;\n  lz2 = 1;\n  bufp = buffer;\n  test_fail_message_prefix(prefix,file,line,type,left,right,op);\n  if (bn1 == (BIGNUM *)0x0) {\n    l1 = 0;\n  }\n  else {\n    iVar2 = BN_num_bits((BIGNUM *)bn1);\n    iVar3 = iVar2 + 7;\n    if (iVar2 + 7 < 0) {\n      iVar3 = iVar2 + 0xe;\n    }\n    iVar2 = BN_is_negative(bn1);\n    l1 = (size_t)(int)((uint)(iVar2 != 0) + (iVar3 >> 3));\n  }\n  if (bn2 == (BIGNUM *)0x0) {\n    l2 = 0;\n  }\n  else {\n    iVar2 = BN_num_bits((BIGNUM *)bn2);\n    iVar3 = iVar2 + 7;\n    if (iVar2 + 7 < 0) {\n      iVar3 = iVar2 + 0xe;\n    }\n    iVar2 = BN_is_negative(bn2);\n    l2 = (size_t)(int)((uint)(iVar2 != 0) + (iVar3 >> 3));\n  }\n  if ((l1 == 0) && (l2 == 0)) {\n    if ((bn2 == (BIGNUM *)0x0) == (bn1 != (BIGNUM *)0x0)) {\n      test_diff_header(left,right);\n      test_bignum_header_line();\n      test_bignum_zero_print(bn1,'-');\n      test_bignum_zero_print(bn2,'+');\n    }\n    else {\n      test_bignum_header_line();\n      test_bignum_zero_print(bn1,' ');\n    }\n    goto fin;\n  }\n  if ((l1 == l2) && ((bn1 != (BIGNUM *)0x0 && (bn2 != (BIGNUM *)0x0)))) {\n    iVar3 = BN_cmp((BIGNUM *)bn1,(BIGNUM *)bn2);\n    if (iVar3 != 0) goto LAB_0000cd2b;\n  }\n  else {\nLAB_0000cd2b:\n    test_diff_header(left,right);\n  }\n  test_bignum_header_line();\n  sVar4 = l1;\n  if (l1 <= l2) {\n    sVar4 = l2;\n  }\n  len = bytes * (((bytes + sVar4) - 1) / bytes);\n  if (2000 < len) {\n    bufp = (uchar *)CRYPTO_malloc((int)len * 2,\"test/testutil/format_output.c\",0x12f);\n    if (bufp == (uchar *)0x0) {\n      bufp = buffer;\n      len = 2000;\n      test_printf_stderr(\"WARNING: these BIGNUMs have been truncated\\n\");\n    }\n  }\n  if (bn1 != (BIGNUM *)0x0) {\n    m1 = bufp;\n    BN_bn2binpad(bn1,bufp,len & 0xffffffff);\n  }\n  if (bn2 != (BIGNUM *)0x0) {\n    m2 = bufp + len;\n    BN_bn2binpad(bn2,m2,len & 0xffffffff);\n  }\n  for (; len != 0; len = len - bytes) {\n    cnt = ((int)len - (int)bytes) * 8;\n    iVar3 = convert_bn_memory(m1,bytes,b1,&lz1,bn1);\n    n1 = (size_t)iVar3;\n    iVar3 = convert_bn_memory(m2,bytes,b2,&lz2,bn2);\n    n2 = (size_t)iVar3;\n    real_diff = 0;\n    diff = 0;\n    p = bdiff;\n    for (i = 0; b1[i] != '\\0'; i = i + 1) {\n      if (((b1[i] == b2[i]) || (b1[i] == ' ')) || (b2[i] == ' ')) {\n        *p = ' ';\n        diff = diff | b1[i] != b2[i];\n      }\n      else {\n        *p = '^';\n        diff = 1;\n        real_diff = 1;\n      }\n      p = p + 1;\n    }\n    pcVar5 = p + 1;\n    *p = '\\0';\n    p = pcVar5;\n    if (diff == 0) {\n      if (n1 < n2) {\n        pcVar5 = b2;\n      }\n      else {\n        pcVar5 = b1;\n      }\n      test_printf_stderr(\" %s:% 5d\\n\",pcVar5,(ulong)cnt);\n    }\n    else {\n      if ((cnt == 0) && (bn1 == (BIGNUM *)0x0)) {\n        test_printf_stderr(\"-%s\\n\",b1);\n      }\n      else if ((cnt == 0) || (n1 != 0)) {\n        test_printf_stderr(\"-%s:% 5d\\n\",b1,(ulong)cnt);\n      }\n      if ((cnt == 0) && (bn2 == (BIGNUM *)0x0)) {\n        test_printf_stderr(\"+%s\\n\",b2);\n      }\n      else if ((cnt == 0) || (n2 != 0)) {\n        test_printf_stderr(\"+%s:% 5d\\n\",b2,(ulong)cnt);\n      }\n      if (((real_diff != 0) && (((cnt == 0 || ((n1 != 0 && (n2 != 0)))) && (bn1 != (BIGNUM *)0x0))))\n         && (bn2 != (BIGNUM *)0x0)) {\n        test_printf_stderr(\" %s\\n\",bdiff);\n      }\n    }\n    if (m1 != (uchar *)0x0) {\n      m1 = m1 + bytes;\n    }\n    if (m2 != (uchar *)0x0) {\n      m2 = m2 + bytes;\n    }\n  }\nfin:\n  test_flush_stderr();\n  if (bufp != buffer) {\n    CRYPTO_free(bufp);\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is test_fail_bignum_common"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s,BIGNUM *a)\n\n{\n  int iVar1;\n  \n  if ((a != (BIGNUM *)0x0) && (iVar1 = BN_is_zero(a), iVar1 == 0)) {\n    return 1;\n  }\n  test_fail_bignum_mono_message((char *)0x0,file,line,\"BIGNUM\",s,\"0\",\"!=\",a);\n  return 0;\n}\n\n",
        "output": "The predicted function name is test_BN_ne_zero"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *value,long *result)\n\n{\n  int iVar1;\n  int *piVar2;\n  long in_FS_OFFSET;\n  int oerrno;\n  char *endp;\n  long l;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  piVar2 = __errno_location();\n  *piVar2 = 0;\n  l = strtol(value,&endp,0);\n  if ((*endp == '\\0') && (value != endp)) {\n    if ((l == 0x7fffffffffffffff) || (l == -0x8000000000000000)) {\n      piVar2 = __errno_location();\n      if (*piVar2 == 0x22) goto LAB_00005453;\n    }\n    if (l == 0) {\n      piVar2 = __errno_location();\n      if (*piVar2 != 0) goto LAB_00005453;\n    }\n    *result = l;\n    piVar2 = __errno_location();\n    *piVar2 = iVar1;\n    iVar1 = 1;\n  }\n  else {\nLAB_00005453:\n    opt_number_error(value);\n    piVar2 = __errno_location();\n    *piVar2 = iVar1;\n    iVar1 = 0;\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is opt_long"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *fmt,...)\n\n{\n  long lVar1;\n  char in_AL;\n  int iVar2;\n  undefined8 in_RCX;\n  undefined8 in_RDX;\n  undefined8 in_RSI;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  int ret;\n  va_list ap;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  ap[0].gp_offset = 8;\n  ap[0].fp_offset = 0x30;\n  ap[0].overflow_arg_area = &stack0x00000008;\n  ap[0].reg_save_area = local_b8;\n  local_b0 = in_RSI;\n  local_a8 = in_RDX;\n  local_a0 = in_RCX;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  iVar2 = test_vprintf_stderr(fmt,ap);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar2;\n}\n\n",
        "output": "The predicted function name is test_printf_stderr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,size_t t1,size_t t2)\n\n{\n  if (t2 <= t1) {\n    test_fail_message((char *)0x0,file,line,\"size_t\",s1,s2,\"<\",\"[%zu] compared to [%zu]\",t1,t2);\n  }\n  return (int)(t2 > t1);\n}\n\n",
        "output": "The predicted function name is test_size_t_lt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,BIGNUM *t1,BIGNUM *t2)\n\n{\n  int iVar1;\n  \n  iVar1 = BN_cmp((BIGNUM *)t1,(BIGNUM *)t2);\n  if (iVar1 == 0) {\n    test_fail_bignum_message((char *)0x0,file,line,\"BIGNUM\",s1,s2,\"!=\",t1,t2);\n  }\n  return (int)(iVar1 != 0);\n}\n\n",
        "output": "The predicted function name is test_BN_ne"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *st1,char *st2,void *s1,size_t n1,void *s2,size_t n2)\n\n{\n  int iVar1;\n  \n  if ((s2 == (void *)0x0) == (s1 == (void *)0x0)) {\n    if (n1 == n2) {\n      if ((s1 != (void *)0x0) && (iVar1 = memcmp(s1,s2,n1), iVar1 != 0)) {\n        return 1;\n      }\n      test_fail_memory_message\n                ((char *)0x0,file,line,\"memory\",st1,st2,\"!=\",(uchar *)s1,n1,(uchar *)s2,n2);\n      iVar1 = 0;\n    }\n    else {\n      iVar1 = 1;\n    }\n  }\n  else {\n    iVar1 = 1;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is test_mem_ne"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *str,size_t len,void *u)\n\n{\n  int iVar1;\n  \n  iVar1 = test_printf_stderr(\"%s\",str);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is openssl_error_cb"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  char *pcVar2;\n  ulong flags;\n  long in_FS_OFFSET;\n  int ival;\n  long lval;\n  ulong ulval;\n  ossl_intmax_t imval;\n  ossl_uintmax_t umval;\n  char *p;\n  OPTIONS *o;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  arg = (char *)0x0;\n  p = argv[opt_index];\n  if (p == (char *)0x0) {\n    iVar1 = 0;\n  }\n  else if (*p == '-') {\n    opt_index = opt_index + 1;\n    iVar1 = strcmp(p,\"--\");\n    if (iVar1 == 0) {\n      iVar1 = 0;\n    }\n    else {\n      pcVar2 = p + 1;\n      if (p[1] == '-') {\n        pcVar2 = p + 2;\n      }\n      p = pcVar2;\n      flag = p + -1;\n      pcVar2 = strchr(p,0x3d);\n      arg = pcVar2;\n      if (pcVar2 != (char *)0x0) {\n        arg = pcVar2 + 1;\n        *pcVar2 = '\\0';\n      }\n      for (o = opts; o->name != (char *)0x0; o = o + 1) {\n        iVar1 = strcmp(p,\"h\");\n        if (((iVar1 == 0) && (iVar1 = strcmp(o->name,\"help\"), iVar1 == 0)) ||\n           (iVar1 = strcmp(p,o->name), iVar1 == 0)) {\n          if ((o->valtype == 0) || (o->valtype == 0x2d)) {\n            if (arg == (char *)0x0) {\n              iVar1 = o->retval;\n            }\n            else {\n              opt_printf_stderr(\"%s: Option -%s does not take a value\\n\",prog,p);\n              iVar1 = -1;\n            }\n            goto LAB_00006199;\n          }\n          if (arg == (char *)0x0) {\n            if (argv[opt_index] == (char *)0x0) {\n              opt_printf_stderr(\"%s: Option -%s needs a value\\n\",prog,o->name);\n              iVar1 = -1;\n              goto LAB_00006199;\n            }\n            arg = argv[opt_index];\n            opt_index = opt_index + 1;\n          }\n          switch(o->valtype) {\n          case 0x2f:\n            iVar1 = opt_isdir(arg);\n            if (iVar1 < 1) {\n              opt_printf_stderr(\"%s: Not a directory: %s\\n\",prog,arg);\n              iVar1 = -1;\n              goto LAB_00006199;\n            }\n            break;\n          case 0x45:\n          case 0x46:\n          case 99:\n          case 0x66:\n            if (o->valtype == 99) {\n              flags = 10;\n            }\n            else if (o->valtype == 0x45) {\n              flags = 0x12;\n            }\n            else if (o->valtype == 0x46) {\n              flags = 2;\n            }\n            else {\n              flags = 0x7be;\n            }\n            iVar1 = opt_format(arg,flags,&ival);\n            if (iVar1 == 0) {\n              opt_printf_stderr(\"%s: Invalid format \\\"%s\\\" for option -%s\\n\",prog,arg,o->name);\n              iVar1 = -1;\n              goto LAB_00006199;\n            }\n            break;\n          case 0x4d:\n            iVar1 = opt_intmax(arg,&imval);\n            if (iVar1 == 0) {\n              iVar1 = -1;\n              goto LAB_00006199;\n            }\n            break;\n          case 0x4e:\n          case 0x6e:\n          case 0x70:\n            iVar1 = opt_int(arg,&ival);\n            if (iVar1 == 0) {\n              iVar1 = -1;\n              goto LAB_00006199;\n            }\n            if ((o->valtype == 0x70) && (ival < 1)) {\n              opt_printf_stderr(\"%s: Non-positive number \\\"%s\\\" for option -%s\\n\",prog,arg,o->name);\n              iVar1 = -1;\n              goto LAB_00006199;\n            }\n            if ((o->valtype == 0x4e) && (ival < 0)) {\n              opt_printf_stderr(\"%s: Negative number \\\"%s\\\" for option -%s\\n\",prog,arg,o->name);\n              iVar1 = -1;\n              goto LAB_00006199;\n            }\n            break;\n          case 0x55:\n            iVar1 = opt_uintmax(arg,&umval);\n            if (iVar1 == 0) {\n              iVar1 = -1;\n              goto LAB_00006199;\n            }\n            break;\n          case 0x6c:\n            iVar1 = opt_long(arg,&lval);\n            if (iVar1 == 0) {\n              iVar1 = -1;\n              goto LAB_00006199;\n            }\n            break;\n          case 0x75:\n            iVar1 = opt_ulong(arg,&ulval);\n            if (iVar1 == 0) {\n              iVar1 = -1;\n              goto LAB_00006199;\n            }\n          }\n          iVar1 = o->retval;\n          goto LAB_00006199;\n        }\n      }\n      if (unknown == (OPTIONS *)0x0) {\n        opt_printf_stderr(\"%s: Unknown option: -%s\\n\",prog,p);\n        iVar1 = -1;\n      }\n      else {\n        dunno = p;\n        iVar1 = unknown->retval;\n      }\n    }\n  }\n  else {\n    iVar1 = 0;\n  }\nLAB_00006199:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is opt_next"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  long lVar1;\n  int iVar2;\n  size_t sVar3;\n  long in_FS_OFFSET;\n  int testresult;\n  long eline;\n  size_t i;\n  BIO *extbio;\n  CONF *conf;\n  X509V3_CTX ctx;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  testresult = 1;\n  i = 0;\n  do {\n    if (0x19 < i) {\nLAB_000044a7:\n      if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return testresult;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    sVar3 = strlen(extvalues[i].value);\n    extbio = (BIO *)BIO_new_mem_buf(extvalues[i].value,(int)sVar3);\n    iVar2 = test_ptr(\"test/v3ext.c\",0x120,\"extbio\",extbio);\n    if (iVar2 == 0) {\n      testresult = 0;\n      goto LAB_000044a7;\n    }\n    conf = (CONF *)NCONF_new_ex(0,0);\n    iVar2 = test_ptr(\"test/v3ext.c\",0x124,\"conf\",conf);\n    if (iVar2 == 0) {\n      BIO_free((BIO *)extbio);\n      testresult = 0;\n      goto LAB_000044a7;\n    }\n    iVar2 = NCONF_load_bio((CONF *)conf,(BIO *)extbio,&eline);\n    iVar2 = test_long_gt(\"test/v3ext.c\",0x128,\"NCONF_load_bio(conf, extbio, &eline)\",\"0\",(long)iVar2\n                         ,0);\n    if (iVar2 == 0) {\n      testresult = 0;\n    }\n    else {\n      X509V3_set_ctx((X509V3_CTX *)&ctx,(X509 *)0x0,(X509 *)0x0,(X509_REQ *)0x0,(X509_CRL *)0x0,1);\n      X509V3_set_nconf((X509V3_CTX *)&ctx,(CONF *)conf);\n      if (extvalues[i].pass == 0) {\n        ERR_set_mark();\n        iVar2 = X509V3_EXT_add_nconf((CONF *)conf,(X509V3_CTX *)&ctx,\"default\",(X509 *)0x0);\n        iVar2 = test_false(\"test/v3ext.c\",0x137,\n                           \"X509V3_EXT_add_nconf(conf, &ctx, \\\"default\\\", NULL)\",(uint)(iVar2 != 0))\n        ;\n        if (iVar2 == 0) {\n          testresult = 0;\n          test_info(\"test/v3ext.c\",0x139,\"Value: %s\");\n          ERR_clear_last_mark();\n        }\n        else {\n          ERR_pop_to_mark();\n        }\n      }\n      else {\n        iVar2 = X509V3_EXT_add_nconf((CONF *)conf,(X509V3_CTX *)&ctx,\"default\",(X509 *)0x0);\n        iVar2 = test_true(\"test/v3ext.c\",0x130,\"X509V3_EXT_add_nconf(conf, &ctx, \\\"default\\\", NULL)\"\n                          ,(uint)(iVar2 != 0));\n        if (iVar2 == 0) {\n          test_info(\"test/v3ext.c\",0x131,\"Value: %s\");\n          testresult = 0;\n        }\n      }\n    }\n    BIO_free((BIO *)extbio);\n    NCONF_free((CONF *)conf);\n    i = i + 1;\n  } while( true );\n}\n\n",
        "output": "The predicted function name is test_ext_syntax"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](void)\n\n{\n  return (char *)0x0;\n}\n\n",
        "output": "The predicted function name is app_get0_propq"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,size_t t1,size_t t2)\n\n{\n  if (t2 < t1) {\n    test_fail_message((char *)0x0,file,line,\"size_t\",s1,s2,\"<=\",\"[%zu] compared to [%zu]\",t1,t2);\n  }\n  return (int)(t1 <= t2);\n}\n\n",
        "output": "The predicted function name is test_size_t_le"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *fmt,...)\n\n{\n  long lVar1;\n  char in_AL;\n  int iVar2;\n  undefined8 in_RCX;\n  undefined8 in_RDX;\n  undefined8 in_RSI;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  int ret;\n  va_list ap;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  ap[0].gp_offset = 8;\n  ap[0].fp_offset = 0x30;\n  ap[0].overflow_arg_area = &stack0x00000008;\n  ap[0].reg_save_area = local_b8;\n  local_b0 = in_RSI;\n  local_a8 = in_RDX;\n  local_a0 = in_RCX;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  iVar2 = test_vprintf_taperr(fmt,ap);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar2;\n}\n\n",
        "output": "The predicted function name is test_printf_taperr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](void)\n\n{\n  return prog;\n}\n\n",
        "output": "The predicted function name is opt_getprog"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *fmt,__va_list_tag *ap)\n\n{\n  int iVar1;\n  \n  iVar1 = BIO_vprintf((BIO *)tap_out,fmt,ap);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is test_vprintf_tapout"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *s)\n\n{\n  int *piVar1;\n  char *pcVar2;\n  \n  piVar1 = __errno_location();\n  pcVar2 = strerror(*piVar1);\n  test_error(\"test/testutil/tests.c\",0x90,\"%s: %s\",s,pcVar2);\n  return;\n}\n\n",
        "output": "The predicted function name is test_perror"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *fmt,...)\n\n{\n  long lVar1;\n  char in_AL;\n  int iVar2;\n  undefined8 in_RCX;\n  undefined8 in_RDX;\n  undefined8 in_RSI;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  int ret;\n  va_list ap;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  ap[0].gp_offset = 8;\n  ap[0].fp_offset = 0x30;\n  ap[0].overflow_arg_area = &stack0x00000008;\n  ap[0].reg_save_area = local_b8;\n  local_b0 = in_RSI;\n  local_a8 = in_RDX;\n  local_a0 = in_RCX;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  iVar2 = test_vprintf_tapout(fmt,ap);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar2;\n}\n\n",
        "output": "The predicted function name is test_printf_tapout"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,int t1,int t2)\n\n{\n  if (t2 < t1) {\n    test_fail_message((char *)0x0,file,line,\"int\",s1,s2,\"<=\",\"[%d] compared to [%d]\",(ulong)(uint)t1\n                      ,(ulong)(uint)t2);\n  }\n  return (int)(t1 <= t2);\n}\n\n",
        "output": "The predicted function name is test_int_le"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  test_printf_stderr(\" %*s\\n\",0x49,\"bit position\");\n  return;\n}\n\n",
        "output": "The predicted function name is test_bignum_header_line"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *name,OPT_PAIR *pairs,int *result)\n\n{\n  int iVar1;\n  OPT_PAIR *pp;\n  \n  pp = pairs;\n  while( true ) {\n    if (pp->name == (char *)0x0) {\n      opt_printf_stderr(\"%s: Value must be one of:\\n\",prog);\n      for (pp = pairs; pp->name != (char *)0x0; pp = pp + 1) {\n        opt_printf_stderr(\"\\t%s\\n\",pp->name);\n      }\n      return 0;\n    }\n    iVar1 = strcmp(pp->name,name);\n    if (iVar1 == 0) break;\n    pp = pp + 1;\n  }\n  *result = pp->retval;\n  return 1;\n}\n\n",
        "output": "The predicted function name is opt_pair"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *fmt,__va_list_tag *ap)\n\n{\n  int iVar1;\n  \n  iVar1 = BIO_vprintf((BIO *)tap_err,fmt,ap);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is test_vprintf_taperr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *st1,char *st2,char *s1,char *s2)\n\n{\n  int iVar1;\n  size_t l2;\n  size_t l1;\n  \n  if ((s1 == (char *)0x0) && (s2 == (char *)0x0)) {\n    iVar1 = 1;\n  }\n  else {\n    if ((s1 != (char *)0x0) && ((s2 != (char *)0x0 && (iVar1 = strcmp(s1,s2), iVar1 == 0)))) {\n      return 1;\n    }\n    if (s2 == (char *)0x0) {\n      l2 = 0;\n    }\n    else {\n      l2 = strlen(s2);\n    }\n    if (s1 == (char *)0x0) {\n      l1 = 0;\n    }\n    else {\n      l1 = strlen(s1);\n    }\n    test_fail_string_message((char *)0x0,file,line,\"string\",st1,st2,\"==\",s1,l1,s2,l2);\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is test_str_eq"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,int t1,int t2)\n\n{\n  if (t2 <= t1) {\n    test_fail_message((char *)0x0,file,line,\"int\",s1,s2,\"<\",\"[%d] compared to [%d]\",(ulong)(uint)t1,\n                      (ulong)(uint)t2);\n  }\n  return (int)(t2 > t1);\n}\n\n",
        "output": "The predicted function name is test_int_lt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *s,ulong flags)\n\n{\n  OPT_PAIR *ap;\n  \n  if (flags == 2) {\n    opt_printf_stderr(\"%s: Bad format \\\"%s\\\"; must be pem or der\\n\",prog,s);\n  }\n  else {\n    opt_printf_stderr(\"%s: Bad format \\\"%s\\\"; must be one of:\\n\",prog,s);\n    for (ap = formats; ap->name != (char *)0x0; ap = ap + 1) {\n      if (((long)ap->retval & flags) != 0) {\n        opt_printf_stderr(\"   %s\\n\",ap->name);\n      }\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is opt_format_error"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s,void *p)\n\n{\n  if (p == (void *)0x0) {\n    test_fail_message((char *)0x0,file,line,\"ptr\",s,\"NULL\",\"!=\",\"%p\",0);\n  }\n  return (int)(p != (void *)0x0);\n}\n\n",
        "output": "The predicted function name is test_ptr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *prefix,char *file,int line,char *type,char *left,char *right,char *op,\n                      char *fmt,...)\n\n{\n  long lVar1;\n  char in_AL;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  va_list ap;\n  undefined local_b8 [48];\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  ap[0].gp_offset = 0x30;\n  ap[0].fp_offset = 0x30;\n  ap[0].overflow_arg_area = &stack0x00000018;\n  ap[0].reg_save_area = local_b8;\n  test_fail_message_va(prefix,file,line,type,left,right,op,fmt,ap);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is test_fail_message"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int s)\n\n{\n  time_t tVar1;\n  \n  seed = s;\n  if (s < 1) {\n    tVar1 = time((time_t *)0x0);\n    seed = (int)tVar1;\n  }\n  test_random_seed(seed);\n  return;\n}\n\n",
        "output": "The predicted function name is set_seed"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,void *t1,void *t2)\n\n{\n  if (t1 == t2) {\n    test_fail_message((char *)0x0,file,line,\"void *\",s1,s2,\"!=\",\"[%p] compared to [%p]\",t1,t2);\n  }\n  return (int)(t1 != t2);\n}\n\n",
        "output": "The predicted function name is test_ptr_ne"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK]\n               (char *prefix,char *file,int line,char *type,char *left,char *right,char *op,\n               BIGNUM *bn)\n\n{\n  test_fail_bignum_common(prefix,file,line,type,left,right,op,bn,bn);\n  test_printf_stderr(\"\\n\");\n  return;\n}\n\n",
        "output": "The predicted function name is test_fail_bignum_mono_message"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *v)\n\n{\n  long lVar1;\n  int iVar2;\n  size_t __n;\n  long in_FS_OFFSET;\n  size_t i;\n  strstr_pair_st b [3];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  b[0].prefix = \"0x\";\n  b[0].name = \"a hexadecimal\";\n  b[1].prefix = \"0X\";\n  b[1].name = \"a hexadecimal\";\n  b[2].prefix = \"0\";\n  b[2].name = \"an octal\";\n  i = 0;\n  do {\n    if (2 < i) {\n      opt_printf_stderr(\"%s: Can\\'t parse \\\"%s\\\" as a number\\n\",prog,v);\nLAB_0000539a:\n      if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n      return;\n    }\n    __n = strlen(b[i].prefix);\n    iVar2 = strncmp(v,b[i].prefix,__n);\n    if (iVar2 == 0) {\n      opt_printf_stderr(\"%s: Can\\'t parse \\\"%s\\\" as %s number\\n\",prog,v,b[i].name);\n      goto LAB_0000539a;\n    }\n    i = i + 1;\n  } while( true );\n}\n\n",
        "output": "The predicted function name is opt_number_error"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s,BIGNUM *a)\n\n{\n  int iVar1;\n  \n  if ((a != (BIGNUM *)0x0) && (iVar1 = BN_is_one(a), iVar1 != 0)) {\n    return 1;\n  }\n  test_fail_bignum_mono_message((char *)0x0,file,line,\"BIGNUM\",s,\"1\",\"==\",a);\n  return 0;\n}\n\n",
        "output": "The predicted function name is test_BN_eq_one"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *left,char *right)\n\n{\n  test_printf_stderr(\"--- %s\\n\",left);\n  test_printf_stderr(\"+++ %s\\n\",right);\n  return;\n}\n\n",
        "output": "The predicted function name is test_diff_header"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK]\n               (char *prefix,char *file,int line,char *type,char *left,char *right,char *op,\n               BIGNUM *bn1,BIGNUM *bn2)\n\n{\n  test_fail_bignum_common(prefix,file,line,type,left,right,op,bn1,bn2);\n  test_printf_stderr(\"\\n\");\n  return;\n}\n\n",
        "output": "The predicted function name is test_fail_bignum_message"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  ERR_print_errors_cb(openssl_error_cb,(void *)0x0);\n  ERR_clear_error();\n  return;\n}\n\n",
        "output": "The predicted function name is test_openssl_errors"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](uchar *in,size_t bytes,char *out,int *lz,BIGNUM *bn)\n\n{\n  char *pcVar1;\n  int iVar2;\n  size_t sVar3;\n  uint uVar4;\n  int n;\n  int i;\n  char *p;\n  char *q;\n  char *r;\n  \n  n = (int)bytes * 2;\n  q = (char *)0x0;\n  p = out;\n  if ((bn == (BIGNUM *)0x0) || (iVar2 = BN_is_zero(bn), iVar2 != 0)) {\n    for (i = 0; i < n; i = i + 1) {\n      pcVar1 = p + 1;\n      *p = ' ';\n      uVar4 = (uint)(i >> 0x1f) >> 0x1c;\n      if (((i + uVar4 & 0xf) - uVar4 == 0xf) && (i != n + -1)) {\n        *pcVar1 = ' ';\n        pcVar1 = p + 2;\n      }\n      p = pcVar1;\n    }\n    *p = '\\0';\n    if (bn == (BIGNUM *)0x0) {\n      r = \"NULL\";\n    }\n    else {\n      iVar2 = BN_is_negative(bn);\n      if (iVar2 == 0) {\n        r = \"0\";\n      }\n      else {\n        r = \"-0\";\n      }\n    }\n    sVar3 = strlen(r);\n    strcpy(p + -sVar3,r);\n    n = 0;\n  }\n  else {\n    hex_convert_memory(in,bytes,out,8);\n    if (*lz != 0) {\n      for (; (*p == '0' || (*p == ' ')); p = p + 1) {\n        if (*p == '0') {\n          q = p;\n          *p = ' ';\n          n = n + -1;\n        }\n      }\n      if (*p == '\\0') {\n        if (((in[bytes] & 0xf0) != 0) && (iVar2 = BN_is_negative(bn), iVar2 != 0)) {\n          *lz = 0;\n          *q = '-';\n          n = n + 1;\n        }\n      }\n      else {\n        *lz = 0;\n        iVar2 = BN_is_negative(bn);\n        if (iVar2 != 0) {\n          *q = '-';\n          n = n + 1;\n        }\n      }\n    }\n  }\n  return n;\n}\n\n",
        "output": "The predicted function name is convert_bn_memory"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int ret)\n\n{\n  set_test_title((char *)0x0);\n  return ret;\n}\n\n",
        "output": "The predicted function name is pulldown_test_framework"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,uchar t1,uchar t2)\n\n{\n  if (t1 < t2) {\n    test_fail_message((char *)0x0,file,line,\"unsigned char\",s1,s2,\">=\",\"[%u] compared to [%u]\",\n                      (ulong)t1,(ulong)t2);\n  }\n  return (int)(t1 >= t2);\n}\n\n",
        "output": "The predicted function name is test_uchar_ge"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](BIGNUM *bn)\n\n{\n  int iVar1;\n  char *pcVar2;\n  \n  if (bn == (BIGNUM *)0x0) {\n    pcVar2 = \"NULL\";\n  }\n  else {\n    iVar1 = BN_is_negative(bn);\n    if (iVar1 == 0) {\n      pcVar2 = \"0\";\n    }\n    else {\n      pcVar2 = \"-0\";\n    }\n  }\n  return pcVar2;\n}\n\n",
        "output": "The predicted function name is test_bignum_zero_null"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nOPENSSL_sk_freefunc * [MASK](sk_IPAddressFamily_freefunc *fr)\n\n{\n  return (OPENSSL_sk_freefunc *)fr;\n}\n\n",
        "output": "The predicted function name is ossl_check_IPAddressFamily_freefunc_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *test_prog_name)\n\n{\n  long lVar1;\n  uint uVar2;\n  int iVar3;\n  uint32_t uVar4;\n  int iVar5;\n  long in_FS_OFFSET;\n  int num_failed;\n  int verdict;\n  int ii;\n  int i;\n  int jj;\n  int j;\n  int jstep;\n  int test_case_count;\n  int subtest_case_count;\n  int num_failed_inner;\n  int v;\n  int permute [1024];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  num_failed = 0;\n  test_case_count = 0;\n  subtest_case_count = 0;\n  iVar3 = process_shared_options();\n  if (iVar3 == 0) {\n    iVar3 = 0;\n  }\n  else if (iVar3 == -1) {\n    iVar3 = 1;\n  }\n  else {\n    if (num_tests < 1) {\n      test_printf_tapout(\"1..0 # Skipped: %s\\n\");\n    }\n    else if ((show_list == 0) && (single_test == -1)) {\n      if (0 < level) {\n        test_printf_stdout(\"Subtest: %s\\n\");\n        test_flush_stdout();\n      }\n      test_printf_tapout(\"1..%d\\n\");\n    }\n    test_flush_tapout();\n    for (i = 0; i < num_tests; i = i + 1) {\n      permute[i] = i;\n    }\n    uVar2 = num_tests;\n    if (rand_order != 0) {\n      while (i = uVar2 - 1, 0 < i) {\n        uVar4 = test_random();\n        iVar3 = permute[(int)(uVar4 % uVar2)];\n        permute[(int)(uVar4 % uVar2)] = permute[i];\n        permute[i] = iVar3;\n        uVar2 = i;\n      }\n    }\n    for (ii = 0; ii != num_tests; ii = ii + 1) {\n      iVar3 = permute[ii];\n      if ((single_test == -1) || (iVar3 + 1 == single_test)) {\n        if (show_list == 0) {\n          if (all_tests[iVar3].num == -1) {\n            set_test_title(all_tests[iVar3].test_case_name);\n            iVar3 = (*all_tests[iVar3].test_fn)();\n            finalize((uint)(iVar3 != 0));\n            test_verdict(iVar3,\"%d - %s\",(ulong)(test_case_count + 1));\n            if (iVar3 == 0) {\n              num_failed = num_failed + 1;\n            }\n            test_case_count = test_case_count + 1;\n          }\n          else {\n            verdict = 0x7b;\n            set_test_title(all_tests[iVar3].test_case_name);\n            if ((char)(all_tests[iVar3].field_0x1c << 7) < '\\0') {\n              level = level + 4;\n              test_adjust_streams_tap_level(level);\n              if (single_iter == -1) {\n                test_printf_stdout(\"Subtest: %s\\n\",test_title);\n                test_printf_tapout(\"%d..%d\\n\",1,(ulong)(uint)all_tests[iVar3].num);\n                test_flush_stdout();\n                test_flush_tapout();\n              }\n            }\n            j = -1;\n            if ((rand_order == 0) || (all_tests[iVar3].num < 3)) {\n              jstep = 1;\n            }\n            else {\n              do {\n                do {\n                  uVar4 = test_random();\n                  jstep = uVar4 % (uint)all_tests[iVar3].num;\n                } while (jstep == 0);\n                iVar5 = gcd(all_tests[iVar3].num,jstep);\n              } while (iVar5 != 1);\n            }\n            for (jj = 0; jj < all_tests[iVar3].num; jj = jj + 1) {\n              j = (j + jstep) % all_tests[iVar3].num;\n              if ((single_iter == -1) || (jj + 1 == single_iter)) {\n                iVar5 = (*all_tests[iVar3].param_test_fn)(j);\n                if (iVar5 == 0) {\n                  verdict = 0;\n                }\n                else if ((iVar5 != 0x7b) && (verdict != 0)) {\n                  verdict = 1;\n                }\n                finalize((uint)(iVar5 != 0));\n                if ((char)(all_tests[iVar3].field_0x1c << 7) < '\\0') {\n                  test_verdict(iVar5,\"%d - iteration %d\",(ulong)(subtest_case_count + 1));\n                }\n                else {\n                  test_verdict(iVar5,\"%d - %s - iteration %d\",\n                               (ulong)(subtest_case_count + test_case_count + 1),test_title,\n                               (ulong)(j + 1));\n                }\n                subtest_case_count = subtest_case_count + 1;\n              }\n            }\n            if ((char)(all_tests[iVar3].field_0x1c << 7) < '\\0') {\n              level = level + -4;\n              test_adjust_streams_tap_level(level);\n            }\n            if (verdict == 0) {\n              num_failed = num_failed + 1;\n            }\n            if ((all_tests[iVar3].num == -1) || ((char)(all_tests[iVar3].field_0x1c << 7) < '\\0')) {\n              test_verdict(verdict,\"%d - %s\",(ulong)(test_case_count + 1));\n            }\n            test_case_count = test_case_count + 1;\n          }\n        }\n        else {\n          if (all_tests[iVar3].num == -1) {\n            test_printf_tapout(\"%d - %s\\n\",(ulong)(ii + 1),all_tests[iVar3].test_case_name);\n          }\n          else {\n            test_printf_tapout(\"%d - %s (%d..%d)\\n\",(ulong)(ii + 1),all_tests[iVar3].test_case_name)\n            ;\n          }\n          test_flush_tapout();\n        }\n      }\n    }\n    if (num_failed == 0) {\n      iVar3 = 0;\n    }\n    else {\n      iVar3 = 1;\n    }\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is run_tests"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *value,ossl_intmax_t *result)\n\n{\n  int iVar1;\n  int *piVar2;\n  long in_FS_OFFSET;\n  int oerrno;\n  char *endp;\n  intmax_t m;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  piVar2 = __errno_location();\n  *piVar2 = 0;\n  m = strtoimax(value,&endp,0);\n  if ((*endp == '\\0') && (value != endp)) {\n    if ((m == 0x7fffffffffffffff) || (m == -0x8000000000000000)) {\n      piVar2 = __errno_location();\n      if (*piVar2 == 0x22) goto LAB_00005549;\n    }\n    if (m == 0) {\n      piVar2 = __errno_location();\n      if (*piVar2 != 0) goto LAB_00005549;\n    }\n    *result = m;\n    piVar2 = __errno_location();\n    *piVar2 = iVar1;\n    iVar1 = 1;\n  }\n  else {\nLAB_00005549:\n    opt_number_error(value);\n    piVar2 = __errno_location();\n    *piVar2 = iVar1;\n    iVar1 = 0;\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is opt_intmax"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *name,char *m,size_t l)\n\n{\n  test_fail_string_common(\"string\",(char *)0x0,0,(char *)0x0,(char *)0x0,(char *)0x0,name,m,l,m,l);\n  return;\n}\n\n",
        "output": "The predicted function name is test_output_string"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,double t1,double t2)\n\n{\n  if (t2 <= t1) {\n    test_fail_message((char *)t1,(char *)t2,0,file,line,\"double\",s1,s2,&DAT_0000f7a4,\n                      \"[%g] compared to [%g]\");\n  }\n  return (int)(t1 < t2);\n}\n\n",
        "output": "The predicted function name is test_double_lt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,char t1,char t2)\n\n{\n  if (t1 <= t2) {\n    test_fail_message((char *)0x0,file,line,\"char\",s1,s2,\">\",\"[%c] compared to [%c]\",\n                      (ulong)(uint)(int)t1,(ulong)(uint)(int)t2);\n  }\n  return (int)(t2 < t1);\n}\n\n",
        "output": "The predicted function name is test_char_gt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *s,ulong flags,int *result)\n\n{\n  int iVar1;\n  \n  switch(*s) {\n  case '1':\n    if ((flags & 4) == 0) {\n      iVar1 = opt_format_error(s,flags);\n      return iVar1;\n    }\n    *result = 6;\n    break;\n  default:\n    opt_printf_stderr(\"%s: Bad format \\\"%s\\\"\\n\",prog,s);\n    return 0;\n  case 'D':\n  case 'd':\n    if ((flags & 2) == 0) {\n      iVar1 = opt_format_error(s,flags);\n      return iVar1;\n    }\n    *result = 4;\n    break;\n  case 'E':\n  case 'e':\n    if ((flags & 0x10) == 0) {\n      iVar1 = opt_format_error(s,flags);\n      return iVar1;\n    }\n    *result = 8;\n    break;\n  case 'H':\n  case 'h':\n    if ((flags & 0x200) == 0) {\n      iVar1 = opt_format_error(s,flags);\n      return iVar1;\n    }\n    *result = 0xd;\n    break;\n  case 'M':\n  case 'm':\n    if ((flags & 0x20) == 0) {\n      iVar1 = opt_format_error(s,flags);\n      return iVar1;\n    }\n    *result = 0xb;\n    break;\n  case 'N':\n  case 'n':\n    if ((flags & 0x80) == 0) {\n      iVar1 = opt_format_error(s,flags);\n      return iVar1;\n    }\n    iVar1 = strcmp(s,\"NSS\");\n    if ((iVar1 != 0) && (iVar1 = strcmp(s,\"nss\"), iVar1 != 0)) {\n      iVar1 = opt_format_error(s,flags);\n      return iVar1;\n    }\n    *result = 0xe;\n    break;\n  case 'P':\n  case 'p':\n    if (((s[1] == '\\0') || (iVar1 = strcmp(s,\"PEM\"), iVar1 == 0)) ||\n       (iVar1 = strcmp(s,\"pem\"), iVar1 == 0)) {\n      if ((flags & 2) == 0) {\n        iVar1 = opt_format_error(s,flags);\n        return iVar1;\n      }\n      *result = 0x8005;\n    }\n    else {\n      iVar1 = strcmp(s,\"PVK\");\n      if ((iVar1 == 0) || (iVar1 = strcmp(s,\"pvk\"), iVar1 == 0)) {\n        if ((flags & 0x400) == 0) {\n          iVar1 = opt_format_error(s,flags);\n          return iVar1;\n        }\n        *result = 0xc;\n      }\n      else {\n        iVar1 = strcmp(s,\"P12\");\n        if (((iVar1 != 0) && (iVar1 = strcmp(s,\"p12\"), iVar1 != 0)) &&\n           ((iVar1 = strcmp(s,\"PKCS12\"), iVar1 != 0 && (iVar1 = strcmp(s,\"pkcs12\"), iVar1 != 0)))) {\n          opt_printf_stderr(\"%s: Bad format \\\"%s\\\"\\n\",prog,s);\n          return 0;\n        }\n        if ((flags & 4) == 0) {\n          iVar1 = opt_format_error(s,flags);\n          return iVar1;\n        }\n        *result = 6;\n      }\n    }\n    break;\n  case 'S':\n  case 's':\n    if ((flags & 8) == 0) {\n      iVar1 = opt_format_error(s,flags);\n      return iVar1;\n    }\n    *result = 0x8007;\n    break;\n  case 'T':\n  case 't':\n    if ((flags & 0x100) == 0) {\n      iVar1 = opt_format_error(s,flags);\n      return iVar1;\n    }\n    *result = 0x8001;\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is opt_format"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](uint32_t sd)\n\n{\n  int i;\n  uint mod;\n  int32_t s;\n  \n  test_random_state[0] = sd;\n  for (i = 1; i < 0x1f; i = i + 1) {\n    test_random_state[i] = (uint32_t)(((long)(int)test_random_state[i + -1] * 0x41a7) % 0x7fffffff);\n  }\n  for (i = 0x22; i < 0x158; i = i + 1) {\n    test_random();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is test_random_seed"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  return;\n}\n\n",
        "output": "The predicted function name is cleanup_tests"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *desc,...)\n\n{\n  long lVar1;\n  char in_AL;\n  undefined8 in_RCX;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  va_list ap;\n  undefined local_b8 [24];\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  ap[0].gp_offset = 0x18;\n  ap[0].fp_offset = 0x30;\n  ap[0].overflow_arg_area = &stack0x00000008;\n  ap[0].reg_save_area = local_b8;\n  local_a0 = in_RCX;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  test_fail_message_va(\"SKIP\",file,line,(char *)0x0,(char *)0x0,(char *)0x0,(char *)0x0,desc,ap);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return 0x7b;\n}\n\n",
        "output": "The predicted function name is test_skip"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *value,ulong *result)\n\n{\n  int iVar1;\n  int *piVar2;\n  long in_FS_OFFSET;\n  int oerrno;\n  char *endptr;\n  ulong l;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  piVar2 = __errno_location();\n  *piVar2 = 0;\n  l = strtoul(value,&endptr,0);\n  if ((*endptr == '\\0') && (value != endptr)) {\n    if (l == 0xffffffffffffffff) {\n      piVar2 = __errno_location();\n      if (*piVar2 == 0x22) goto LAB_00005703;\n    }\n    if (l == 0) {\n      piVar2 = __errno_location();\n      if (*piVar2 != 0) goto LAB_00005703;\n    }\n    *result = l;\n    piVar2 = __errno_location();\n    *piVar2 = iVar1;\n    iVar1 = 1;\n  }\n  else {\nLAB_00005703:\n    opt_number_error(value);\n    piVar2 = __errno_location();\n    *piVar2 = iVar1;\n    iVar1 = 0;\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is opt_ulong"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,double t1,double t2)\n\n{\n  if (t1 == t2) {\n    test_fail_message((char *)t1,(char *)t2,0,file,line,\"double\",s1,s2,&DAT_0000f7a1,\n                      \"[%g] compared to [%g]\");\n  }\n  return (uint)(t1 != t2);\n}\n\n",
        "output": "The predicted function name is test_double_ne"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *name,char *testname,char *itname)\n\n{\n  int iVar1;\n  int i;\n  \n  if (name != (char *)0x0) {\n    for (i = 0; i < num_tests; i = i + 1) {\n      iVar1 = strcmp(name,all_tests[i].test_case_name);\n      if (iVar1 == 0) {\n        single_test = i + 1;\n        break;\n      }\n    }\n    if (num_tests <= i) {\n      single_test = atoi(name);\n    }\n  }\n  if ((single_test == -1) && (single_iter != -1)) {\n    single_test = 1;\n  }\n  if ((single_test != -1) && ((single_test < 1 || (num_tests < single_test)))) {\n    test_printf_stderr(\"Invalid -%s value (Value must be a valid test name OR a value between %d..%d)\\n\"\n                       ,testname,1,(ulong)(uint)num_tests);\n    return 0;\n  }\n  if (single_iter != -1) {\n    if (all_tests[single_test + -1].num == -1) {\n      test_printf_stderr(\"-%s option is not valid for test %d:%s\\n\",itname,(ulong)(uint)single_test,\n                         all_tests[single_test + -1].test_case_name);\n      return 0;\n    }\n    if ((single_iter < 1) || (all_tests[single_test + -1].num < single_iter)) {\n      test_printf_stderr(\"Invalid -%s value for test %d:%s\\t(Value must be in the range %d..%d)\\n\",\n                         itname,(ulong)(uint)single_test,all_tests[single_test + -1].test_case_name,\n                         1,(ulong)(uint)all_tests[single_test + -1].num);\n      return 0;\n    }\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is check_single_test_params"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s,BIGNUM *a)\n\n{\n  int iVar1;\n  \n  if ((a != (BIGNUM *)0x0) && (iVar1 = BN_is_zero(a), iVar1 != 0)) {\n    return 1;\n  }\n  test_fail_bignum_mono_message((char *)0x0,file,line,\"BIGNUM\",s,\"0\",\"==\",a);\n  return 0;\n}\n\n",
        "output": "The predicted function name is test_BN_eq_zero"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s,BIGNUM *a)\n\n{\n  int iVar1;\n  \n  if (a == (BIGNUM *)0x0) {\nLAB_0000b059:\n    test_fail_bignum_mono_message((char *)0x0,file,line,\"BIGNUM\",s,\"0\",\">=\",a);\n    iVar1 = 0;\n  }\n  else {\n    iVar1 = BN_is_negative(a);\n    if (iVar1 != 0) {\n      iVar1 = BN_is_zero(a);\n      if (iVar1 == 0) goto LAB_0000b059;\n    }\n    iVar1 = 1;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is test_BN_ge_zero"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,long t1,long t2)\n\n{\n  if (t1 != t2) {\n    test_fail_message((char *)0x0,file,line,\"long\",s1,s2,\"==\",\"[%ld] compared to [%ld]\",t1,t2);\n  }\n  return (int)(t1 == t2);\n}\n\n",
        "output": "The predicted function name is test_long_eq"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s,int b)\n\n{\n  if (b == 0) {\n    test_fail_message((char *)0x0,file,line,\"bool\",s,\"true\",\"==\",\"false\");\n  }\n  return (int)(b != 0);\n}\n\n",
        "output": "The predicted function name is test_true"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,uint t1,uint t2)\n\n{\n  if (t1 <= t2) {\n    test_fail_message((char *)0x0,file,line,\"unsigned int\",s1,s2,\">\",\"[%u] compared to [%u]\",\n                      (ulong)t1,(ulong)t2);\n  }\n  return (int)(t2 < t1);\n}\n\n",
        "output": "The predicted function name is test_uint_gt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *name,uchar *m,size_t l)\n\n{\n  test_fail_memory_common(\"memory\",(char *)0x0,0,(char *)0x0,(char *)0x0,(char *)0x0,name,m,l,m,l);\n  return;\n}\n\n",
        "output": "The predicted function name is test_output_memory"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *file,int line,char *desc,...)\n\n{\n  long lVar1;\n  char in_AL;\n  undefined8 in_RCX;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  va_list ap;\n  undefined local_b8 [24];\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  ap[0].gp_offset = 0x18;\n  ap[0].fp_offset = 0x30;\n  ap[0].overflow_arg_area = &stack0x00000008;\n  ap[0].reg_save_area = local_b8;\n  local_a0 = in_RCX;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  test_fail_message_va\n            ((char *)0x0,file,line,(char *)0x0,(char *)0x0,(char *)0x0,(char *)0x0,desc,ap);\n  test_printf_stderr(\"\\n\");\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is test_error"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,uchar t1,uchar t2)\n\n{\n  if (t1 <= t2) {\n    test_fail_message((char *)0x0,file,line,\"unsigned char\",s1,s2,\">\",\"[%u] compared to [%u]\",\n                      (ulong)t1,(ulong)t2);\n  }\n  return (int)(t2 < t1);\n}\n\n",
        "output": "The predicted function name is test_uchar_gt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *desc,...)\n\n{\n  long lVar1;\n  char in_AL;\n  undefined8 in_RCX;\n  undefined8 in_RDX;\n  undefined8 in_RSI;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  va_list ap;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  ap[0].gp_offset = 8;\n  ap[0].fp_offset = 0x30;\n  ap[0].overflow_arg_area = &stack0x00000008;\n  ap[0].reg_save_area = local_b8;\n  local_b0 = in_RSI;\n  local_a8 = in_RDX;\n  local_a0 = in_RCX;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  test_fail_message_va\n            (\"SKIP\",(char *)0x0,-1,(char *)0x0,(char *)0x0,(char *)0x0,(char *)0x0,desc,ap);\n  test_printf_stderr(\"\\n\");\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return 0x7b;\n}\n\n",
        "output": "The predicted function name is test_skip_c90"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  byte bVar1;\n  int iVar2;\n  OPENSSL_sk_freefunc *pOVar3;\n  OPENSSL_STACK *pOVar4;\n  int testresult;\n  IPAddrBlocks *addr;\n  ASN1_OCTET_STRING *ip1;\n  ASN1_OCTET_STRING *ip2;\n  size_t i;\n  \n  testresult = 0;\n  i = 0;\n  while( true ) {\n    ip2 = (ASN1_OCTET_STRING *)0x0;\n    ip1 = (ASN1_OCTET_STRING *)0x0;\n    addr = (IPAddrBlocks *)0x0;\n    if (0x11 < i) break;\n    addr = (IPAddrBlocks *)OPENSSL_sk_new_null();\n    iVar2 = test_ptr(\"test/v3ext.c\",0xb7,\"addr\",addr);\n    if (iVar2 == 0) goto end;\n    iVar2 = X509v3_addr_canonize(addr);\n    iVar2 = test_true(\"test/v3ext.c\",0xbd,\"X509v3_addr_canonize(addr)\",(uint)(iVar2 != 0));\n    if (iVar2 == 0) goto end;\n    ip1 = (ASN1_OCTET_STRING *)a2i_IPADDRESS(ranges[i].ip1);\n    iVar2 = test_ptr(\"test/v3ext.c\",0xc1,\"ip1\",ip1);\n    if (iVar2 == 0) goto end;\n    if ((((ASN1_OCTET_STRING *)ip1)->length == 4) || (((ASN1_OCTET_STRING *)ip1)->length == 0x10)) {\n      bVar1 = 1;\n    }\n    else {\n      bVar1 = 0;\n    }\n    iVar2 = test_true(\"test/v3ext.c\",0xc3,\"ip1->length == 4 || ip1->length == 16\",(uint)bVar1);\n    if (iVar2 == 0) goto end;\n    ip2 = (ASN1_OCTET_STRING *)a2i_IPADDRESS(ranges[i].ip2);\n    iVar2 = test_ptr(\"test/v3ext.c\",0xc6,\"ip2\",ip2);\n    if ((iVar2 == 0) ||\n       (iVar2 = test_int_eq(\"test/v3ext.c\",200,\"ip2->length\",\"ip1->length\",\n                            ((ASN1_OCTET_STRING *)ip2)->length,((ASN1_OCTET_STRING *)ip1)->length),\n       iVar2 == 0)) goto end;\n    iVar2 = memcmp(((ASN1_OCTET_STRING *)ip1)->data,((ASN1_OCTET_STRING *)ip2)->data,\n                   (long)((ASN1_OCTET_STRING *)ip1)->length);\n    iVar2 = test_true(\"test/v3ext.c\",0xca,\"memcmp(ip1->data, ip2->data, ip1->length) <= 0\",\n                      (uint)(iVar2 < 1));\n    if (iVar2 == 0) goto end;\n    iVar2 = X509v3_addr_add_range(addr,ranges[i].afi,0);\n    iVar2 = test_true(\"test/v3ext.c\",0xcd,\n                      \"X509v3_addr_add_range(addr, ranges[i].afi, NULL, ip1->data, ip2->data)\",\n                      (uint)(iVar2 != 0));\n    if (iVar2 == 0) goto end;\n    iVar2 = X509v3_addr_is_canonical(addr);\n    iVar2 = test_true(\"test/v3ext.c\",0xd0,\"X509v3_addr_is_canonical(addr)\",(uint)(iVar2 != 0));\n    if ((iVar2 == 0) || (iVar2 = check_addr(addr,ranges[i].rorp), iVar2 == 0)) goto end;\n    pOVar3 = ossl_check_IPAddressFamily_freefunc_type\n                       ((sk_IPAddressFamily_freefunc *)PTR_IPAddressFamily_free_00212fd0);\n    pOVar4 = ossl_check_IPAddressFamily_sk_type(addr);\n    OPENSSL_sk_pop_free(pOVar4,pOVar3);\n    ASN1_OCTET_STRING_free((ASN1_OCTET_STRING *)ip1);\n    ASN1_OCTET_STRING_free((ASN1_OCTET_STRING *)ip2);\n    i = i + 1;\n  }\n  testresult = 1;\nend:\n  pOVar3 = ossl_check_IPAddressFamily_freefunc_type\n                     ((sk_IPAddressFamily_freefunc *)PTR_IPAddressFamily_free_00212fd0);\n  pOVar4 = ossl_check_IPAddressFamily_sk_type(addr);\n  OPENSSL_sk_pop_free(pOVar4,pOVar3);\n  ASN1_OCTET_STRING_free((ASN1_OCTET_STRING *)ip1);\n  ASN1_OCTET_STRING_free((ASN1_OCTET_STRING *)ip2);\n  return testresult;\n}\n\n",
        "output": "The predicted function name is test_addr_ranges"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,uint t1,uint t2)\n\n{\n  if (t1 < t2) {\n    test_fail_message((char *)0x0,file,line,\"unsigned int\",s1,s2,\">=\",\"[%u] compared to [%u]\",\n                      (ulong)t1,(ulong)t2);\n  }\n  return (int)(t1 >= t2);\n}\n\n",
        "output": "The predicted function name is test_uint_ge"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,long t1,long t2)\n\n{\n  if (t1 < t2) {\n    test_fail_message((char *)0x0,file,line,\"long\",s1,s2,\">=\",\"[%ld] compared to [%ld]\",t1,t2);\n  }\n  return (int)(t1 >= t2);\n}\n\n",
        "output": "The predicted function name is test_long_ge"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int argc,char **argv)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *__nptr;\n  OPTIONS *o;\n  char *test_seed;\n  char *TAP_levels;\n  \n  pcVar2 = getenv(\"OPENSSL_TEST_RAND_ORDER\");\n  __nptr = getenv(\"HARNESS_OSSL_LEVEL\");\n  if (__nptr != (char *)0x0) {\n    iVar1 = atoi(__nptr);\n    level = iVar1 << 2;\n  }\n  test_adjust_streams_tap_level(level);\n  if (pcVar2 == (char *)0x0) {\n    set_seed(0);\n  }\n  else {\n    rand_order = 1;\n    iVar1 = atoi(pcVar2);\n    set_seed(iVar1);\n  }\n  o = test_get_options();\n  pcVar2 = opt_init(argc,argv,o);\n  return (int)(pcVar2 != (char *)0x0);\n}\n\n",
        "output": "The predicted function name is setup_test_framework"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](size_t n)\n\n{\n  int iVar1;\n  char **ppcVar2;\n  char *pcVar3;\n  char **argv;\n  \n  ppcVar2 = opt_rest();\n  if (399 < n) {\n    OPENSSL_die(\"assertion failed: n < sizeof(used)\",\"test/testutil/options.c\",0x2b);\n  }\n  iVar1 = opt_num_rest();\n  if (((int)n < iVar1) && (ppcVar2 != (char **)0x0)) {\n    used[n] = 1;\n    pcVar3 = ppcVar2[n];\n  }\n  else {\n    pcVar3 = (char *)0x0;\n  }\n  return pcVar3;\n}\n\n",
        "output": "The predicted function name is test_get_argument"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,BIGNUM *t1,BIGNUM *t2)\n\n{\n  int iVar1;\n  \n  iVar1 = BN_cmp((BIGNUM *)t1,(BIGNUM *)t2);\n  if (-1 < iVar1) {\n    test_fail_bignum_message((char *)0x0,file,line,\"BIGNUM\",s1,s2,\"<\",t1,t2);\n  }\n  return (int)(-1 >= iVar1);\n}\n\n",
        "output": "The predicted function name is test_BN_lt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *desc,...)\n\n{\n  long lVar1;\n  char in_AL;\n  undefined8 in_RCX;\n  undefined8 in_RDX;\n  undefined8 in_RSI;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  va_list ap;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  ap[0].gp_offset = 8;\n  ap[0].fp_offset = 0x30;\n  ap[0].overflow_arg_area = &stack0x00000008;\n  ap[0].reg_save_area = local_b8;\n  local_b0 = in_RSI;\n  local_a8 = in_RDX;\n  local_a0 = in_RCX;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  test_fail_message_va\n            (\"INFO\",(char *)0x0,-1,(char *)0x0,(char *)0x0,(char *)0x0,(char *)0x0,desc,ap);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is test_info_c90"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int i;\n  char **pp;\n  \n  i = 0;\n  for (pp = opt_rest(); *pp != (char *)0x0; pp = pp + 1) {\n    i = i + 1;\n  }\n  return i;\n}\n\n",
        "output": "The predicted function name is opt_num_rest"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,ulong t1,ulong t2)\n\n{\n  if (t1 != t2) {\n    test_fail_message((char *)0x0,file,line,\"unsigned long\",s1,s2,\"==\",\"[%lu] compared to [%lu]\",t1,\n                      t2);\n  }\n  return (int)(t1 == t2);\n}\n\n",
        "output": "The predicted function name is test_ulong_eq"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nsize_t [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = opt_num_rest();\n  return (long)iVar1;\n}\n\n",
        "output": "The predicted function name is test_get_argument_count"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *fmt,...)\n\n{\n  long lVar1;\n  char in_AL;\n  undefined8 in_RCX;\n  undefined8 in_RDX;\n  undefined8 in_RSI;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  va_list ap;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  local_b0 = in_RSI;\n  local_a8 = in_RDX;\n  local_a0 = in_RCX;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  if (fmt != (char *)0x0) {\n    ap[0].gp_offset = 8;\n    ap[0].fp_offset = 0x30;\n    ap[0].overflow_arg_area = &stack0x00000008;\n    ap[0].reg_save_area = local_b8;\n    test_vprintf_stderr(fmt,ap);\n    test_printf_stderr(\"\\n\");\n  }\n  test_flush_stderr();\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is test_note"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s,BIGNUM *a)\n\n{\n  int iVar1;\n  \n  if (((a != (BIGNUM *)0x0) && (iVar1 = BN_is_negative(a), iVar1 != 0)) &&\n     (iVar1 = BN_is_zero(a), iVar1 == 0)) {\n    return 1;\n  }\n  test_fail_bignum_mono_message((char *)0x0,file,line,\"BIGNUM\",s,\"0\",\"<\",a);\n  return 0;\n}\n\n",
        "output": "The predicted function name is test_BN_lt_zero"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  long lVar1;\n  \n  lVar1 = BIO_ctrl((BIO *)tap_out,0xb,0,(void *)0x0);\n  return (int)lVar1;\n}\n\n",
        "output": "The predicted function name is test_flush_tapout"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,char t1,char t2)\n\n{\n  if (t1 != t2) {\n    test_fail_message((char *)0x0,file,line,\"char\",s1,s2,\"==\",\"[%c] compared to [%c]\",\n                      (ulong)(uint)(int)t1,(ulong)(uint)(int)t2);\n  }\n  return (int)(t1 == t2);\n}\n\n",
        "output": "The predicted function name is test_char_eq"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](OPTIONS *o,int doingparams,int width)\n\n{\n  char *fmt;\n  char *pcVar1;\n  size_t sVar2;\n  long in_FS_OFFSET;\n  char *p;\n  char *help;\n  char start [81];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (o->helpstr == (char *)0x0) {\n    fmt = \"(No additional info)\";\n  }\n  else {\n    fmt = o->helpstr;\n  }\n  if ((undefined3 *)o->name == &OPT_HELP_STR) {\n    opt_printf_stderr(fmt,prog);\n  }\n  else if ((undefined3 *)o->name == &OPT_SECTION_STR) {\n    opt_printf_stderr(\"\\n\");\n    opt_printf_stderr(fmt,prog);\n  }\n  else if ((undefined3 *)o->name == &OPT_PARAM_STR) {\n    opt_printf_stderr(\"\\nParameters:\\n\");\n  }\n  else {\n    memset(start,0x20,0x50);\n    start[80] = '\\0';\n    if ((undefined3 *)o->name == &OPT_MORE_STR) {\n      start[width] = '\\0';\n      opt_printf_stderr(\"%s  %s\\n\",start,fmt);\n    }\n    else {\n      p = start + 1;\n      start[0] = ' ';\n      if (doingparams == 0) {\n        p = start + 2;\n        start[1] = '-';\n      }\n      if (*o->name == '\\0') {\n        *p = '*';\n        p = p + 1;\n      }\n      else {\n        pcVar1 = strcpy(p,o->name);\n        sVar2 = strlen(pcVar1);\n        p = p + sVar2;\n      }\n      if (o->valtype != 0x2d) {\n        *p = ' ';\n        pcVar1 = valtype2param(o);\n        pcVar1 = strcpy(p + 1,pcVar1);\n        sVar2 = strlen(pcVar1);\n        p = p + 1 + sVar2;\n      }\n      *p = ' ';\n      if (0x1d < (int)p - ((int)register0x00000020 + -0x68)) {\n        *p = '\\0';\n        opt_printf_stderr(\"%s\\n\",start);\n        memset(start,0x20,0x51);\n      }\n      start[width] = '\\0';\n      opt_printf_stderr(\"%s  %s\\n\",start,fmt);\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is opt_print"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s,BIGNUM *a)\n\n{\n  int iVar1;\n  \n  if ((a != (BIGNUM *)0x0) && (iVar1 = BN_is_odd(a), iVar1 != 0)) {\n    return 1;\n  }\n  test_fail_bignum_mono_message((char *)0x0,file,line,\"BIGNUM\",\"ODD(\",\")\",s,a);\n  return 0;\n}\n\n",
        "output": "The predicted function name is test_BN_odd"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](OPTIONS *o)\n\n{\n  char *pcVar1;\n  \n  switch(o->valtype) {\n  case 0:\n  case 0x2d:\n    pcVar1 = \"\";\n    break;\n  default:\n    pcVar1 = \"parm\";\n    break;\n  case 0x2f:\n    pcVar1 = \"dir\";\n    break;\n  case 0x3a:\n    pcVar1 = \"uri\";\n    break;\n  case 0x3c:\n    pcVar1 = \"infile\";\n    break;\n  case 0x3e:\n    pcVar1 = \"outfile\";\n    break;\n  case 0x45:\n    pcVar1 = \"PEM|DER|ENGINE\";\n    break;\n  case 0x46:\n    pcVar1 = \"PEM|DER\";\n    break;\n  case 0x4d:\n    pcVar1 = \"intmax\";\n    break;\n  case 0x4e:\n    pcVar1 = \"nonneg\";\n    break;\n  case 0x55:\n    pcVar1 = \"uintmax\";\n    break;\n  case 0x66:\n    pcVar1 = \"format\";\n    break;\n  case 0x6c:\n    pcVar1 = \"long\";\n    break;\n  case 0x6e:\n    pcVar1 = \"int\";\n    break;\n  case 0x70:\n    pcVar1 = \"+int\";\n    break;\n  case 0x73:\n    pcVar1 = \"val\";\n    break;\n  case 0x75:\n    pcVar1 = \"ulong\";\n  }\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is valtype2param"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,ulong t1,ulong t2)\n\n{\n  if (t1 < t2) {\n    test_fail_message((char *)0x0,file,line,\"unsigned long\",s1,s2,\">=\",\"[%lu] compared to [%lu]\",t1,\n                      t2);\n  }\n  return (int)(t1 >= t2);\n}\n\n",
        "output": "The predicted function name is test_ulong_ge"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,double t1,double t2)\n\n{\n  if (t2 < t1) {\n    test_fail_message((char *)t1,(char *)t2,0,file,line,\"double\",s1,s2,&DAT_0000f7a6,\n                      \"[%g] compared to [%g]\");\n  }\n  return (int)(t2 >= t1);\n}\n\n",
        "output": "The predicted function name is test_double_le"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,char t1,char t2)\n\n{\n  if (t1 < t2) {\n    test_fail_message((char *)0x0,file,line,\"char\",s1,s2,\">=\",\"[%c] compared to [%c]\",\n                      (ulong)(uint)(int)t1,(ulong)(uint)(int)t2);\n  }\n  return (int)(t1 >= t2);\n}\n\n",
        "output": "The predicted function name is test_char_ge"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nOPENSSL_STACK * [MASK](stack_st_IPAddressFamily *sk)\n\n{\n  return (OPENSSL_STACK *)sk;\n}\n\n",
        "output": "The predicted function name is ossl_check_const_IPAddressFamily_sk_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,long t1,long t2)\n\n{\n  if (t1 <= t2) {\n    test_fail_message((char *)0x0,file,line,\"long\",s1,s2,\">\",\"[%ld] compared to [%ld]\",t1,t2);\n  }\n  return (int)(t2 < t1);\n}\n\n",
        "output": "The predicted function name is test_long_gt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK]\n               (char *prefix,char *file,int line,char *type,char *left,char *right,char *op,char *m1\n               ,size_t l1,char *m2,size_t l2)\n\n{\n  bool bVar1;\n  char cVar2;\n  int iVar3;\n  long lVar4;\n  ulong uVar5;\n  ushort **ppuVar6;\n  size_t sVar7;\n  char *pcVar8;\n  long lVar9;\n  long in_FS_OFFSET;\n  char *local_1a0;\n  char *local_198;\n  uint cnt;\n  uint diff;\n  size_t n1;\n  size_t n2;\n  size_t i;\n  size_t width;\n  size_t j;\n  char b1 [81];\n  char b2 [81];\n  char bdiff [81];\n  long local_10;\n  \n  local_198 = m1;\n  local_1a0 = m2;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar4 = BIO_ctrl((BIO *)bio_err,0x51,0,(void *)0x0);\n  lVar9 = -lVar4 + 0x44;\n  if (lVar9 < 0) {\n    lVar9 = -lVar4 + 0x53;\n  }\n  uVar5 = (lVar9 >> 4) << 4;\n  cnt = 0;\n  test_fail_message_prefix(prefix,file,line,type,left,right,op);\n  if (m1 == (char *)0x0) {\n    l1 = 0;\n  }\n  if (m2 == (char *)0x0) {\n    l2 = 0;\n  }\n  if ((l1 == 0) && (l2 == 0)) {\n    if ((m2 == (char *)0x0) == (m1 != (char *)0x0)) {\n      test_diff_header(left,right);\n      test_string_null_empty(m1,'-');\n      test_string_null_empty(m2,'+');\n    }\n    else {\n      test_string_null_empty(m1,' ');\n    }\n  }\n  else {\n    if ((l1 != l2) || (iVar3 = strncmp(m1,m2,l1), iVar3 != 0)) {\n      test_diff_header(left,right);\n    }\n    for (; (l1 != 0 || (l2 != 0)); l2 = l2 - n2) {\n      n2 = 0;\n      n1 = 0;\n      if (l1 != 0) {\n        n1 = uVar5;\n        if (l1 <= uVar5) {\n          n1 = l1;\n        }\n        b1[n1] = '\\0';\n        for (i = 0; i < n1; i = i + 1) {\n          ppuVar6 = __ctype_b_loc();\n          if (((*ppuVar6)[(byte)local_198[i]] & 0x4000) == 0) {\n            cVar2 = '.';\n          }\n          else {\n            cVar2 = local_198[i];\n          }\n          b1[i] = cVar2;\n        }\n      }\n      if (l2 != 0) {\n        n2 = uVar5;\n        if (l2 <= uVar5) {\n          n2 = l2;\n        }\n        b2[n2] = '\\0';\n        for (i = 0; i < n2; i = i + 1) {\n          ppuVar6 = __ctype_b_loc();\n          if (((*ppuVar6)[(byte)local_1a0[i]] & 0x4000) == 0) {\n            cVar2 = '.';\n          }\n          else {\n            cVar2 = local_1a0[i];\n          }\n          b2[i] = cVar2;\n        }\n      }\n      bVar1 = false;\n      i = 0;\n      if ((n1 != 0) && (n2 != 0)) {\n        sVar7 = n1;\n        if (n2 <= n1) {\n          sVar7 = n2;\n        }\n        for (; i < sVar7; i = i + 1) {\n          if (local_198[i] == local_1a0[i]) {\n            bdiff[i] = ' ';\n          }\n          else {\n            bdiff[i] = '^';\n            bVar1 = true;\n          }\n        }\n        bdiff[i] = '\\0';\n      }\n      if ((n1 != n2) || (bVar1)) {\n        if ((cnt == 0) && ((local_198 == (char *)0x0 || (*local_198 == '\\0')))) {\n          test_string_null_empty(local_198,'-');\n        }\n        else if (n1 != 0) {\n          test_printf_stderr(\"%4u:- \\'%s\\'\\n\",(ulong)cnt,b1);\n        }\n        if ((cnt == 0) && ((local_1a0 == (char *)0x0 || (*local_1a0 == '\\0')))) {\n          test_string_null_empty(local_1a0,'+');\n        }\n        else if (n2 != 0) {\n          test_printf_stderr(\"%4u:+ \\'%s\\'\\n\",(ulong)cnt,b2);\n        }\n        if ((bVar1) && (i != 0)) {\n          test_printf_stderr(\"%4s    %s\\n\",&DAT_0000f988,bdiff);\n        }\n      }\n      else {\n        if (n1 < n2) {\n          pcVar8 = b2;\n        }\n        else {\n          pcVar8 = b1;\n        }\n        test_printf_stderr(\"%4u:  \\'%s\\'\\n\",(ulong)cnt,pcVar8);\n      }\n      if (local_198 != (char *)0x0) {\n        local_198 = local_198 + n1;\n      }\n      if (local_1a0 != (char *)0x0) {\n        local_1a0 = local_1a0 + n2;\n      }\n      l1 = l1 - n1;\n      cnt = cnt + (int)uVar5;\n    }\n  }\n  test_flush_stderr();\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_fail_string_common"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,uint t1,uint t2)\n\n{\n  if (t1 != t2) {\n    test_fail_message((char *)0x0,file,line,\"unsigned int\",s1,s2,\"==\",\"[%u] compared to [%u]\",\n                      (ulong)t1,(ulong)t2);\n  }\n  return (int)(t1 == t2);\n}\n\n",
        "output": "The predicted function name is test_uint_eq"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,uchar t1,uchar t2)\n\n{\n  if (t1 != t2) {\n    test_fail_message((char *)0x0,file,line,\"unsigned char\",s1,s2,\"==\",\"[%u] compared to [%u]\",\n                      (ulong)t1,(ulong)t2);\n  }\n  return (int)(t1 == t2);\n}\n\n",
        "output": "The predicted function name is test_uchar_eq"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,BIGNUM *t1,BIGNUM *t2)\n\n{\n  int iVar1;\n  \n  iVar1 = BN_cmp((BIGNUM *)t1,(BIGNUM *)t2);\n  if (0 < iVar1) {\n    test_fail_bignum_message((char *)0x0,file,line,\"BIGNUM\",s1,s2,\"<=\",t1,t2);\n  }\n  return (int)(iVar1 < 1);\n}\n\n",
        "output": "The predicted function name is test_BN_le"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *bns,char *ws,BIGNUM *a,ulong w)\n\n{\n  int iVar1;\n  BIGNUM *b;\n  BIGNUM *a_00;\n  BIGNUM *aa;\n  BIGNUM *bw;\n  \n  if ((a != (BIGNUM *)0x0) && (iVar1 = BN_abs_is_word(a,w), iVar1 != 0)) {\n    return 1;\n  }\n  b = BN_dup((BIGNUM *)a);\n  if (b != (BIGNUM *)0x0) {\n    BN_set_negative(b,0);\n  }\n  a_00 = BN_new();\n  if (a_00 != (BIGNUM *)0x0) {\n    BN_set_word(a_00,w);\n  }\n  test_fail_bignum_message((char *)0x0,file,line,\"BIGNUM\",bns,ws,\"abs==\",(BIGNUM *)b,(BIGNUM *)a_00)\n  ;\n  BN_free(a_00);\n  BN_free(b);\n  return 0;\n}\n\n",
        "output": "The predicted function name is test_BN_abs_eq_word"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,char t1,char t2)\n\n{\n  if (t2 < t1) {\n    test_fail_message((char *)0x0,file,line,\"char\",s1,s2,\"<=\",\"[%c] compared to [%c]\",\n                      (ulong)(uint)(int)t1,(ulong)(uint)(int)t2);\n  }\n  return (int)(t1 <= t2);\n}\n\n",
        "output": "The predicted function name is test_char_le"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,int t1,int t2)\n\n{\n  if (t1 != t2) {\n    test_fail_message((char *)0x0,file,line,\"int\",s1,s2,\"==\",\"[%d] compared to [%d]\",(ulong)(uint)t1\n                      ,(ulong)(uint)t2);\n  }\n  return (int)(t1 == t2);\n}\n\n",
        "output": "The predicted function name is test_int_eq"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int a,int b)\n\n{\n  int iVar1;\n  int local_20;\n  int local_1c;\n  int t;\n  \n  local_20 = b;\n  local_1c = a;\n  while (local_20 != 0) {\n    iVar1 = local_1c % local_20;\n    local_1c = local_20;\n    local_20 = iVar1;\n  }\n  return local_1c;\n}\n\n",
        "output": "The predicted function name is gcd"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *name,char **options)\n\n{\n  int iVar1;\n  char **p;\n  \n  p = options;\n  while( true ) {\n    if (*p == (char *)0x0) {\n      opt_printf_stderr(\"%s: Value must be one of:\\n\",prog);\n      for (p = options; *p != (char *)0x0; p = p + 1) {\n        opt_printf_stderr(\"\\t%s\\n\",*p);\n      }\n      return 0;\n    }\n    iVar1 = strcmp(*p,name);\n    if (iVar1 == 0) break;\n    p = p + 1;\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is opt_string"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *dir,char *file)\n\n{\n  size_t sVar1;\n  size_t sVar2;\n  size_t sVar3;\n  long lVar4;\n  char *pcVar5;\n  char *sep;\n  size_t dirlen;\n  size_t len;\n  char *full_file;\n  \n  if (dir == (char *)0x0) {\n    sVar1 = 0;\n  }\n  else {\n    sVar1 = strlen(dir);\n  }\n  sVar2 = strlen(\"/\");\n  sVar3 = strlen(file);\n  lVar4 = sVar3 + sVar2 + sVar1 + 1;\n  pcVar5 = (char *)CRYPTO_zalloc(lVar4,\"test/testutil/driver.c\",0x1bc);\n  if (pcVar5 != (char *)0x0) {\n    if ((dir != (char *)0x0) && (sVar1 != 0)) {\n      OPENSSL_strlcpy(pcVar5,dir,lVar4);\n      OPENSSL_strlcat(pcVar5,&DAT_0000f66a,lVar4);\n    }\n    OPENSSL_strlcat(pcVar5,file,lVar4);\n  }\n  return pcVar5;\n}\n\n",
        "output": "The predicted function name is test_mk_file_path"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  long lVar1;\n  \n  lVar1 = BIO_ctrl((BIO *)bio_out,0xb,0,(void *)0x0);\n  return (int)lVar1;\n}\n\n",
        "output": "The predicted function name is test_flush_stdout"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *st1,char *st2,char *s1,size_t n1,char *s2,size_t n2)\n\n{\n  int iVar1;\n  size_t l2;\n  size_t l1;\n  \n  if ((s2 == (char *)0x0) == (s1 == (char *)0x0)) {\n    if (((n1 == n2) && (s1 != (char *)0x0)) && (iVar1 = strncmp(s1,s2,n1), iVar1 != 0)) {\n      return 1;\n    }\n    if (s2 == (char *)0x0) {\n      l2 = 0;\n    }\n    else {\n      l2 = OPENSSL_strnlen(s2,n2);\n    }\n    if (s1 == (char *)0x0) {\n      l1 = 0;\n    }\n    else {\n      l1 = OPENSSL_strnlen(s1,n1);\n    }\n    test_fail_string_message((char *)0x0,file,line,\"string\",st1,st2,\"!=\",s1,l1,s2,l2);\n    iVar1 = 0;\n  }\n  else {\n    iVar1 = 1;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is test_strn_ne"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK]\n               (char *prefix,char *file,int line,char *type,char *left,char *right,char *op,char *m1\n               ,size_t l1,char *m2,size_t l2)\n\n{\n  test_fail_string_common(prefix,file,line,type,left,right,op,m1,l1,m2,l2);\n  test_printf_stderr(\"\\n\");\n  return;\n}\n\n",
        "output": "The predicted function name is test_fail_string_message"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s,BIGNUM *a)\n\n{\n  int iVar1;\n  \n  if (((a != (BIGNUM *)0x0) && (iVar1 = BN_is_negative(a), iVar1 == 0)) &&\n     (iVar1 = BN_is_zero(a), iVar1 == 0)) {\n    return 1;\n  }\n  test_fail_bignum_mono_message((char *)0x0,file,line,\"BIGNUM\",s,\"0\",\">\",a);\n  return 0;\n}\n\n",
        "output": "The predicted function name is test_BN_gt_zero"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,time_t t1,time_t t2)\n\n{\n  int iVar1;\n  ASN1_TIME *t;\n  ASN1_TIME *t_00;\n  char *pcVar2;\n  char *pcVar3;\n  int r;\n  ASN1_TIME *at1;\n  ASN1_TIME *at2;\n  \n  t = ASN1_TIME_set((ASN1_TIME *)0x0,t1);\n  t_00 = ASN1_TIME_set((ASN1_TIME *)0x0,t2);\n  if ((t != (ASN1_TIME *)0x0) && (t_00 != (ASN1_TIME *)0x0)) {\n    iVar1 = ASN1_TIME_compare(t,t_00);\n    if (iVar1 == 0) {\n      iVar1 = 1;\n      goto LAB_0000b646;\n    }\n  }\n  iVar1 = 0;\nLAB_0000b646:\n  if (iVar1 == 0) {\n    pcVar2 = print_time((ASN1_TIME *)t_00);\n    pcVar3 = print_time((ASN1_TIME *)t);\n    test_fail_message((char *)0x0,file,line,\"time_t\",s1,s2,\"==\",\"[%s] compared to [%s]\",pcVar3,\n                      pcVar2);\n  }\n  ASN1_STRING_free(t);\n  ASN1_STRING_free(t_00);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is test_time_t_eq"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,size_t t1,size_t t2)\n\n{\n  if (t1 != t2) {\n    test_fail_message((char *)0x0,file,line,\"size_t\",s1,s2,\"==\",\"[%zu] compared to [%zu]\",t1,t2);\n  }\n  return (int)(t1 == t2);\n}\n\n",
        "output": "The predicted function name is test_size_t_eq"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int verdict,char *description,...)\n\n{\n  long lVar1;\n  char in_AL;\n  char *pcVar2;\n  undefined8 in_RCX;\n  undefined8 in_RDX;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  va_list ap;\n  undefined local_b8 [16];\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  local_a8 = in_RDX;\n  local_a0 = in_RCX;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  test_flush_stdout();\n  test_flush_stderr();\n  if ((verdict == 0) && (seed != 0)) {\n    test_printf_tapout(\"# OPENSSL_TEST_RAND_ORDER=%d\\n\",(ulong)(uint)seed);\n  }\n  if (verdict == 0) {\n    pcVar2 = \"not ok\";\n  }\n  else {\n    pcVar2 = \"ok\";\n  }\n  test_printf_tapout(\"%s \",pcVar2);\n  ap[0].gp_offset = 0x10;\n  ap[0].fp_offset = 0x30;\n  ap[0].overflow_arg_area = &stack0x00000008;\n  ap[0].reg_save_area = local_b8;\n  test_vprintf_tapout(description,ap);\n  if (verdict == 0x7b) {\n    test_printf_tapout(\" # skipped\");\n  }\n  test_printf_tapout(\"\\n\");\n  test_flush_tapout();\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is test_verdict"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *desc,...)\n\n{\n  long lVar1;\n  char in_AL;\n  undefined8 in_RCX;\n  undefined8 in_RDX;\n  undefined8 in_RSI;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  va_list ap;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  ap[0].gp_offset = 8;\n  ap[0].fp_offset = 0x30;\n  ap[0].overflow_arg_area = &stack0x00000008;\n  ap[0].reg_save_area = local_b8;\n  local_b0 = in_RSI;\n  local_a8 = in_RDX;\n  local_a0 = in_RCX;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  test_fail_message_va\n            ((char *)0x0,(char *)0x0,-1,(char *)0x0,(char *)0x0,(char *)0x0,(char *)0x0,desc,ap);\n  test_printf_stderr(\"\\n\");\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is test_error_c90"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  long lVar1;\n  \n  lVar1 = BIO_ctrl((BIO *)tap_err,0xb,0,(void *)0x0);\n  return (int)lVar1;\n}\n\n",
        "output": "The predicted function name is test_flush_taperr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *test_case_name,anon_subr_int *test_fn)\n\n{\n  all_tests[num_tests].test_case_name = test_case_name;\n  all_tests[num_tests].test_fn = (anon_subr_int_for_test_fn *)test_fn;\n  all_tests[num_tests].num = -1;\n  num_tests = num_tests + 1;\n  num_test_cases = num_test_cases + 1;\n  return;\n}\n\n",
        "output": "The predicted function name is add_test"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](BIGNUM *bn,char sep)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *v;\n  char *suf;\n  \n  pcVar1 = test_bignum_zero_null(bn);\n  if (bn == (BIGNUM *)0x0) {\n    pcVar2 = \"\";\n  }\n  else {\n    pcVar2 = \":    0\";\n  }\n  test_printf_stderr(\"%c%*s%s\\n\",(ulong)(uint)(int)sep,0x43,pcVar1,pcVar2);\n  return;\n}\n\n",
        "output": "The predicted function name is test_bignum_zero_print"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *st1,char *st2,void *s1,size_t n1,void *s2,size_t n2)\n\n{\n  int iVar1;\n  \n  if ((s1 == (void *)0x0) && (s2 == (void *)0x0)) {\n    iVar1 = 1;\n  }\n  else {\n    if ((n1 == n2) &&\n       (((s1 != (void *)0x0 && (s2 != (void *)0x0)) && (iVar1 = memcmp(s1,s2,n1), iVar1 == 0)))) {\n      return 1;\n    }\n    test_fail_memory_message\n              ((char *)0x0,file,line,\"memory\",st1,st2,\"==\",(uchar *)s1,n1,(uchar *)s2,n2);\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is test_mem_eq"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,char t1,char t2)\n\n{\n  if (t2 <= t1) {\n    test_fail_message((char *)0x0,file,line,\"char\",s1,s2,\"<\",\"[%c] compared to [%c]\",\n                      (ulong)(uint)(int)t1,(ulong)(uint)(int)t2);\n  }\n  return (int)(t2 > t1);\n}\n\n",
        "output": "The predicted function name is test_char_lt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *argv0)\n\n{\n  size_t sVar1;\n  size_t len;\n  \n  sVar1 = strlen(prog);\n  if (argv0 != (char *)0x0) {\n    BIO_snprintf(prog + sVar1,0x27 - sVar1,\" %s\",argv0);\n  }\n  return prog;\n}\n\n",
        "output": "The predicted function name is opt_appname"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK]\n               (char *prefix,char *file,int line,char *type,char *left,char *right,char *op,\n               uchar *m1,size_t l1,uchar *m2,size_t l2)\n\n{\n  bool bVar1;\n  char *pcVar2;\n  int iVar3;\n  size_t sVar4;\n  long in_FS_OFFSET;\n  uchar *local_1b0;\n  uchar *local_1a8;\n  uint cnt;\n  uint diff;\n  char *p;\n  size_t n1;\n  size_t n2;\n  size_t i;\n  size_t bytes;\n  size_t j;\n  char b1 [81];\n  char b2 [81];\n  char bdiff [81];\n  long local_10;\n  \n  local_1a8 = m1;\n  local_1b0 = m2;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  bytes = 0x20;\n  cnt = 0;\n  test_fail_message_prefix(prefix,file,line,type,left,right,op);\n  if (m1 == (uchar *)0x0) {\n    l1 = 0;\n  }\n  if (m2 == (uchar *)0x0) {\n    l2 = 0;\n  }\n  if ((l1 == 0) && (l2 == 0)) {\n    if ((m2 == (uchar *)0x0) == (m1 != (uchar *)0x0)) {\n      test_diff_header(left,right);\n      test_memory_null_empty(m1,'-');\n      test_memory_null_empty(m2,'+');\n    }\n    else {\n      test_memory_null_empty(m1,' ');\n    }\n  }\n  else {\n    if ((l1 != l2) || ((m1 != m2 && (iVar3 = memcmp(m1,m2,l1), iVar3 != 0)))) {\n      test_diff_header(left,right);\n    }\n    for (; (l1 != 0 || (l2 != 0)); l2 = l2 - n2) {\n      n2 = 0;\n      n1 = 0;\n      if (l1 != 0) {\n        n1 = bytes;\n        if (l1 < 0x21) {\n          n1 = l1;\n        }\n        hex_convert_memory(local_1a8,n1,b1,8);\n      }\n      if (l2 != 0) {\n        n2 = bytes;\n        if (l2 < 0x21) {\n          n2 = l2;\n        }\n        hex_convert_memory(local_1b0,n2,b2,8);\n      }\n      bVar1 = false;\n      i = 0;\n      p = bdiff;\n      if ((n1 != 0) && (n2 != 0)) {\n        sVar4 = n1;\n        if (n2 <= n1) {\n          sVar4 = n2;\n        }\n        for (; pcVar2 = p, i < sVar4; i = i + 1) {\n          if (local_1a8[i] == local_1b0[i]) {\n            *p = ' ';\n            p[1] = ' ';\n          }\n          else {\n            *p = '^';\n            p[1] = '^';\n            bVar1 = true;\n          }\n          p = p + 2;\n          if ((((uint)i & 7) == 7) && (i != sVar4 - 1)) {\n            *p = ' ';\n            p = pcVar2 + 3;\n          }\n        }\n        *p = '\\0';\n      }\n      if ((n1 != n2) || (bVar1)) {\n        if ((cnt == 0) && ((local_1a8 == (uchar *)0x0 || (l1 == 0)))) {\n          test_memory_null_empty(local_1a8,'-');\n        }\n        else if (n1 != 0) {\n          test_printf_stderr(\"%04x:-%s\\n\",(ulong)cnt,b1);\n        }\n        if ((cnt == 0) && ((local_1b0 == (uchar *)0x0 || (l2 == 0)))) {\n          test_memory_null_empty(local_1b0,'+');\n        }\n        else if (n2 != 0) {\n          test_printf_stderr(\"%04x:+%s\\n\",(ulong)cnt,b2);\n        }\n        if ((bVar1) && (i != 0)) {\n          test_printf_stderr(\"%4s  %s\\n\",&DAT_0000f988,bdiff);\n        }\n      }\n      else {\n        test_printf_stderr(\"%04x: %s\\n\",(ulong)cnt,b1);\n      }\n      if (local_1a8 != (uchar *)0x0) {\n        local_1a8 = local_1a8 + n1;\n      }\n      if (local_1b0 != (uchar *)0x0) {\n        local_1b0 = local_1b0 + n2;\n      }\n      l1 = l1 - n1;\n      cnt = cnt + 0x20;\n    }\n  }\n  test_flush_stderr();\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_fail_memory_common"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,BIGNUM *t1,BIGNUM *t2)\n\n{\n  int iVar1;\n  \n  iVar1 = BN_cmp((BIGNUM *)t1,(BIGNUM *)t2);\n  if (iVar1 != 0) {\n    test_fail_bignum_message((char *)0x0,file,line,\"BIGNUM\",s1,s2,\"==\",t1,t2);\n  }\n  return (int)(iVar1 == 0);\n}\n\n",
        "output": "The predicted function name is test_BN_eq"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  BIO_free((BIO *)bio_out);\n  BIO_free((BIO *)bio_err);\n  BIO_free_all((BIO *)tap_out);\n  BIO_free_all((BIO *)tap_err);\n  return;\n}\n\n",
        "output": "The predicted function name is test_close_streams"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,int t1,int t2)\n\n{\n  if (t1 < t2) {\n    test_fail_message((char *)0x0,file,line,\"int\",s1,s2,\">=\",\"[%d] compared to [%d]\",(ulong)(uint)t1\n                      ,(ulong)(uint)t2);\n  }\n  return (int)(t1 >= t2);\n}\n\n",
        "output": "The predicted function name is test_int_ge"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *name,EVP_CIPHER **cipherp)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  int ret;\n  int mode;\n  EVP_CIPHER *c;\n  ulong flags;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  ret = 0;\n  c = (EVP_CIPHER *)0x0;\n  iVar1 = opt_cipher_any(name,&c);\n  if (iVar1 != 0) {\n    iVar1 = EVP_CIPHER_get_mode(c);\n    flags = EVP_CIPHER_get_flags(c);\n    if (iVar1 == 0x10001) {\n      opt_printf_stderr(\"%s XTS ciphers not supported\\n\",prog);\n    }\n    else if ((flags & 0x200000) == 0) {\n      ret = 1;\n      if (cipherp != (EVP_CIPHER **)0x0) {\n        *cipherp = c;\n      }\n    }\n    else {\n      opt_printf_stderr(\"%s: AEAD ciphers not supported\\n\",prog);\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return ret;\n}\n\n",
        "output": "The predicted function name is opt_cipher"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  BIO *bp;\n  int ret;\n  X509 *x;\n  BIO *b;\n  long pathlen;\n  \n  x = (X509 *)0x0;\n  ret = 0;\n  bp = BIO_new_file(infile,\"r\");\n  iVar1 = test_ptr(\"test/v3ext.c\",0x1d,\"b = BIO_new_file(infile, \\\"r\\\")\",bp);\n  if (iVar1 != 0) {\n    x = (X509 *)PEM_read_bio_X509(bp,(X509 **)0x0,(undefined1 *)0x0,(void *)0x0);\n    iVar1 = test_ptr(\"test/v3ext.c\",0x1e,\"x = PEM_read_bio_X509(b, NULL, NULL, NULL)\",x);\n    if (iVar1 != 0) {\n      iVar1 = X509_get_pathlen(x);\n      iVar1 = test_int_eq(\"test/v3ext.c\",0x1f,\"pathlen = X509_get_pathlen(x)\",\"6\",iVar1,6);\n      if (iVar1 != 0) {\n        ret = 1;\n      }\n    }\n  }\n  BIO_free(bp);\n  X509_free((X509 *)x);\n  return ret;\n}\n\n",
        "output": "The predicted function name is test_pathlen"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,time_t t1,time_t t2)\n\n{\n  int iVar1;\n  ASN1_TIME *t;\n  ASN1_TIME *t_00;\n  char *pcVar2;\n  char *pcVar3;\n  int r;\n  ASN1_TIME *at1;\n  ASN1_TIME *at2;\n  \n  t = ASN1_TIME_set((ASN1_TIME *)0x0,t1);\n  t_00 = ASN1_TIME_set((ASN1_TIME *)0x0,t2);\n  if ((t != (ASN1_TIME *)0x0) && (t_00 != (ASN1_TIME *)0x0)) {\n    iVar1 = ASN1_TIME_compare(t,t_00);\n    if (-1 < iVar1) {\n      iVar1 = 1;\n      goto LAB_0000b95b;\n    }\n  }\n  iVar1 = 0;\nLAB_0000b95b:\n  if (iVar1 == 0) {\n    pcVar2 = print_time((ASN1_TIME *)t_00);\n    pcVar3 = print_time((ASN1_TIME *)t);\n    test_fail_message((char *)0x0,file,line,\"time_t\",s1,s2,\">=\",\"[%s] compared to [%s]\",pcVar3,\n                      pcVar2);\n  }\n  ASN1_STRING_free(t);\n  ASN1_STRING_free(t_00);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is test_time_t_ge"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *title)\n\n{\n  free(test_title);\n  if (title == (char *)0x0) {\n    test_title = (char *)0x0;\n  }\n  else {\n    test_title = strdup(title);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is set_test_title"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](void)\n\n{\n  return arg;\n}\n\n",
        "output": "The predicted function name is opt_arg"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,double t1,double t2)\n\n{\n  if (t1 < t2) {\n    test_fail_message((char *)t1,(char *)t2,0,file,line,\"double\",s1,s2,&DAT_0000f7ab,\n                      \"[%g] compared to [%g]\");\n  }\n  return (int)(t1 >= t2);\n}\n\n",
        "output": "The predicted function name is test_double_ge"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,time_t t1,time_t t2)\n\n{\n  int iVar1;\n  ASN1_TIME *t;\n  ASN1_TIME *t_00;\n  char *pcVar2;\n  char *pcVar3;\n  int r;\n  ASN1_TIME *at1;\n  ASN1_TIME *at2;\n  \n  t = ASN1_TIME_set((ASN1_TIME *)0x0,t1);\n  t_00 = ASN1_TIME_set((ASN1_TIME *)0x0,t2);\n  if ((t != (ASN1_TIME *)0x0) && (t_00 != (ASN1_TIME *)0x0)) {\n    iVar1 = ASN1_TIME_compare(t,t_00);\n    if (0 < iVar1) {\n      iVar1 = 1;\n      goto LAB_0000b854;\n    }\n  }\n  iVar1 = 0;\nLAB_0000b854:\n  if (iVar1 == 0) {\n    pcVar2 = print_time((ASN1_TIME *)t_00);\n    pcVar3 = print_time((ASN1_TIME *)t);\n    test_fail_message((char *)0x0,file,line,\"time_t\",s1,s2,\">\",\"[%s] compared to [%s]\",pcVar3,pcVar2\n                     );\n  }\n  ASN1_STRING_free(t);\n  ASN1_STRING_free(t_00);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is test_time_t_gt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  return 0;\n}\n\n",
        "output": "The predicted function name is opt_provider_option_given"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](uchar *m,char c)\n\n{\n  if (m == (uchar *)0x0) {\n    test_printf_stderr(\"%4s %c%s\\n\",&DAT_0000f988,(ulong)(uint)(int)c,&DAT_0000fa0c);\n  }\n  else {\n    test_printf_stderr(\"%04x %c%s\\n\",0,(ulong)(uint)(int)c,\"empty\");\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is test_memory_null_empty"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](ASN1_TIME *t)\n\n{\n  char *pcVar1;\n  \n  if (t == (ASN1_TIME *)0x0) {\n    pcVar1 = \"<null>\";\n  }\n  else {\n    pcVar1 = (char *)ASN1_STRING_get0_data(t);\n  }\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is print_time"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *name,EVP_MD **mdp)\n\n{\n  int iVar1;\n  char *pcVar2;\n  OSSL_LIB_CTX *pOVar3;\n  EVP_MD *md;\n  \n  ERR_set_mark();\n  pcVar2 = app_get0_propq();\n  pOVar3 = app_get0_libctx();\n  md = (EVP_MD *)EVP_MD_fetch(pOVar3,name,pcVar2);\n  if (md == (EVP_MD *)0x0) {\n    iVar1 = opt_legacy_okay();\n    if (iVar1 != 0) {\n      md = (EVP_MD *)EVP_get_digestbyname(name);\n      if ((EVP_MD *)md != (EVP_MD *)0x0) goto LAB_00004f9b;\n    }\n    ERR_clear_last_mark();\n    iVar1 = 0;\n  }\n  else {\nLAB_00004f9b:\n    ERR_pop_to_mark();\n    if (mdp == (EVP_MD **)0x0) {\n      EVP_MD_free(md);\n    }\n    else {\n      EVP_MD_free(*mdp);\n      *mdp = md;\n    }\n    iVar1 = 1;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is opt_md_silent"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](void)\n\n{\n  return dunno;\n}\n\n",
        "output": "The predicted function name is opt_unknown"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar ** [MASK](void)\n\n{\n  return argv + opt_index;\n}\n\n",
        "output": "The predicted function name is opt_rest"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,BIGNUM *t1,BIGNUM *t2)\n\n{\n  int iVar1;\n  \n  iVar1 = BN_cmp((BIGNUM *)t1,(BIGNUM *)t2);\n  if (iVar1 < 0) {\n    test_fail_bignum_message((char *)0x0,file,line,\"BIGNUM\",s1,s2,\">=\",t1,t2);\n  }\n  return (int)(iVar1 >= 0);\n}\n\n",
        "output": "The predicted function name is test_BN_ge"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *name,EVP_MD **mdp)\n\n{\n  int iVar1;\n  int ret;\n  \n  iVar1 = opt_md_silent(name,mdp);\n  if (iVar1 == 0) {\n    if (name == (char *)0x0) {\n      name = \"\\\"\\\"\";\n    }\n    opt_printf_stderr(\"%s: Unknown option or message digest: %s\\n\",prog,name);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is opt_md"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,long t1,long t2)\n\n{\n  if (t2 <= t1) {\n    test_fail_message((char *)0x0,file,line,\"long\",s1,s2,\"<\",\"[%ld] compared to [%ld]\",t1,t2);\n  }\n  return (int)(t2 > t1);\n}\n\n",
        "output": "The predicted function name is test_long_lt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,void *t1,void *t2)\n\n{\n  if (t1 != t2) {\n    test_fail_message((char *)0x0,file,line,\"void *\",s1,s2,\"==\",\"[%p] compared to [%p]\",t1,t2);\n  }\n  return (int)(t1 == t2);\n}\n\n",
        "output": "The predicted function name is test_ptr_eq"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *st1,char *st2,char *s1,char *s2)\n\n{\n  int iVar1;\n  size_t l2;\n  size_t l1;\n  \n  if ((s2 == (char *)0x0) == (s1 == (char *)0x0)) {\n    if ((s1 != (char *)0x0) && (iVar1 = strcmp(s1,s2), iVar1 != 0)) {\n      return 1;\n    }\n    if (s2 == (char *)0x0) {\n      l2 = 0;\n    }\n    else {\n      l2 = strlen(s2);\n    }\n    if (s1 == (char *)0x0) {\n      l1 = 0;\n    }\n    else {\n      l1 = strlen(s1);\n    }\n    test_fail_string_message((char *)0x0,file,line,\"string\",st1,st2,\"!=\",s1,l1,s2,l2);\n    iVar1 = 0;\n  }\n  else {\n    iVar1 = 1;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is test_str_ne"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,BIGNUM *t1,BIGNUM *t2)\n\n{\n  int iVar1;\n  \n  iVar1 = BN_cmp((BIGNUM *)t1,(BIGNUM *)t2);\n  if (iVar1 < 1) {\n    test_fail_bignum_message((char *)0x0,file,line,\"BIGNUM\",s1,s2,\">\",t1,t2);\n  }\n  return (int)(0 < iVar1);\n}\n\n",
        "output": "The predicted function name is test_BN_gt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nOPENSSL_STACK * [MASK](stack_st_IPAddressOrRange *sk)\n\n{\n  return (OPENSSL_STACK *)sk;\n}\n\n",
        "output": "The predicted function name is ossl_check_const_IPAddressOrRange_sk_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int success)\n\n{\n  if (success == 0) {\n    ERR_print_errors_cb(openssl_error_cb,(void *)0x0);\n  }\n  else {\n    ERR_clear_error();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is finalize"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,long t1,long t2)\n\n{\n  if (t2 < t1) {\n    test_fail_message((char *)0x0,file,line,\"long\",s1,s2,\"<=\",\"[%ld] compared to [%ld]\",t1,t2);\n  }\n  return (int)(t1 <= t2);\n}\n\n",
        "output": "The predicted function name is test_long_le"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,double t1,double t2)\n\n{\n  if (t1 <= t2) {\n    test_fail_message((char *)t1,(char *)t2,0,file,line,\"double\",s1,s2,&DAT_0000f7a9,\n                      \"[%g] compared to [%g]\");\n  }\n  return (int)(t2 < t1);\n}\n\n",
        "output": "The predicted function name is test_double_gt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *name,BIGNUM *bn)\n\n{\n  long lVar1;\n  int iVar2;\n  char *pcVar3;\n  undefined *puVar4;\n  long in_FS_OFFSET;\n  int n;\n  char *p;\n  uchar buf [8];\n  char out [17];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if (bn != (BIGNUM *)0x0) {\n    iVar2 = BN_is_zero(bn);\n    if (iVar2 == 0) {\n      iVar2 = BN_num_bits((BIGNUM *)bn);\n      if (iVar2 + 7 < 0x48) {\n        p = out;\n        iVar2 = BN_bn2bin((BIGNUM *)bn,buf);\n        hex_convert_memory(buf,(long)iVar2,p,8);\n        do {\n          if (*p != '0') break;\n          p = p + 1;\n        } while (*p != '\\0');\n        iVar2 = BN_is_negative(bn);\n        if (iVar2 == 0) {\n          puVar4 = &DAT_0000f988;\n        }\n        else {\n          puVar4 = &DAT_0000faac;\n        }\n        test_printf_stderr(\"bignum: \\'%s\\' = %s0x%s\\n\",name,puVar4,p);\n      }\n      else {\n        test_fail_bignum_common\n                  (\"bignum\",(char *)0x0,0,(char *)0x0,(char *)0x0,(char *)0x0,name,bn,bn);\n      }\n      goto code_r0x0000d467;\n    }\n  }\n  pcVar3 = test_bignum_zero_null(bn);\n  test_printf_stderr(\"bignum: \\'%s\\' = %s\\n\",name,pcVar3);\ncode_r0x0000d467:\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is test_output_bignum"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,ulong t1,ulong t2)\n\n{\n  if (t2 < t1) {\n    test_fail_message((char *)0x0,file,line,\"unsigned long\",s1,s2,\"<=\",\"[%lu] compared to [%lu]\",t1,\n                      t2);\n  }\n  return (int)(t1 <= t2);\n}\n\n",
        "output": "The predicted function name is test_ulong_le"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  BIO *pBVar1;\n  BIO_METHOD *pBVar2;\n  BIO *pBVar3;\n  \n  tap_out = (BIO *)BIO_new_fp(*(FILE **)PTR_stdout_00212fe0,0x10);\n  tap_err = (BIO *)BIO_new_fp(*(FILE **)PTR_stderr_00212fd8,0x10);\n  pBVar1 = tap_out;\n  pBVar2 = (BIO_METHOD *)BIO_f_prefix();\n  pBVar3 = BIO_new(pBVar2);\n  tap_out = (BIO *)BIO_push(pBVar3,(BIO *)pBVar1);\n  pBVar1 = tap_err;\n  pBVar2 = (BIO_METHOD *)BIO_f_prefix();\n  pBVar3 = BIO_new(pBVar2);\n  tap_err = (BIO *)BIO_push(pBVar3,(BIO *)pBVar1);\n  pBVar1 = tap_out;\n  pBVar2 = (BIO_METHOD *)BIO_f_prefix();\n  pBVar3 = BIO_new(pBVar2);\n  bio_out = (BIO *)BIO_push(pBVar3,(BIO *)pBVar1);\n  pBVar1 = tap_err;\n  pBVar2 = (BIO_METHOD *)BIO_f_prefix();\n  pBVar3 = BIO_new(pBVar2);\n  bio_err = (BIO *)BIO_push(pBVar3,(BIO *)pBVar1);\n  BIO_ctrl((BIO *)bio_out,0x4f,0,&DAT_0000f908);\n  BIO_ctrl((BIO *)bio_err,0x4f,0,&DAT_0000f908);\n  if (bio_out == (BIO *)0x0) {\n    OPENSSL_die(\"assertion failed: bio_out != NULL\",\"test/testutil/basic_output.c\",0x29);\n  }\n  if (bio_err == (BIO *)0x0) {\n    OPENSSL_die(\"assertion failed: bio_err != NULL\",\"test/testutil/basic_output.c\",0x2a);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is test_open_streams"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  return 1;\n}\n\n",
        "output": "The predicted function name is opt_legacy_okay"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](size_t sz,char *what)\n\n{\n  int iVar1;\n  void *p;\n  void *vp;\n  \n  p = CRYPTO_malloc((int)sz,\"test/testutil/apps_shims.c\",0x19);\n  iVar1 = test_ptr(\"test/testutil/apps_shims.c\",0x19,\"vp = OPENSSL_malloc(sz)\",p);\n  if (iVar1 == 0) {\n    test_info(\"test/testutil/apps_shims.c\",0x1a,\"Could not allocate %zu bytes for %s\\n\",sz,what);\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  return p;\n}\n\n",
        "output": "The predicted function name is app_malloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *fmt,...)\n\n{\n  long lVar1;\n  char in_AL;\n  int iVar2;\n  undefined8 in_RCX;\n  undefined8 in_RDX;\n  undefined8 in_RSI;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  int ret;\n  va_list ap;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  ap[0].gp_offset = 8;\n  ap[0].fp_offset = 0x30;\n  ap[0].overflow_arg_area = &stack0x00000008;\n  ap[0].reg_save_area = local_b8;\n  local_b0 = in_RSI;\n  local_a8 = in_RDX;\n  local_a0 = in_RCX;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  iVar2 = test_vprintf_stderr(fmt,ap);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar2;\n}\n\n",
        "output": "The predicted function name is opt_printf_stderr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char **list,size_t *out_len)\n\n{\n  int iVar1;\n  char *p_00;\n  char *__s;\n  size_t sVar2;\n  int i;\n  size_t len;\n  char *p;\n  char *ret;\n  \n  len = 0;\n  for (i = 0; list[i] != (char *)0x0; i = i + 1) {\n    sVar2 = strlen(list[i]);\n    len = len + sVar2;\n  }\n  if (out_len != (size_t *)0x0) {\n    *out_len = len;\n  }\n  p_00 = (char *)CRYPTO_malloc((int)len + 1,\"test/testutil/driver.c\",0x1a8);\n  iVar1 = test_ptr(\"test/testutil/driver.c\",0x1a8,\"ret = p = OPENSSL_malloc(len + 1)\",p_00);\n  if (iVar1 == 0) {\n    p_00 = (char *)0x0;\n  }\n  else {\n    p = p_00;\n    for (i = 0; list[i] != (char *)0x0; i = i + 1) {\n      __s = strcpy(p,list[i]);\n      sVar2 = strlen(__s);\n      p = p + sVar2;\n    }\n  }\n  return p_00;\n}\n\n",
        "output": "The predicted function name is glue_strings"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *filename)\n\n{\n  char *pcVar1;\n  size_t sVar2;\n  char *p;\n  \n  sVar2 = strlen(filename);\n  pcVar1 = filename + sVar2;\n  do {\n    p = pcVar1;\n    pcVar1 = p + -1;\n    if (pcVar1 <= filename) {\n      return pcVar1;\n    }\n  } while (*pcVar1 != '/');\n  return p;\n}\n\n",
        "output": "The predicted function name is opt_path_end"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *file,int line,char *desc,...)\n\n{\n  long lVar1;\n  char in_AL;\n  undefined8 in_RCX;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  va_list ap;\n  undefined local_b8 [24];\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  ap[0].gp_offset = 0x18;\n  ap[0].fp_offset = 0x30;\n  ap[0].overflow_arg_area = &stack0x00000008;\n  ap[0].reg_save_area = local_b8;\n  local_a0 = in_RCX;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  test_fail_message_va(\"INFO\",file,line,(char *)0x0,(char *)0x0,(char *)0x0,(char *)0x0,desc,ap);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is test_info"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK]\n               (char *prefix,char *file,int line,char *type,char *left,char *right,char *op,\n               char *fmt,__va_list_tag *ap)\n\n{\n  test_fail_message_prefix(prefix,file,line,type,left,right,op);\n  if (fmt != (char *)0x0) {\n    test_vprintf_stderr(fmt,ap);\n    test_printf_stderr(\"\\n\");\n  }\n  test_flush_stderr();\n  return;\n}\n\n",
        "output": "The predicted function name is test_fail_message_va"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s,int b)\n\n{\n  if (b != 0) {\n    test_fail_message((char *)0x0,file,line,\"bool\",s,\"false\",\"==\",\"true\");\n  }\n  return (int)(b == 0);\n}\n\n",
        "output": "The predicted function name is test_false"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *m,char c)\n\n{\n  if (m == (char *)0x0) {\n    test_printf_stderr(\"%4s %c NULL\\n\",&DAT_0000f988,(ulong)(uint)(int)c);\n  }\n  else {\n    test_printf_stderr(\"%4u:%c \\'\\'\\n\",0,(ulong)(uint)(int)c);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is test_string_null_empty"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](int ac,char **av,OPTIONS *o)\n\n{\n  OPTIONS *local_20;\n  \n  argv = av;\n  argc = ac;\n  opt_begin();\n  unknown = (OPTIONS *)0x0;\n  opts = o;\n  opt_progname(*argv);\n  for (local_20 = o;\n      (local_20->name != (char *)0x0 && ((undefined3 *)local_20->name != &OPT_PARAM_STR));\n      local_20 = local_20 + 1) {\n    if (((undefined3 *)local_20->name != &OPT_HELP_STR) &&\n       ((((undefined3 *)local_20->name != &OPT_MORE_STR &&\n         ((undefined3 *)local_20->name != &OPT_SECTION_STR)) && (*local_20->name == '\\0')))) {\n      if (unknown != (OPTIONS *)0x0) {\n        OPENSSL_die(\"assertion failed: unknown == NULL\",\"apps/lib/opt.c\",0xda);\n      }\n      unknown = local_20;\n      if ((local_20->valtype != 0) && (local_20->valtype != 0x2d)) {\n        OPENSSL_die(\"assertion failed: unknown->valtype == 0 || unknown->valtype == \\'-\\'\",\n                    \"apps/lib/opt.c\",0xdc);\n      }\n    }\n  }\n  return prog;\n}\n\n",
        "output": "The predicted function name is opt_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](uchar *m,size_t n,char *b,size_t width)\n\n{\n  char *pcVar1;\n  byte bVar2;\n  char *local_30;\n  byte *local_20;\n  uchar c;\n  size_t i;\n  \n  local_30 = b;\n  local_20 = m;\n  for (i = 0; i < n; i = i + 1) {\n    bVar2 = *local_20;\n    *local_30 = \"0123456789abcdef\"[(int)(uint)(bVar2 >> 4)];\n    pcVar1 = local_30 + 2;\n    local_30[1] = \"0123456789abcdef\"[(int)(bVar2 & 0xf)];\n    if ((i % width == width - 1) && (i != n - 1)) {\n      *pcVar1 = ' ';\n      pcVar1 = local_30 + 3;\n    }\n    local_30 = pcVar1;\n    local_20 = local_20 + 1;\n  }\n  *local_30 = '\\0';\n  return;\n}\n\n",
        "output": "The predicted function name is hex_convert_memory"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s,BIGNUM *a)\n\n{\n  int iVar1;\n  \n  if ((a != (BIGNUM *)0x0) && (iVar1 = BN_is_odd(a), iVar1 == 0)) {\n    return 1;\n  }\n  test_fail_bignum_mono_message((char *)0x0,file,line,\"BIGNUM\",\"EVEN(\",\")\",s,a);\n  return 0;\n}\n\n",
        "output": "The predicted function name is test_BN_even"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nOPENSSL_STACK * [MASK](stack_st_IPAddressFamily *sk)\n\n{\n  return (OPENSSL_STACK *)sk;\n}\n\n",
        "output": "The predicted function name is ossl_check_IPAddressFamily_sk_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,ulong t1,ulong t2)\n\n{\n  if (t2 <= t1) {\n    test_fail_message((char *)0x0,file,line,\"unsigned long\",s1,s2,\"<\",\"[%lu] compared to [%lu]\",t1,\n                      t2);\n  }\n  return (int)(t2 > t1);\n}\n\n",
        "output": "The predicted function name is test_ulong_lt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *test_case_name,anon_subr_int_int *test_fn,int num,int subtest)\n\n{\n  all_tests[num_tests].test_case_name = test_case_name;\n  all_tests[num_tests].param_test_fn = (anon_subr_int_int_for_param_test_fn *)test_fn;\n  all_tests[num_tests].num = num;\n  all_tests[num_tests].field_0x1c =\n       all_tests[num_tests].field_0x1c & 0xfe | (char)(subtest << 7) >> 7 & 1U;\n  if (subtest == 0) {\n    num_test_cases = num + num_test_cases;\n  }\n  else {\n    num_test_cases = num_test_cases + 1;\n  }\n  num_tests = num_tests + 1;\n  return;\n}\n\n",
        "output": "The predicted function name is add_all_tests"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *value,ossl_uintmax_t *result)\n\n{\n  int iVar1;\n  int *piVar2;\n  long in_FS_OFFSET;\n  int oerrno;\n  char *endp;\n  uintmax_t m;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  piVar2 = __errno_location();\n  *piVar2 = 0;\n  m = strtoumax(value,&endp,0);\n  if ((*endp == '\\0') && (value != endp)) {\n    if (m == 0xffffffffffffffff) {\n      piVar2 = __errno_location();\n      if (*piVar2 == 0x22) goto LAB_00005626;\n    }\n    if (m == 0) {\n      piVar2 = __errno_location();\n      if (*piVar2 != 0) goto LAB_00005626;\n    }\n    *result = m;\n    piVar2 = __errno_location();\n    *piVar2 = iVar1;\n    iVar1 = 1;\n  }\n  else {\nLAB_00005626:\n    opt_number_error(value);\n    piVar2 = __errno_location();\n    *piVar2 = iVar1;\n    iVar1 = 0;\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is opt_uintmax"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK]\n               (char *prefix,char *file,int line,char *type,char *left,char *right,char *op)\n\n{\n  if (prefix == (char *)0x0) {\n    prefix = \"ERROR\";\n  }\n  test_printf_stderr(\"%s: \",prefix);\n  if (type != (char *)0x0) {\n    test_printf_stderr(\"(%s) \",type);\n  }\n  if (op != (char *)0x0) {\n    if ((left == (char *)0x0) || (right == (char *)0x0)) {\n      test_printf_stderr(\"\\'%s\\'\",op);\n    }\n    else {\n      test_printf_stderr(\"\\'%s %s %s\\' failed\",left,op,right);\n    }\n  }\n  if (file != (char *)0x0) {\n    test_printf_stderr(\" @ %s:%d\",file,(ulong)(uint)line);\n  }\n  test_printf_stderr(\"\\n\");\n  return;\n}\n\n",
        "output": "The predicted function name is test_fail_message_prefix"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,double t1,double t2)\n\n{\n  if (t1 != t2) {\n    test_fail_message((char *)t1,(char *)t2,0,file,line,\"double\",s1,s2,&DAT_0000f79e,\n                      \"[%g] compared to [%g]\");\n  }\n  return (uint)(t1 == t2);\n}\n\n",
        "output": "The predicted function name is test_double_eq"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,long t1,long t2)\n\n{\n  if (t1 == t2) {\n    test_fail_message((char *)0x0,file,line,\"long\",s1,s2,\"!=\",\"[%ld] compared to [%ld]\",t1,t2);\n  }\n  return (int)(t1 != t2);\n}\n\n",
        "output": "The predicted function name is test_long_ne"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](void)\n\n{\n  return flag;\n}\n\n",
        "output": "The predicted function name is opt_flag"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,ulong t1,ulong t2)\n\n{\n  if (t1 == t2) {\n    test_fail_message((char *)0x0,file,line,\"unsigned long\",s1,s2,\"!=\",\"[%lu] compared to [%lu]\",t1,\n                      t2);\n  }\n  return (int)(t1 != t2);\n}\n\n",
        "output": "The predicted function name is test_ulong_ne"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,char t1,char t2)\n\n{\n  if (t1 == t2) {\n    test_fail_message((char *)0x0,file,line,\"char\",s1,s2,\"!=\",\"[%c] compared to [%c]\",\n                      (ulong)(uint)(int)t1,(ulong)(uint)(int)t2);\n  }\n  return (int)(t1 != t2);\n}\n\n",
        "output": "The predicted function name is test_char_ne"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,int t1,int t2)\n\n{\n  if (t1 <= t2) {\n    test_fail_message((char *)0x0,file,line,\"int\",s1,s2,\">\",\"[%d] compared to [%d]\",(ulong)(uint)t1,\n                      (ulong)(uint)t2);\n  }\n  return (int)(t2 < t1);\n}\n\n",
        "output": "The predicted function name is test_int_gt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  OPTION_CHOICE_DEFAULT o;\n  \n  do {\n    iVar1 = opt_next();\n    if (iVar1 == 0) {\n      return 1;\n    }\n  } while (iVar1 - 500U < 6);\n  return 0;\n}\n\n",
        "output": "The predicted function name is test_skip_common_options"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  int iVar1;\n  char **ppcVar2;\n  int i;\n  int n;\n  int arg_count;\n  char **argv;\n  \n  ppcVar2 = opt_rest();\n  iVar1 = opt_num_rest();\n  n = iVar1;\n  if (100 < iVar1) {\n    n = 100;\n  }\n  for (i = 0; i < n; i = i + 1) {\n    if (used[i] == 0) {\n      test_printf_stderr(\"Warning ignored command-line argument %d: %s\\n\",(ulong)(uint)i,ppcVar2[i])\n      ;\n    }\n  }\n  if (i < iVar1) {\n    test_printf_stderr(\"Warning arguments %d and later unchecked\\n\",(ulong)(uint)i);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is opt_check_usage"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = test_skip_common_options();\n  if (iVar1 == 0) {\n    test_error(\"test/v3ext.c\",0x14d,\"Error parsing test options\\n\");\n    iVar1 = 0;\n  }\n  else {\n    infile = test_get_argument(0);\n    iVar1 = test_ptr(\"test/v3ext.c\",0x151,\"infile = test_get_argument(0)\",infile);\n    if (iVar1 == 0) {\n      iVar1 = 0;\n    }\n    else {\n      add_test(\"test_pathlen\",test_pathlen);\n      add_test(\"test_asid\",test_asid);\n      add_test(\"test_addr_ranges\",test_addr_ranges);\n      add_test(\"test_ext_syntax\",test_ext_syntax);\n      iVar1 = 1;\n    }\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is setup_tests"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,size_t t1,size_t t2)\n\n{\n  if (t1 <= t2) {\n    test_fail_message((char *)0x0,file,line,\"size_t\",s1,s2,\">\",\"[%zu] compared to [%zu]\",t1,t2);\n  }\n  return (int)(t2 < t1);\n}\n\n",
        "output": "The predicted function name is test_size_t_gt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  int iVar2;\n  OPTIONS *list;\n  char *pcVar3;\n  long in_FS_OFFSET;\n  int value;\n  int ret;\n  OPTION_CHOICE_DEFAULT o;\n  char *flag_test;\n  char *flag_iter;\n  char *testname;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  ret = -1;\n  flag_test = \"\";\n  flag_iter = \"\";\n  testname = (char *)0x0;\n  opt_begin();\n  do {\n    while( true ) {\n      while( true ) {\n        while( true ) {\n          while( true ) {\n            o = opt_next();\n            if (o == OPT_EOF) {\n              iVar1 = check_single_test_params(testname,flag_test,flag_iter);\n              iVar2 = ret;\n              if (iVar1 != 0) {\n                ret = 1;\n                iVar2 = ret;\n              }\n              goto LAB_00006e62;\n            }\n            if (o != OPT_TEST_SINGLE) break;\n            flag_test = opt_flag();\n            testname = opt_arg();\n          }\n          if (OPT_TEST_SINGLE < o) break;\n          if (o == OPT_TEST_HELP) {\n            list = test_get_options();\n            opt_help(list);\n            iVar2 = 0;\n            goto LAB_00006e62;\n          }\n          if (o < OPT_TEST_LIST) {\n            iVar2 = ret;\n            if (o == OPT_ERR) goto LAB_00006e62;\n          }\n          else {\n            show_list = 1;\n          }\n        }\n        if (o != OPT_TEST_INDENT) break;\n        pcVar3 = opt_arg();\n        iVar1 = opt_int(pcVar3,&value);\n        iVar2 = ret;\n        if (iVar1 == 0) goto LAB_00006e62;\n        level = value << 2;\n        test_adjust_streams_tap_level(level);\n      }\n      if (o < OPT_TEST_INDENT) break;\n      if (o == OPT_TEST_SEED) {\n        pcVar3 = opt_arg();\n        iVar1 = opt_int(pcVar3,&value);\n        iVar2 = ret;\n        if (iVar1 == 0) goto LAB_00006e62;\n        set_seed(value);\n      }\n    }\n    flag_iter = opt_flag();\n    pcVar3 = opt_arg();\n    iVar1 = opt_int(pcVar3,&single_iter);\n    iVar2 = ret;\n  } while (iVar1 != 0);\nLAB_00006e62:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is process_shared_options"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](IPAddrBlocks *addr,int type)\n\n{\n  int iVar1;\n  OPENSSL_STACK *pOVar2;\n  void *p;\n  int *p_00;\n  IPAddressFamily *fam;\n  IPAddressOrRange *aorr;\n  \n  pOVar2 = ossl_check_const_IPAddressFamily_sk_type(addr);\n  iVar1 = OPENSSL_sk_num(pOVar2);\n  iVar1 = test_int_eq(\"test/v3ext.c\",0x97,\"sk_IPAddressFamily_num(addr)\",\"1\",iVar1,1);\n  if (iVar1 == 0) {\n    iVar1 = 0;\n  }\n  else {\n    pOVar2 = ossl_check_const_IPAddressFamily_sk_type(addr);\n    p = (void *)OPENSSL_sk_value(pOVar2,0);\n    iVar1 = test_ptr(\"test/v3ext.c\",0x9b,\"fam\",p);\n    if (iVar1 == 0) {\n      iVar1 = 0;\n    }\n    else {\n      iVar1 = test_int_eq(\"test/v3ext.c\",0x9e,\"fam->ipAddressChoice->type\",\n                          \"IPAddressChoice_addressesOrRanges\",**(int **)((long)p + 8),1);\n      if (iVar1 == 0) {\n        iVar1 = 0;\n      }\n      else {\n        pOVar2 = ossl_check_const_IPAddressOrRange_sk_type\n                           (*(stack_st_IPAddressOrRange **)(*(long *)((long)p + 8) + 8));\n        iVar1 = OPENSSL_sk_num(pOVar2);\n        iVar1 = test_int_eq(\"test/v3ext.c\",0xa1,\n                            \"sk_IPAddressOrRange_num(fam->ipAddressChoice->u.addressesOrRanges)\",\"1\"\n                            ,iVar1,1);\n        if (iVar1 == 0) {\n          iVar1 = 0;\n        }\n        else {\n          pOVar2 = ossl_check_const_IPAddressOrRange_sk_type\n                             (*(stack_st_IPAddressOrRange **)(*(long *)((long)p + 8) + 8));\n          p_00 = (int *)OPENSSL_sk_value(pOVar2,0);\n          iVar1 = test_ptr(\"test/v3ext.c\",0xa5,\"aorr\",p_00);\n          if (iVar1 == 0) {\n            iVar1 = 0;\n          }\n          else {\n            iVar1 = test_int_eq(\"test/v3ext.c\",0xa8,\"aorr->type\",\"type\",*p_00,type);\n            if (iVar1 == 0) {\n              iVar1 = 0;\n            }\n            else {\n              iVar1 = 1;\n            }\n          }\n        }\n      }\n    }\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is check_addr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,uchar t1,uchar t2)\n\n{\n  if (t2 <= t1) {\n    test_fail_message((char *)0x0,file,line,\"unsigned char\",s1,s2,\"<\",\"[%u] compared to [%u]\",\n                      (ulong)t1,(ulong)t2);\n  }\n  return (int)(t2 > t1);\n}\n\n",
        "output": "The predicted function name is test_uchar_lt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *value,int *result)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  long l;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = opt_long(value,&l);\n  if (iVar1 == 0) {\n    iVar1 = 0;\n  }\n  else {\n    *result = (int)l;\n    if (*result == l) {\n      iVar1 = 1;\n    }\n    else {\n      opt_printf_stderr(\"%s: Value \\\"%s\\\" outside integer range\\n\",prog,value);\n      iVar1 = 0;\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is opt_int"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int opt,X509_VERIFY_PARAM *vpm)\n\n{\n  int iVar1;\n  char *pcVar2;\n  long in_FS_OFFSET;\n  int i;\n  ossl_intmax_t t;\n  X509_VERIFY_PARAM *vtmp;\n  X509_PURPOSE *xptmp;\n  ASN1_OBJECT *otmp;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  t = 0;\n  if (vpm == (X509_VERIFY_PARAM *)0x0) {\n    OPENSSL_die(\"assertion failed: vpm != NULL\",\"apps/lib/opt.c\",0x2ad);\n  }\n  if (opt < 0x7d1) {\n    OPENSSL_die(\"assertion failed: opt > OPT_V__FIRST\",\"apps/lib/opt.c\",0x2ae);\n  }\n  if (0x7ee < opt) {\n    OPENSSL_die(\"assertion failed: opt < OPT_V__LAST\",\"apps/lib/opt.c\",0x2af);\n  }\n  switch(opt) {\n  case 2000:\n  case 0x7ef:\n    iVar1 = 0;\n    goto LAB_00005c54;\n  case 0x7d1:\n    pcVar2 = opt_arg();\n    otmp = (ASN1_OBJECT *)OBJ_txt2obj(pcVar2,0);\n    if ((ASN1_OBJECT *)otmp == (ASN1_OBJECT *)0x0) {\n      pcVar2 = opt_arg();\n      opt_printf_stderr(\"%s: Invalid Policy %s\\n\",prog,pcVar2);\n      iVar1 = 0;\n      goto LAB_00005c54;\n    }\n    X509_VERIFY_PARAM_add0_policy((X509_VERIFY_PARAM *)vpm,(ASN1_OBJECT *)otmp);\n    break;\n  case 0x7d2:\n    pcVar2 = opt_arg();\n    iVar1 = X509_PURPOSE_get_by_sname(pcVar2);\n    if (iVar1 < 0) {\n      pcVar2 = opt_arg();\n      opt_printf_stderr(\"%s: Invalid purpose %s\\n\",prog,pcVar2);\n      iVar1 = 0;\n      goto LAB_00005c54;\n    }\n    xptmp = (X509_PURPOSE *)X509_PURPOSE_get0(iVar1);\n    iVar1 = X509_PURPOSE_get_id((X509_PURPOSE *)xptmp);\n    iVar1 = X509_VERIFY_PARAM_set_purpose((X509_VERIFY_PARAM *)vpm,iVar1);\n    if (iVar1 == 0) {\n      pcVar2 = opt_arg();\n      opt_printf_stderr(\"%s: Internal error setting purpose %s\\n\",prog,pcVar2);\n      iVar1 = 0;\n      goto LAB_00005c54;\n    }\n    break;\n  case 0x7d3:\n    pcVar2 = opt_arg();\n    vtmp = (X509_VERIFY_PARAM *)X509_VERIFY_PARAM_lookup(pcVar2);\n    if ((X509_VERIFY_PARAM *)vtmp == (X509_VERIFY_PARAM *)0x0) {\n      pcVar2 = opt_arg();\n      opt_printf_stderr(\"%s: Invalid verify name %s\\n\",prog,pcVar2);\n      iVar1 = 0;\n      goto LAB_00005c54;\n    }\n    X509_VERIFY_PARAM_set1((X509_VERIFY_PARAM *)vpm,(X509_VERIFY_PARAM *)vtmp);\n    break;\n  case 0x7d4:\n    pcVar2 = opt_arg();\n    iVar1 = atoi(pcVar2);\n    if (-1 < iVar1) {\n      X509_VERIFY_PARAM_set_depth((X509_VERIFY_PARAM *)vpm,iVar1);\n    }\n    break;\n  case 0x7d5:\n    pcVar2 = opt_arg();\n    iVar1 = opt_intmax(pcVar2,&t);\n    if (iVar1 == 0) {\n      iVar1 = 0;\n      goto LAB_00005c54;\n    }\n    X509_VERIFY_PARAM_set_time((X509_VERIFY_PARAM *)vpm,t);\n    break;\n  case 0x7d6:\n    pcVar2 = opt_arg();\n    iVar1 = X509_VERIFY_PARAM_set1_host(vpm,pcVar2,0);\n    if (iVar1 == 0) {\n      iVar1 = 0;\n      goto LAB_00005c54;\n    }\n    break;\n  case 0x7d7:\n    pcVar2 = opt_arg();\n    iVar1 = X509_VERIFY_PARAM_set1_email(vpm,pcVar2,0);\n    if (iVar1 == 0) {\n      iVar1 = 0;\n      goto LAB_00005c54;\n    }\n    break;\n  case 0x7d8:\n    pcVar2 = opt_arg();\n    iVar1 = X509_VERIFY_PARAM_set1_ip_asc(vpm,pcVar2);\n    if (iVar1 == 0) {\n      iVar1 = 0;\n      goto LAB_00005c54;\n    }\n    break;\n  case 0x7d9:\n    X509_VERIFY_PARAM_set_flags((X509_VERIFY_PARAM *)vpm,0x10);\n    break;\n  case 0x7da:\n    break;\n  case 0x7db:\n    X509_VERIFY_PARAM_set_flags((X509_VERIFY_PARAM *)vpm,4);\n    break;\n  case 0x7dc:\n    X509_VERIFY_PARAM_set_flags((X509_VERIFY_PARAM *)vpm,0xc);\n    break;\n  case 0x7dd:\n    X509_VERIFY_PARAM_set_flags((X509_VERIFY_PARAM *)vpm,0x80);\n    break;\n  case 0x7de:\n    X509_VERIFY_PARAM_set_flags((X509_VERIFY_PARAM *)vpm,0x100);\n    break;\n  case 0x7df:\n    X509_VERIFY_PARAM_set_flags((X509_VERIFY_PARAM *)vpm,0x200);\n    break;\n  case 0x7e0:\n    X509_VERIFY_PARAM_set_flags((X509_VERIFY_PARAM *)vpm,0x400);\n    break;\n  case 0x7e1:\n    X509_VERIFY_PARAM_set_flags((X509_VERIFY_PARAM *)vpm,0x20);\n    break;\n  case 0x7e2:\n    X509_VERIFY_PARAM_set_flags((X509_VERIFY_PARAM *)vpm,0x1000);\n    break;\n  case 0x7e3:\n    X509_VERIFY_PARAM_set_flags((X509_VERIFY_PARAM *)vpm,0x2000);\n    break;\n  case 0x7e4:\n    X509_VERIFY_PARAM_set_flags((X509_VERIFY_PARAM *)vpm,0x800);\n    break;\n  case 0x7e5:\n    X509_VERIFY_PARAM_set_flags((X509_VERIFY_PARAM *)vpm,0x4000);\n    break;\n  case 0x7e6:\n    X509_VERIFY_PARAM_set_flags((X509_VERIFY_PARAM *)vpm,0x8000);\n    break;\n  case 0x7e7:\n    X509_VERIFY_PARAM_set_flags((X509_VERIFY_PARAM *)vpm,0x10000);\n    break;\n  case 0x7e8:\n    X509_VERIFY_PARAM_set_flags((X509_VERIFY_PARAM *)vpm,0x30000);\n    break;\n  case 0x7e9:\n    X509_VERIFY_PARAM_set_flags((X509_VERIFY_PARAM *)vpm,0x20000);\n    break;\n  case 0x7ea:\n    X509_VERIFY_PARAM_set_flags((X509_VERIFY_PARAM *)vpm,0x80000);\n    break;\n  case 0x7eb:\n    X509_VERIFY_PARAM_set_flags((X509_VERIFY_PARAM *)vpm,0x100000);\n    break;\n  case 0x7ec:\n    X509_VERIFY_PARAM_set_flags((X509_VERIFY_PARAM *)vpm,0x200000);\n    break;\n  case 0x7ed:\n    pcVar2 = opt_arg();\n    iVar1 = atoi(pcVar2);\n    if (-1 < iVar1) {\n      X509_VERIFY_PARAM_set_auth_level(vpm,iVar1);\n    }\n    break;\n  case 0x7ee:\n    X509_VERIFY_PARAM_set_flags((X509_VERIFY_PARAM *)vpm,0x40);\n  }\n  iVar1 = 1;\nLAB_00005c54:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is opt_verify"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s,BIGNUM *a)\n\n{\n  int iVar1;\n  \n  if (a == (BIGNUM *)0x0) {\nLAB_0000b267:\n    test_fail_bignum_mono_message((char *)0x0,file,line,\"BIGNUM\",s,\"0\",\"<=\",a);\n    iVar1 = 0;\n  }\n  else {\n    iVar1 = BN_is_negative(a);\n    if (iVar1 == 0) {\n      iVar1 = BN_is_zero(a);\n      if (iVar1 == 0) goto LAB_0000b267;\n    }\n    iVar1 = 1;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is test_BN_le_zero"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char *argv0)\n\n{\n  char *__src;\n  char *p;\n  \n  __src = opt_path_end(argv0);\n  if (__src != prog) {\n    strncpy(prog,__src,0x27);\n  }\n  prog[39] = '\\0';\n  return prog;\n}\n\n",
        "output": "The predicted function name is opt_progname"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,size_t t1,size_t t2)\n\n{\n  if (t1 < t2) {\n    test_fail_message((char *)0x0,file,line,\"size_t\",s1,s2,\">=\",\"[%zu] compared to [%zu]\",t1,t2);\n  }\n  return (int)(t1 >= t2);\n}\n\n",
        "output": "The predicted function name is test_size_t_ge"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,time_t t1,time_t t2)\n\n{\n  int iVar1;\n  ASN1_TIME *t;\n  ASN1_TIME *t_00;\n  char *pcVar2;\n  char *pcVar3;\n  int r;\n  ASN1_TIME *at1;\n  ASN1_TIME *at2;\n  \n  t = ASN1_TIME_set((ASN1_TIME *)0x0,t1);\n  t_00 = ASN1_TIME_set((ASN1_TIME *)0x0,t2);\n  if ((t != (ASN1_TIME *)0x0) && (t_00 != (ASN1_TIME *)0x0)) {\n    iVar1 = ASN1_TIME_compare(t,t_00);\n    if (iVar1 < 1) {\n      iVar1 = 1;\n      goto LAB_0000bb69;\n    }\n  }\n  iVar1 = 0;\nLAB_0000bb69:\n  if (iVar1 == 0) {\n    pcVar2 = print_time((ASN1_TIME *)t_00);\n    pcVar3 = print_time((ASN1_TIME *)t);\n    test_fail_message((char *)0x0,file,line,\"time_t\",s1,s2,\"<=\",\"[%s] compared to [%s]\",pcVar3,\n                      pcVar2);\n  }\n  ASN1_STRING_free(t);\n  ASN1_STRING_free(t_00);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is test_time_t_le"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,uchar t1,uchar t2)\n\n{\n  if (t1 == t2) {\n    test_fail_message((char *)0x0,file,line,\"unsigned char\",s1,s2,\"!=\",\"[%u] compared to [%u]\",\n                      (ulong)t1,(ulong)t2);\n  }\n  return (int)(t1 != t2);\n}\n\n",
        "output": "The predicted function name is test_uchar_ne"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s,void *p)\n\n{\n  if (p != (void *)0x0) {\n    test_fail_message((char *)0x0,file,line,\"ptr\",s,\"NULL\",\"==\",\"%p\",p);\n  }\n  return (int)(p == (void *)0x0);\n}\n\n",
        "output": "The predicted function name is test_ptr_null"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *name,EVP_CIPHER **cipherp)\n\n{\n  int iVar1;\n  int ret;\n  \n  iVar1 = opt_cipher_silent(name,cipherp);\n  if (iVar1 == 0) {\n    opt_printf_stderr(\"%s: Unknown cipher: %s\\n\",prog,name);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is opt_cipher_any"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *name,EVP_CIPHER **cipherp)\n\n{\n  int iVar1;\n  char *pcVar2;\n  OSSL_LIB_CTX *pOVar3;\n  EVP_CIPHER *c;\n  \n  ERR_set_mark();\n  pcVar2 = app_get0_propq();\n  pOVar3 = app_get0_libctx();\n  c = (EVP_CIPHER *)EVP_CIPHER_fetch(pOVar3,name,pcVar2);\n  if (c == (EVP_CIPHER *)0x0) {\n    iVar1 = opt_legacy_okay();\n    if (iVar1 != 0) {\n      c = (EVP_CIPHER *)EVP_get_cipherbyname(name);\n      if ((EVP_CIPHER *)c != (EVP_CIPHER *)0x0) goto LAB_00004db7;\n    }\n    ERR_clear_last_mark();\n    iVar1 = 0;\n  }\n  else {\nLAB_00004db7:\n    ERR_pop_to_mark();\n    if (cipherp == (EVP_CIPHER **)0x0) {\n      EVP_CIPHER_free(c);\n    }\n    else {\n      EVP_CIPHER_free(*cipherp);\n      *cipherp = c;\n    }\n    iVar1 = 1;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is opt_cipher_silent"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nuint32_t [MASK](void)\n\n{\n  ulong uVar1;\n  \n  if (test_random::pos == 0x1f) {\n    test_random::pos = 0;\n  }\n  test_random_state[test_random::pos] =\n       test_random_state[test_random::pos] + test_random_state[(test_random::pos + 0x1c) % 0x1f];\n  uVar1 = (ulong)test_random::pos;\n  test_random::pos = test_random::pos + 1;\n  return test_random_state[uVar1] >> 1;\n}\n\n",
        "output": "The predicted function name is test_random"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  long in_FS_OFFSET;\n  int result;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  result = -1;\n  opt_int(arg,&result);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return result;\n}\n\n",
        "output": "The predicted function name is opt_int_arg"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  long lVar1;\n  \n  lVar1 = BIO_ctrl((BIO *)bio_err,0xb,0,(void *)0x0);\n  return (int)lVar1;\n}\n\n",
        "output": "The predicted function name is test_flush_stderr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](OPTIONS *list)\n\n{\n  long lVar1;\n  undefined3 *puVar2;\n  size_t sVar3;\n  char *__s;\n  long in_FS_OFFSET;\n  int i;\n  int sawparams;\n  int width;\n  int standard_prolog;\n  OPTIONS *o;\n  char start [81];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  sawparams = 0;\n  width = 5;\n  puVar2 = (undefined3 *)list->name;\n  for (o = list; o->name != (char *)0x0; o = o + 1) {\n    if ((undefined3 *)o->name != &OPT_MORE_STR) {\n      sVar3 = strlen(o->name);\n      i = (int)sVar3 + 2;\n      if (o->valtype != 0x2d) {\n        __s = valtype2param(o);\n        sVar3 = strlen(__s);\n        i = i + (int)sVar3 + 1;\n      }\n      if ((i < 0x1e) && (width < i)) {\n        width = i;\n      }\n      if (0x50 < i) {\n        OPENSSL_die(\"assertion failed: i < (int)sizeof(start)\",\"apps/lib/opt.c\",0x46b);\n      }\n    }\n  }\n  o = list;\n  if ((puVar2 != &OPT_HELP_STR) &&\n     (opt_printf_stderr(\"Usage: %s [options]\\n\"), (undefined3 *)list->name != &OPT_SECTION_STR)) {\n    opt_printf_stderr(\"Valid options are:\\n\");\n  }\n  for (; o->name != (char *)0x0; o = o + 1) {\n    if ((undefined3 *)o->name == &OPT_PARAM_STR) {\n      sawparams = 1;\n    }\n    opt_print(o,sawparams,width);\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is opt_help"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,time_t t1,time_t t2)\n\n{\n  int iVar1;\n  ASN1_TIME *t;\n  ASN1_TIME *t_00;\n  char *pcVar2;\n  char *pcVar3;\n  int r;\n  ASN1_TIME *at1;\n  ASN1_TIME *at2;\n  \n  t = ASN1_TIME_set((ASN1_TIME *)0x0,t1);\n  t_00 = ASN1_TIME_set((ASN1_TIME *)0x0,t2);\n  if ((t != (ASN1_TIME *)0x0) && (t_00 != (ASN1_TIME *)0x0)) {\n    iVar1 = ASN1_TIME_compare(t,t_00);\n    if (iVar1 < 0) {\n      iVar1 = 1;\n      goto LAB_0000ba62;\n    }\n  }\n  iVar1 = 0;\nLAB_0000ba62:\n  if (iVar1 == 0) {\n    pcVar2 = print_time((ASN1_TIME *)t_00);\n    pcVar3 = print_time((ASN1_TIME *)t);\n    test_fail_message((char *)0x0,file,line,\"time_t\",s1,s2,\"<\",\"[%s] compared to [%s]\",pcVar3,pcVar2\n                     );\n  }\n  ASN1_STRING_free(t);\n  ASN1_STRING_free(t_00);\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is test_time_t_lt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  ASIdentifiers *a;\n  ASIdentifiers *a_00;\n  ASIdentifiers *a_01;\n  ASIdentifiers *a_02;\n  int testresult;\n  ASN1_INTEGER *val1;\n  ASN1_INTEGER *val2;\n  ASIdentifiers *asid1;\n  ASIdentifiers *asid2;\n  ASIdentifiers *asid3;\n  ASIdentifiers *asid4;\n  \n  val1 = (ASN1_INTEGER *)0x0;\n  val2 = (ASN1_INTEGER *)0x0;\n  a = ASIdentifiers_new();\n  a_00 = ASIdentifiers_new();\n  a_01 = ASIdentifiers_new();\n  a_02 = ASIdentifiers_new();\n  testresult = 0;\n  iVar1 = test_ptr(\"test/v3ext.c\",0x32,\"asid1\",a);\n  if (((iVar1 != 0) && (iVar1 = test_ptr(\"test/v3ext.c\",0x33,\"asid2\",a_00), iVar1 != 0)) &&\n     (iVar1 = test_ptr(\"test/v3ext.c\",0x34,\"asid3\",a_01), iVar1 != 0)) {\n    val1 = (ASN1_INTEGER *)ASN1_INTEGER_new();\n    iVar1 = test_ptr(\"test/v3ext.c\",0x37,\"val1 = ASN1_INTEGER_new()\",val1);\n    if (iVar1 != 0) {\n      iVar1 = ASN1_INTEGER_set_int64(val1,0xfbf0);\n      iVar1 = test_true(\"test/v3ext.c\",0x38,\"ASN1_INTEGER_set_int64(val1, 64496)\",(uint)(iVar1 != 0)\n                       );\n      if (iVar1 != 0) {\n        iVar1 = X509v3_asid_add_id_or_range(a,0,val1);\n        iVar1 = test_true(\"test/v3ext.c\",0x3b,\n                          \"X509v3_asid_add_id_or_range(asid1, V3_ASID_ASNUM, val1, NULL)\",\n                          (uint)(iVar1 != 0));\n        if (iVar1 != 0) {\n          val1 = (ASN1_INTEGER *)0x0;\n          val2 = (ASN1_INTEGER *)ASN1_INTEGER_new();\n          iVar1 = test_ptr(\"test/v3ext.c\",0x3f,\"val2 = ASN1_INTEGER_new()\",val2);\n          if (iVar1 != 0) {\n            iVar1 = ASN1_INTEGER_set_int64(val2,0xfbf1);\n            iVar1 = test_true(\"test/v3ext.c\",0x40,\"ASN1_INTEGER_set_int64(val2, 64497)\",\n                              (uint)(iVar1 != 0));\n            if (iVar1 != 0) {\n              iVar1 = X509v3_asid_add_id_or_range(a_00,0,val2);\n              iVar1 = test_true(\"test/v3ext.c\",0x43,\n                                \"X509v3_asid_add_id_or_range(asid2, V3_ASID_ASNUM, val2, NULL)\",\n                                (uint)(iVar1 != 0));\n              if (iVar1 != 0) {\n                val2 = (ASN1_INTEGER *)0x0;\n                val1 = (ASN1_INTEGER *)ASN1_INTEGER_new();\n                iVar1 = test_ptr(\"test/v3ext.c\",0x47,\"val1 = ASN1_INTEGER_new()\",val1);\n                if (iVar1 != 0) {\n                  iVar1 = ASN1_INTEGER_set_int64(val1,0xfbf0);\n                  iVar1 = test_true(\"test/v3ext.c\",0x48,\"ASN1_INTEGER_set_int64(val1, 64496)\",\n                                    (uint)(iVar1 != 0));\n                  if (iVar1 != 0) {\n                    val2 = (ASN1_INTEGER *)ASN1_INTEGER_new();\n                    iVar1 = test_ptr(\"test/v3ext.c\",0x49,\"val2 = ASN1_INTEGER_new()\",val2);\n                    if (iVar1 != 0) {\n                      iVar1 = ASN1_INTEGER_set_int64(val2,0xfbf1);\n                      iVar1 = test_true(\"test/v3ext.c\",0x4a,\"ASN1_INTEGER_set_int64(val2, 64497)\",\n                                        (uint)(iVar1 != 0));\n                      if (iVar1 != 0) {\n                        iVar1 = X509v3_asid_add_id_or_range(a_01,0,val1);\n                        iVar1 = test_true(\"test/v3ext.c\",0x51,\n                                          \"X509v3_asid_add_id_or_range(asid3, V3_ASID_ASNUM, val1, val2)\"\n                                          ,(uint)(iVar1 != 0));\n                        if (iVar1 != 0) {\n                          val2 = (ASN1_INTEGER *)0x0;\n                          val1 = (ASN1_INTEGER *)0x0;\n                          iVar1 = X509v3_asid_subset(0,0);\n                          iVar1 = test_true(\"test/v3ext.c\",0x56,\"X509v3_asid_subset(NULL, NULL)\",\n                                            (uint)(iVar1 != 0));\n                          if (iVar1 != 0) {\n                            iVar1 = X509v3_asid_subset(0,a);\n                            iVar1 = test_true(\"test/v3ext.c\",0x57,\"X509v3_asid_subset(NULL, asid1)\",\n                                              (uint)(iVar1 != 0));\n                            if (iVar1 != 0) {\n                              iVar1 = X509v3_asid_subset(a,a);\n                              iVar1 = test_true(\"test/v3ext.c\",0x58,\n                                                \"X509v3_asid_subset(asid1, asid1)\",\n                                                (uint)(iVar1 != 0));\n                              if (iVar1 != 0) {\n                                iVar1 = X509v3_asid_subset(a_00,a_00);\n                                iVar1 = test_true(\"test/v3ext.c\",0x59,\n                                                  \"X509v3_asid_subset(asid2, asid2)\",\n                                                  (uint)(iVar1 != 0));\n                                if (iVar1 != 0) {\n                                  iVar1 = X509v3_asid_subset(a,a_01);\n                                  iVar1 = test_true(\"test/v3ext.c\",0x5a,\n                                                    \"X509v3_asid_subset(asid1, asid3)\",\n                                                    (uint)(iVar1 != 0));\n                                  if (iVar1 != 0) {\n                                    iVar1 = X509v3_asid_subset(a_00,a_01);\n                                    iVar1 = test_true(\"test/v3ext.c\",0x5b,\n                                                      \"X509v3_asid_subset(asid2, asid3)\",\n                                                      (uint)(iVar1 != 0));\n                                    if (iVar1 != 0) {\n                                      iVar1 = X509v3_asid_subset(a_01,a_01);\n                                      iVar1 = test_true(\"test/v3ext.c\",0x5c,\n                                                        \"X509v3_asid_subset(asid3, asid3)\",\n                                                        (uint)(iVar1 != 0));\n                                      if (iVar1 != 0) {\n                                        iVar1 = X509v3_asid_subset(a_02,a);\n                                        iVar1 = test_true(\"test/v3ext.c\",0x5d,\n                                                          \"X509v3_asid_subset(asid4, asid1)\",\n                                                          (uint)(iVar1 != 0));\n                                        if (iVar1 != 0) {\n                                          iVar1 = X509v3_asid_subset(a_02,a_00);\n                                          iVar1 = test_true(\"test/v3ext.c\",0x5e,\n                                                            \"X509v3_asid_subset(asid4, asid2)\",\n                                                            (uint)(iVar1 != 0));\n                                          if (iVar1 != 0) {\n                                            iVar1 = X509v3_asid_subset(a_02,a_01);\n                                            iVar1 = test_true(\"test/v3ext.c\",0x5f,\n                                                              \"X509v3_asid_subset(asid4, asid3)\",\n                                                              (uint)(iVar1 != 0));\n                                            if (iVar1 != 0) {\n                                              iVar1 = X509v3_asid_subset(a,0);\n                                              iVar1 = test_false(\"test/v3ext.c\",99,\n                                                                 \"X509v3_asid_subset(asid1, NULL)\",\n                                                                 (uint)(iVar1 != 0));\n                                              if (iVar1 != 0) {\n                                                iVar1 = X509v3_asid_subset(a,a_00);\n                                                iVar1 = test_false(\"test/v3ext.c\",100,\n                                                                                                                                      \n                                                  \"X509v3_asid_subset(asid1, asid2)\",\n                                                  (uint)(iVar1 != 0));\n                                                if (iVar1 != 0) {\n                                                  iVar1 = X509v3_asid_subset(a_00,a);\n                                                  iVar1 = test_false(\"test/v3ext.c\",0x65,\n                                                                                                                                          \n                                                  \"X509v3_asid_subset(asid2, asid1)\",\n                                                  (uint)(iVar1 != 0));\n                                                  if (iVar1 != 0) {\n                                                    iVar1 = X509v3_asid_subset(a_01,a);\n                                                    iVar1 = test_false(\"test/v3ext.c\",0x66,\n                                                                                                                                              \n                                                  \"X509v3_asid_subset(asid3, asid1)\",\n                                                  (uint)(iVar1 != 0));\n                                                  if (iVar1 != 0) {\n                                                    iVar1 = X509v3_asid_subset(a_01,a_00);\n                                                    iVar1 = test_false(\"test/v3ext.c\",0x67,\n                                                                                                                                              \n                                                  \"X509v3_asid_subset(asid3, asid2)\",\n                                                  (uint)(iVar1 != 0));\n                                                  if (iVar1 != 0) {\n                                                    iVar1 = X509v3_asid_subset(a,a_02);\n                                                    iVar1 = test_false(\"test/v3ext.c\",0x68,\n                                                                                                                                              \n                                                  \"X509v3_asid_subset(asid1, asid4)\",\n                                                  (uint)(iVar1 != 0));\n                                                  if (iVar1 != 0) {\n                                                    iVar1 = X509v3_asid_subset(a_00,a_02);\n                                                    iVar1 = test_false(\"test/v3ext.c\",0x69,\n                                                                                                                                              \n                                                  \"X509v3_asid_subset(asid2, asid4)\",\n                                                  (uint)(iVar1 != 0));\n                                                  if (iVar1 != 0) {\n                                                    iVar1 = X509v3_asid_subset(a_01,a_02);\n                                                    iVar1 = test_false(\"test/v3ext.c\",0x6a,\n                                                                                                                                              \n                                                  \"X509v3_asid_subset(asid3, asid4)\",\n                                                  (uint)(iVar1 != 0));\n                                                  if (iVar1 != 0) {\n                                                    testresult = 1;\n                                                  }\n                                                  }\n                                                  }\n                                                  }\n                                                  }\n                                                  }\n                                                }\n                                              }\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  ASN1_INTEGER_free((ASN1_INTEGER *)val1);\n  ASN1_INTEGER_free((ASN1_INTEGER *)val2);\n  ASIdentifiers_free(a);\n  ASIdentifiers_free(a_00);\n  ASIdentifiers_free(a_01);\n  ASIdentifiers_free(a_02);\n  return testresult;\n}\n\n",
        "output": "The predicted function name is test_asid"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char *file,int line,char *s1,char *s2,uint t1,uint t2)\n\n{\n  if (t1 == t2) {\n    test_fail_message((char *)0x0,file,line,\"unsigned int\",s1,s2,\"!=\",\"[%u] compared to [%u]\",\n                      (ulong)t1,(ulong)t2);\n  }\n  return (int)(t1 != t2);\n}\n\n",
        "output": "The predicted function name is test_uint_ne"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nOSSL_LIB_CTX * [MASK](void)\n\n{\n  return (OSSL_LIB_CTX *)0x0;\n}\n\n",
        "output": "The predicted function name is app_get0_libctx"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  return 1;\n}\n\n",
        "output": "The predicted function name is global_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](uint8_t *buf,size_t len)\n\n{\n  int iVar1;\n  BIO_METHOD *pBVar2;\n  BIO *b;\n  CMS_ContentInfo *cms_00;\n  BIO *bp;\n  BIO *in;\n  CMS_ContentInfo *cms;\n  BIO *out;\n  \n  if (len != 0) {\n    pBVar2 = BIO_s_mem();\n    b = BIO_new(pBVar2);\n    iVar1 = BIO_write(b,buf,(int)len);\n    if (len != (long)iVar1) {\n      OPENSSL_die(\"assertion failed: (size_t)BIO_write(in, buf, len) == len\",\"fuzz/cms.c\",0x25);\n    }\n    cms_00 = d2i_CMS_bio(b,(CMS_ContentInfo **)0x0);\n    if (cms_00 != (CMS_ContentInfo *)0x0) {\n      pBVar2 = BIO_s_null();\n      bp = BIO_new(pBVar2);\n      i2d_CMS_bio(bp,cms_00);\n      BIO_free(bp);\n      CMS_ContentInfo_free(cms_00);\n    }\n    BIO_free(b);\n    ERR_clear_error();\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is FuzzerTestOneInput"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *pathname)\n\n{\n  long lVar1;\n  int iVar2;\n  FILE *__stream;\n  uint8_t *buf_00;\n  size_t len;\n  long in_FS_OFFSET;\n  FILE *f;\n  uchar *buf;\n  size_t s;\n  stat st;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar2 = stat(pathname,(stat *)&st);\n  if ((-1 < iVar2) && ((st.st_mode & 0xf000) == 0x8000)) {\n    printf(\"# %s\\n\",pathname);\n    fflush(stdout);\n    __stream = fopen(pathname,\"rb\");\n    if (__stream != (FILE *)0x0) {\n      buf_00 = (uint8_t *)malloc(st.st_size);\n      if (buf_00 != (uint8_t *)0x0) {\n        len = fread(buf_00,1,st.st_size,__stream);\n        if (len != st.st_size) {\n          OPENSSL_die(\"assertion failed: s == (size_t)st.st_size\",\"fuzz/test-corpus.c\",0x36);\n        }\n        FuzzerTestOneInput(buf_00,len);\n        free(buf_00);\n      }\n      fclose(__stream);\n    }\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is testfile"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int *argc,char ***argv)\n\n{\n  OPENSSL_init_crypto(2,0);\n  ERR_clear_error();\n  CRYPTO_free_ex_index(0,0xffffffff);\n  return 1;\n}\n\n",
        "output": "The predicted function name is FuzzerInitialize"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  return;\n}\n\n",
        "output": "The predicted function name is FuzzerCleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](adns_query qu,size_t sz)\n\n{\n  void *pvVar1;\n  ulong uVar2;\n  void *rp;\n  \n  uVar2 = sz + 7 & 0xfffffffffffffff8;\n  pvVar1 = qu->final_allocspace;\n  if (pvVar1 == (void *)0x0) {\n                    /* WARNING: Subroutine does not return */\n    __assert_fail(\"rp\",\"../src/query.c\",0x1d7,\"adns__alloc_final\");\n  }\n  qu->interim_allocd = qu->interim_allocd - (int)uVar2;\n  if (qu->interim_allocd < 0) {\n                    /* WARNING: Subroutine does not return */\n    __assert_fail(\"qu->interim_allocd>=0\",\"../src/query.c\",0x1d9,\"adns__alloc_final\");\n  }\n  qu->final_allocspace = (void *)((long)pvVar1 + uVar2);\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is adns__alloc_final"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nadns_status [MASK](vbuf *vb,char *mailbox)\n\n{\n  adns_status aVar1;\n  \n  aVar1 = csp_domain(vb,mailbox);\n  return aVar1;\n}\n\n",
        "output": "The predicted function name is csp_mailbox"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](adns_state ads)\n\n{\n  if (ads->nsearchlist != 0) {\n    Hfree(*ads->searchlist);\n  }\n  Hfree(ads->searchlist);\n  return;\n}\n\n",
        "output": "The predicted function name is freesearchlist"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](adns_state ads,int act,timeval **tv_io,timeval *tvbuf,timeval now)\n\n{\n  query_queue *in_R8;\n  undefined8 in_R9;\n  undefined8 in_stack_ffffffffffffffc0;\n  \n  timeouts_queue(ads,act,tv_io,tvbuf,(timeval)CONCAT88(in_stack_ffffffffffffffc0,&ads->udpw),in_R8);\n  timeouts_queue(ads,act,tv_io,tvbuf,(timeval)CONCAT88(in_stack_ffffffffffffffc0,&ads->tcpw),in_R8);\n  tcp_events(ads,act,tv_io,tvbuf,(timeval)CONCAT88(in_R9,in_R8));\n  return;\n}\n\n",
        "output": "The predicted function name is adns__timeouts"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](adns_state ads,pollfd *fds,int nfds,timeval *now)\n\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  undefined4 in_stack_ffffffffffffffc0;\n  timeval tv_buf;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  adns__consistency(ads,(adns_query)0x0,cc_enter);\n  adns__must_gettimeofday(ads,(timeval **)&stack0xffffffffffffffb8,&tv_buf);\n  if (now != (timeval *)0x0) {\n    adns__timeouts(ads,1,(timeval **)0x0,(timeval *)0x0,\n                   (timeval)CONCAT412(nfds,CONCAT48(in_stack_ffffffffffffffc0,now)));\n    adns__intdone_process(ads);\n    adns__fdevents(ads,fds,nfds,0,(fd_set *)0x0,(fd_set *)0x0,(fd_set *)0x0,*now,(int *)0x0);\n  }\n  adns__returning(ads,(adns_query)0x0);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is adns_afterpoll"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](adns_query qu,char **strp)\n\n{\n  char *__s;\n  int iVar1;\n  size_t sVar2;\n  char *__dest;\n  int l;\n  char *before;\n  char *after;\n  \n  __s = *strp;\n  if (__s != (char *)0x0) {\n    sVar2 = strlen(__s);\n    iVar1 = (int)sVar2 + 1;\n    __dest = (char *)adns__alloc_final(qu,(long)iVar1);\n    memcpy(__dest,__s,(long)iVar1);\n    *strp = __dest;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is adns__makefinal_str"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](adns_state ads,adns_rr_hostaddr *ap,adns_rr_hostaddr *bp)\n\n{\n  adns_status aVar1;\n  \n  if (ap->astatus == bp->astatus) {\n    if (ap->astatus == adns_s_ok) {\n      aVar1 = dip_sockaddr(ads,(sockaddr *)&ap->addrs->addr,(sockaddr *)&bp->addrs->addr);\n    }\n    else {\n      aVar1 = adns_s_ok;\n    }\n  }\n  else {\n    aVar1 = ap->astatus;\n  }\n  return aVar1;\n}\n\n",
        "output": "The predicted function name is dip_hostaddr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](typeinfo *typei,adns_rrtype_conflict type)\n\n{\n  int iVar1;\n  \n  if ((type & 0x1000000U) == 0) {\n    iVar1 = 0x14;\n  }\n  else {\n    iVar1 = 0x20;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is gsz_addr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *argname)\n\n{\n  int iVar1;\n  long lVar2;\n  size_t sVar3;\n  int l;\n  \n  iVar1 = vb2.used + 1;\n  lVar2 = (long)vb2.used;\n  vb2.used = iVar1;\n  if (vb2.buf[lVar2] != ' ') {\n    Psyntax(\"not a space before argument\");\n  }\n  sVar3 = strlen(argname);\n  iVar1 = memcmp(vb2.buf + vb2.used,argname,(long)(int)sVar3);\n  if (iVar1 != 0) {\n    Psyntax(\"argument name wrong\");\n  }\n  iVar1 = (int)sVar3 + vb2.used;\n  vb2.used = iVar1 + 1;\n  if (vb2.buf[iVar1] != '=') {\n    Psyntax(\"not = after argument name\");\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is Parg"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](void *p,size_t s)\n\n{\n  void *pvVar1;\n  \n  if (s == 0) {\n                    /* WARNING: Subroutine does not return */\n    __assert_fail(\"s\",\"hfuzz.c\",0x89,\"Hrealloc\");\n  }\n  pvVar1 = realloc(p,s);\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is Hrealloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  return;\n}\n\n",
        "output": "The predicted function name is Tmallocshutdown"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  Tshutdown();\n  adns__vbuf_free(&vb);\n  adns__vbuf_free(&vbw);\n  Tmallocshutdown();\n  return;\n}\n\n",
        "output": "The predicted function name is Tcommonshutdown"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nint [MASK](pollfd *fds,int nfds,int timeout)\n\n{\n  int iVar1;\n  size_t sVar2;\n  int *piVar3;\n  long in_FS_OFFSET;\n  int r;\n  int amtread;\n  char *ep;\n  ulong ul_r;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  Qpoll(fds,nfds,timeout);\n  iVar1 = adns__vbuf_ensure(&vb2,1000);\n  if (iVar1 == 0) {\n    Tnomem();\n  }\n  fgets((char *)vb2.buf,vb2.avail,(FILE *)Tinputfile);\n  Pcheckinput();\n  Tensuresetup();\n  fputs((char *)vb2.buf,(FILE *)Treportfile);\n  sVar2 = strlen((char *)vb2.buf);\n  amtread = (int)sVar2;\n  if ((amtread < 1) || (amtread = amtread + -1, vb2.buf[amtread] != '\\n')) {\n    Psyntax(\"badly formed line\");\n  }\n  vb2.buf[amtread] = '\\0';\n  iVar1 = memcmp(vb2.buf,\" poll=\",6);\n  if (iVar1 != 0) {\n    Psyntax(\"syscall reply mismatch\");\n  }\n  if (vb2.buf[6] == 'E') {\n    ep._0_4_ = Perrno((char *)(vb2.buf + 6));\n    P_updatetime();\n    piVar3 = __errno_location();\n    *piVar3 = (int)ep;\n    FR_write(&ep,4);\n    iVar1 = -1;\n  }\n  else {\n    r = 0;\n    FR_write(&r,4);\n    ul_r = strtoul((char *)(vb2.buf + 6),&ep,10);\n    if ((0x7fffffff < ul_r) ||\n       ((*(char *)CONCAT44(ep._4_4_,(int)ep) != '\\0' && (*(char *)CONCAT44(ep._4_4_,(int)ep) != ' ')\n        ))) {\n      Psyntax(\"return value not E* or positive number\");\n    }\n    r = (int)ul_r;\n    vb2.used = (int)ep - (int)vb2.buf;\n    Parg(\"fds\");\n    Ppollfds(fds,nfds);\n    if (amtread < vb2.used) {\n                    /* WARNING: Subroutine does not return */\n      __assert_fail(\"vb2.used <= amtread\",\"hplayback.c\",0x16f,\"Hpoll\");\n    }\n    if (amtread != vb2.used) {\n      Psyntax(\"junk at end of line\");\n    }\n    P_updatetime();\n    iVar1 = r;\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is Hpoll"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](adns_state ads)\n\n{\n  adns_query paVar1;\n  adns_query parent;\n  adns_query child;\n  adns_query search;\n  \n  if ((ads->childw).head != (adns_query)0x0) {\n    if (((ads->childw).head)->back != (adns_query)0x0) {\n                    /* WARNING: Subroutine does not return */\n      __assert_fail(\"! (ads->childw).head-> back\",\"../src/check.c\",0x9b,\"checkc_queue_childw\");\n    }\n    for (parent = (ads->childw).head; parent != (adns_query)0x0; parent = parent->next) {\n      if (parent->next == (adns_query)0x0) {\n        paVar1 = (ads->childw).tail;\n      }\n      else {\n        paVar1 = parent->next->back;\n      }\n      if (parent != paVar1) {\n                    /* WARNING: Subroutine does not return */\n        __assert_fail(\"(parent)-> next ? (parent) == (parent)-> next-> back : (parent) == (ads->childw).tail\"\n                      ,\"../src/check.c\",0x9b,\"checkc_queue_childw\");\n      }\n      if (parent->state != _IScntrl) {\n                    /* WARNING: Subroutine does not return */\n        __assert_fail(\"parent->state == query_childw\",\"../src/check.c\",0x9b,\"checkc_queue_childw\");\n      }\n      if ((parent->children).head == (adns_query)0x0) {\n                    /* WARNING: Subroutine does not return */\n        __assert_fail(\"parent->children.head\",\"../src/check.c\",0x9b,\"checkc_queue_childw\");\n      }\n      if ((parent->children).head != (adns_query)0x0) {\n        if ((((parent->children).head)->siblings).back != (adns_query)0x0) {\n                    /* WARNING: Subroutine does not return */\n          __assert_fail(\"! (parent->children).head->siblings. back\",\"../src/check.c\",0x9b,\n                        \"checkc_queue_childw\");\n        }\n        for (child = (parent->children).head; child != (adns_query)0x0;\n            child = (child->siblings).next) {\n          if ((child->siblings).next == (adns_query)0x0) {\n            paVar1 = (parent->children).tail;\n          }\n          else {\n            paVar1 = (((child->siblings).next)->siblings).back;\n          }\n          if (child != paVar1) {\n                    /* WARNING: Subroutine does not return */\n            __assert_fail(\"(child)->siblings. next ? (child) == (child)->siblings. next->siblings. back : (child) == (parent->children).tail\"\n                          ,\"../src/check.c\",0x9b,\"checkc_queue_childw\");\n          }\n          if (parent != child->parent) {\n                    /* WARNING: Subroutine does not return */\n            __assert_fail(\"child->parent == parent\",\"../src/check.c\",0x9b,\"checkc_queue_childw\");\n          }\n          if (child->state == query_done) {\n            search = (ads->intdone).head;\n            while( true ) {\n              if (search == (adns_query)0x0) {\n                    /* WARNING: Subroutine does not return */\n                __assert_fail(\"!\\\"done child not on intdone\\\"\",\"../src/check.c\",0x9b,\n                              \"checkc_queue_childw\");\n              }\n              if (search == child) break;\n              search = search->next;\n            }\n          }\n        }\n      }\n      checkc_query(ads,parent);\n      checkc_query_alloc(ads,parent);\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is checkc_queue_childw"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](byte *buf,int maxlen)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  int local_34;\n  byte *local_30;\n  int done;\n  int c;\n  int v;\n  char *pf;\n  \n  done = 0;\n  local_34 = maxlen;\n  local_30 = buf;\n  while( true ) {\n    do {\n      do {\n        iVar1 = _IO_getc((_IO_FILE *)Tinputfile);\n        Pcheckinput();\n      } while (iVar1 == 10);\n    } while ((iVar1 == 0x20) || (iVar1 == 9));\n    if (iVar1 == 0x2e) break;\n    pcVar2 = strchr(\"0123456789abcdef\",iVar1);\n    if (pcVar2 == (char *)0x0) {\n      Psyntax(\"invalid first hex digit\");\n    }\n    iVar1 = _IO_getc((_IO_FILE *)Tinputfile);\n    Pcheckinput();\n    pcVar3 = strchr(\"0123456789abcdef\",iVar1);\n    if (pcVar3 == (char *)0x0) {\n      Psyntax(\"invalid second hex digit\");\n    }\n    if (local_34 < 1) {\n      Psyntax(\"buffer overflow in bytes\");\n    }\n    *local_30 = (char)pcVar2 * '\\x10' | (char)pcVar3 - 0x30U;\n    local_34 = local_34 + -1;\n    done = done + 1;\n    local_30 = local_30 + 1;\n  }\n  do {\n    iVar1 = _IO_getc((_IO_FILE *)Tinputfile);\n    Pcheckinput();\n  } while (iVar1 != 10);\n  return done;\n}\n\n",
        "output": "The predicted function name is Pbytes"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](adns_state ads,char *owner,adns_rrtype_conflict type,adns_queryflags flags,\n               void *context,adns_query *query_r)\n\n{\n  long lVar1;\n  int iVar2;\n  typeinfo *typei_00;\n  adns_query qu_00;\n  size_t sVar3;\n  char *pcVar4;\n  int *piVar5;\n  long in_FS_OFFSET;\n  undefined8 in_stack_ffffffffffffff78;\n  adns_queryflags local_70;\n  int ol;\n  int ndots;\n  adns_status st;\n  int r;\n  char *p;\n  typeinfo *typei;\n  adns_query qu;\n  timeval now;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  adns__consistency(ads,(adns_query)0x0,cc_enter);\n  if ((flags & 0xbff60000U) != 0) {\n    iVar2 = 0x26;\n    goto LAB_00010623;\n  }\n  typei_00 = adns__findtype(type);\n  if (typei_00 == (typeinfo *)0x0) {\n    iVar2 = 0x26;\n    goto LAB_00010623;\n  }\n  iVar2 = adns__gettimeofday(ads,&now);\n  if ((iVar2 != 0) ||\n     (qu_00 = query_alloc(ads,typei_00,type,flags,\n                          (timeval)CONCAT88(query_r,in_stack_ffffffffffffff78)),\n     qu_00 == (adns_query)0x0)) {\n    piVar5 = __errno_location();\n    iVar2 = *piVar5;\n    if (iVar2 == 0) {\n                    /* WARNING: Subroutine does not return */\n      __assert_fail(\"r\",\"../src/query.c\",0x14c,\"adns_submit\");\n    }\n    adns__returning(ads,(adns_query)0x0);\n    goto LAB_00010623;\n  }\n  (qu_00->ctx).ext = context;\n  (qu_00->ctx).callback = (anon_subr_void_adns_query_adns_query_for_callback *)0x0;\n  memset(&(qu_00->ctx).pinfo,0,8);\n  memset(&(qu_00->ctx).tinfo,0,0x20);\n  *query_r = qu_00;\n  sVar3 = strlen(owner);\n  ol = (int)sVar3;\n  if (ol == 0) {\n    st = 0xc9;\n  }\n  else if (ol < 0x101) {\n    local_70 = flags;\n    if (((0 < ol) && (owner[(long)ol + -1] == '.')) && ((ol < 2 || (owner[(long)ol + -2] != '\\\\'))))\n    {\n      local_70 = flags & 0xfffffffe;\n      qu_00->flags = local_70;\n      ol = ol + -1;\n    }\n    if ((local_70 & 1U) == 0) {\n      if (((local_70 & 4U) == 0) || (iVar2 = save_owner(qu_00,owner,ol), iVar2 != 0)) {\n        query_simple(ads,qu_00,owner,ol,typei_00,local_70,\n                     (timeval)CONCAT79((int7)((ulong)now.tv_usec >> 8),\n                                       CONCAT18((char)now.tv_usec,now.tv_sec)));\n        goto LAB_00010580;\n      }\n      st = adns_s_nomemory;\n    }\n    else {\n      iVar2 = adns__vbuf_append(&qu_00->search_vb,(byte *)owner,ol);\n      if (iVar2 != 0) {\n        ndots = 0;\n        p = owner;\n        while (pcVar4 = strchr(p,0x2e), pcVar4 != (char *)0x0) {\n          p = pcVar4 + 1;\n          ndots = ndots + 1;\n        }\n        if (ndots < ads->searchndots) {\n          iVar2 = 0;\n        }\n        else {\n          iVar2 = -1;\n        }\n        qu_00->search_doneabs = iVar2;\n        qu_00->search_origlen = ol;\n        adns__search_next(ads,qu_00,(timeval)CONCAT88(query_r,in_stack_ffffffffffffff78));\nLAB_00010580:\n        adns__autosys(ads,(timeval)CONCAT88(query_r,in_stack_ffffffffffffff78));\n        adns__returning(ads,qu_00);\n        iVar2 = 0;\n        goto LAB_00010623;\n      }\n      st = adns_s_nomemory;\n    }\n  }\n  else {\n    st = 0xca;\n  }\n  adns__query_fail(qu_00,st);\n  adns__returning(ads,qu_00);\n  iVar2 = 0;\nLAB_00010623:\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is adns_submit"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nadns_status\n[MASK](parseinfo *pai,adns_rr_hostaddr *ha,uint *want_io,size_t addrsz,int *cbyte_io,\n             int count,int dmstart)\n\n{\n  int iVar1;\n  adns_status aVar2;\n  long in_FS_OFFSET;\n  undefined4 in_stack_ffffffffffffff88;\n  int type;\n  int class;\n  int rdlen;\n  int rdstart;\n  int ownermatched;\n  int rri;\n  int naddrs;\n  uint need;\n  uint want;\n  adns_status st;\n  uint typef;\n  int rdend;\n  ulong ttl;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  need = *want_io;\n  naddrs = 0;\n  want = need;\n  for (rri = 0; rri < count; rri = rri + 1) {\n    st = adns__findrr_anychk(pai->qu,pai->serv,pai->dgram,pai->dglen,cbyte_io,&type,&class,&ttl,\n                             &rdlen,&rdstart,pai->dgram,pai->dglen,dmstart,&ownermatched);\n    aVar2 = st;\n    if (st != adns_s_ok) goto LAB_0000a373;\n    if ((((type != -1) && (ownermatched != 0)) && (class == 1)) &&\n       (typef = addr_rrtypeflag(type), (want & typef) != 0)) {\n      need = need & ~typef;\n      iVar1 = adns__vbuf_ensure(&pai->qu->vb,(int)addrsz * (naddrs + 1));\n      if (iVar1 == 0) {\n        aVar2 = adns_s_nomemory;\n        goto LAB_0000a373;\n      }\n      adns__update_expires\n                (pai->qu,ttl,(timeval)CONCAT88(cbyte_io,CONCAT44(count,in_stack_ffffffffffffff88)));\n      rdend = rdlen + rdstart;\n      st = pap_addr(pai,type,addrsz,&rdstart,rdend,\n                    (adns_rr_addr *)((pai->qu->vb).buf + (long)naddrs * addrsz));\n      aVar2 = st;\n      if (st != adns_s_ok) goto LAB_0000a373;\n      if (rdend != rdstart) {\n        aVar2 = adns_s_invaliddata;\n        goto LAB_0000a373;\n      }\n      naddrs = naddrs + 1;\n    }\n  }\n  if (0 < naddrs) {\n    aVar2 = append_addrs(pai->qu,addrsz,&ha->addrs,&ha->naddrs,(adns_rr_addr *)(pai->qu->vb).buf,\n                         naddrs);\n    st = aVar2;\n    if (aVar2 != adns_s_ok) goto LAB_0000a373;\n    ha->astatus = adns_s_ok;\n    if (need == 0) {\n      adns__isort(ha->addrs,naddrs,(int)addrsz,(pai->qu->vb).buf,div_addr,pai->ads);\n    }\n  }\n  *want_io = need;\n  aVar2 = adns_s_ok;\nLAB_0000a373:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return aVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is pap_findaddrs"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](adns_query qu,timeval now)\n\n{\n  int serv_00;\n  adns_state ads_00;\n  int iVar1;\n  udpsocket *puVar2;\n  int *piVar3;\n  char *pcVar4;\n  undefined8 in_RDX;\n  long in_RSI;\n  int serv;\n  int r;\n  adns_state ads;\n  adns_rr_addr *addr;\n  udpsocket *udp;\n  \n  if (qu->state != adns_qf_none) {\n                    /* WARNING: Subroutine does not return */\n    __assert_fail(\"qu->state == query_tosend\",\"../src/transmit.c\",0x100,\"adns__query_send\");\n  }\n  if (((qu->flags & 2U) == 0) && (qu->query_dglen < 0x201)) {\n    if (qu->retries < 0xf) {\n      ads_00 = qu->ads;\n      serv_00 = qu->udpnextserver;\n      puVar2 = adns__udpsocket_by_af(ads_00,(uint)*(ushort *)&ads_00->servers[serv_00].addr);\n      if (puVar2 == (udpsocket *)0x0) {\n                    /* WARNING: Subroutine does not return */\n        __assert_fail(\"udp\",\"../src/transmit.c\",0x10f,\"adns__query_send\");\n      }\n      iVar1 = Hsendto(puVar2->fd,qu->query_dgram,qu->query_dglen,0,\n                      (sockaddr *)&ads_00->servers[serv_00].addr,ads_00->servers[serv_00].len);\n      if ((iVar1 < 0) && (piVar3 = __errno_location(), *piVar3 == 0x5a)) {\n        qu->retries = 0;\n        query_usetcp(qu,(timeval)CONCAT88(in_RDX,in_RSI));\n        return;\n      }\n      if ((iVar1 < 0) && (piVar3 = __errno_location(), *piVar3 != 0xb)) {\n        piVar3 = __errno_location();\n        pcVar4 = strerror(*piVar3);\n        adns__warn(ads_00,serv_00,(adns_query)0x0,\"sendto failed: %s\",pcVar4);\n      }\n      adns__timeout_set(qu,(timeval)CONCAT88(in_RDX,in_RSI),in_RSI);\n      qu->udpsent = qu->udpsent | (long)(1 << ((byte)serv_00 & 0x1f));\n      qu->udpnextserver = (serv_00 + 1) % ads_00->nservers;\n      qu->retries = qu->retries + 1;\n      qu->next = (adns_query)0x0;\n      qu->back = (ads_00->udpw).tail;\n      if ((ads_00->udpw).tail == (adns_query)0x0) {\n        (ads_00->udpw).head = qu;\n      }\n      else {\n        ((ads_00->udpw).tail)->next = qu;\n      }\n      (ads_00->udpw).tail = qu;\n    }\n    else {\n      adns__query_fail(qu,adns_s_timeout);\n    }\n  }\n  else {\n    query_usetcp(qu,(timeval)CONCAT88(in_RDX,in_RSI));\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is adns__query_send"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  int __fd;\n  char *__nptr;\n  int fd;\n  char *fdstr;\n  \n  if (Tensure_fuzzrawfile::done == 0) {\n    Tensure_fuzzrawfile::done = 1;\n    __nptr = getenv(\"ADNS_TEST_FUZZRAW_DUMP_FD\");\n    if (__nptr != (char *)0x0) {\n      __fd = atoi(__nptr);\n      Tfuzzrawfile = (FILE *)fdopen(__fd,\"ab\");\n      if ((FILE *)Tfuzzrawfile == (FILE *)0x0) {\n        Tfailed(\"fdopen ADNS_TEST_FUZZRAW_DUMP_FD\");\n      }\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is Tensure_fuzzrawfile"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](adns_query qu)\n\n{\n  adns_state paVar1;\n  adns_answer_conflict *paVar2;\n  int iVar3;\n  adns_state ads;\n  adns_answer_conflict *ans;\n  \n  paVar1 = qu->ads;\n  adns__cancel_children(qu);\n  qu->id = -1;\n  paVar2 = qu->answer;\n  if ((((qu->flags & 1U) != 0) && (paVar2->status != adns_s_nomemory)) &&\n     (iVar3 = save_owner(qu,(char *)(qu->search_vb).buf,(qu->search_vb).used), iVar3 == 0)) {\n    adns__query_fail(qu,adns_s_nomemory);\n    return;\n  }\n  if ((paVar2->nrrs != 0) &&\n     (qu->typei->diff_needswap !=\n      (anon_subr_int_adns_state_void_ptr_void_ptr_for_diff_needswap *)0x0)) {\n    iVar3 = adns__vbuf_ensure(&qu->vb,qu->answer->rrsz);\n    if (iVar3 == 0) {\n      adns__query_fail(qu,adns_s_nomemory);\n      return;\n    }\n    adns__isort((void *)paVar2->rrs,paVar2->nrrs,paVar2->rrsz,(qu->vb).buf,\n                (anon_subr_int_void_ptr_void_ptr_void_ptr *)qu->typei->diff_needswap,qu->ads);\n  }\n  if ((paVar2->nrrs != 0) &&\n     (qu->typei->postsort !=\n      (anon_subr_void_adns_state_void_ptr_int_int_typeinfo_ptr_for_postsort *)0x0)) {\n    (*qu->typei->postsort)(qu->ads,(void *)paVar2->rrs,paVar2->nrrs,paVar2->rrsz,qu->typei);\n  }\n  paVar2->expires = qu->expires;\n  qu->state = query_done;\n  if (qu->parent == (adns_query)0x0) {\n    makefinal_query(qu);\n    qu->next = (adns_query)0x0;\n    qu->back = (qu->ads->output).tail;\n    if ((qu->ads->output).tail == (adns_query)0x0) {\n      (qu->ads->output).head = qu;\n    }\n    else {\n      ((qu->ads->output).tail)->next = qu;\n    }\n    (qu->ads->output).tail = qu;\n  }\n  else {\n    qu->next = (adns_query)0x0;\n    qu->back = (paVar1->intdone).tail;\n    if ((paVar1->intdone).tail == (adns_query)0x0) {\n      (paVar1->intdone).head = qu;\n    }\n    else {\n      ((paVar1->intdone).tail)->next = qu;\n    }\n    (paVar1->intdone).tail = qu;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is adns__query_done"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](revparse_state *rps,char *dgram,int nlabels,adns_rrtype_conflict *rrtype_r\n                         ,adns_sockaddr *addr_r)\n\n{\n  _Bool _Var1;\n  \n  _Var1 = revparse_inet(rps,dgram,nlabels,rrtype_r,addr_r);\n  if ((_Var1 == false) &&\n     (_Var1 = revparse_inet6(rps,dgram,nlabels,rrtype_r,addr_r), _Var1 == false)) {\n    return false;\n  }\n  return true;\n}\n\n",
        "output": "The predicted function name is adns__revparse_done"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](adns_state ads,adns_query qu)\n\n{\n  adns_query paVar1;\n  adns_query an;\n  \n  if ((qu->allocations).head != (adns_query)0x0) {\n    if (*(long *)&((qu->allocations).head)->state != 0) {\n                    /* WARNING: Subroutine does not return */\n      __assert_fail(\"! (qu->allocations).head-> back\",\"../src/check.c\",0x3b,\"checkc_query_alloc\");\n    }\n    for (an = (qu->allocations).head; an != (adns_query)0x0; an = (adns_query)an->ads) {\n      if (an->ads == (adns_state)0x0) {\n        paVar1 = (qu->allocations).tail;\n      }\n      else {\n        paVar1 = (adns_query)an->ads->logfn;\n      }\n      if (an != paVar1) {\n                    /* WARNING: Subroutine does not return */\n        __assert_fail(\"(an)-> next ? (an) == (an)-> next-> back : (an) == (qu->allocations).tail\",\n                      \"../src/check.c\",0x3b,\"checkc_query_alloc\");\n      }\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is checkc_query_alloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](adns_query qu,void *datap)\n\n{\n  adns_rr_srvha *rrp;\n  \n  mfp_hostaddr(qu,(adns_rr_hostaddr *)((long)datap + 0x10));\n  return;\n}\n\n",
        "output": "The predicted function name is mf_srvha"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  return t_sys_fd;\n}\n\n",
        "output": "The predicted function name is Ttestinputfd"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](adns_query parent,adns_query child)\n\n{\n  adns_answer_conflict *paVar1;\n  adns_state paVar2;\n  int iVar3;\n  int i;\n  uchar *found;\n  adns_answer_conflict *cans;\n  adns_state ads;\n  adns_sockaddr *queried;\n  \n  paVar1 = child->answer;\n  paVar2 = parent->ads;\n  if ((paVar1->status == adns_s_nxdomain) || (paVar1->status == adns_s_nodata)) {\n    adns__query_fail(parent,adns_s_inconsistent);\n  }\n  else if (paVar1->status == adns_s_ok) {\n    i = 0;\n    found = (uchar *)paVar1->rrs;\n    for (; i < paVar1->nrrs; i = i + 1) {\n      iVar3 = adns__addrs_equal_raw\n                        ((sockaddr *)&(parent->ctx).tinfo.field_0x4,\n                         (uint)*(ushort *)&(parent->ctx).tinfo.field_0x4,found);\n      if (iVar3 != 0) {\n        if ((parent->children).head == (adns_query)0x0) {\n          adns__query_done(parent);\n          return;\n        }\n        parent->next = (adns_query)0x0;\n        parent->back = (paVar2->childw).tail;\n        if ((paVar2->childw).tail == (adns_query)0x0) {\n          (paVar2->childw).head = parent;\n        }\n        else {\n          ((paVar2->childw).tail)->next = parent;\n        }\n        (paVar2->childw).tail = parent;\n        return;\n      }\n      found = found + paVar1->rrsz;\n    }\n    adns__query_fail(parent,adns_s_inconsistent);\n  }\n  else {\n    adns__query_fail(parent,paVar1->status);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is icb_ptr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](adns_state ads,char *envvar)\n\n{\n  char *text;\n  char *textdata;\n  \n  if ((ads->iflags & 1U) == 0) {\n    text = instrum_getenv(ads,envvar);\n    if (text != (char *)0x0) {\n      readconfigtext(ads,text,envvar);\n    }\n  }\n  else {\n    adns__debug(ads,-1,(adns_query)0x0,\"not checking environment variable `%s\\'\",envvar);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is readconfigenvtext"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](adns_state ads,int fd)\n\n{\n  uint uVar1;\n  int iVar2;\n  int *piVar3;\n  int r;\n  \n  uVar1 = Hfcntl(fd,3,0);\n  if ((int)uVar1 < 0) {\n    piVar3 = __errno_location();\n    iVar2 = *piVar3;\n  }\n  else {\n    iVar2 = Hfcntl(fd,4,(ulong)(uVar1 | 0x800));\n    if (iVar2 < 0) {\n      piVar3 = __errno_location();\n      iVar2 = *piVar3;\n    }\n    else {\n      iVar2 = 0;\n    }\n  }\n  return iVar2;\n}\n\n",
        "output": "The predicted function name is adns__setnonblock"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](adns_query qu)\n\n{\n  adns_query paVar1;\n  adns_query cqu;\n  adns_query ncqu;\n  \n  cqu = (qu->children).head;\n  while (cqu != (adns_query)0x0) {\n    paVar1 = (cqu->siblings).next;\n    adns__cancel(cqu);\n    cqu = paVar1;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is adns__cancel_children"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int domain,int type)\n\n{\n  char *pcVar1;\n  \n  vb.used = 0;\n  Tvba(\"socket\");\n  if (domain == 2) {\n    pcVar1 = \" domain=AF_INET\";\n  }\n  else if (domain == 10) {\n    pcVar1 = \" domain=AF_INET6\";\n  }\n  else {\n    pcVar1 = \" domain=AF_???\";\n  }\n  Tvbf(pcVar1);\n  if (type == 1) {\n    pcVar1 = \" type=SOCK_STREAM\";\n  }\n  else {\n    pcVar1 = \" type=SOCK_DGRAM\";\n  }\n  Tvbf(pcVar1);\n  Q_vb();\n  return;\n}\n\n",
        "output": "The predicted function name is Qsocket"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *fmt,__va_list_tag *al)\n\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  char buf [1000];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  buf[998] = '\\t';\n  vsnprintf(buf,1000,fmt,al);\n  if (buf[998] != '\\t') {\n                    /* WARNING: Subroutine does not return */\n    __assert_fail(\"buf[sizeof(buf)-2] == \\'\\\\t\\'\",\"hcommon.c\",0xe9,\"Tvbvf\");\n  }\n  Tvba(buf);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is Tvbvf"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nadns_status [MASK](parseinfo *pai,int *cbyte_io,int max,char **mb_r)\n\n{\n  uchar *puVar1;\n  long lVar2;\n  adns_status aVar3;\n  int iVar4;\n  long in_FS_OFFSET;\n  int lablen;\n  int labstart;\n  int i;\n  int needquote;\n  int neednorm;\n  adns_status st;\n  int r;\n  int c;\n  uchar *p;\n  vbuf *vb;\n  char *str;\n  findlabel_state fls;\n  \n  lVar2 = *(long *)(in_FS_OFFSET + 0x28);\n  vb = &pai->qu->vb;\n  vb->used = 0;\n  adns__findlabel_start(&fls,pai->ads,-1,pai->qu,pai->dgram,pai->dglen,max,*cbyte_io,cbyte_io);\n  aVar3 = adns__findlabel_next(&fls,&lablen,&labstart);\n  st = aVar3;\n  if (aVar3 != adns_s_ok) goto LAB_0000b9a5;\n  if (lablen == 0) {\n    adns__vbuf_appendstr(vb,\".\");\n  }\n  else {\n    neednorm = 1;\n    i = 0;\n    needquote = 0;\n    p = pai->dgram + labstart;\n    for (; i < lablen; i = i + 1) {\n      puVar1 = p + 1;\n      c = (int)*p;\n      p = puVar1;\n      if (((c & 0xffffff7fU) < 0x20) || ((c & 0xffffff7fU) == 0x7f)) {\n        aVar3 = adns_s_invaliddata;\n        goto LAB_0000b9a5;\n      }\n      if ((c == 0x2e) && (neednorm == 0)) {\n        neednorm = 1;\n      }\n      else if ((c == 0x20) || ((0x7e < (uint)c || (iVar4 = ctype_822special(c), iVar4 != 0)))) {\n        needquote = needquote + 1;\n      }\n      else {\n        neednorm = 0;\n      }\n    }\n    if ((needquote == 0) && (neednorm == 0)) {\n      r = adns__vbuf_append(vb,pai->dgram + labstart,lablen);\n      if (r == 0) {\n        aVar3 = adns_s_nomemory;\n        goto LAB_0000b9a5;\n      }\n    }\n    else {\n      r = adns__vbuf_ensure(vb,needquote + lablen + 4);\n      if (r == 0) {\n        aVar3 = adns_s_nomemory;\n        goto LAB_0000b9a5;\n      }\n      adns__vbuf_appendq(vb,\"\\\"\",1);\n      i = 0;\n      needquote = 0;\n      p = pai->dgram + labstart;\n      for (; i < lablen; i = i + 1) {\n        c = (int)*p;\n        if ((c == 0x22) || (c == 0x5c)) {\n          adns__vbuf_appendq(vb,\"\\\\\",1);\n        }\n        adns__vbuf_appendq(vb,p,1);\n        p = p + 1;\n      }\n      adns__vbuf_appendq(vb,\"\\\"\",1);\n    }\n    r = adns__vbuf_appendstr(vb,\"@\");\n    if (r == 0) {\n      aVar3 = adns_s_nomemory;\n      goto LAB_0000b9a5;\n    }\n    aVar3 = adns__parse_domain_more(&fls,pai->ads,pai->qu,vb,0,pai->dgram);\n    st = aVar3;\n    if (aVar3 != adns_s_ok) goto LAB_0000b9a5;\n  }\n  str = (char *)adns__alloc_interim(pai->qu,(long)(vb->used + 1));\n  if (str == (char *)0x0) {\n    aVar3 = adns_s_nomemory;\n  }\n  else {\n    memcpy(str,vb->buf,(long)vb->used);\n    str[vb->used] = '\\0';\n    *mb_r = str;\n    aVar3 = adns_s_ok;\n  }\nLAB_0000b9a5:\n  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return aVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is pap_mailbox822"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nadns_status [MASK](vbuf *vb,adns_rrtype_conflict rrt,void *datap)\n\n{\n  adns_status aVar1;\n  adns_rr_hostaddr *rrp;\n  \n  aVar1 = csp_hostaddr(vb,rrt,(adns_rr_hostaddr *)datap);\n  return aVar1;\n}\n\n",
        "output": "The predicted function name is cs_hostaddr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](adns_state ads,int serv,adns_query qu,char *fmt,...)\n\n{\n  long lVar1;\n  char in_AL;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  undefined4 in_XMM1_Da;\n  undefined4 in_XMM2_Da;\n  undefined4 in_XMM3_Da;\n  undefined4 in_XMM4_Da;\n  undefined4 in_XMM5_Da;\n  undefined4 in_XMM6_Da;\n  undefined4 in_XMM7_Da;\n  va_list al;\n  undefined local_b8 [32];\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = in_XMM0_Da;\n    local_78 = in_XMM1_Da;\n    local_68 = in_XMM2_Da;\n    local_58 = in_XMM3_Da;\n    local_48 = in_XMM4_Da;\n    local_38 = in_XMM5_Da;\n    local_28 = in_XMM6_Da;\n    local_18 = in_XMM7_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  al[0].gp_offset = 0x20;\n  al[0].fp_offset = 0x30;\n  al[0].overflow_arg_area = &stack0x00000008;\n  al[0].reg_save_area = local_b8;\n  local_98 = in_R8;\n  local_90 = in_R9;\n  adns__vdiag(ads,\" debug\",adns_if_none,serv,qu,fmt,al);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is adns__debug"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](adns_state ads,char *filename,\n                      anon_subr_int_adns_state_getline_ctx_ptr_char_ptr_int_char_ptr_int *getline,\n                      undefined8 gl_ctx)\n\n{\n  int iVar1;\n  size_t sVar2;\n  long in_FS_OFFSET;\n  undefined8 local_838;\n  anon_subr_int_adns_state_getline_ctx_ptr_char_ptr_int_char_ptr_int *local_830;\n  char *local_828;\n  adns_state local_820;\n  int lno;\n  int l;\n  int dirl;\n  char *p;\n  char *q;\n  configcommandinfo *ccip;\n  char linebuf [2000];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  lno = 1;\n  local_838 = gl_ctx;\n  local_830 = getline;\n  local_828 = filename;\n  local_820 = ads;\n  while (l = (*local_830)(local_820,&local_838,local_828,lno,linebuf,2000), l != -1) {\n    if (l != -2) {\n      while ((0 < l && (iVar1 = ctype_whitespace((int)linebuf[l + -1]), iVar1 != 0))) {\n        l = l + -1;\n      }\n      linebuf[l] = '\\0';\n      p = linebuf;\n      while (iVar1 = ctype_whitespace((int)*p), iVar1 != 0) {\n        p = p + 1;\n      }\n      if (((*p != '#') && (*p != ';')) && (*p != '\\0')) {\n        q = p;\n        while ((*q != '\\0' && (iVar1 = ctype_whitespace((int)*q), iVar1 == 0))) {\n          q = q + 1;\n        }\n        dirl = (int)q - (int)p;\n        ccip = configcommandinfos;\n        while ((ccip->name != (char *)0x0 &&\n               ((sVar2 = strlen(ccip->name), sVar2 != (long)dirl ||\n                (iVar1 = memcmp(ccip->name,p,(long)q - (long)p), iVar1 != 0))))) {\n          ccip = ccip + 1;\n        }\n        if (ccip->name == (char *)0x0) {\n          if ((local_820->field_0x608 & 1) != 0) {\n            adns__diag(local_820,-1,(adns_query)0x0,\"%s:%d: unknown configuration directive `%.*s\\'\"\n                       ,local_828,(ulong)(uint)lno,(long)q - (long)p & 0xffffffff,p);\n          }\n        }\n        else {\n          while (iVar1 = ctype_whitespace((int)*q), iVar1 != 0) {\n            q = q + 1;\n          }\n          (*ccip->fn)(local_820,local_828,lno,q);\n        }\n      }\n    }\n    lno = lno + 1;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is readconfiggeneric"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](adns_state ads,adns_query qu)\n\n{\n  if (qu->state != query_done) {\n                    /* WARNING: Subroutine does not return */\n    __assert_fail(\"qu->state == query_done\",\"../src/check.c\",0x9f,\"checkc_query_done\");\n  }\n  if (((qu->children).head == (adns_query)0x0) && ((qu->children).tail == (adns_query)0x0)) {\n    checkc_query(ads,qu);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __assert_fail(\"!qu->children.head && !qu->children.tail\",\"../src/check.c\",0xa0,\"checkc_query_done\"\n               );\n}\n\n",
        "output": "The predicted function name is checkc_query_done"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nadns_status [MASK](vbuf *vb,adns_rrtype_conflict rrt,void *datap)\n\n{\n  adns_status aVar1;\n  char **domainp;\n  \n                    /* WARNING: Load size is inaccurate */\n  aVar1 = csp_domain(vb,*datap);\n  return aVar1;\n}\n\n",
        "output": "The predicted function name is cs_domain"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](adns_state ads,adns_query qu,typeinfo *typei,vbuf *qumsg_vb,int id,\n                 adns_queryflags flags,timeval now)\n\n{\n  byte *pbVar1;\n  undefined8 in_stack_ffffffffffffffc8;\n  \n  pbVar1 = qumsg_vb->buf;\n  *(undefined8 *)&qu->vb = *(undefined8 *)qumsg_vb;\n  (qu->vb).buf = pbVar1;\n  adns__vbuf_init(qumsg_vb);\n  pbVar1 = (byte *)Hmalloc((long)(qu->vb).used);\n  qu->query_dgram = pbVar1;\n  if (qu->query_dgram == (byte *)0x0) {\n    adns__query_fail(qu,adns_s_nomemory);\n  }\n  else {\n    qu->id = id;\n    qu->query_dglen = (qu->vb).used;\n    memcpy(qu->query_dgram,(qu->vb).buf,(long)(qu->vb).used);\n    (*typei->query_send)(qu,(timeval)CONCAT412(id,CONCAT48(flags,in_stack_ffffffffffffffc8)));\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is query_submit"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n_Bool [MASK](int e)\n\n{\n  _Bool _Var1;\n  \n  if ((((e == 0x61) || (e == 0x16)) || (e == 0x1c)) || (e == 0x26)) {\n    _Var1 = true;\n  }\n  else {\n    _Var1 = false;\n  }\n  return _Var1;\n}\n\n",
        "output": "The predicted function name is addrtext_our_errno"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void *p,size_t sz)\n\n{\n  int iVar1;\n  size_t sVar2;\n  ssize_t got;\n  \n  if (Tfuzzrawfile != (FILE *)0x0) {\n    sVar2 = fwrite(p,1,sz,(FILE *)Tfuzzrawfile);\n    iVar1 = ferror((FILE *)Tfuzzrawfile);\n    if (iVar1 != 0) {\n      Tfailed(\"write fuzzraw output file\");\n    }\n    if (sz != sVar2) {\n                    /* WARNING: Subroutine does not return */\n      __assert_fail(\"got==sz\",\"hplayback.c\",0x27,\"FR_write\");\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is FR_write"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nadns_status\n[MASK](adns_query parent,adns_query *query_r,vbuf *qumsg_vb,int id,uint want,\n           adns_queryflags flags,timeval now,qcontext *ctx)\n\n{\n  adns_rrtype_conflict aVar1;\n  adns_status aVar2;\n  typeinfo *typei;\n  long in_FS_OFFSET;\n  adns_rrtype_conflict type;\n  adns_status err;\n  adns_query qu;\n  adns_state ads;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  ads = parent->ads;\n  aVar1 = parent->answer->type;\n  *(uint *)&ctx->tinfo = want;\n  *(undefined4 *)&(ctx->tinfo).field_0x4 = 0;\n  typei = adns__findtype(adns_r_addr);\n  aVar2 = adns__internal_submit\n                    (ads,&qu,parent,typei,aVar1 & 0xff000000U | 0x10001,qumsg_vb,id,flags,now,ctx);\n  if (aVar2 == adns_s_ok) {\n    *query_r = qu;\n    aVar2 = adns_s_ok;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return aVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is addr_submit"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nadns_status [MASK](vbuf *vb,adns_rrtype_conflict rrt,void *datap)\n\n{\n  adns_status aVar1;\n  adns_status st;\n  adns_rr_srvha *rrp;\n  \n  aVar1 = csp_srv_begin(vb,(adns_rr_srvha *)datap);\n  if (aVar1 == adns_s_ok) {\n    aVar1 = csp_hostaddr(vb,rrt,(adns_rr_hostaddr *)((long)datap + 0x10));\n  }\n  return aVar1;\n}\n\n",
        "output": "The predicted function name is cs_srvha"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](adns_state ads,pollfd *fds,int *nfds_io,int *timeout_io,timeval *now)\n\n{\n  long lVar1;\n  int iVar2;\n  int iVar3;\n  long in_FS_OFFSET;\n  undefined8 in_stack_ffffffffffffff68;\n  int timeout_ms;\n  int r;\n  int space;\n  int found;\n  timeval *tv_to;\n  timeval tv_nowbuf;\n  timeval tv_tobuf;\n  pollfd fds_tmp [3];\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  adns__consistency(ads,(adns_query)0x0,cc_enter);\n  if (timeout_io != (int *)0x0) {\n    adns__must_gettimeofday(ads,(timeval **)&stack0xffffffffffffff70,&tv_nowbuf);\n    if (now == (timeval *)0x0) {\n      *nfds_io = 0;\n      r = 0;\n      goto xit;\n    }\n    iVar2 = *timeout_io;\n    if (iVar2 == -1) {\n      tv_to = (timeval *)0x0;\n    }\n    else {\n      tv_tobuf.tv_sec = (__time_t)(iVar2 / 1000);\n      tv_tobuf.tv_usec = (__suseconds_t)((iVar2 % 1000) * 1000);\n      tv_to = &tv_tobuf;\n    }\n    adns__timeouts(ads,0,&tv_to,&tv_tobuf,(timeval)CONCAT88(now,in_stack_ffffffffffffff68));\n    if (tv_to == (timeval *)0x0) {\n      timeout_ms = -1;\n    }\n    else {\n      if (tv_to != &tv_tobuf) {\n                    /* WARNING: Subroutine does not return */\n        __assert_fail(\"tv_to == &tv_tobuf\",\"../src/poll.c\",0x3a,\"adns_beforepoll\");\n      }\n      iVar2 = (int)((tv_tobuf.tv_usec + 999) / 1000);\n      if ((0x7fffffff - iVar2) / 1000 <= tv_tobuf.tv_sec) {\n                    /* WARNING: Subroutine does not return */\n        __assert_fail(\"tv_tobuf.tv_sec < (INT_MAX-timeout_ms)/1000\",\"../src/poll.c\",0x3c,\n                      \"adns_beforepoll\");\n      }\n      timeout_ms = iVar2 + (int)tv_tobuf.tv_sec * 1000;\n    }\n    *timeout_io = timeout_ms;\n  }\n  iVar2 = *nfds_io;\n  if (iVar2 < 3) {\n    iVar3 = adns__pollfds(ads,fds_tmp);\n    *nfds_io = iVar3;\n    if (iVar2 < iVar3) {\n      r = 0x22;\n      goto xit;\n    }\n    memcpy(fds,fds_tmp,(long)iVar3 * 8);\n  }\n  else {\n    iVar2 = adns__pollfds(ads,fds);\n    *nfds_io = iVar2;\n  }\n  r = 0;\nxit:\n  adns__returning(ads,(adns_query)0x0);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return r;\n}\n\n",
        "output": "The predicted function name is adns_beforepoll"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nint [MASK](int fd,void *msg,int msglen,uint flags,sockaddr *addr,int addrlen)\n\n{\n  int iVar1;\n  size_t sVar2;\n  int *piVar3;\n  long in_FS_OFFSET;\n  int r;\n  int amtread;\n  char *ep;\n  ulong ul_r;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  Tmust(\"sendto\",\"flags\",(uint)(flags == 0));\n  Qsendto(fd,msg,msglen,addr,addrlen);\n  iVar1 = adns__vbuf_ensure(&vb2,1000);\n  if (iVar1 == 0) {\n    Tnomem();\n  }\n  fgets((char *)vb2.buf,vb2.avail,(FILE *)Tinputfile);\n  Pcheckinput();\n  Tensuresetup();\n  fputs((char *)vb2.buf,(FILE *)Treportfile);\n  sVar2 = strlen((char *)vb2.buf);\n  amtread = (int)sVar2;\n  if ((amtread < 1) || (amtread = amtread + -1, vb2.buf[amtread] != '\\n')) {\n    Psyntax(\"badly formed line\");\n  }\n  vb2.buf[amtread] = '\\0';\n  iVar1 = memcmp(vb2.buf,\" sendto=\",8);\n  if (iVar1 != 0) {\n    Psyntax(\"syscall reply mismatch\");\n  }\n  if (vb2.buf[8] == 'E') {\n    ep._0_4_ = Perrno((char *)(vb2.buf + 8));\n    P_updatetime();\n    piVar3 = __errno_location();\n    *piVar3 = (int)ep;\n    FR_write(&ep,4);\n    iVar1 = -1;\n  }\n  else {\n    r = 0;\n    FR_write(&r,4);\n    ul_r = strtoul((char *)(vb2.buf + 8),&ep,10);\n    if ((0x7fffffff < ul_r) ||\n       ((*(char *)CONCAT44(ep._4_4_,(int)ep) != '\\0' && (*(char *)CONCAT44(ep._4_4_,(int)ep) != ' ')\n        ))) {\n      Psyntax(\"return value not E* or positive number\");\n    }\n    r = (int)ul_r;\n    vb2.used = (int)ep - (int)vb2.buf;\n    FR_write(&r,4);\n    if (amtread < vb2.used) {\n                    /* WARNING: Subroutine does not return */\n      __assert_fail(\"vb2.used <= amtread\",\"hplayback.c\",0x254,\"Hsendto\");\n    }\n    if (amtread != vb2.used) {\n      Psyntax(\"junk at end of line\");\n    }\n    P_updatetime();\n    iVar1 = r;\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is Hsendto"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](char **bufp_io,char **word_r,int *l_r)\n\n{\n  int iVar1;\n  char *p;\n  char *q;\n  \n  p = *bufp_io;\n  while( true ) {\n    iVar1 = ctype_whitespace((int)*p);\n    if (iVar1 == 0) break;\n    p = p + 1;\n  }\n  if (*p == '\\0') {\n    iVar1 = 0;\n  }\n  else {\n    for (q = p; *q != '\\0'; q = q + 1) {\n      iVar1 = ctype_whitespace((int)*q);\n      if (iVar1 != 0) break;\n    }\n    *l_r = (int)q - (int)p;\n    *word_r = p;\n    *bufp_io = q;\n    iVar1 = 1;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is nextword"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nadns_status\n[MASK](adns_state ads,adns_queryflags flags,checklabel_state *cls,qcontext *ctx,int labnum,\n       char *dgram,int labstart,int lablen)\n\n{\n  _Bool _Var1;\n  \n  if (lablen == 0) {\n    _Var1 = adns__revparse_done((revparse_state *)cls,dgram,labnum,\n                                (adns_rrtype_conflict *)&ctx->tinfo,\n                                (adns_sockaddr *)&(ctx->tinfo).field_0x4);\n    if (_Var1 != true) {\n      return 200;\n    }\n  }\n  else {\n    _Var1 = adns__revparse_label((revparse_state *)cls,labnum,dgram,labstart,lablen);\n    if (_Var1 != true) {\n      return 200;\n    }\n  }\n  return adns_s_ok;\n}\n\n",
        "output": "The predicted function name is ckl_ptr"
    }
]