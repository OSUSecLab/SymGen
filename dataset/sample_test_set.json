[
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  if (DAT_002053d0 == (code *)0x0) {\n    EVP_PKEY_meth_get_ctrl(DAT_00205350,0,&DAT_002053d0);\n  }\n  (*DAT_002053d0)(param_1,param_2,param_3);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_rsa_ctrl_str"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  DAT_00253e98 = 1;\n  return;\n}\n\n",
        "output": "The predicted function name is enable_testing"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8\n[MASK](undefined *param_1,void *param_2,ulong *param_3,undefined4 param_4,undefined8 param_5,\n            undefined8 param_6)\n\n{\n  int iVar1;\n  \n  iVar1 = FUN_0000879a(\"test/fake_rsaprov.c\",0xd8,\"sigctx\",param_1,param_5,param_6,param_6,param_5);\n  if ((iVar1 != 0) &&\n     (iVar1 = FUN_00006d5b(\"test/fake_rsaprov.c\",0xd8,\"*sigctx\",&DAT_0000e145,*param_1,1),\n     iVar1 != 0)) {\n    *param_3 = 0x100;\n    if (param_2 != (void *)0x0) {\n      iVar1 = FUN_00006fd6(\"test/fake_rsaprov.c\",0xde,\"sigsize\",\"*siglen\",param_4,\n                           *param_3 & 0xffffffff);\n      if (iVar1 == 0) {\n        return 0;\n      }\n      *param_1 = 2;\n      memset(param_2,0x61,*param_3);\n    }\n    return 1;\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is fake_rsa_sig_sign"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,long param_2)\n\n{\n  int iVar1;\n  int local_c;\n  \n  local_c = 0;\n  while( true ) {\n    if (*(long *)(param_2 + (long)local_c * 8) == 0) {\n      return 0;\n    }\n    iVar1 = FUN_0000cc4d(param_1,*(undefined8 *)(param_2 + (long)local_c * 8));\n    if (iVar1 != 0) break;\n    local_c = local_c + 1;\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is domfind"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](char *param_1,int param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  uint local_c;\n  \n  iVar1 = strcasecmp(param_1,\"ibt\");\n  if (iVar1 == 0) {\n    local_c = 1;\n  }\n  else {\n    iVar1 = strcasecmp(param_1,\"shstk\");\n    if (iVar1 == 0) {\n      local_c = 2;\n    }\n    else {\n      iVar1 = strcasecmp(param_1,\"lam_u48\");\n      if (iVar1 == 0) {\n        local_c = 4;\n      }\n      else {\n        iVar1 = strcasecmp(param_1,\"lam_u57\");\n        if (iVar1 != 0) {\n          uVar2 = gettext(\"Unknown x86 feature: %s\\n\");\n          error(uVar2,param_1);\n          return 0xffffffff;\n        }\n        local_c = 8;\n      }\n    }\n  }\n  if (param_2 == 0) {\n    DAT_0020a364 = DAT_0020a364 | local_c;\n    DAT_0020a360 = DAT_0020a360 & ~local_c;\n  }\n  else {\n    DAT_0020a360 = DAT_0020a360 | local_c;\n    DAT_0020a364 = DAT_0020a364 & ~local_c;\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is elf_x86_feature"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8\n[MASK](undefined8 param_1,ulong param_2,undefined8 param_3,undefined8 param_4,\n            undefined8 param_5)\n\n{\n  ulong local_28;\n  undefined8 local_20;\n  undefined8 local_10;\n  \n  local_28 = param_2;\n  local_20 = param_1;\n  local_10 = param_5;\n  if ((param_2 & 1) != 0) {\n    local_10 = param_1;\n  }\n  while (local_28 != 0) {\n    local_20 = FUN_000035fb(local_20,local_20,param_3,param_4);\n    local_28 = local_28 >> 1;\n    if ((local_28 & 1) != 0) {\n      local_10 = FUN_000035fb(local_10,local_20,param_3,param_4);\n    }\n  }\n  return local_10;\n}\n\n",
        "output": "The predicted function name is powm"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined4 param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  switch(param_2) {\n  case 0:\n    iVar1 = FUN_0000840c(param_1);\n    if ((iVar1 == 0) && (iVar1 = FUN_00008431(param_1), iVar1 == 0)) {\n      return 4;\n    }\n    uVar2 = 1;\n    break;\n  case 1:\n    uVar2 = 2;\n    break;\n  case 2:\n    iVar1 = FUN_00008431(param_1);\n    if (iVar1 == 0) {\n      uVar2 = 3;\n    }\n    else {\n      uVar2 = 4;\n    }\n    break;\n  case 3:\n    uVar2 = 4;\n    break;\n  case 4:\n    uVar2 = 5;\n    break;\n  case 5:\n    uVar2 = 6;\n    break;\n  case 6:\n    FUN_00012811(\"test/helpers/handshake.c\",0x459,\"Trying to progress after connection done\");\n  default:\n    uVar2 = 0xffffffff;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is next_phase"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](char *param_1,int param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  long in_FS_OFFSET;\n  bool bVar4;\n  uint local_2d0;\n  FILE *local_2c8;\n  long local_2c0;\n  undefined local_2b8 [664];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_2d0 = 0;\n  local_2c0 = 0;\n  iVar1 = strcmp(param_1,\"-\");\n  bVar4 = iVar1 != 0;\n  if (bVar4) {\n    local_2c8 = fopen(param_1,\"r\");\n    if (local_2c8 == (FILE *)0x0) {\n      uVar2 = FUN_00005321(0,3,param_1);\n      piVar3 = __errno_location();\n      error(0,*piVar3,&DAT_00007786,uVar2);\n      uVar2 = 0;\n      goto LAB_00002131;\n    }\n  }\n  else {\n    local_2c8 = stdin;\n    DAT_0020a0e9 = 1;\n    FUN_00006265(0,0);\n  }\n  FUN_0000280d(local_2c8,2);\n  while( true ) {\n    iVar1 = getc_unlocked(local_2c8);\n    if (iVar1 == -1) break;\n    local_2c0 = local_2c0 + 1;\n    local_2d0 = (local_2d0 & 1) * 0x8000 + ((int)local_2d0 >> 1) + iVar1 & 0xffff;\n  }\n  iVar1 = ferror_unlocked(local_2c8);\n  if (iVar1 == 0) {\n    if (bVar4) {\n      iVar1 = FUN_00006779(local_2c8);\n      if (iVar1 != 0) {\n        uVar2 = FUN_00005321(0,3,param_1);\n        piVar3 = __errno_location();\n        error(0,*piVar3,&DAT_00007786,uVar2);\n        uVar2 = 0;\n        goto LAB_00002131;\n      }\n    }\n    uVar2 = FUN_00002a64(local_2c0,local_2b8,0,1,0x400);\n    printf(\"%05d %5s\",(ulong)local_2d0,uVar2);\n    if (1 < param_2) {\n      printf(\" %s\",param_1);\n    }\n    putchar_unlocked(10);\n    uVar2 = 1;\n  }\n  else {\n    uVar2 = FUN_00005321(0,3,param_1);\n    piVar3 = __errno_location();\n    error(0,*piVar3,&DAT_00007786,uVar2);\n    if (bVar4) {\n      FUN_00006779(local_2c8);\n    }\n    uVar2 = 0;\n  }\nLAB_00002131:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is bsd_sum_file"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  ASN1_ITEM *it;\n  \n  it = (ASN1_ITEM *)FUN_000029aa();\n  ASN1_item_new(it);\n  return;\n}\n\n",
        "output": "The predicted function name is ASN1_LONG_DATA_new"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](undefined8 param_1,undefined8 param_2,char param_3)\n\n{\n  int iVar1;\n  \n  iVar1 = FUN_00020c38(param_1,param_2,(int)param_3);\n  if (-1 < iVar1) {\n    DAT_002533d5 = DAT_00253416;\n    DAT_002533dc = DAT_00253416;\n    DAT_002533e5 = DAT_00253416;\n    DAT_002533e3 = DAT_00253416;\n    DAT_00253406 = DAT_00253416;\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is parse_local_db"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  int iVar1;\n  long lVar2;\n  long in_FS_OFFSET;\n  undefined8 local_20;\n  long local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = 0;\n  local_18 = 0;\nLAB_00017029:\n  do {\n    lVar2 = wget_fdgetline(&local_18,&local_20,0);\n    if (lVar2 < 0) {\n      if (local_18 != 0) {\n        (*wget_free)(local_18);\n        local_18 = 0;\n      }\n      wget_debug_printf(\"input closed\\n\");\n      wget_thread_cond_signal(DAT_00253d40);\n      DAT_00253cf8 = 0;\n      if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n      DAT_00253cf8 = 0;\n      return 0;\n    }\n    FUN_00013cc9(local_18,DAT_002530c0,DAT_00253110,0x20);\n    if (DAT_00253cf4 < DAT_002533bc) {\n      iVar1 = FUN_0000fad2();\n      if (DAT_00253cf4 < iVar1) {\n        wget_thread_cond_signal(DAT_00253d40);\n        goto LAB_00017029;\n      }\n    }\n    wget_thread_cond_signal(DAT_00253d48);\n  } while( true );\n}\n\n",
        "output": "The predicted function name is input_thread"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](byte **param_1)\n\n{\n  int local_14;\n  byte *local_10;\n  \n  local_14 = *(int *)(param_1 + 6) + (uint)*(ushort *)((long)param_1 + 0x34) * 0x65;\n  for (local_10 = *param_1; (local_10 != (byte *)0x0 && (*local_10 != 0)); local_10 = local_10 + 1)\n  {\n    local_14 = (uint)*local_10 + local_14 * 0x65;\n  }\n  return local_14;\n}\n\n",
        "output": "The predicted function name is _host_hash"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](long param_1)\n\n{\n  char *pcVar1;\n  size_t sVar2;\n  char *__src;\n  \n  pcVar1 = (char *)gettext(&DAT_00007513);\n  sVar2 = strlen(pcVar1);\n  pcVar1 = (char *)FUN_000069b0(sVar2 + 5);\n  __src = (char *)gettext(&DAT_00007513);\n  strcpy(pcVar1,__src);\n  strncat(pcVar1,(char *)(param_1 + 0x28),4);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is make_id_equals_comment"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  EVP_CIPHER *cipher;\n  EVP_CIPHER_CTX *ctx;\n  int local_1c;\n  \n  local_1c = 0;\n  iVar1 = ENGINE_init(DAT_002110c8);\n  iVar1 = FUN_00006d79(\"test/afalgtest.c\",0x76,\"ENGINE_init(e)\",iVar1 != 0);\n  if (iVar1 == 0) {\n    local_1c = 0;\n  }\n  else {\n    cipher = ENGINE_get_cipher(DAT_002110c8,0x1a3);\n    ctx = EVP_CIPHER_CTX_new();\n    if ((cipher != (EVP_CIPHER *)0x0) && (ctx != (EVP_CIPHER_CTX *)0x0)) {\n      local_1c = EVP_EncryptInit_ex(ctx,cipher,DAT_002110c8,(uchar *)0x0,(uchar *)0x0);\n    }\n    FUN_00006d79(\"test/afalgtest.c\",0x7c,&DAT_0000c744,local_1c != 0);\n    EVP_CIPHER_CTX_free(ctx);\n    ENGINE_finish(DAT_002110c8);\n  }\n  return local_1c;\n}\n\n",
        "output": "The predicted function name is test_pr16743"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                 undefined4 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n                 undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  long in_FS_OFFSET;\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined *local_d0;\n  undefined *local_c8;\n  long local_c0;\n  undefined local_b8 [16];\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = param_1;\n    local_78 = param_2;\n    local_68 = param_3;\n    local_58 = param_4;\n    local_48 = param_5;\n    local_38 = param_6;\n    local_28 = param_7;\n    local_18 = param_8;\n  }\n  local_c0 = *(long *)(in_FS_OFFSET + 0x28);\n  local_d8 = 0x10;\n  local_d4 = 0x30;\n  local_d0 = &stack0x00000008;\n  local_c8 = local_b8;\n  local_a8 = param_11;\n  local_a0 = param_12;\n  local_98 = param_13;\n  local_90 = param_14;\n  FUN_0000d364(param_9,param_10,&local_d8);\n  if (local_c0 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is bar_printf"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  undefined8 uVar1;\n  double dVar2;\n  double dVar3;\n  long lVar4;\n  char cVar5;\n  double dVar6;\n  \n  lVar4 = *(long *)(*(long *)(param_1 + 0x38) + 8);\n  cVar5 = FUN_00001be7();\n  if ((((cVar5 == '\\0') && (cVar5 = FUN_00001be7(), cVar5 == '\\0')) &&\n      (cVar5 = FUN_00001be7(), cVar5 == '\\0')) && (cVar5 = FUN_00001c1d(param_1), cVar5 == '\\0')) {\n    uVar1 = *(undefined8 *)(lVar4 + 0x20);\n    dVar2 = *(double *)(lVar4 + 0x28);\n    dVar3 = *(double *)(lVar4 + 0x50);\n    printf(\"\\t<!-- ellipse-%d -->\\n\",(ulong)*(uint *)(param_1 + 0x14));\n    printf(*(char **)(lVar4 + 0x20),*(undefined8 *)(lVar4 + 0x28),*(undefined8 *)(lVar4 + 0x30),\n           *(undefined8 *)(lVar4 + 0x50),*(undefined8 *)(lVar4 + 0x58),*(undefined8 *)(lVar4 + 0x60)\n           ,\"\\t<!-- sm_axis=(%f,%f,%f) axis_ratio=%f start_angle=%f end_angle=%f-->\\n\");\n    dVar6 = cos(*(double *)(lVar4 + 0x20));\n    printf(*(char **)(lVar4 + 8),*(undefined8 *)(lVar4 + 0x10),uVar1,dVar3 * dVar2,dVar6,\n           \"\\t<ellipse id=\\\"dwg-object-%d\\\" cx=\\\"%f\\\" cy=\\\"%f\\\" rx=\\\"%f\\\" ry=\\\"%f\\\" transform=\\\"rotate=(%f)\\\"\\n\\t\"\n           ,(ulong)*(uint *)(param_1 + 0x14));\n    FUN_00001e87(*(undefined8 *)(param_1 + 0x38));\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is output_ELLIPSE"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  long lVar4;\n  \n  lVar4 = DAT_00215128 - DAT_00215120;\n  lVar1 = FUN_0000781f(1,DAT_00215120,lVar4);\n  if (lVar4 != lVar1) {\n    uVar2 = gettext(\"write error\");\n    piVar3 = __errno_location();\n    error(1,*piVar3,&DAT_000113b4,uVar2);\n  }\n  DAT_00215128 = DAT_00215120;\n  return;\n}\n\n",
        "output": "The predicted function name is lbuf_flush"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  int iVar3;\n  undefined4 uVar4;\n  long in_FS_OFFSET;\n  undefined8 local_128;\n  undefined8 local_120;\n  undefined8 local_118;\n  undefined8 local_110;\n  undefined8 local_108;\n  undefined4 local_ec;\n  undefined8 *local_e8;\n  undefined8 local_e0;\n  undefined8 local_d8;\n  undefined8 uStack208;\n  undefined8 uStack200;\n  undefined8 uStack192;\n  undefined8 uStack184;\n  undefined8 auStack176 [15];\n  undefined local_38 [24];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_e8 = auStack176;\n  OSSL_PARAM_construct_utf8_string(&local_128,\"cipher\",\"AES-128-CBC\",0);\n  puVar2 = local_e8;\n  local_d8 = local_128;\n  uStack208 = local_120;\n  uStack200 = local_118;\n  uStack192 = local_110;\n  uStack184 = local_108;\n  local_e8 = local_e8 + 5;\n  OSSL_PARAM_construct_octet_string(&local_128,&DAT_00013cfa,&DAT_00219460,0x10);\n  uVar1 = local_120;\n  *puVar2 = local_128;\n  puVar2[1] = uVar1;\n  uVar1 = local_110;\n  puVar2[2] = local_118;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_108;\n  puVar2 = local_e8;\n  local_e8 = local_e8 + 5;\n  OSSL_PARAM_construct_octet_string(&local_128,\"constant\",&DAT_00219470,5);\n  uVar1 = local_120;\n  *puVar2 = local_128;\n  puVar2[1] = uVar1;\n  uVar1 = local_110;\n  puVar2[2] = local_118;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_108;\n  puVar2 = local_e8;\n  OSSL_PARAM_construct_end(&local_128);\n  *puVar2 = local_128;\n  puVar2[1] = local_120;\n  puVar2[2] = local_118;\n  puVar2[3] = local_110;\n  puVar2[4] = local_108;\n  local_e0 = FUN_00002d68(\"KRB5KDF\");\n  iVar3 = FUN_0000e315(\"test/evp_kdf_test.c\",0x64e,\"kctx = get_kdfbyname(OSSL_KDF_NAME_KRB5KDF)\",\n                       local_e0);\n  if (iVar3 != 0) {\n    uVar4 = EVP_KDF_derive(local_e0,local_38,0x10,&local_d8);\n    iVar3 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x64f,\n                         \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar4,0);\n    if (iVar3 != 0) {\n      iVar3 = FUN_0000e848(\"test/evp_kdf_test.c\",0x650,&DAT_00013c68,\"expected\",local_38,0x10,\n                           &DAT_00014c30,0x10);\n      if (iVar3 != 0) {\n        local_ec = 1;\n        goto LAB_0000a19c;\n      }\n    }\n  }\n  local_ec = 0;\nLAB_0000a19c:\n  EVP_KDF_CTX_free(local_e0);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_ec;\n}\n\n",
        "output": "The predicted function name is test_kdf_krb5kdf"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,long *param_2)\n\n{\n  int iVar1;\n  long lVar2;\n  long in_FS_OFFSET;\n  int local_58;\n  long local_50;\n  undefined **local_38;\n  long local_30;\n  long local_28;\n  ulong local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = 0;\n  local_28 = 0;\n  local_20 = 0;\n  local_38 = &PTR_FUN_00253040;\n  iVar1 = wget_vector_size(DAT_00253c30);\n  for (local_58 = 0; local_58 < iVar1; local_58 = local_58 + 1) {\n    lVar2 = wget_vector_get(DAT_00253c30,local_58);\n    if (*(long *)(lVar2 + 0x30) != 0) {\n      local_50 = local_30;\n      if (local_30 == 0) {\n        local_50 = param_1;\n      }\n      (**(code **)(lVar2 + 0x30))(lVar2,local_50,&local_38);\n      if (((local_20 & 1) != 0) || ((local_20 & 2) != 0)) break;\n    }\n  }\n  *param_2 = local_30;\n  param_2[1] = local_28;\n  param_2[2] = local_20;\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is plugin_db_forward_url"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  FUN_00009d51(param_2,param_1 + 0x30);\n  return;\n}\n\n",
        "output": "The predicted function name is parse_server_force_pha"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,long param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  iVar1 = FUN_00012c68(\"test/ssl_test.c\",0x30,\"result->client_alert_sent\",\n                       \"result->client_alert_received\",*(undefined4 *)(param_1 + 4),\n                       *(undefined4 *)(param_1 + 0xc));\n  if (iVar1 == 0) {\n    uVar2 = FUN_0000bd21(*(undefined4 *)(param_1 + 0xc));\n    uVar3 = FUN_0000bd21(*(undefined4 *)(param_1 + 4));\n    FUN_0001261b(\"test/ssl_test.c\",0x33,\"Client sent alert %s but server received %s.\",uVar3,uVar2);\n  }\n  iVar1 = FUN_00012c68(\"test/ssl_test.c\",0x43,\"result->server_alert_sent\",\n                       \"result->server_alert_received\",*(undefined4 *)(param_1 + 0x10),\n                       *(undefined4 *)(param_1 + 0x18));\n  if (iVar1 == 0) {\n    uVar2 = FUN_0000bd21(*(undefined4 *)(param_1 + 0x18));\n    uVar3 = FUN_0000bd21(*(undefined4 *)(param_1 + 0x10));\n    FUN_0001261b(\"test/ssl_test.c\",0x46,\"Server sent alert %s but client received %s.\",uVar3,uVar2);\n  }\n  if ((*(int *)(param_2 + 0x1ac) == 0) ||\n     ((*(uint *)(param_1 + 4) & 0xff) == *(uint *)(param_2 + 0x1ac))) {\n    if ((*(int *)(param_2 + 0x1b0) == 0) ||\n       ((*(uint *)(param_1 + 0x10) & 0xff) == *(uint *)(param_2 + 0x1b0))) {\n      iVar1 = FUN_00012de5(\"test/ssl_test.c\",0x60,\"result->client_num_fatal_alerts_sent\",\n                           &DAT_00018dc3,*(undefined4 *)(param_1 + 8),1);\n      if (iVar1 == 0) {\n        uVar2 = 0;\n      }\n      else {\n        iVar1 = FUN_00012de5(\"test/ssl_test.c\",0x62,\"result->server_num_fatal_alerts_sent\",\n                             &DAT_00018dc3,*(undefined4 *)(param_1 + 0x14),1);\n        if (iVar1 == 0) {\n          uVar2 = 0;\n        }\n        else {\n          uVar2 = 1;\n        }\n      }\n    }\n    else {\n      uVar2 = FUN_0000bd21(*(undefined4 *)(param_1 + 0x10));\n      uVar3 = FUN_0000bd21(*(undefined4 *)(param_2 + 0x1b0));\n      FUN_00012811(\"test/ssl_test.c\",0x5c,\"ServerAlert mismatch: expected %s, got %s.\",uVar3,uVar2);\n      uVar2 = 0;\n    }\n  }\n  else {\n    uVar2 = FUN_0000bd21(*(undefined4 *)(param_1 + 4));\n    uVar3 = FUN_0000bd21(*(undefined4 *)(param_2 + 0x1ac));\n    FUN_00012811(\"test/ssl_test.c\",0x54,\"ClientAlert mismatch: expected %s, got %s.\",uVar3,uVar2);\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is check_alerts"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  undefined8 uVar1;\n  long lVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  undefined local_28 [8];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_00253d64 == 0) {\n    uVar1 = 0;\n  }\n  else {\n    FUN_0001f9f6(local_28);\n    lVar2 = FUN_000114a6(param_2,local_28);\n    if (lVar2 == 0) {\n      uVar1 = FUN_0001fa0c(local_28);\n      uVar3 = gettext(\"Plugin \\'%s\\' failed to load: %s\\n\");\n      wget_error_printf(uVar3,param_2,uVar1);\n      FUN_0000defe(local_28,0);\n      uVar1 = 0xffffffff;\n    }\n    else {\n      uVar1 = 0;\n    }\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is parse_plugin"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  undefined8 uVar1;\n  \n  while ((DAT_00215a00 != 0 && (*(long *)(DAT_00215a00 + DAT_002159f0 * 8) != 0))) {\n    if (DAT_00215a00 == 0) {\n      uVar1 = 0;\n    }\n    else {\n      uVar1 = *(undefined8 *)(DAT_00215a00 + DAT_002159f0 * 8);\n    }\n    gcide_markup_yy_delete_buffer(uVar1);\n    *(undefined8 *)(DAT_00215a00 + DAT_002159f0 * 8) = 0;\n    yypop_buffer_state();\n  }\n  gcide_markup_yyfree(DAT_00215a00);\n  DAT_00215a00 = 0;\n  FUN_0000ee45();\n  return 0;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yylex_destroy"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char **ppcVar3;\n  FILE *pFVar4;\n  char **ppcVar5;\n  undefined *puVar6;\n  int iVar7;\n  int iVar8;\n  undefined8 uVar9;\n  int *piVar10;\n  undefined8 uVar11;\n  size_t sVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined *puVar15;\n  long in_FS_OFFSET;\n  undefined auStack1272 [8];\n  undefined *local_4f0;\n  long local_4e8;\n  undefined8 local_4e0;\n  int local_4d8;\n  int local_4d4;\n  char **local_4d0;\n  undefined8 local_4c8;\n  long local_4c0;\n  long local_4b8;\n  FILE *local_4b0;\n  char *local_4a8;\n  long *local_4a0;\n  char *local_498;\n  char **local_490;\n  char **local_488;\n  long local_480;\n  long local_478;\n  char *local_470;\n  char *local_468;\n  char *local_460;\n  undefined local_448 [1032];\n  long local_40;\n  \n  puVar15 = auStack1272;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_4b0 = (FILE *)0x0;\n  wget_buffer_init(&local_468,local_448,0x400);\n  local_4c8 = wget_hashmap_iterator_alloc(DAT_00253c80);\n  local_4d8 = 0;\n  do {\n    uVar11 = local_4c8;\n    *(undefined8 *)(puVar15 + -8) = 0x160a9;\n    lVar13 = FUN_00012e74(uVar11,&local_4d0);\n    if (lVar13 == 0) {\n      *(undefined8 *)(puVar15 + -8) = 0x160c1;\n      wget_hashmap_iterator_free(&local_4c8);\n      *(undefined8 *)(puVar15 + -8) = 0x160d0;\n      wget_buffer_deinit(&local_468);\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return;\n      }\n                    /* WARNING: Subroutine does not return */\n      *(undefined8 *)(puVar15 + -8) = 0x160e5;\n      __stack_chk_fail();\n    }\n    pcVar1 = local_4d0[1];\n    uVar11 = *(undefined8 *)local_4d0[2];\n    pcVar14 = *local_4d0;\n    *(undefined8 *)(puVar15 + -8) = 0x15adf;\n    uVar9 = gettext(\"convert %s %s %s\\n\");\n    *(undefined8 *)(puVar15 + -8) = 0x15af5;\n    wget_info_printf(uVar9,pcVar14,uVar11,pcVar1);\n    pcVar1 = *local_4d0;\n    *(undefined8 *)(puVar15 + -8) = 0x15b11;\n    local_4a8 = (char *)wget_read_file(pcVar1,&local_4c0);\n    local_498 = local_4a8;\n    if (local_4a8 == (char *)0x0) {\n      *(undefined8 *)(puVar15 + -8) = 0x15b35;\n      piVar10 = __errno_location();\n      iVar7 = *piVar10;\n      pcVar1 = *local_4d0;\n      *(undefined8 *)(puVar15 + -8) = 0x15b4e;\n      uVar11 = gettext(\"%s not found (%d)\\n\");\n      *(undefined8 *)(puVar15 + -8) = 0x15b61;\n      wget_error_printf(uVar11,pcVar1,iVar7);\n    }\n    else {\n      local_4d4 = 0;\n      while( true ) {\n        uVar11 = *(undefined8 *)local_4d0[3];\n        *(undefined8 *)(puVar15 + -8) = 0x15fec;\n        iVar8 = wget_vector_size(uVar11);\n        pcVar1 = local_4a8;\n        pFVar4 = local_4b0;\n        iVar7 = local_4d4;\n        if (iVar8 <= local_4d4) break;\n        uVar11 = *(undefined8 *)local_4d0[3];\n        *(undefined8 *)(puVar15 + -8) = 0x15b93;\n        local_490 = (char **)wget_vector_get(uVar11,iVar7);\n        local_488 = local_490;\n        *local_490 = *local_490 + (long)local_498;\n        if ((local_490[1] == (char *)0x0) || (**local_490 != '#')) {\n          pcVar1 = local_490[1];\n          pcVar14 = *local_490;\n          pcVar2 = local_4d0[2];\n          *(undefined8 *)(puVar15 + -8) = 0x15c1d;\n          lVar13 = wget_iri_relative_to_abs(pcVar2,pcVar14,pcVar1,&local_468);\n          pcVar1 = local_468;\n          if (lVar13 != 0) {\n            *(undefined8 *)(puVar15 + -8) = 0x15c43;\n            lVar13 = wget_iri_parse(pcVar1);\n            local_4b8 = lVar13;\n            if (lVar13 == 0) {\n              *(undefined8 *)(puVar15 + -8) = 0x15c69;\n              uVar11 = gettext(\"Cannot resolve URI \\'%s\\'\\n\");\n              *(undefined8 *)(puVar15 + -8) = 0x15c79;\n              wget_info_printf(uVar11);\n            }\n            else {\n              *(undefined8 *)(puVar15 + -8) = 0x15c8d;\n              local_4a0 = (long *)FUN_0000dc5d(lVar13);\n              lVar13 = local_4b8;\n              if (local_4a0 == (long *)0x0) {\n                *(undefined8 *)(puVar15 + -8) = 0x15cad;\n                local_4a0 = (long *)FUN_0000de1a(lVar13);\n                *(undefined8 *)(puVar15 + -8) = 0x15cc3;\n                wget_iri_free(&local_4b8);\n              }\n              ppcVar5 = local_488;\n              ppcVar3 = local_4d0;\n              lVar13 = local_4a0[1];\n              local_480 = lVar13;\n              if (DAT_002533e0 == '\\0') {\n                if (DAT_002533df != '\\0') {\n                  *(undefined8 *)(puVar15 + -8) = 0x15d7f;\n                  FUN_00015724(lVar13,ppcVar5,&local_468);\n                }\n              }\n              else {\n                *(undefined8 *)(puVar15 + -8) = 0x15d04;\n                FUN_000158be(lVar13,ppcVar3,ppcVar5,&local_468);\n                if (*(long *)(*local_4a0 + 0x38) != 0) {\n                  *(undefined8 *)(puVar15 + -8) = 0x15d32;\n                  wget_buffer_memcat(&local_468,&DAT_00041f82,1);\n                  *(undefined8 *)(puVar15 + -8) = 0x15d52;\n                  wget_buffer_strcat(&local_468);\n                }\n              }\n              pcVar1 = local_468;\n              if (local_460 == local_488[1]) {\n                pcVar14 = local_488[1];\n                pcVar2 = *local_488;\n                *(undefined8 *)(puVar15 + -8) = 0x15dbd;\n                iVar7 = strncmp(pcVar1,pcVar2,(size_t)pcVar14);\n                if (iVar7 == 0) goto LAB_00015fcf;\n              }\n              if (local_4b0 == (FILE *)0x0) {\n                puVar6 = puVar15;\n                if (DAT_002533de != '\\0') {\n                  local_4f0 = puVar15;\n                  pcVar1 = *local_4d0;\n                  *(undefined8 *)(puVar15 + -8) = 0x15dfe;\n                  sVar12 = strlen(pcVar1);\n                  local_478 = sVar12 + 5;\n                  local_4e8 = sVar12 + 6;\n                  local_4e0 = 0;\n                  lVar13 = ((sVar12 + 0x15) / 0x10) * -0x10;\n                  local_470 = puVar15 + lVar13;\n                  pcVar1 = *local_4d0;\n                  *(undefined8 *)(puVar15 + lVar13 + -8) = 0x15e81;\n                  wget_snprintf(puVar15 + lVar13,sVar12 + 6,\"%s.orig\",pcVar1);\n                  pcVar14 = local_470;\n                  pcVar1 = *local_4d0;\n                  *(undefined8 *)(puVar15 + lVar13 + -8) = 0x15e9d;\n                  iVar7 = rename(pcVar1,pcVar14);\n                  puVar6 = local_4f0;\n                  if (iVar7 == -1) {\n                    *(undefined8 *)(puVar15 + lVar13 + -8) = 0x15ea7;\n                    piVar10 = __errno_location();\n                    pcVar14 = local_470;\n                    iVar7 = *piVar10;\n                    pcVar1 = *local_4d0;\n                    *(undefined8 *)(puVar15 + lVar13 + -8) = 0x15ec7;\n                    uVar11 = gettext(\"Failed to rename %s to %s (%d)\");\n                    *(undefined8 *)(puVar15 + lVar13 + -8) = 0x15edd;\n                    wget_error_printf(uVar11,pcVar1,pcVar14,iVar7);\n                    puVar6 = local_4f0;\n                  }\n                }\n                puVar15 = puVar6;\n                pcVar1 = *local_4d0;\n                *(undefined8 *)(puVar15 + -8) = 0x15efd;\n                local_4b0 = fopen(pcVar1,\"wb\");\n                if (local_4b0 == (FILE *)0x0) {\n                  *(undefined8 *)(puVar15 + -8) = 0x15f13;\n                  piVar10 = __errno_location();\n                  iVar7 = *piVar10;\n                  pcVar1 = *local_4d0;\n                  *(undefined8 *)(puVar15 + -8) = 0x15f2c;\n                  uVar11 = gettext(\"Failed to write open %s (%d)\");\n                  *(undefined8 *)(puVar15 + -8) = 0x15f3f;\n                  wget_error_printf(uVar11,pcVar1,iVar7);\n                }\n              }\n              pcVar1 = local_4a8;\n              pFVar4 = local_4b0;\n              if (local_4b0 != (FILE *)0x0) {\n                sVar12 = (long)*local_488 - (long)local_4a8;\n                *(undefined8 *)(puVar15 + -8) = 0x15f8b;\n                fwrite(pcVar1,1,sVar12,pFVar4);\n                pcVar14 = local_460;\n                pcVar1 = local_468;\n                pFVar4 = local_4b0;\n                *(undefined8 *)(puVar15 + -8) = 0x15fad;\n                fwrite(pcVar1,1,(size_t)pcVar14,pFVar4);\n                local_4a8 = local_488[1] + (long)*local_488;\n              }\n            }\n          }\n        }\nLAB_00015fcf:\n        local_4d4 = local_4d4 + 1;\n      }\n      if (local_4b0 != (FILE *)0x0) {\n        pcVar14 = local_498 + (local_4c0 - (long)local_4a8);\n        *(undefined8 *)(puVar15 + -8) = 0x16047;\n        fwrite(pcVar1,1,(size_t)pcVar14,pFVar4);\n        pFVar4 = local_4b0;\n        *(undefined8 *)(puVar15 + -8) = 0x16056;\n        FUN_000285bb(pFVar4);\n        local_4b0 = (FILE *)0x0;\n      }\n      pcVar1 = local_498;\n      if (local_498 != (char *)0x0) {\n        *(undefined8 *)(puVar15 + -8) = 0x1607e;\n        (*wget_free)(pcVar1);\n        local_498 = (char *)0x0;\n      }\n    }\n    local_4d8 = local_4d8 + 1;\n  } while( true );\n}\n\n",
        "output": "The predicted function name is convert_links"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,char **param_4)\n\n{\n  ulong uVar1;\n  undefined4 uVar2;\n  int iVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  long in_FS_OFFSET;\n  int local_58;\n  int local_54;\n  undefined8 local_50;\n  undefined8 local_48;\n  char *local_40;\n  char *local_38;\n  undefined8 *local_30;\n  undefined8 *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_40 = (char *)0x0;\n  wget_sitemap_get_urls_inline(param_2,&local_50,&local_48);\n  if (param_4 != (char **)0x0) {\n    local_38 = strrchr(*param_4,0x2f);\n    if (local_38 == (char *)0x0) {\n      local_40 = (char *)strlen(*param_4);\n    }\n    else {\n      local_40 = local_38 + (1 - (long)*param_4);\n    }\n  }\n  if (param_4 == (char **)0x0) {\n    pcVar6 = (char *)0x0;\n  }\n  else {\n    pcVar6 = *param_4;\n  }\n  uVar2 = wget_vector_size(local_50);\n  uVar4 = gettext(\"found %d url(s) (base=%s)\\n\");\n  wget_info_printf(uVar4,uVar2,pcVar6);\n  wget_thread_mutex_lock(DAT_00253d18);\n  local_58 = 0;\n  do {\n    iVar3 = wget_vector_size(local_50);\n    if (iVar3 <= local_58) {\n      if (param_4 == (char **)0x0) {\n        pcVar6 = (char *)0x0;\n      }\n      else {\n        pcVar6 = *param_4;\n      }\n      uVar2 = wget_vector_size(local_48);\n      uVar4 = gettext(\"found %d sitemap url(s) (base=%s)\\n\");\n      wget_info_printf(uVar4,uVar2,pcVar6);\n      local_54 = 0;\n      while( true ) {\n        iVar3 = wget_vector_size(local_48);\n        if (iVar3 <= local_54) break;\n        local_30 = (undefined8 *)wget_vector_get(local_48,local_54);\n        local_38 = (char *)wget_strmemdup(*local_30,local_30[1]);\n        iVar3 = wget_hashmap_put(DAT_00253cc8,local_38,0);\n        if (iVar3 == 0) {\n          FUN_00014525(param_1,param_3,local_38,2,0);\n        }\n        else {\n          uVar4 = *local_30;\n          uVar1 = local_30[1];\n          uVar5 = gettext(\"URL \\'%.*s\\' not followed (already known)\\n\");\n          wget_info_printf(uVar5,uVar1 & 0xffffffff,uVar4);\n        }\n        local_54 = local_54 + 1;\n      }\n      wget_thread_mutex_unlock(DAT_00253d18);\n      wget_vector_free(&local_50);\n      wget_vector_free(&local_48);\n      if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n      return;\n    }\n    local_28 = (undefined8 *)wget_vector_get(local_50,local_58);\n    if (local_40 == (char *)0x0) {\nLAB_0001ae71:\n      local_38 = (char *)wget_strmemdup(*local_28,local_28[1]);\n      iVar3 = wget_hashmap_put(DAT_00253cc8,local_38,0);\n      if (iVar3 == 0) {\n        FUN_00014525(param_1,param_3,local_38,0,0);\n      }\n      else {\n        uVar4 = *local_28;\n        uVar1 = local_28[1];\n        uVar5 = gettext(\"URL \\'%.*s\\' not followed (already known)\\n\");\n        wget_info_printf(uVar5,uVar1 & 0xffffffff,uVar4);\n      }\n    }\n    else {\n      if (local_40 < (char *)local_28[1]) {\n        iVar3 = wget_strncasecmp(*local_28,*param_4,local_40);\n        if (iVar3 == 0) goto LAB_0001ae71;\n      }\n      uVar4 = *local_28;\n      uVar1 = local_28[1];\n      uVar5 = gettext(\"URL \\'%.*s\\' not followed (not matching sitemap location)\\n\");\n      wget_info_printf(uVar5,uVar1 & 0xffffffff,uVar4);\n    }\n    local_58 = local_58 + 1;\n  } while( true );\n}\n\n",
        "output": "The predicted function name is sitemap_parse_xml"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  FUN_00009d51(param_2,param_1 + 0x44);\n  return;\n}\n\n",
        "output": "The predicted function name is parse_client_no_extms_on_reneg"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x18);\n}\n\n",
        "output": "The predicted function name is outline_compare_count"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  return param_1;\n}\n\n",
        "output": "The predicted function name is ossl_check_CONF_VALUE_sk_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  void **__s;\n  \n  __s = *(void ***)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  CRYPTO_free(*__s);\n  CRYPTO_free(__s[2]);\n  memset(__s,0,0x28);\n  return;\n}\n\n",
        "output": "The predicted function name is encode_test_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](char *param_1,undefined8 *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  bool bVar4;\n  regex_t local_68;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = regcomp(&local_68,param_1,0xf);\n  if (iVar1 == 0) {\n    iVar1 = regexec(&local_68,(char *)param_2[1],0,(regmatch_t *)0x0,0);\n    bVar4 = iVar1 == 0;\n    regfree(&local_68);\n  }\n  else {\n    uVar2 = mu_sieve_get_message_num(*param_2);\n    uVar3 = dgettext(\"mailutils\",\"%lu: cannot compile regular expression \\\"%s\\\"\");\n    mu_sieve_error(*param_2,uVar3,uVar2,param_1);\n    bVar4 = false;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return bVar4;\n}\n\n",
        "output": "The predicted function name is regex_comparator"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  FUN_0000ae56(param_1 + 0x1dc,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is parse_expected_tmp_key_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,long param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = dico_key_match(param_2 + 0x10,*(undefined8 *)(param_1 + 0x30));\n  if ((iVar1 != 0) && (iVar1 = FUN_0000a46a(*(undefined8 *)(param_2 + 8),param_1), iVar1 != 0)) {\n    return 1;\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is match_key"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](void)\n\n{\n  long in_FS_OFFSET;\n  bool bVar1;\n  undefined *local_20;\n  long local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = &DAT_00211010;\n  local_18 = FUN_00002be3(0,&local_20,4);\n  bVar1 = local_18 != 0;\n  if (bVar1) {\n    FUN_00002c55(local_18);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return bVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_uint32"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\ndouble [MASK](double param_1)\n\n{\n  return DAT_00209220 - (param_1 - DAT_00209200);\n}\n\n",
        "output": "The predicted function name is transform_Y"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  wget_thread_mutex_destroy(&DAT_00253bf8);\n  return;\n}\n\n",
        "output": "The predicted function name is blacklist_exit"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  bool bVar1;\n  char *pcVar2;\n  int iVar3;\n  __pid_t _Var4;\n  int *piVar5;\n  undefined8 uVar6;\n  FILE *pFVar7;\n  \n  bVar1 = false;\n  if ((DAT_00253188 == (char *)0x0) &&\n     (((DAT_0025340d != '\\x01' || (DAT_00253402 != '\\0')) && (DAT_00253417 != '\\x01')))) {\n    DAT_00253188 = (char *)wget_strdup(\"wget-log\");\n    iVar3 = open(DAT_00253188,0x201);\n    if (iVar3 != -1) {\n      close(iVar3);\n    }\n    bVar1 = true;\n  }\n  _Var4 = fork();\n  if (_Var4 < 0) {\n    piVar5 = __errno_location();\n    iVar3 = *piVar5;\n    uVar6 = gettext(\"Failed to fork (%d)\\n\");\n    wget_error_printf_exit(uVar6,iVar3);\n  }\n  if (_Var4 != 0) {\n    uVar6 = gettext(\"Continuing in background, pid %d.\\n\");\n    wget_printf(uVar6,_Var4);\n    pcVar2 = DAT_00253188;\n    if (bVar1) {\n      uVar6 = gettext(\"Output will be written to %s.\\n\");\n      wget_printf(uVar6,pcVar2);\n    }\n                    /* WARNING: Subroutine does not return */\n    exit(0);\n  }\n  setsid();\n  pFVar7 = freopen(\"/dev/null\",\"r\",stdin);\n  if (pFVar7 == (FILE *)0x0) {\n    uVar6 = gettext(\"Failed to redirect stdin to /dev/null.\\n\");\n    wget_error_printf(uVar6);\n  }\n  pFVar7 = freopen(\"/dev/null\",\"w\",stdout);\n  if (pFVar7 == (FILE *)0x0) {\n    uVar6 = gettext(\"Failed to redirect stdout to /dev/null.\\n\");\n    wget_error_printf(uVar6);\n  }\n  pFVar7 = freopen(\"/dev/null\",\"w\",stderr);\n  if (pFVar7 == (FILE *)0x0) {\n    uVar6 = gettext(\"Failed to redirect stderr to /dev/null.\\n\");\n    wget_error_printf(uVar6);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is fork_to_background"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_14;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_00009ddc(&PTR_DAT_0021f1e0,3,&local_14,param_2);\n  if (iVar1 != 0) {\n    *(undefined4 *)(param_1 + 0x1c) = local_14;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1 != 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is parse_certstatus"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  undefined local_18 [8];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_00253d64 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    FUN_0001f9f6(local_18);\n    iVar1 = FUN_000116de(param_2,local_18);\n    if (iVar1 < 0) {\n      uVar2 = FUN_0001fa0c(local_18);\n      wget_error_printf(&DAT_00043720,uVar2);\n      FUN_0000defe(local_18,0);\n      uVar2 = 0xffffffff;\n    }\n    else {\n      uVar2 = 0;\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is parse_plugin_option"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  undefined8 uVar1;\n  \n  if (*(long *)(param_1 + 0x30) != 0) {\n    uVar1 = wget_iri_clone(param_2);\n    wget_vector_add(*(undefined8 *)(param_1 + 0x30),uVar1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is impl_file_add_recurse_url"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1,EVP_PKEY_CTX *param_2,char *param_3)\n\n{\n  bool bVar1;\n  int iVar2;\n  char *__s;\n  char *pcVar3;\n  int local_1c;\n  \n  local_1c = 0;\n  __s = CRYPTO_strdup(param_3,\"test/evp_test.c\",0x4ff);\n  iVar2 = FUN_00018f92(\"test/evp_test.c\",0x4ff,\"tmpval = OPENSSL_strdup(value)\",__s);\n  if (iVar2 == 0) {\n    bVar1 = false;\n  }\n  else {\n    pcVar3 = strchr(__s,0x3a);\n    if (pcVar3 != (char *)0x0) {\n      *pcVar3 = '\\0';\n      local_1c = EVP_PKEY_CTX_ctrl_str(param_2,__s,pcVar3 + 1);\n    }\n    if (local_1c == -2) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"PKEY_CTRL_INVALID\";\n    }\n    else if (local_1c < 1) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"PKEY_CTRL_ERROR\";\n    }\n    else {\n      local_1c = 1;\n    }\n    CRYPTO_free(__s);\n    bVar1 = 0 < local_1c;\n  }\n  return bVar1;\n}\n\n",
        "output": "The predicted function name is mac_test_ctrl_pkey"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  iVar1 = wget_strcasecmp_ascii(param_2,\"bytes\");\n  if (iVar1 == 0) {\n    **(undefined4 **)(param_1 + 0x18) = 0;\n  }\n  else {\n    iVar1 = wget_strcasecmp_ascii(param_2,&DAT_0004372a);\n    if (iVar1 != 0) {\n      if (*param_2 == '\\0') {\n        uVar2 = gettext(\"Missing required type specifier\\n\");\n        wget_error_printf(uVar2);\n        return 0xffffffff;\n      }\n      uVar2 = gettext(\"Invalid type specifier: %s\\n\");\n      wget_error_printf(uVar2,param_2);\n      return 0xffffffff;\n    }\n    **(undefined4 **)(param_1 + 0x18) = 1;\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is parse_report_speed_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void **param_1)\n\n{\n  CRYPTO_free(*param_1);\n  *param_1 = (void *)0x0;\n  CRYPTO_free(param_1[2]);\n  param_1[2] = (void *)0x0;\n  CRYPTO_free(param_1[4]);\n  param_1[4] = (void *)0x0;\n  CRYPTO_free(param_1[5]);\n  param_1[5] = (void *)0x0;\n  CRYPTO_free(param_1[6]);\n  param_1[6] = (void *)0x0;\n  return;\n}\n\n",
        "output": "The predicted function name is ctx_data_free_data"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  undefined local_78 [8];\n  undefined8 local_70;\n  undefined local_58 [32];\n  undefined local_38 [40];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    iVar1 = (**(code **)(DAT_00202118 + 0xa8))(DAT_00202120,&DAT_00001446,\"PROCINFO\",5,local_78);\n    if (iVar1 == 0) {\n      uVar2 = 0;\n    }\n    else {\n      FUN_00000b8f(DAT_00202118,DAT_00202120,\"readfile\",8,1,local_58);\n      iVar1 = (**(code **)(DAT_00202118 + 0xe0))(DAT_00202120,local_70,local_58,0,local_38);\n      if (iVar1 == 0) {\n        uVar2 = 0;\n      }\n      else {\n        uVar2 = 1;\n      }\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is readfile_can_take_file"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  ASN1_ITEM *it;\n  \n  it = (ASN1_ITEM *)FUN_00002f18();\n  ASN1_item_new(it);\n  return;\n}\n\n",
        "output": "The predicted function name is INVALIDTEMPLATE_new"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  size_t sVar5;\n  size_t sVar6;\n  long in_FS_OFFSET;\n  undefined local_229;\n  long local_228;\n  undefined4 *local_220;\n  char *local_218;\n  char *local_210;\n  undefined local_208 [72];\n  long local_1c0;\n  undefined4 local_16b;\n  char local_164 [12];\n  undefined4 local_158;\n  undefined auStack340 [44];\n  char local_128 [264];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_220 = &local_158;\n  sprintf(local_164,\"%ld\",(long)*(int *)(param_1 + 4));\n  if (*(char *)(param_1 + 8) != '/') {\n    local_158 = 0x7665642f;\n    auStack340._0_2_ = 0x2f;\n    local_220 = (undefined4 *)(auStack340 + 1);\n  }\n  FUN_00001feb(local_220,param_1 + 8,0x20);\n  iVar2 = FUN_00007270(&local_158,local_208);\n  if (iVar2 == 0) {\n    cVar1 = FUN_0000249e(local_208);\n    if (cVar1 == '\\0') {\n      local_229 = 0x2d;\n    }\n    else {\n      local_229 = 0x2b;\n    }\n    local_228 = local_1c0;\n  }\n  else {\n    local_229 = 0x3f;\n    local_228 = 0;\n  }\n  if (local_228 == 0) {\n    local_16b = 0x3f2020;\n  }\n  else {\n    uVar3 = FUN_0000204b(local_228,param_2);\n    sprintf((char *)&local_16b,\"%.*s\",6,uVar3);\n  }\n  if (*(char *)(param_1 + 0x4c) == '\\0') {\n    if (DAT_0020a168 == 0) {\n      DAT_0020a168 = 1;\n      free(DAT_0020a170);\n      DAT_0020a170 = (char *)FUN_000069b0(DAT_0020a168);\n    }\n    *DAT_0020a170 = '\\0';\n  }\n  else {\n    local_218 = (char *)0x0;\n    FUN_00001feb(local_128,param_1 + 0x4c,0x100);\n    pcVar4 = strchr(local_128,0x3a);\n    local_210 = pcVar4;\n    if (pcVar4 != (char *)0x0) {\n      local_210 = pcVar4 + 1;\n      *pcVar4 = '\\0';\n    }\n    if ((local_128[0] != '\\0') && (DAT_0020a100 != '\\0')) {\n      local_218 = (char *)FUN_00003b97(local_128);\n    }\n    if (local_218 == (char *)0x0) {\n      local_218 = local_128;\n    }\n    if (local_210 == (char *)0x0) {\n      sVar5 = strlen(local_218);\n      if (DAT_0020a168 < sVar5 + 3) {\n        sVar5 = strlen(local_218);\n        DAT_0020a168 = sVar5 + 3;\n        free(DAT_0020a170);\n        DAT_0020a170 = (char *)FUN_000069b0(DAT_0020a168);\n      }\n      sprintf(DAT_0020a170,\"(%s)\",local_218);\n    }\n    else {\n      sVar5 = strlen(local_218);\n      sVar6 = strlen(local_210);\n      if (DAT_0020a168 < sVar6 + sVar5 + 4) {\n        sVar5 = strlen(local_218);\n        sVar6 = strlen(local_210);\n        DAT_0020a168 = sVar6 + sVar5 + 4;\n        free(DAT_0020a170);\n        DAT_0020a170 = (char *)FUN_000069b0(DAT_0020a168);\n      }\n      sprintf(DAT_0020a170,\"(%s:%s)\",local_218,local_210);\n    }\n    if (local_218 != local_128) {\n      free(local_218);\n    }\n  }\n  pcVar4 = DAT_0020a170;\n  if (DAT_0020a170 == (char *)0x0) {\n    pcVar4 = \"\";\n  }\n  uVar3 = FUN_00002192(param_1);\n  FUN_00002228(0x20,param_1 + 0x2c,local_229,0x20,param_1 + 8,uVar3,&local_16b,local_164,pcVar4,\n               &DAT_000073d6);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is print_user"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined4 param_2,undefined4 param_3,undefined8 param_4)\n\n{\n  EVP_CIPHER *pEVar1;\n  \n  pEVar1 = EVP_aes_128_cbc();\n  FUN_00003068(param_1,param_2,param_3,param_4,0,pEVar1);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_aes128_cbc_ctrl"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](int *param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  undefined8 local_28;\n  long local_20;\n  long local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_28 = 0;\n  local_20 = ASYNC_get_current_job();\n  if (local_20 == 0) {\n    iVar1 = FUN_00001b16(0);\n    *param_1 = iVar1;\n    if (*param_1 == -1) {\n      fprintf(*(FILE **)PTR_stderr_00203ff8,\"ALG_PERR: %s(%d): Failed to get eventfd : \",\n              \"engines/e_afalg.c\",0xea);\n      perror((char *)0x0);\n      FUN_00001a71(0,0x6c,\"engines/e_afalg.c\",0xec);\n      uVar2 = 0;\n      goto LAB_00001de8;\n    }\n    param_1[1] = 1;\n  }\n  else {\n    local_18 = ASYNC_get_wait_ctx(local_20);\n    if (local_18 == 0) {\n      uVar2 = 0;\n      goto LAB_00001de8;\n    }\n    iVar1 = ASYNC_WAIT_CTX_get_fd(local_18,PTR_s_afalg_00204330,param_1,&local_28);\n    if (iVar1 == 0) {\n      iVar1 = FUN_00001b16(0);\n      *param_1 = iVar1;\n      if (*param_1 == -1) {\n        fprintf(*(FILE **)PTR_stderr_00203ff8,\"ALG_PERR: %s(%d): Failed to get eventfd : \",\n                \"engines/e_afalg.c\",0xd2);\n        perror((char *)0x0);\n        FUN_00001a71(0,0x6c,\"engines/e_afalg.c\",0xd4);\n        uVar2 = 0;\n        goto LAB_00001de8;\n      }\n      iVar1 = ASYNC_WAIT_CTX_set_wait_fd\n                        (local_18,PTR_s_afalg_00204330,*param_1,local_28,FUN_00001bde);\n      if (iVar1 == 0) {\n        close(*param_1);\n        uVar2 = 0;\n        goto LAB_00001de8;\n      }\n      fcntl(*param_1,4,0x800);\n    }\n    param_1[1] = 2;\n  }\n  uVar2 = 1;\nLAB_00001de8:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is afalg_setup_async_event_notification"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  undefined8 uVar1;\n  long lVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  undefined local_28 [8];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_00253d64 == 0) {\n    uVar1 = 0;\n  }\n  else {\n    FUN_0001f9f6(local_28);\n    lVar2 = FUN_00011450(param_2,local_28);\n    if (lVar2 == 0) {\n      uVar1 = FUN_0001fa0c(local_28);\n      uVar3 = gettext(\"Plugin \\'%s\\' failed to load: %s\\n\");\n      wget_error_printf(uVar3,param_2,uVar1);\n      FUN_0000defe(local_28,0);\n      uVar1 = 0xffffffff;\n    }\n    else {\n      uVar1 = 0;\n    }\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is parse_plugin_local"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  if (DAT_00253d64 != 0) {\n    FUN_00010ed2();\n    FUN_00010ea5(param_2,0x2c);\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is parse_plugin_dirs"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,uint param_4)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  undefined local_111;\n  undefined8 *local_110;\n  long local_108;\n  long local_100;\n  undefined8 *local_f8;\n  char *local_f0;\n  undefined8 *local_e8;\n  long local_e0;\n  byte local_d8;\n  undefined local_c8 [184];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_f8 = (undefined8 *)0x0;\n  local_111 = 0;\n  local_110 = (undefined8 *)wget_iri_parse_base(param_2,param_1,param_3);\n  if (local_110 == (undefined8 *)0x0) {\n    uVar3 = gettext(\"Failed to parse URI \\'%s\\'\\n\");\n    wget_error_printf(uVar3,param_1);\n    goto LAB_0001450f;\n  }\n  FUN_00011a93(local_110,&local_e8);\n  if ((local_d8 & 1) != 0) {\n    wget_iri_free(&local_110);\n    FUN_00011ba9(&local_e8);\n    goto LAB_0001450f;\n  }\n  if (local_e8 != (undefined8 *)0x0) {\n    wget_iri_free(&local_110);\n    local_110 = local_e8;\n    local_e8 = (undefined8 *)0x0;\n  }\n  cVar1 = wget_iri_supported(local_110);\n  if (cVar1 != '\\x01') {\n    uVar3 = gettext(\"URI scheme not supported: \\'%s\\'\\n\");\n    wget_error_printf(uVar3,param_1);\n    wget_iri_free(&local_110);\n    FUN_00011ba9(&local_e8);\n    goto LAB_0001450f;\n  }\n  if (*(int *)((long)local_110 + 0x5c) == 0) {\n    FUN_00013c2a(local_110);\n  }\n  if ((*(int *)((long)local_110 + 0x5c) == 0) && (DAT_002533c8 != 0)) {\n    wget_iri_set_scheme(local_110,1);\n    if (DAT_002533c8 == 1) {\n      local_111 = 1;\n    }\n  }\n  wget_thread_mutex_lock(DAT_00253d08);\n  local_108 = FUN_0000dc5d(local_110);\n  if (local_108 == 0) {\n    if ((param_4 & 0x20) != 0) {\n      local_108 = FUN_0000de1a(local_110);\n      if (local_108 != 0) goto LAB_00013f34;\n    }\n    wget_thread_mutex_unlock(DAT_00253d08);\n    FUN_00011ba9(&local_e8);\n    wget_iri_free(&local_110);\n    goto LAB_0001450f;\n  }\nLAB_00013f34:\n  cVar1 = wget_vector_contains(DAT_00253288,local_110[4]);\n  if (cVar1 != '\\0') {\n    wget_debug_printf(\"not requesting \\'%s\\'. (Exclude Domains)\\n\",*local_110);\n    wget_thread_mutex_unlock(DAT_00253d08);\n    FUN_00011ba9(&local_e8);\n    goto LAB_0001450f;\n  }\n  if (local_e0 != 0) {\n    if (*(long *)(local_108 + 8) != 0) {\n      (*wget_free)(*(undefined8 *)(local_108 + 8));\n      *(undefined8 *)(local_108 + 8) = 0;\n    }\n    *(long *)(local_108 + 8) = local_e0;\n    local_e0 = 0;\n  }\n  if ((DAT_002533f5 != '\\x01') && (*(long *)(local_108 + 8) != 0)) {\n    iVar2 = access(*(char **)(local_108 + 8),0);\n    if (iVar2 == 0) {\n      wget_debug_printf(\"not requesting \\'%s\\'. (File already exists)\\n\",*local_110);\n      wget_thread_mutex_unlock(DAT_00253d08);\n      if ((DAT_00253423 != '\\0') || (DAT_002533ec != '\\0')) {\n        FUN_00013810(0,*(undefined8 *)(local_108 + 8),0,0,local_110);\n      }\n      FUN_00011ba9(&local_e8);\n      goto LAB_0001450f;\n    }\n  }\n  local_100 = FUN_0000e8bf(local_110);\n  if (local_100 == 0) {\n    local_100 = FUN_0000e9fe(local_110);\n  }\n  else if (DAT_00253423 != '\\0') {\n    if ((DAT_002533f5 != '\\x01') && (*(long *)(local_108 + 8) != 0)) {\n      iVar2 = access(*(char **)(local_108 + 8),0);\n      if (iVar2 == 0) {\n        wget_debug_printf(\"not requesting \\'%s\\'. (File already exists)\\n\",*local_110);\n        goto LAB_00014187;\n      }\n    }\n    FUN_0000f36f(local_100,local_110,param_3,local_111);\n  }\nLAB_00014187:\n  if (DAT_00253423 != '\\0') {\n    if ((DAT_0025340b != '\\x01') && (DAT_00253278 != 0)) {\n      iVar2 = wget_vector_find(DAT_00253278,local_110[4]);\n      if (iVar2 < 0) {\n        uVar3 = wget_strdup(local_110[4]);\n        wget_vector_add(DAT_00253278,uVar3);\n      }\n    }\n    if (DAT_002533e9 != '\\x01') {\n      if (DAT_00253d00 == 0) {\n        DAT_00253d00 = wget_vector_create(4,0);\n      }\n      if (local_110[5] == 0) {\nLAB_00014266:\n        local_110[9] = 0;\n      }\n      else {\n        local_f0 = strrchr((char *)local_110[5],0x2f);\n        if (local_f0 == (char *)0x0) goto LAB_00014266;\n        local_110[9] = local_f0 + (1 - local_110[5]);\n      }\n      wget_vector_add(DAT_00253d00,local_110);\n    }\n  }\n  local_f8 = (undefined8 *)FUN_00010626(local_c8,local_108,local_111);\n  if ((local_d8 & 2) == 0) {\n    if (DAT_00253423 != '\\0') {\n      if (DAT_00253290 == 0) {\nLAB_00014346:\n        if (DAT_002531e8 != 0) {\n          iVar2 = FUN_000137cb(*(undefined8 *)*local_f8,DAT_002531e8);\n          if (iVar2 == 0) goto LAB_00014375;\n        }\n      }\n      else {\n        iVar2 = FUN_0001346f(DAT_00253290,*(undefined8 *)*local_f8);\n        if (iVar2 != 0) goto LAB_00014346;\nLAB_00014375:\n        *(byte *)(local_f8 + 0x15) = *(byte *)(local_f8 + 0x15) | 0x20;\n        *(byte *)((long)local_f8 + 0xa9) = *(byte *)((long)local_f8 + 0xa9) | 2;\n      }\n      if (DAT_00253298 == 0) {\nLAB_000143d2:\n        if (DAT_002531f0 != 0) {\n          iVar2 = FUN_000137cb(*(undefined8 *)*local_f8,DAT_002531f0);\n          if (iVar2 != 0) goto LAB_00014401;\n        }\n      }\n      else {\n        iVar2 = FUN_0001346f(DAT_00253298,*(undefined8 *)*local_f8);\n        if (iVar2 == 0) goto LAB_000143d2;\nLAB_00014401:\n        *(byte *)(local_f8 + 0x15) = *(byte *)(local_f8 + 0x15) | 0x20;\n        *(byte *)((long)local_f8 + 0xa9) = *(byte *)((long)local_f8 + 0xa9) | 2;\n      }\n    }\n  }\n  else {\n    *(byte *)(local_f8 + 0x15) = *(byte *)(local_f8 + 0x15) | 0x80;\n  }\n  if (DAT_00253423 != '\\0') {\n    *(byte *)(local_f8 + 0x15) = *(byte *)(local_f8 + 0x15) | 0x40;\n  }\n  if ((((DAT_00253407 != '\\0') || (DAT_00253368 != 0)) || (DAT_002532c0 != 0)) ||\n     ((DAT_0025341e != '\\x01' && (DAT_002533ff != '\\0')))) {\n    *(byte *)(local_f8 + 0x15) = *(byte *)(local_f8 + 0x15) | 0x20;\n  }\n  if (DAT_0025341f != '\\0') {\n    local_f8[4] = DAT_002532b0;\n    *(byte *)(local_f8 + 0x15) = *(byte *)(local_f8 + 0x15) & 0xfe;\n  }\n  FUN_0000f20f(local_100,local_f8);\n  wget_thread_mutex_unlock(DAT_00253d08);\n  FUN_00011ba9(&local_e8);\nLAB_0001450f:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is queue_url_from_local"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long lVar3;\n  long in_FS_OFFSET;\n  undefined8 local_1a8;\n  undefined8 local_1a0;\n  undefined8 local_198;\n  undefined8 local_190;\n  undefined8 local_188;\n  int local_16c;\n  int local_168;\n  int local_164;\n  undefined8 local_160;\n  undefined8 local_158 [4];\n  undefined8 uStack312;\n  undefined8 local_38;\n  undefined8 local_30;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_16c = 0;\n  local_38 = 0;\n  local_30 = 0;\n  for (local_168 = 0; local_168 < 3; local_168 = local_168 + 1) {\n    local_164 = 1;\n    OSSL_PARAM_construct_utf8_string(&local_1a8,\"cipher\",\"CAMELLIA-128-CBC\",0);\n    local_158[0] = local_1a8;\n    local_158[1] = local_1a0;\n    local_158[2] = local_198;\n    local_158[3] = local_190;\n    uStack312 = local_188;\n    lVar3 = (long)local_164;\n    local_164 = local_164 + 1;\n    OSSL_PARAM_construct_utf8_string(&local_1a8,&DAT_000141e1,&DAT_000141dc,0);\n    local_158[lVar3 * 5] = local_1a8;\n    local_158[lVar3 * 5 + 1] = local_1a0;\n    local_158[lVar3 * 5 + 2] = local_198;\n    local_158[lVar3 * 5 + 3] = local_190;\n    local_158[lVar3 * 5 + 4] = local_188;\n    lVar3 = (long)local_164;\n    local_164 = local_164 + 1;\n    OSSL_PARAM_construct_utf8_string(&local_1a8,&DAT_00013d10,\"FEEDBACK\",0);\n    local_158[lVar3 * 5] = local_1a8;\n    local_158[lVar3 * 5 + 1] = local_1a0;\n    local_158[lVar3 * 5 + 2] = local_198;\n    local_158[lVar3 * 5 + 3] = local_190;\n    local_158[lVar3 * 5 + 4] = local_188;\n    lVar3 = (long)local_164;\n    local_164 = local_164 + 1;\n    OSSL_PARAM_construct_octet_string(&local_1a8,&DAT_00013cfa,&DAT_00219100,0x10);\n    local_158[lVar3 * 5] = local_1a8;\n    local_158[lVar3 * 5 + 1] = local_1a0;\n    local_158[lVar3 * 5 + 2] = local_198;\n    local_158[lVar3 * 5 + 3] = local_190;\n    local_158[lVar3 * 5 + 4] = local_188;\n    lVar3 = (long)local_164;\n    local_164 = local_164 + 1;\n    OSSL_PARAM_construct_octet_string\n              (&local_1a8,&DAT_00013cf5,&DAT_00219110 + (long)local_168 * 5,5);\n    local_158[lVar3 * 5] = local_1a8;\n    local_158[lVar3 * 5 + 1] = local_1a0;\n    local_158[lVar3 * 5 + 2] = local_198;\n    local_158[lVar3 * 5 + 3] = local_190;\n    local_158[lVar3 * 5 + 4] = local_188;\n    lVar3 = (long)local_164;\n    local_164 = local_164 + 1;\n    OSSL_PARAM_construct_octet_string(&local_1a8,&DAT_00013be2,&DAT_00219550,0x10);\n    local_158[lVar3 * 5] = local_1a8;\n    local_158[lVar3 * 5 + 1] = local_1a0;\n    local_158[lVar3 * 5 + 2] = local_198;\n    local_158[lVar3 * 5 + 3] = local_190;\n    local_158[lVar3 * 5 + 4] = local_188;\n    lVar3 = (long)local_164;\n    OSSL_PARAM_construct_end(&local_1a8);\n    local_158[lVar3 * 5] = local_1a8;\n    local_158[lVar3 * 5 + 1] = local_1a0;\n    local_158[lVar3 * 5 + 2] = local_198;\n    local_158[lVar3 * 5 + 3] = local_190;\n    local_158[lVar3 * 5 + 4] = local_188;\n    local_160 = FUN_00002d68(\"KBKDF\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x3de,&DAT_000141f4,local_160);\n    if (iVar1 == 0) {\nLAB_0000714e:\n      local_16c = 0;\n    }\n    else {\n      uVar2 = EVP_KDF_derive(local_160,&local_38,0x10,local_158);\n      iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x3e0,\n                           \"EVP_KDF_derive(kctx, result, sizeof(result), params)\",&DAT_00013c2d,\n                           uVar2,0);\n      if ((iVar1 == 0) ||\n         (iVar1 = FUN_0000e848(\"test/evp_kdf_test.c\",0x3e2,\"result\",\"outputs[i]\",&local_38,0x10,\n                               &DAT_00219120 + (long)local_168 * 0x10,0x10), iVar1 == 0))\n      goto LAB_0000714e;\n      local_16c = 1;\n    }\n    EVP_KDF_CTX_free(local_160);\n    if (local_16c != 1) break;\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_16c;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_kdf_kbkdf_6803_128"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_14;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_00009ddc(&PTR_s_Simple_0021f100,7,&local_14,param_2);\n  if (iVar1 != 0) {\n    *(undefined4 *)(param_1 + 4) = local_14;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1 != 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is parse_handshake_mode"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined4 param_1)\n\n{\n  FUN_00009e5e(&PTR_s_Success_0021ee20,5,param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is ssl_test_result_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  CRYPTO_free(*(void **)(\"EVP_PKEY_verify_recover_init\" + param_1));\n  *(undefined8 *)(\"EVP_PKEY_verify_recover_init\" + param_1) = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is keypair_test_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,long param_2,char param_3)\n\n{\n  int iVar1;\n  void *pvVar2;\n  undefined8 uVar3;\n  \n  iVar1 = FUN_00020c38(param_1,param_2,(int)param_3);\n  if (iVar1 < 0) {\n    if (param_3 == '\\0') {\n      pvVar2 = bsearch(\"http-proxy\",s_accept_0024e220,0xba,0x58,FUN_00022401);\n      if (pvVar2 != (void *)0x0) {\n        uVar3 = FUN_0001ffad(pvVar2,param_2,0);\n        return uVar3;\n      }\n      pvVar2 = bsearch(\"https-proxy\",s_accept_0024e220,0xba,0x58,FUN_00022401);\n      if (pvVar2 != (void *)0x0) {\n        uVar3 = FUN_0001ffad(pvVar2,param_2,0);\n        return uVar3;\n      }\n    }\n    else {\n      if (DAT_00253168 != 0) {\n        (*wget_free)(DAT_00253168);\n        DAT_00253168 = 0;\n      }\n      if (param_2 == 0) {\n        DAT_00253168 = 0;\n      }\n      else {\n        DAT_00253168 = wget_strdup(param_2);\n      }\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is parse_proxy"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  undefined local_418 [1032];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_00253360 != 0) {\n    (*wget_free)(DAT_00253360);\n    DAT_00253360 = 0;\n  }\n  iVar1 = FUN_00023996(\"Type username:\",&DAT_00253360);\n  if (iVar1 < 0) {\n    uVar2 = 0xffffffff;\n  }\n  else {\n    wget_snprintf(local_418,0x400,\"Type password for \\'%s\\':\",DAT_00253360);\n    if (DAT_00253358 != 0) {\n      (*wget_free)(DAT_00253358);\n      DAT_00253358 = 0;\n    }\n    iVar1 = FUN_00023996(local_418,&DAT_00253358);\n    if (iVar1 < 0) {\n      uVar2 = 0xffffffff;\n    }\n    else {\n      uVar2 = 0;\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is use_askpass"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](int param_1,long param_2)\n\n{\n  void *__ptr;\n  void *__ptr_00;\n  long lVar1;\n  bool bVar2;\n  \n  if (param_1 == 3) {\n    __ptr = (void *)FUN_00000b21(*(undefined8 *)(param_2 + 8));\n    __ptr_00 = (void *)FUN_00000b21(*(undefined8 *)(param_2 + 0x10));\n    lVar1 = utf8_wc_strstr(__ptr,__ptr_00);\n    bVar2 = lVar1 == 0;\n    if (!bVar2) {\n      printf(\"%td\\n\",lVar1 - (long)__ptr >> 2);\n    }\n    free(__ptr);\n    free(__ptr_00);\n  }\n  else {\n    dico_log(4,0,0xcd0);\n    bVar2 = true;\n  }\n  return bVar2;\n}\n\n",
        "output": "The predicted function name is substr_run_test"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,long param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = *(int *)(param_1 + 0x10);\n  if (iVar1 == 1) {\n    *(long *)(param_1 + 0x20) = *(long *)(param_1 + 0x20) + param_2;\n  }\n  else if ((iVar1 != 0) && (iVar1 == 2)) {\n    dico_list_iterate(*(undefined8 *)(param_1 + 0x20),FUN_0000f0b8,param_2);\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is tag_fixup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (*(long *)(param_1 + 0x40) == 0) {\n    uVar1 = 0;\n  }\n  else {\n    uVar1 = FUN_00002b0e(param_1,*(undefined8 *)(param_1 + 0x40),1);\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is outline_db_mime_header"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](SSL *param_1,undefined *param_2)\n\n{\n  undefined *parg;\n  undefined8 uVar1;\n  long lVar2;\n  \n  parg = (undefined *)CRYPTO_malloc(1,\"test/helpers/handshake.c\",0x112);\n  if (parg == (undefined *)0x0) {\n    uVar1 = 2;\n  }\n  else {\n    *parg = *param_2;\n    lVar2 = SSL_ctrl(param_1,0x47,1,parg);\n    if (lVar2 == 0) {\n      CRYPTO_free(parg);\n      uVar1 = 2;\n    }\n    else {\n      uVar1 = 0;\n    }\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is server_ocsp_cb"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  undefined8 *puVar1;\n  int local_14;\n  \n  puVar1 = *(undefined8 **)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  CRYPTO_free((void *)puVar1[4]);\n  CRYPTO_free((void *)puVar1[5]);\n  for (local_14 = 0; local_14 <= *(int *)(puVar1 + 2); local_14 = local_14 + 1) {\n    CRYPTO_free((void *)puVar1[(long)local_14 * 0x14 + 6]);\n    CRYPTO_free((void *)puVar1[(long)local_14 * 0x14 + 7]);\n    CRYPTO_free((void *)puVar1[(long)local_14 * 0x14 + 8]);\n    CRYPTO_free((void *)puVar1[(long)local_14 * 0x14 + 9]);\n    CRYPTO_free((void *)puVar1[(long)local_14 * 0x14 + 10]);\n    CRYPTO_free((void *)puVar1[(long)local_14 * 0x14 + 0xb]);\n    CRYPTO_free((void *)puVar1[(long)local_14 * 0x14 + 0xc]);\n    CRYPTO_free((void *)puVar1[(long)local_14 * 0x14 + 0xd]);\n    CRYPTO_free((void *)puVar1[(long)local_14 * 0x14 + 0xe]);\n    CRYPTO_free((void *)puVar1[(long)local_14 * 0x14 + 0xf]);\n  }\n  EVP_RAND_CTX_free(*puVar1);\n  EVP_RAND_CTX_free(puVar1[1]);\n  return;\n}\n\n",
        "output": "The predicted function name is rand_test_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  ASN1_ITEM *it;\n  \n  it = (ASN1_ITEM *)FUN_00002cec();\n  ASN1_item_new(it);\n  return;\n}\n\n",
        "output": "The predicted function name is ASN1_INT64_DATA_new"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  if (DAT_0020533c != 0) {\n    ERR_unload_strings(DAT_00205338,(ERR_STRING_DATA *)&DAT_00205300);\n    DAT_0020533c = 0;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is ERR_unload_DASYNC_strings"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](int param_1,undefined8 *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  long lVar2;\n  long in_FS_OFFSET;\n  bool bVar3;\n  undefined8 local_20;\n  void *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == 1) {\n    local_20 = param_2[1];\n    iVar1 = utf8_mbstr_to_wc(param_3,&local_18,0);\n    if (iVar1 == 0) {\n      utf8_wc_strupper(local_18);\n      lVar2 = utf8_wc_strstr(local_18,local_20);\n      bVar3 = lVar2 != 0;\n      free(local_18);\n    }\n    else {\n      bVar3 = false;\n    }\n  }\n  else {\n    if (param_1 == 2) {\n      free((void *)param_2[1]);\n    }\n    else if (param_1 == 0) {\n      iVar1 = utf8_mbstr_to_wc(*param_2,&local_20,0);\n      if (iVar1 != 0) {\n        bVar3 = true;\n        goto LAB_00000ae9;\n      }\n      utf8_wc_strupper(local_20);\n      param_2[1] = local_20;\n    }\n    bVar3 = false;\n  }\nLAB_00000ae9:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return bVar3;\n}\n\n",
        "output": "The predicted function name is substr_sel"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  long lVar1;\n  \n  lVar1 = wget_read_file(param_2,0);\n  if (lVar1 != 0) {\n    FUN_0001b75c(param_1,lVar1,param_3,param_4);\n    (*wget_free)(lVar1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is atom_parse_localfile"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,char *param_2,char param_3)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  if ((param_2 == (char *)0x0) && (param_3 != '\\0')) {\n    DAT_002533d4 = 0;\n    uVar2 = 0;\n  }\n  else if (param_2 == (char *)0x0) {\n    DAT_002533d4 = 1;\n    uVar2 = 0;\n  }\n  else if (param_3 == '\\0') {\n    iVar1 = strcasecmp(param_2,\"strippath\");\n    if (iVar1 == 0) {\n      DAT_002533d4 = 1;\n    }\n    else {\n      iVar1 = strcasecmp(param_2,\"usepath\");\n      if (iVar1 != 0) {\n        uVar2 = gettext(\"Invalid value for --download-attr: %s\\n\");\n        wget_error_printf(uVar2,param_2);\n        return 0xffffffff;\n      }\n      DAT_002533d4 = 2;\n    }\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = gettext(\"Disallowed Value for --no-download-attr: %s\\n\");\n    wget_error_printf(uVar2,param_2);\n    uVar2 = 0xffffffff;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is parse_download_attr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  undefined8 uVar3;\n  \n  ptr = (void *)FUN_000076f4(&DAT_00013c6c,&DAT_00014269,&DAT_00219200,1,&DAT_00014265,&DAT_00014260\n                            );\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x451,\"params\",ptr);\n  if (iVar1 == 0) {\n    return 0;\n  }\n  uVar3 = FUN_00002d68(\"KBKDF\");\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x456,&DAT_000141f4,uVar3);\n  if (iVar1 != 0) {\n    iVar1 = EVP_KDF_CTX_set_params(uVar3,ptr);\n    iVar1 = FUN_0000e3f6(\"test/evp_kdf_test.c\",0x457,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                         iVar1 != 0);\n    if (iVar1 != 0) {\n      uVar2 = 1;\n      goto LAB_00007ac0;\n    }\n  }\n  uVar2 = 0;\nLAB_00007ac0:\n  EVP_KDF_CTX_free(uVar3);\n  CRYPTO_free(ptr);\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_kbkdf_invalid_digest"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  double dVar1;\n  double dVar2;\n  double dVar3;\n  double dVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  long lVar7;\n  double dVar8;\n  double dVar9;\n  char cVar10;\n  bool bVar11;\n  long in_FS_OFFSET;\n  double dVar12;\n  double dVar13;\n  double dVar14;\n  double dVar15;\n  undefined8 uVar16;\n  undefined8 uVar17;\n  undefined8 uVar18;\n  char *__format;\n  double local_28;\n  double local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar7 = *(long *)(*(long *)(param_1 + 0x38) + 8);\n  cVar10 = FUN_00001be7();\n  if (((cVar10 == '\\0') && (cVar10 = FUN_00001be7(), cVar10 == '\\0')) &&\n     (cVar10 = FUN_00001c1d(param_1), cVar10 == '\\0')) {\n    FUN_000058cd(&local_28);\n    dVar8 = local_28;\n    dVar1 = *(double *)(lVar7 + 0x20);\n    dVar12 = cos(*(double *)(lVar7 + 0x48));\n    dVar9 = local_20;\n    dVar2 = *(double *)(lVar7 + 0x20);\n    dVar13 = sin(*(double *)(lVar7 + 0x48));\n    dVar3 = *(double *)(lVar7 + 0x20);\n    dVar14 = cos(*(double *)(lVar7 + 0x50));\n    dVar4 = *(double *)(lVar7 + 0x20);\n    dVar15 = sin(*(double *)(lVar7 + 0x50));\n    bVar11 = DAT_000067c8 <= *(double *)(lVar7 + 0x50) - *(double *)(lVar7 + 0x48);\n    printf(\"\\t<!-- arc-%d -->\\n\",(ulong)*(uint *)(param_1 + 0x14));\n    uVar16 = FUN_00001b1f(dVar15 * dVar4 + local_20);\n    uVar17 = FUN_00001b03(dVar14 * dVar3 + local_28);\n    uVar5 = *(undefined8 *)(lVar7 + 0x20);\n    uVar6 = *(undefined8 *)(lVar7 + 0x20);\n    uVar18 = FUN_00001b1f(dVar13 * dVar2 + dVar9);\n    __format = (char *)FUN_00001b03(dVar12 * dVar1 + dVar8);\n    printf(__format,uVar18,uVar6,uVar5,uVar17,uVar16,\n           \"\\t<path id=\\\"dwg-object-%d\\\" d=\\\"M %f,%f A %f,%f 0 %d,0 %f,%f\\\"\\n\\t\",\n           (ulong)*(uint *)(param_1 + 0x14),(ulong)bVar11);\n    FUN_00001e87(*(undefined8 *)(param_1 + 0x38));\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is output_ARC"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long *param_1)\n\n{\n  if (param_1 != (long *)0x0) {\n    if (*param_1 != 0) {\n      (*wget_free)(*param_1);\n      *param_1 = 0;\n    }\n    if (param_1[1] != 0) {\n      (*wget_free)(param_1[1]);\n      param_1[1] = 0;\n    }\n    if (param_1 != (long *)0x0) {\n      (*wget_free)(param_1);\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is free_host_entry"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  if (DAT_00205378 == (code *)0x0) {\n    EVP_PKEY_meth_get_init(DAT_00205350,&DAT_00205378);\n  }\n  (*DAT_00205378)(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_rsa_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,int param_2)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  byte *pbVar3;\n  byte *pbVar4;\n  uint32_t *puVar5;\n  int iVar6;\n  int iVar7;\n  uint uVar8;\n  uint32_t uVar9;\n  undefined8 uVar10;\n  long in_FS_OFFSET;\n  int local_74;\n  uint local_58;\n  uint local_54;\n  uint32_t *local_48;\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48 = (uint32_t *)(param_1 + 0x14);\n  local_74 = param_2;\n  do {\n    if (local_74 < 0x15) {\n      if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    bVar1 = *(byte *)local_48;\n    if (bVar1 == 7) {\n      pbVar2 = (byte *)((long)local_48 + 1);\n      local_48 = (uint32_t *)((long)local_48 + 2);\n      local_74 = local_74 + -2;\n      local_58 = (uint)*(byte *)local_48;\n      if ((uint)*pbVar2 < (uint)*(byte *)local_48) {\n        local_58 = (uint)*pbVar2;\n      }\n      iVar7 = local_58 - 4;\n      iVar6 = local_74;\n      puVar5 = local_48;\n      if (0 < iVar7) {\n        if ((((iVar7 == DAT_00214980) && (local_48 == (uint32_t *)(param_1 + 0x16))) &&\n            (iVar6 = memcmp(local_48,&DAT_002149a0,(long)iVar7), iVar6 == 0)) &&\n           ((DAT_00214a48 & 1) == 0)) {\n          printf(\"\\t (same route)\");\n          iVar7 = local_58 - 1;\n          if ((int)(local_58 - 1) < 0) {\n            iVar7 = local_58 + 2;\n          }\n          iVar6 = local_74 + (iVar7 >> 2) * -4;\n          puVar5 = (uint32_t *)((long)local_48 + (long)((iVar7 >> 2) * 4));\n        }\n        else {\n          if (iVar7 < 0x28) {\n            DAT_00214980 = iVar7;\n            memmove(&DAT_002149a0,local_48,(long)iVar7);\n          }\n          else {\n            DAT_00214980 = 0;\n          }\n          printf(\"\\nRR: \");\n          local_54 = 0;\n          local_58 = iVar7;\n          while( true ) {\n            pbVar2 = (byte *)((long)local_48 + 1);\n            pbVar3 = (byte *)((long)local_48 + 2);\n            pbVar4 = (byte *)((long)local_48 + 3);\n            local_48 = local_48 + 1;\n            uVar9 = (uint)*(byte *)local_48 +\n                    ((uint)*pbVar4 + ((uint)*pbVar3 + (uint)*pbVar2 * 0x100) * 0x100) * 0x100;\n            if (uVar9 == 0) {\n              printf(\"\\t0.0.0.0\");\n            }\n            else {\n              uVar9 = htonl(uVar9);\n              uVar10 = FUN_0000453b(uVar9);\n              printf(\"\\t%s\",uVar10);\n              FUN_0000be7b(uVar10);\n            }\n            local_74 = local_74 + -4;\n            local_58 = local_58 + -4;\n            local_54 = local_54 + 4;\n            iVar6 = local_74;\n            puVar5 = local_48;\n            if ((int)local_58 < 1) goto LAB_000058b3;\n            if (0x27 < (int)local_54) break;\n            putchar(10);\n          }\n          printf(\"\\t (truncated route)\");\n        }\n      }\n    }\n    else {\n      iVar6 = local_74;\n      puVar5 = local_48;\n      if (bVar1 < 8) {\n        if (bVar1 == 0) {\n          local_74 = 0;\n          iVar6 = local_74;\n        }\n        else if (bVar1 == 1) {\n          printf(\"\\nNOP\");\n        }\n        else {\nLAB_0000588d:\n          printf(\"\\nunknown option %x\",(ulong)*(byte *)local_48);\n        }\n      }\n      else if ((bVar1 == 0x83) || (bVar1 == 0x89)) {\n        if (*(byte *)local_48 == 0x83) {\n          uVar8 = 0x4c;\n        }\n        else {\n          uVar8 = 0x53;\n        }\n        printf(\"\\n%cSRR: \",(ulong)uVar8);\n        local_74 = local_74 + -2;\n        local_54 = (uint)*(byte *)((long)local_48 + 1);\n        local_48 = (uint32_t *)((long)local_48 + 2);\n        iVar6 = local_74;\n        puVar5 = local_48;\n        if (4 < local_54) {\n          while( true ) {\n            pbVar2 = (byte *)((long)local_48 + 1);\n            pbVar3 = (byte *)((long)local_48 + 2);\n            pbVar4 = (byte *)((long)local_48 + 3);\n            local_48 = local_48 + 1;\n            uVar9 = (uint)*(byte *)local_48 +\n                    ((uint)*pbVar4 + ((uint)*pbVar3 + (uint)*pbVar2 * 0x100) * 0x100) * 0x100;\n            if (uVar9 == 0) {\n              printf(\"\\t0.0.0.0\");\n            }\n            else {\n              uVar9 = htonl(uVar9);\n              uVar10 = FUN_0000453b(uVar9);\n              printf(\"\\t%s\",uVar10);\n              FUN_0000be7b(uVar10);\n            }\n            local_74 = local_74 + -4;\n            local_54 = local_54 - 4;\n            iVar6 = local_74;\n            puVar5 = local_48;\n            if ((int)local_54 < 5) break;\n            putchar(10);\n          }\n        }\n      }\n      else {\n        if (bVar1 != 0x44) goto LAB_0000588d;\n        uVar8 = (uint)*(byte *)((long)local_48 + 1);\n        local_58 = (uint)*(byte *)(uint32_t *)((long)local_48 + 2);\n        if (uVar8 < local_58) {\n          local_58 = uVar8;\n        }\n        iVar6 = local_74 + -2;\n        puVar5 = (uint32_t *)((long)local_48 + 2);\n        if (8 < uVar8) {\n          bVar1 = *(byte *)((long)local_48 + 3);\n          local_48 = local_48 + 1;\n          local_74 = local_74 + -4;\n          printf(\"\\nTS:\");\n          local_54 = 5;\n          do {\n            if ((bVar1 & 0xf) == 0) {\nLAB_000057c3:\n              uVar9 = ntohl(*local_48);\n              uVar10 = FUN_0000400a(local_28,0x10,uVar9);\n              printf(\"\\t%s ms\",uVar10);\n              if ((DAT_00214a48 & 0x20) != 0) {\n                uVar9 = ntohl(*local_48);\n                printf(\" = 0x%08x\",(ulong)uVar9);\n              }\n              putchar(10);\n            }\n            else {\n              iVar7 = local_54;\n              if ((int)local_54 < 0) {\n                iVar7 = local_54 + 3;\n              }\n              if (((iVar7 >> 2) - (iVar7 >> 0x1f) & 1U) + (iVar7 >> 0x1f) != 1) goto LAB_000057c3;\n              uVar10 = FUN_0000453b(*local_48);\n              printf(\"\\t%s\",uVar10);\n              FUN_0000be7b();\n            }\n            local_48 = local_48 + 1;\n            local_54 = local_54 + 4;\n            local_74 = local_74 + -4;\n          } while ((int)local_54 < (int)local_58);\n          iVar6 = local_74;\n          puVar5 = local_48;\n          if ((bVar1 & 0xf0) != 0) {\n            printf(\"\\t(%u overflowing hosts)\",(ulong)(uint)((int)(uint)bVar1 >> 4));\n          }\n        }\n      }\n    }\nLAB_000058b3:\n    local_48 = puVar5;\n    local_74 = iVar6;\n    local_74 = local_74 + -1;\n    local_48 = (uint32_t *)((long)local_48 + 1);\n  } while( true );\n}\n\n",
        "output": "The predicted function name is print_ip_opt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nuint [MASK](void)\n\n{\n  uint local_10;\n  uint local_c;\n  \n  local_c = 0;\n  for (local_10 = 0; local_10 < 10; local_10 = local_10 + 1) {\n    local_c = local_c | *(uint *)(&DAT_00201d68 + (long)(int)local_10 * 0x10);\n  }\n  return local_c;\n}\n\n",
        "output": "The predicted function name is getallflags"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2)\n\n{\n  int iVar1;\n  void *ptr;\n  char *pcVar2;\n  \n  ptr = (void *)CRYPTO_zalloc(0x28,\"test/evp_test.c\",0x8d7);\n  iVar1 = FUN_00018f92(\"test/evp_test.c\",0x8d7,\"edata = OPENSSL_zalloc(sizeof(*edata))\",ptr);\n  if (iVar1 == 0) {\n    return 0;\n  }\n  iVar1 = strcmp(param_2,\"canonical\");\n  if (iVar1 == 0) {\n    *(undefined4 *)((long)ptr + 0x20) = 0;\n  }\n  else {\n    iVar1 = strcmp(param_2,\"valid\");\n    if (iVar1 != 0) {\n      iVar1 = strcmp(param_2,\"invalid\");\n      if (iVar1 == 0) {\n        *(undefined4 *)((long)ptr + 0x20) = 2;\n        pcVar2 = CRYPTO_strdup(\"DECODE_ERROR\",\"test/evp_test.c\",0x8df);\n        *(char **)(\"EVP_CIPHER_CTX_set_flags\" + param_1 + 9) = pcVar2;\n        iVar1 = FUN_00018f92(\"test/evp_test.c\",0x8df,\n                             \"t->expected_err = OPENSSL_strdup(\\\"DECODE_ERROR\\\")\",\n                             *(undefined8 *)(\"EVP_CIPHER_CTX_set_flags\" + param_1 + 9));\n        if (iVar1 != 0) goto LAB_0000cef4;\n      }\n      else {\n        FUN_000170fc(\"test/evp_test.c\",0x8e4,\n                     \"Bad encoding: %s. Should be one of {canonical, valid, invalid}\",param_2);\n      }\n      CRYPTO_free(ptr);\n      return 0;\n    }\n    *(undefined4 *)((long)ptr + 0x20) = 1;\n  }\nLAB_0000cef4:\n  *(void **)(\"EVP_PKEY_verify_recover_init\" + param_1) = ptr;\n  return 1;\n}\n\n",
        "output": "The predicted function name is encode_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  long lVar1;\n  \n  lVar1 = wget_read_file(param_2,0);\n  if (lVar1 != 0) {\n    FUN_0001acf5(param_1,lVar1,param_3,param_4);\n    (*wget_free)(lVar1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is sitemap_parse_xml_localfile"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long *param_1)\n\n{\n  if (param_1 != (long *)0x0) {\n    if (param_1[1] != 0) {\n      (*wget_free)(param_1[1]);\n      param_1[1] = 0;\n    }\n    if (*param_1 != 0) {\n      (*wget_free)(*param_1);\n      *param_1 = 0;\n    }\n    if (param_1 != (long *)0x0) {\n      (*wget_free)(param_1);\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is tag_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long *param_1,int *param_2)\n\n{\n  int iVar1;\n  long lVar2;\n  long in_FS_OFFSET;\n  int local_1c;\n  long *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 == (int *)0x0) {\n    local_1c = 0;\n  }\n  else {\n    local_1c = *param_2;\n  }\n  iVar1 = *(int *)(param_1 + 2);\n  local_18 = param_1;\n  if (iVar1 == 1) {\n    if (local_1c != 0) {\n      lVar2 = FUN_0000f12e(param_1[4]);\n      local_18[4] = lVar2;\n    }\n  }\n  else if ((iVar1 != 0) && (iVar1 == 2)) {\n    if ((*param_1 == 0) || (iVar1 = strcmp(*(char **)param_1[1],\"grk\"), iVar1 != 0)) {\n      local_1c = 0;\n    }\n    else {\n      local_1c = 1;\n    }\n    dico_list_iterate(local_18[4],FUN_0000f1f4,&local_1c);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is early_fixup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,char *param_2,undefined8 param_3,char **param_4)\n\n{\n  int iVar1;\n  ushort **ppuVar2;\n  undefined8 uVar3;\n  undefined *puVar4;\n  size_t sVar5;\n  long in_FS_OFFSET;\n  char *local_458;\n  char *local_450;\n  char *local_448;\n  char *local_440;\n  undefined local_428 [1032];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_458 = (char *)0x0;\n  local_450 = param_2;\n  local_448 = param_2;\n  if (param_4 != (char **)0x0) {\n    local_458 = strrchr(*param_4,0x2f);\n    if (local_458 == (char *)0x0) {\n      local_458 = (char *)strlen(*param_4);\n    }\n    else {\n      local_458 = local_458 + (1 - (long)*param_4);\n    }\n  }\n  while (*local_450 != '\\0') {\n    local_450 = strchr(local_448,10);\n    if (local_450 == (char *)0x0) {\n      sVar5 = strlen(local_448);\n      local_450 = local_448 + sVar5;\n    }\n    if (local_450 == (char *)0x0) break;\n    local_440 = local_450 + -(long)local_448;\n    while ((local_440 != (char *)0x0 &&\n           (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[*local_448] & 0x2000) != 0))) {\n      local_448 = local_448 + 1;\n      local_440 = local_440 + -1;\n    }\n    while ((local_440 != (char *)0x0 &&\n           (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[local_448[(long)(local_440 + -1)]] & 0x2000) != 0\n           ))) {\n      local_440 = local_440 + -1;\n    }\n    if (local_440 != (char *)0x0) {\n      if ((local_458 == (char *)0x0) ||\n         ((local_458 < local_440 &&\n          (iVar1 = wget_strncasecmp(local_448,*param_4,local_458), iVar1 == 0)))) {\n        puVar4 = (undefined *)wget_strmemcpy_a(local_428,0x400,local_448,local_440);\n        FUN_00014525(param_1,param_3,puVar4,0,0);\n        if ((puVar4 != local_428) && (puVar4 != (undefined *)0x0)) {\n          (*wget_free)(puVar4);\n        }\n      }\n      else {\n        uVar3 = gettext(\"URL \\'%.*s\\' not followed (not matching sitemap location)\\n\");\n        wget_info_printf(uVar3,(ulong)local_440 & 0xffffffff,local_448);\n      }\n    }\n    local_448 = local_450 + 1;\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is sitemap_parse_text"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,undefined8 param_2)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  undefined8 uVar3;\n  long lVar4;\n  long in_FS_OFFSET;\n  undefined8 local_78;\n  undefined8 local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_48;\n  long local_40;\n  long *local_30;\n  long local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48 = param_2;\n  local_40 = param_1;\n  iVar2 = FUN_00011e68(param_2);\n  if (iVar2 == 0) {\n    local_30 = (long *)CRYPTO_zalloc(0x340,\"test/evp_test.c\",0xa8a);\n    iVar2 = FUN_00018f92(\"test/evp_test.c\",0xa8a,\"kdata = OPENSSL_zalloc(sizeof(*kdata))\",local_30);\n    if (iVar2 == 0) {\n      uVar3 = 0;\n    }\n    else {\n      local_30[0x67] = (long)(local_30 + 3);\n      puVar1 = (undefined8 *)local_30[0x67];\n      OSSL_PARAM_construct_end(&local_78);\n      *puVar1 = local_78;\n      puVar1[1] = local_70;\n      puVar1[2] = local_68;\n      puVar1[3] = local_60;\n      puVar1[4] = local_58;\n      local_28 = EVP_KDF_fetch(DAT_002241a8,local_48,0);\n      if (local_28 == 0) {\n        CRYPTO_free(local_30);\n        uVar3 = 0;\n      }\n      else {\n        lVar4 = EVP_KDF_CTX_new(local_28);\n        *local_30 = lVar4;\n        EVP_KDF_free(local_28);\n        if (*local_30 == 0) {\n          CRYPTO_free(local_30);\n          uVar3 = 0;\n        }\n        else {\n          *(long **)(\"EVP_PKEY_verify_recover_init\" + local_40) = local_30;\n          uVar3 = 1;\n        }\n      }\n    }\n  }\n  else {\n    FUN_00016f06(\"test/evp_test.c\",0xa85,\"skipping, \\'%s\\' is disabled\",local_48);\n    *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + local_40 + 7) = 1;\n    uVar3 = 1;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is kdf_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](undefined8 param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  \n  iVar1 = FUN_00006555(param_1,param_3,1);\n  if (iVar1 == 0) {\n    *param_2 = 0x70;\n  }\n  return iVar1 != 0;\n}\n\n",
        "output": "The predicted function name is client_hello_ignore_cb"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong [MASK](undefined8 param_1,char *param_2)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  ulong uVar4;\n  bool bVar5;\n  bool local_16;\n  int local_14;\n  \n  local_16 = false;\n  local_14 = 0;\n  do {\n    iVar1 = wget_vector_size(param_1);\n    if (iVar1 <= local_14) {\n      uVar4 = wget_debug_printf(\"mime check %d\",local_16);\n      return uVar4 & 0xffffffffffffff00 | (ulong)(local_16 != false);\n    }\n    pcVar2 = (char *)wget_vector_get(param_1,local_14);\n    bVar5 = *pcVar2 == '!';\n    wget_debug_printf(\"mime check %s - %s\",pcVar2,param_2);\n    pcVar2 = pcVar2 + bVar5;\n    pcVar3 = strpbrk(pcVar2,\"*?[]\");\n    if (pcVar3 == (char *)0x0) {\nLAB_0001c4ca:\n      iVar1 = wget_strcasecmp(pcVar2);\n      if (iVar1 == 0) {\n        local_16 = !bVar5;\n      }\n    }\n    else {\n      iVar1 = fnmatch(pcVar2,param_2,0x10);\n      if (iVar1 != 0) goto LAB_0001c4ca;\n      local_16 = !bVar5;\n    }\n    local_14 = local_14 + 1;\n  } while( true );\n}\n\n",
        "output": "The predicted function name is check_mime_list"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  if (param_1 != 0) {\n    if (*(long *)(param_1 + 0x50) != 0) {\n      (*wget_free)(*(undefined8 *)(param_1 + 0x50));\n      *(undefined8 *)(param_1 + 0x50) = 0;\n    }\n    if (param_1 != 0) {\n      (*wget_free)(param_1);\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is free_stats"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  EVP_MD *pEVar1;\n  code *pcVar2;\n  \n  FUN_00002e1a();\n  pEVar1 = EVP_sha1();\n  pcVar2 = (code *)EVP_MD_meth_get_init(pEVar1);\n  (*pcVar2)(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_sha1_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2,char *param_3)\n\n{\n  int iVar1;\n  uint uVar2;\n  char *pcVar3;\n  long lVar4;\n  undefined8 uVar5;\n  \n  lVar4 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  pcVar3 = strchr(param_2,0x2e);\n  if (pcVar3 == (char *)0x0) {\n    iVar1 = strcmp(param_2,\"Cipher\");\n    if (iVar1 == 0) {\n      pcVar3 = CRYPTO_strdup(param_3,\"test/evp_test.c\",0x9e3);\n      *(char **)(lVar4 + 0x20) = pcVar3;\n      uVar5 = FUN_00018f92(\"test/evp_test.c\",0x9e3,\"rdata->cipher = OPENSSL_strdup(value)\",\n                           *(undefined8 *)(lVar4 + 0x20));\n      return uVar5;\n    }\n    iVar1 = strcmp(param_2,\"Digest\");\n    if (iVar1 == 0) {\n      pcVar3 = CRYPTO_strdup(param_3,\"test/evp_test.c\",0x9e5);\n      *(char **)(lVar4 + 0x28) = pcVar3;\n      uVar5 = FUN_00018f92(\"test/evp_test.c\",0x9e5,\"rdata->digest = OPENSSL_strdup(value)\",\n                           *(undefined8 *)(lVar4 + 0x28));\n      return uVar5;\n    }\n    iVar1 = strcmp(param_2,\"DerivationFunction\");\n    if (iVar1 == 0) {\n      iVar1 = atoi(param_3);\n      *(uint *)(lVar4 + 0x18) = (uint)(iVar1 != 0);\n      return 1;\n    }\n    iVar1 = strcmp(param_2,\"GenerateBits\");\n    if (iVar1 == 0) {\n      uVar2 = atoi(param_3);\n      if ((0 < (int)uVar2) && ((uVar2 & 7) == 0)) {\n        *(uint *)(lVar4 + 0x1c) = uVar2;\n        return 1;\n      }\n      return 0;\n    }\n    iVar1 = strcmp(param_2,\"PredictionResistance\");\n    if (iVar1 == 0) {\n      iVar1 = atoi(param_3);\n      *(uint *)(lVar4 + 0x14) = (uint)(iVar1 != 0);\n      return 1;\n    }\n  }\n  else {\n    iVar1 = atoi(pcVar3 + 1);\n    if (0xe < iVar1) {\n      return 0;\n    }\n    if (*(int *)(lVar4 + 0x10) < iVar1) {\n      *(int *)(lVar4 + 0x10) = iVar1;\n    }\n    lVar4 = (long)iVar1 * 0xa0 + lVar4 + 0x30;\n    iVar1 = strncmp(param_2,\"Entropy.\",8);\n    if (iVar1 == 0) {\n      uVar5 = FUN_000066e2(param_3,lVar4,lVar4 + 0x50);\n      return uVar5;\n    }\n    iVar1 = strncmp(param_2,\"ReseedEntropy.\",0xe);\n    if (iVar1 == 0) {\n      uVar5 = FUN_000066e2(param_3,lVar4 + 8,lVar4 + 0x90);\n      return uVar5;\n    }\n    iVar1 = strncmp(param_2,\"Nonce.\",6);\n    if (iVar1 == 0) {\n      uVar5 = FUN_000066e2(param_3,lVar4 + 0x10,lVar4 + 0x58);\n      return uVar5;\n    }\n    iVar1 = strncmp(param_2,\"PersonalisationString.\",0x16);\n    if (iVar1 == 0) {\n      uVar5 = FUN_000066e2(param_3,lVar4 + 0x18,lVar4 + 0x60);\n      return uVar5;\n    }\n    iVar1 = strncmp(param_2,\"ReseedAdditionalInput.\",0x16);\n    if (iVar1 == 0) {\n      uVar5 = FUN_000066e2(param_3,lVar4 + 0x20,lVar4 + 0x98);\n      return uVar5;\n    }\n    iVar1 = strncmp(param_2,\"AdditionalInputA.\",0x11);\n    if (iVar1 == 0) {\n      uVar5 = FUN_000066e2(param_3,lVar4 + 0x28,lVar4 + 0x68);\n      return uVar5;\n    }\n    iVar1 = strncmp(param_2,\"AdditionalInputB.\",0x11);\n    if (iVar1 == 0) {\n      uVar5 = FUN_000066e2(param_3,lVar4 + 0x30,lVar4 + 0x70);\n      return uVar5;\n    }\n    iVar1 = strncmp(param_2,\"EntropyPredictionResistanceA.\",0x1d);\n    if (iVar1 == 0) {\n      uVar5 = FUN_000066e2(param_3,lVar4 + 0x38,lVar4 + 0x78);\n      return uVar5;\n    }\n    iVar1 = strncmp(param_2,\"EntropyPredictionResistanceB.\",0x1d);\n    if (iVar1 == 0) {\n      uVar5 = FUN_000066e2(param_3,lVar4 + 0x40,lVar4 + 0x80);\n      return uVar5;\n    }\n    iVar1 = strncmp(param_2,\"Output.\",7);\n    if (iVar1 == 0) {\n      uVar5 = FUN_000066e2(param_3,lVar4 + 0x48,lVar4 + 0x88);\n      return uVar5;\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is rand_test_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  ulong uVar3;\n  long in_FS_OFFSET;\n  undefined4 local_88;\n  uint local_84;\n  undefined8 local_80;\n  void *local_78;\n  long local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  undefined local_58 [32];\n  undefined local_38;\n  undefined local_37;\n  undefined local_36;\n  undefined local_35;\n  undefined local_34;\n  undefined local_33;\n  undefined local_32;\n  undefined local_31;\n  undefined local_30;\n  undefined local_2f;\n  undefined local_2e;\n  undefined local_2d;\n  undefined local_2c;\n  undefined local_2b;\n  undefined local_2a;\n  undefined local_29;\n  undefined local_28;\n  undefined local_27;\n  undefined local_26;\n  undefined local_25;\n  undefined local_24;\n  undefined local_23;\n  undefined local_22;\n  undefined local_21;\n  undefined local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_84 = 0;\n  local_80 = 0;\n  local_88 = 0x1000;\n  local_60 = 0;\n  local_78 = (void *)0x0;\n  local_70 = 0;\n  local_68 = 0;\n  local_38 = 0xfb;\n  local_37 = 0x83;\n  local_36 = 0x4d;\n  local_35 = 0x36;\n  local_34 = 0x6d;\n  local_33 = 0xbc;\n  local_32 = 0x53;\n  local_31 = 0x87;\n  local_30 = 0x35;\n  local_2f = 0x1b;\n  local_2e = 0x34;\n  local_2d = 0x75;\n  local_2c = 0x95;\n  local_2b = 0x88;\n  local_2a = 0x32;\n  local_29 = 0x4f;\n  local_28 = 0x3e;\n  local_27 = 0x82;\n  local_26 = 0x81;\n  local_25 = 1;\n  local_24 = 0x21;\n  local_23 = 0x93;\n  local_22 = 100;\n  local_21 = 0;\n  local_20 = 0xcc;\n  local_60 = OSSL_LIB_CTX_new();\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x201,\"libctx = OSSL_LIB_CTX_new()\",local_60);\n  if (iVar1 != 0) {\n    local_70 = OSSL_PROVIDER_load(local_60,\"legacy\");\n    if (local_70 == 0) {\n      OSSL_LIB_CTX_free(local_60);\n      uVar3 = FUN_0000c6b6(\"test/evp_kdf_test.c\",0x208,\"PBKDF1 only available in legacy provider\");\n      goto LAB_00005107;\n    }\n    local_68 = OSSL_PROVIDER_load(local_60,\"default\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x20b,\n                         \"defprov = OSSL_PROVIDER_load(libctx, \\\"default\\\")\",local_68);\n    if (iVar1 != 0) {\n      local_78 = (void *)FUN_00004bfd(\"passwordPASSWORDpassword\",\"sha256\",\n                                      \"saltSALTsaltSALTsaltSALTsaltSALTsalt\",&local_88);\n      iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x212,\"params\",local_78);\n      if (iVar1 != 0) {\n        local_80 = FUN_00002d1a(local_60,\"PBKDF1\");\n        iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x213,\n                             \"kctx = get_kdfbyname_libctx(libctx, OSSL_KDF_NAME_PBKDF1)\",local_80);\n        if (iVar1 != 0) {\n          iVar1 = EVP_KDF_CTX_set_params(local_80,local_78);\n          iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0x214,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                               iVar1 != 0);\n          if (iVar1 != 0) {\n            uVar2 = EVP_KDF_derive(local_80,local_58,0x19,0);\n            iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x215,\n                                 \"EVP_KDF_derive(kctx, out, sizeof(out), NULL)\",&DAT_00013c2d,uVar2,\n                                 0);\n            if ((iVar1 != 0) &&\n               (iVar1 = FUN_0000e848(\"test/evp_kdf_test.c\",0x216,&DAT_00013c68,\"expected\",local_58,\n                                     0x19,&local_38,0x19), iVar1 != 0)) {\n              local_84 = 1;\n            }\n          }\n        }\n      }\n    }\n  }\n  EVP_KDF_CTX_free(local_80);\n  CRYPTO_free(local_78);\n  OSSL_PROVIDER_unload(local_68);\n  OSSL_PROVIDER_unload(local_70);\n  OSSL_LIB_CTX_free(local_60);\n  uVar3 = (ulong)local_84;\nLAB_00005107:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_kdf_pbkdf1"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4\n[MASK](undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n            undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n            X509 *param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n            undefined8 param_13,undefined8 param_14)\n\n{\n  long lVar1;\n  void *data;\n  char in_AL;\n  int iVar2;\n  int iVar3;\n  GENERAL_NAMES *a;\n  void **ppvVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  ulong uVar7;\n  long in_FS_OFFSET;\n  undefined4 local_110;\n  GENERAL_NAME *local_108;\n  ASN1_IA5STRING *local_100;\n  uint local_e8;\n  void **local_e0;\n  void *local_c8 [4];\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined4 local_98;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  \n  if (in_AL != '\\0') {\n    local_98 = param_1;\n    local_88 = param_2;\n    local_78 = param_3;\n    local_68 = param_4;\n    local_58 = param_5;\n    local_48 = param_6;\n    local_38 = param_7;\n    local_28 = param_8;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  local_110 = 0;\n  local_108 = (GENERAL_NAME *)0x0;\n  local_100 = (ASN1_IA5STRING *)0x0;\n  local_e8 = 8;\n  local_e0 = (void **)&stack0x00000008;\n  local_c8[1] = (void *)param_10;\n  local_c8[2] = (void *)param_11;\n  local_c8[3] = (void *)param_12;\n  local_a8 = param_13;\n  local_a0 = param_14;\n  a = (GENERAL_NAMES *)OPENSSL_sk_new_null();\n  if (a != (GENERAL_NAMES *)0x0) {\n    while( true ) {\n      local_100 = (ASN1_IA5STRING *)0x0;\n      local_108 = (GENERAL_NAME *)0x0;\n      if (local_e8 < 0x30) {\n        uVar7 = (ulong)local_e8;\n        local_e8 = local_e8 + 8;\n        ppvVar4 = (void **)((long)local_c8 + uVar7);\n      }\n      else {\n        ppvVar4 = local_e0;\n        local_e0 = local_e0 + 1;\n      }\n      iVar3 = *(int *)ppvVar4;\n      if (iVar3 == 0) break;\n      if (local_e8 < 0x30) {\n        uVar7 = (ulong)local_e8;\n        local_e8 = local_e8 + 8;\n        ppvVar4 = (void **)((long)local_c8 + uVar7);\n      }\n      else {\n        ppvVar4 = local_e0;\n        local_e0 = local_e0 + 1;\n      }\n      data = *ppvVar4;\n      local_108 = GENERAL_NAME_new();\n      if (((local_108 == (GENERAL_NAME *)0x0) ||\n          (local_100 = ASN1_IA5STRING_new(), local_100 == (ASN1_IA5STRING *)0x0)) ||\n         (iVar2 = ASN1_STRING_set(local_100,data,-1), iVar2 == 0)) goto LAB_00003af8;\n      if (1 < iVar3 - 1U) {\n                    /* WARNING: Subroutine does not return */\n        abort();\n      }\n      GENERAL_NAME_set0_value(local_108,iVar3,local_100);\n      uVar5 = FUN_000035ea(local_108);\n      uVar6 = FUN_000035f8(a);\n      OPENSSL_sk_push(uVar6,uVar5);\n    }\n    iVar3 = X509_add1_ext_i2d(param_9,0x55,a,0,0);\n    if (iVar3 != 0) {\n      local_110 = 1;\n    }\n  }\nLAB_00003af8:\n  ASN1_IA5STRING_free(local_100);\n  GENERAL_NAME_free(local_108);\n  GENERAL_NAMES_free(a);\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_110;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is set_altname"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  char *__ptr;\n  char *__format;\n  \n  __format = (char *)FUN_00001cc0(param_1);\n  __ptr = (char *)FUN_00001d07(param_1);\n  printf(__format,\"      style=\\\"fill:none;stroke:%s;stroke-width:%.1fpx\\\" />\\n\",__ptr);\n  if (*__ptr == '#') {\n    free(__ptr);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is common_entity"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long *param_1)\n\n{\n  if (*param_1 != 0) {\n    (*wget_free)(*param_1);\n    *param_1 = 0;\n  }\n  if (param_1[1] != 0) {\n    (*wget_free)(param_1[1]);\n    param_1[1] = 0;\n  }\n  wget_iri_free(param_1 + 2);\n  wget_html_free_urls_inline(param_1 + 3);\n  if (param_1 != (long *)0x0) {\n    (*wget_free)(param_1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is free_conversion"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](char *param_1,double *param_2,char *param_3)\n\n{\n  bool bVar1;\n  char cVar2;\n  undefined8 uVar3;\n  char *local_20;\n  double local_10;\n  \n  bVar1 = false;\n  local_20 = param_1;\n  while( true ) {\n    cVar2 = FUN_000284f3((int)*local_20);\n    if (cVar2 == '\\0') break;\n    local_20 = local_20 + 1;\n  }\n  if (*local_20 == '+') {\n    local_20 = local_20 + 1;\n  }\n  else if (*local_20 == '-') {\n    local_20 = local_20 + 1;\n    bVar1 = true;\n  }\n  cVar2 = FUN_00028435((int)*local_20);\n  if (cVar2 == '\\x01') {\n    *param_2 = 0.0;\n    while( true ) {\n      cVar2 = FUN_00028435((int)*local_20);\n      if (cVar2 == '\\0') break;\n      *param_2 = (double)(*local_20 + -0x30) + *param_2 * DAT_00047498;\n      local_20 = local_20 + 1;\n    }\n    if (*local_20 == '.') {\n      local_10 = DAT_00047498;\n      while( true ) {\n        local_20 = local_20 + 1;\n        cVar2 = FUN_00028435((int)*local_20);\n        if (cVar2 == '\\0') break;\n        *param_2 = (double)(*local_20 + -0x30) / local_10 + *param_2;\n        local_10 = DAT_00047498 * local_10;\n      }\n    }\n    if (bVar1) {\n      *param_2 = (double)(DAT_000474a0 ^ (ulong)*param_2);\n    }\n    *param_3 = *local_20;\n    if (*param_3 == '\\0') {\n      uVar3 = 1;\n    }\n    else {\n      uVar3 = 2;\n    }\n  }\n  else {\n    uVar3 = 0;\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is parse_double_modifier"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  FUN_00009d51(param_2,param_1 + 0x210);\n  return;\n}\n\n",
        "output": "The predicted function name is parse_test_use_sctp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_000036d5(0x30,0,0);\n  return;\n}\n\n",
        "output": "The predicted function name is test_http_keep_alive_0_no_no"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  char cVar1;\n  long in_FS_OFFSET;\n  undefined8 uVar2;\n  char *__format;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  cVar1 = FUN_00001be7();\n  if (cVar1 == '\\0') {\n    cVar1 = FUN_00001be7();\n    if (cVar1 == '\\0') {\n      cVar1 = FUN_00001c1d(param_1);\n      if (cVar1 == '\\0') {\n        FUN_000058cd(&local_28);\n        printf(\"\\t<!-- point-%d -->\\n\",(ulong)*(uint *)(param_1 + 0x14));\n        uVar2 = FUN_00001b1f(local_20);\n        __format = (char *)FUN_00001b03(local_28);\n        printf(__format,uVar2,\"\\t<circle id=\\\"dwg-object-%d\\\" cx=\\\"%f\\\" cy=\\\"%f\\\" r=\\\"0.1\\\"\\n\\t\",\n               (ulong)*(uint *)(param_1 + 0x14));\n        FUN_00001e87(*(undefined8 *)(param_1 + 0x38));\n      }\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is output_POINT"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 *param_1,undefined4 param_2)\n\n{\n  void *__ptr;\n  undefined8 uVar1;\n  \n  __ptr = (void *)dico_full_file_name(*param_1,&DAT_0000fa46);\n  uVar1 = FUN_00009e9a(__ptr,param_2);\n  free(__ptr);\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is read_dictionary_info"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](BIO *param_1,int param_2,undefined8 param_3,undefined8 param_4,int param_5,\n                 undefined8 param_6,int param_7)\n\n{\n  undefined8 *puVar1;\n  \n  puVar1 = (undefined8 *)BIO_get_callback_arg(param_1);\n  if ((param_2 == 0x86) && (param_5 == 0xb)) {\n    param_7 = FUN_00002ef6(param_1,*puVar1,(int)*(char *)(puVar1 + 1),\n                           *(undefined4 *)((long)puVar1 + 0xc),DAT_002130f0,DAT_002130e8);\n  }\n  return (long)param_7;\n}\n\n",
        "output": "The predicted function name is http_bio_cb_ex"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\ndouble [MASK](double param_1)\n\n{\n  return param_1 - DAT_002091f8;\n}\n\n",
        "output": "The predicted function name is transform_X"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  ENGINE *e;\n  \n  e = (ENGINE *)FUN_00002bb6();\n  if (e != (ENGINE *)0x0) {\n    ERR_set_mark();\n    ENGINE_add(e);\n    ENGINE_free(e);\n    ERR_pop_to_mark();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is engine_load_dasync_int"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Type propagation algorithm not settling */\n\nvoid [MASK](undefined8 param_1)\n\n{\n  int iVar1;\n  char *pcVar2;\n  \n  FUN_000061e7(DAT_00214a50,0x11);\n  FUN_00006846(DAT_00214a50,FUN_00005af3,0);\n  FUN_00006871(DAT_00214a50,0xc);\n  FUN_000041e4(DAT_00214a50,1);\n  iVar1 = FUN_0000688c(DAT_00214a50,param_1);\n  if (iVar1 != 0) {\n    error(1,0,0xff00);\n  }\n  pcVar2 = inet_ntoa((in_addr)((in_addr *)(DAT_00214a50 + 0x2c))->s_addr);\n  printf(\"PING %s (%s): sending address mask request\\n\",*(undefined8 *)(DAT_00214a50 + 0x48),pcVar2)\n  ;\n  FUN_0000349f(DAT_00214a50,FUN_00005c2f);\n  return;\n}\n\n",
        "output": "The predicted function name is ping_address"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 *param_1)\n\n{\n  dlclose(*param_1);\n  (*wget_free)(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is dl_file_close"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,long param_2,int param_3,uint param_4)\n\n{\n  long local_28;\n  uint local_c;\n  \n  local_28 = param_2;\n  for (local_c = 0; local_c < param_4; local_c = local_c + 1) {\n    local_28 = local_28 + (ulong)(byte)(&DAT_0000e240)[local_c + param_3];\n  }\n  FUN_00002a58(param_1,local_28,1);\n  return;\n}\n\n",
        "output": "The predicted function name is factor_insert_refind"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,long param_2)\n\n{\n  FUN_0000c7e8(\"Server CA names\",*(undefined8 *)(param_2 + 0x1f0),*(undefined8 *)(param_1 + 0x70));\n  return;\n}\n\n",
        "output": "The predicted function name is check_server_ca_names"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0000b38a(param_1,param_2,1,PTR_EVP_PKEY_verify_init_00223fe8,0);\n  return;\n}\n\n",
        "output": "The predicted function name is verify_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return DAT_00205340;\n}\n\n",
        "output": "The predicted function name is dasync_sha1"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](int param_1,long param_2)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined8 uVar3;\n  long lVar4;\n  char *pcVar5;\n  long lVar6;\n  short local_56;\n  int local_54;\n  int local_50;\n  int local_4c;\n  long local_40;\n  \n  local_40 = 0;\n  if (DAT_00253d80 == 0) {\n    for (local_56 = 0; local_56 < 0xba; local_56 = local_56 + 1) {\n      if ('\\0' < (char)(&DAT_0024e24c)[(long)(int)local_56 * 0x58]) {\n        (&DAT_00253d80)[(int)(uint)(byte)(&DAT_0024e24c)[(long)(int)local_56 * 0x58]] = local_56 + 1\n        ;\n      }\n    }\n  }\n  local_54 = 1;\n  do {\n    if (param_1 <= local_54) {\n      return local_54;\n    }\n    if (local_40 == *(long *)(param_2 + (long)local_54 * 8)) {\n      return local_54;\n    }\n    pcVar5 = *(char **)(param_2 + (long)local_54 * 8);\n    if (*pcVar5 == '-') {\n      if (pcVar5[1] == '-') {\n        if (pcVar5[2] == '\\0') {\n          return local_54 + 1;\n        }\n        if (local_54 < param_1 + -1) {\n          uVar3 = *(undefined8 *)(param_2 + ((long)local_54 + 1) * 8);\n        }\n        else {\n          uVar3 = 0;\n        }\n        iVar2 = FUN_00022516(pcVar5 + 2,uVar3,0);\n        if (iVar2 < 0) {\n          return iVar2;\n        }\n        local_54 = local_54 + iVar2;\n      }\n      else if (pcVar5[1] != '\\0') {\n        for (local_4c = 1; pcVar5[local_4c] != '\\0'; local_4c = local_4c + 1) {\n          cVar1 = FUN_0002836d((int)pcVar5[local_4c]);\n          if ((cVar1 == '\\0') || ((&DAT_00253d80)[(int)(uint)(byte)pcVar5[local_4c]] == 0)) {\n            cVar1 = pcVar5[local_4c];\n            uVar3 = gettext(\"Unknown option \\'-%c\\'\\n\");\n            wget_error_printf(uVar3,(int)cVar1);\n            return -1;\n          }\n          lVar6 = (long)((&DAT_00253d80)[(int)(uint)(byte)pcVar5[local_4c]] + -1);\n          lVar4 = lVar6 * 0x58;\n          if (0 < *(int *)(lVar4 + 0x24e248)) {\n            if ((pcVar5[(long)local_4c + 1] == '\\0') &&\n               (param_1 <= local_54 + *(int *)(lVar4 + 0x24e248))) {\n              cVar1 = pcVar5[local_4c];\n              uVar3 = gettext(\"Missing argument(s) for option \\'-%c\\'\\n\");\n              wget_error_printf(uVar3,(int)cVar1);\n              return -1;\n            }\n            if (pcVar5[(long)local_4c + 1] == '\\0') {\n              local_54 = local_54 + 1;\n              pcVar5 = *(char **)(param_2 + (long)local_54 * 8);\n            }\n            else {\n              pcVar5 = pcVar5 + (long)local_4c + 1;\n            }\n            iVar2 = (*(code *)(&PTR_FUN_0024e240)[lVar6 * 0xb])(s_accept_0024e220 + lVar4,pcVar5,0);\n            if (iVar2 < 0) {\n              return iVar2;\n            }\n            local_54 = local_54 + iVar2;\n            break;\n          }\n          iVar2 = (*(code *)(&PTR_FUN_0024e240)[lVar6 * 0xb])(s_accept_0024e220 + lVar4,0,0);\n          if (iVar2 < 0) {\n            return iVar2;\n          }\n        }\n      }\n    }\n    else {\n      lVar4 = *(long *)(param_2 + (long)local_54 * 8);\n      for (local_50 = local_54; local_50 < param_1 + -1; local_50 = local_50 + 1) {\n        *(undefined8 *)(param_2 + (long)local_50 * 8) =\n             *(undefined8 *)(param_2 + ((long)local_50 + 1) * 8);\n      }\n      *(long *)((long)param_1 * 8 + -8 + param_2) = lVar4;\n      if (local_40 == 0) {\n        local_40 = lVar4;\n      }\n      local_54 = local_54 + -1;\n    }\n    local_54 = local_54 + 1;\n  } while( true );\n}\n\n",
        "output": "The predicted function name is parse_command_line"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](int param_1)\n\n{\n  char *pcVar1;\n  \n  if (param_1 == 1) {\n    pcVar1 = \"HPKP_MATCH\";\n  }\n  else if (param_1 == 0) {\n    pcVar1 = \"HPKP_NO\";\n  }\n  else if (param_1 == 2) {\n    pcVar1 = \"HPKP_NOMATCH\";\n  }\n  else if (param_1 == 3) {\n    pcVar1 = \"HPKP_ERROR\";\n  }\n  else {\n    pcVar1 = \"?\";\n  }\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is hpkp_string"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,long param_2)\n\n{\n  utf8_strcasecmp(*(undefined8 *)(param_1 + 0x30),*(undefined8 *)(param_2 + 0x30));\n  return;\n}\n\n",
        "output": "The predicted function name is compare_ref"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2)\n\n{\n  long *plVar1;\n  int iVar2;\n  long lVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  undefined8 *puVar6;\n  long local_38;\n  char *local_30;\n  \n  local_38 = **(long **)(param_1 + 0x18);\n  if ((param_2 == (char *)0x0) || (*param_2 == '\\0')) {\n    if ((param_2 != (char *)0x0) && (*param_2 == '\\0')) {\n      wget_vector_clear(local_38);\n    }\n  }\n  else {\n    if (local_38 == 0) {\n      plVar1 = *(long **)(param_1 + 0x18);\n      lVar3 = wget_vector_create(8,FUN_000200eb);\n      *plVar1 = lVar3;\n      local_38 = *plVar1;\n      wget_vector_set_destructor(local_38,PTR_wget_http_free_param_00252ff8);\n    }\n    pcVar4 = strchr(param_2,0x3a);\n    if ((pcVar4 == (char *)0x0) || (local_30 = pcVar4, pcVar4 == param_2)) {\n      uVar5 = gettext(\"Ignoring invalid header: %s\\n\");\n      wget_error_printf(uVar5,param_2);\n    }\n    else {\n      do {\n        local_30 = local_30 + 1;\n      } while (*local_30 == ' ');\n      if (*local_30 == '\\0') {\n        uVar5 = gettext(\"No value in header (ignoring): %s\\n\");\n        wget_error_printf(uVar5,param_2);\n      }\n      else {\n        puVar6 = (undefined8 *)FUN_0001f967(0x10);\n        uVar5 = wget_strmemdup(param_2,(long)pcVar4 - (long)param_2);\n        *puVar6 = uVar5;\n        uVar5 = wget_strdup(local_30);\n        puVar6[1] = uVar5;\n        iVar2 = wget_vector_find(local_38,puVar6);\n        if (iVar2 < 0) {\n          wget_vector_add(local_38,puVar6);\n        }\n        else {\n          wget_http_free_param(puVar6);\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is parse_header"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 *param_2)\n\n{\n  int iVar1;\n  __pid_t _Var2;\n  uint uVar3;\n  undefined8 uVar4;\n  int *piVar5;\n  long in_FS_OFFSET;\n  uint local_30;\n  __pid_t local_2c;\n  char *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_28 = PTR_s__home_xin_Downloads_gnu_projects_002133a0;\n  if (param_2[4] != 0) {\n    local_28 = (char *)param_2[4];\n  }\n  uVar4 = gettext(\"gcide_open_idx: creating index %s\");\n  dico_log(2,0,uVar4,param_1);\n  iVar1 = access(local_28,1);\n  if (iVar1 == 0) {\n    local_2c = fork();\n    if (local_2c == 0) {\n      execl(local_28,local_28,*param_2,param_2[1],0);\n    }\n    if (local_2c == -1) {\n      uVar4 = gettext(\"gcide_open_idx: fork failed\");\n      piVar5 = __errno_location();\n      dico_log(4,*piVar5,uVar4);\n      uVar4 = 1;\n    }\n    else {\n      _Var2 = waitpid(local_2c,(int *)&local_30,0);\n      if (local_2c == _Var2) {\n        if ((local_30 & 0x7f) == 0) {\n          uVar3 = (int)local_30 >> 8 & 0xff;\n          local_30 = uVar3;\n          if (uVar3 == 0) {\n            uVar4 = 0;\n          }\n          else {\n            uVar4 = gettext(\"gcide_open_idx: %s exited with status %d\");\n            dico_log(4,0,uVar4,local_28,uVar3);\n            uVar4 = 1;\n          }\n        }\n        else {\n          uVar4 = gettext(\"gcide_open_idx: %s failed\");\n          dico_log(4,0,uVar4,local_28);\n          uVar4 = 1;\n        }\n      }\n      else {\n        uVar4 = gettext(\"gcide_open_idx: %s failed\");\n        piVar5 = __errno_location();\n        dico_log(4,*piVar5,uVar4,local_28);\n        kill(local_2c,9);\n        uVar4 = 1;\n      }\n    }\n  }\n  else {\n    uVar4 = gettext(\"gcide_open_idx: cannot run %s\");\n    piVar5 = __errno_location();\n    dico_log(4,*piVar5,uVar4,local_28);\n    uVar4 = 1;\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is run_idxgcide"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined [MASK](undefined8 param_1,undefined8 param_2,char param_3,undefined8 param_4)\n\n{\n  undefined8 uVar1;\n  void *__ptr;\n  undefined local_19;\n  \n  if (DAT_00225110 != '\\0') {\n    FUN_0000f862(param_1);\n  }\n  if (param_3 == '\\0') {\n    local_19 = FUN_00003b08(param_1,param_2,param_4);\n  }\n  else {\n    uVar1 = FUN_0000f7ab(param_1);\n    __ptr = (void *)FUN_0000ff4b(param_2,uVar1,0);\n    FUN_0000f862(__ptr);\n    local_19 = FUN_00003b08(param_1,__ptr,param_4);\n    free(__ptr);\n  }\n  return local_19;\n}\n\n",
        "output": "The predicted function name is movefile"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long in_FS_OFFSET;\n  undefined4 local_74;\n  undefined4 local_70;\n  undefined4 local_6c;\n  undefined8 local_68;\n  void *local_60;\n  undefined local_58 [32];\n  undefined local_38;\n  undefined local_37;\n  undefined local_36;\n  undefined local_35;\n  undefined local_34;\n  undefined local_33;\n  undefined local_32;\n  undefined local_31;\n  undefined local_30;\n  undefined local_2f;\n  undefined local_2e;\n  undefined local_2d;\n  undefined local_2c;\n  undefined local_2b;\n  undefined local_2a;\n  undefined local_29;\n  undefined local_28;\n  undefined local_27;\n  undefined local_26;\n  undefined local_25;\n  undefined local_24;\n  undefined local_23;\n  undefined local_22;\n  undefined local_21;\n  undefined local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_6c = 0;\n  local_68 = 0;\n  local_74 = 0x1000;\n  local_70 = 0;\n  local_38 = 0x34;\n  local_37 = 0x8c;\n  local_36 = 0x89;\n  local_35 = 0xdb;\n  local_34 = 0xcb;\n  local_33 = 0xd3;\n  local_32 = 0x2b;\n  local_31 = 0x2f;\n  local_30 = 0x32;\n  local_2f = 0xd8;\n  local_2e = 0x14;\n  local_2d = 0xb8;\n  local_2c = 0x11;\n  local_2b = 0x6e;\n  local_2a = 0x84;\n  local_29 = 0xcf;\n  local_28 = 0x2b;\n  local_27 = 0x17;\n  local_26 = 0x34;\n  local_25 = 0x7e;\n  local_24 = 0xbc;\n  local_23 = 0x18;\n  local_22 = 0;\n  local_21 = 0x18;\n  local_20 = 0x1c;\n  local_60 = (void *)FUN_0000511d(\"passwordPASSWORDpassword\",\"sha256\",\n                                  \"saltSALTsaltSALTsaltSALTsaltSALTsalt\",&local_74,&local_70);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x24c,\"params\",local_60);\n  if (iVar1 != 0) {\n    local_68 = FUN_00002d68(\"PBKDF2\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x24d,\"kctx = get_kdfbyname(OSSL_KDF_NAME_PBKDF2)\",\n                         local_68);\n    if (iVar1 != 0) {\n      uVar2 = EVP_KDF_derive(local_68,local_58,0x19,local_60);\n      iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x24e,\n                           \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar2,0);\n      if (iVar1 != 0) {\n        iVar1 = FUN_0000e848(\"test/evp_kdf_test.c\",0x24f,&DAT_00013c68,\"expected\",local_58,0x19,\n                             &local_38,0x19);\n        if (iVar1 != 0) {\n          local_6c = 1;\n        }\n      }\n    }\n  }\n  EVP_KDF_CTX_free(local_68);\n  CRYPTO_free(local_60);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_6c;\n}\n\n",
        "output": "The predicted function name is test_kdf_pbkdf2"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,long param_2,long param_3)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  int iVar3;\n  undefined8 uVar4;\n  X509_NAME *b;\n  X509_NAME *a;\n  int local_1c;\n  \n  if (param_2 == 0) {\n    return 1;\n  }\n  if (param_3 != 0) {\n    uVar4 = FUN_0000bd13(param_3);\n    iVar1 = OPENSSL_sk_num(uVar4);\n    if (iVar1 != 0) {\n      uVar4 = FUN_0000bd13(param_3);\n      iVar1 = OPENSSL_sk_num(uVar4);\n      uVar4 = FUN_0000bd13(param_2);\n      iVar3 = OPENSSL_sk_num(uVar4);\n      if (iVar1 == iVar3) {\n        local_1c = 0;\n        while( true ) {\n          uVar4 = FUN_0000bd13(param_3);\n          iVar1 = OPENSSL_sk_num(uVar4);\n          if (iVar1 <= local_1c) {\n            return 1;\n          }\n          uVar4 = FUN_0000bd13(param_2);\n          b = (X509_NAME *)OPENSSL_sk_value(uVar4,local_1c);\n          uVar4 = FUN_0000bd13(param_3);\n          a = (X509_NAME *)OPENSSL_sk_value(uVar4,local_1c);\n          iVar1 = X509_NAME_cmp(a,b);\n          iVar1 = FUN_00012c68(\"test/ssl_test.c\",0x10b,\n                               \"X509_NAME_cmp(sk_X509_NAME_value(names, i), sk_X509_NAME_value(expected_names, i))\"\n                               ,&DAT_000191e4,iVar1,0);\n          if (iVar1 == 0) break;\n          local_1c = local_1c + 1;\n        }\n      }\n      goto LAB_0000c957;\n    }\n  }\n  uVar4 = FUN_0000bd13(param_2);\n  uVar2 = OPENSSL_sk_num(uVar4);\n  iVar1 = FUN_00012c68(\"test/ssl_test.c\",0x102,\"sk_X509_NAME_num(expected_names)\",&DAT_000191e4,\n                       uVar2,0);\n  if (iVar1 != 0) {\n    return 1;\n  }\nLAB_0000c957:\n  FUN_0001261b(\"test/ssl_test.c\",0x111,\"%s: list mismatch\",param_1);\n  FUN_0001295d(\"Expected Names:\");\n  FUN_0000c734(param_2);\n  FUN_0001295d(\"Received Names:\");\n  FUN_0000c734(param_3);\n  return 0;\n}\n\n",
        "output": "The predicted function name is check_ca_names"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return *(undefined8 *)PTR_gcide_markup_yytext_00212f90;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyget_text"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  undefined8 uVar1;\n  int *piVar2;\n  \n  if (param_1 == 0) {\n    uVar1 = 0;\n  }\n  else {\n    piVar2 = (int *)EVP_CIPHER_CTX_get_cipher_data();\n    if ((piVar2 == (int *)0x0) || (*piVar2 != 0x1890671)) {\n      uVar1 = 1;\n    }\n    else {\n      close(piVar2[1]);\n      close(piVar2[2]);\n      if (piVar2[5] == 1) {\n        close(piVar2[4]);\n      }\n      FUN_00001b3c(*(undefined8 *)(piVar2 + 6));\n      uVar1 = 1;\n    }\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is afalg_cipher_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](SSL *param_1)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  char *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar1 = SSL_ctrl(param_1,0x46,0,&local_18);\n  if (((int)lVar1 == 1) && (*local_18 == DAT_00220010)) {\n    uVar2 = 1;\n  }\n  else {\n    uVar2 = 0;\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is client_ocsp_cb"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  if (param_1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    if (*(long *)(param_1 + 0x48) == 0) {\n      do {\n        iVar1 = gcide_iterator_next(param_1);\n      } while (iVar1 == 0);\n      gcide_iterator_rewind(param_1);\n    }\n    uVar2 = *(undefined8 *)(param_1 + 0x48);\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is gcide_iterator_count"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  FUN_00009f56(param_1 + 0x1ac,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is parse_client_alert"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](undefined8 param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_34;\n  undefined4 local_30;\n  int local_2c;\n  undefined *local_28;\n  undefined *local_20;\n  undefined *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_28 = &DAT_0000e115;\n  local_20 = &DAT_0000e115;\n  local_18 = &DAT_0000e115;\n  local_34 = 1;\n  local_30 = 1;\n  iVar1 = OSSL_HTTP_parse_url(param_1,&local_30,0,&local_28,&local_20,&local_34,&local_18,0,0);\n  iVar1 = FUN_0000aa55(\"test/http_test.c\",0x11a,\n                       \"OSSL_HTTP_parse_url(url, &ssl, NULL, &host, &port, &num, &path, NULL, NULL)\"\n                       ,iVar1 != 0);\n  if (iVar1 != 0) {\n    iVar1 = FUN_0000a8ff(\"test/http_test.c\",0x11b,&DAT_0000e199,local_28);\n    if (iVar1 != 0) {\n      iVar1 = FUN_0000a8ff(\"test/http_test.c\",0x11c,&DAT_0000e1a7,local_20);\n      if (iVar1 != 0) {\n        iVar1 = FUN_0000a8ff(\"test/http_test.c\",0x11d,&DAT_0000e1c1,local_18);\n        if (iVar1 != 0) {\n          local_2c = 1;\n          goto LAB_0000402e;\n        }\n      }\n    }\n  }\n  local_2c = 0;\nLAB_0000402e:\n  if (local_2c == 0) {\n    CRYPTO_free(local_28);\n    CRYPTO_free(local_20);\n    CRYPTO_free(local_18);\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_2c;\n}\n\n",
        "output": "The predicted function name is test_http_url_invalid"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](long param_1)\n\n{\n  long lVar1;\n  undefined *puVar2;\n  char cVar3;\n  undefined8 uVar4;\n  char *__s;\n  long lVar5;\n  long in_FS_OFFSET;\n  undefined8 uStack464;\n  undefined auStack456 [8];\n  long local_1c0;\n  char local_1ad;\n  int local_1ac;\n  long local_1a8;\n  char *local_1a0;\n  long local_198;\n  undefined *local_190;\n  long local_188;\n  long local_180;\n  char *local_168 [4];\n  undefined local_148 [264];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_1ad = DAT_00253423;\n  if (DAT_002533fe != '\\x01') {\n    local_1ad = '\\0';\n  }\n  if (DAT_002533fd != '\\0') {\n    local_1ad = '\\x01';\n  }\n  uStack464 = 0xd59f;\n  local_1c0 = param_1;\n  wget_buffer_init(&local_188,0,0x100);\n  if ((DAT_00253150 != (char *)0x0) && (*DAT_00253150 != '\\0')) {\n    uStack464 = 0xd5d2;\n    wget_buffer_strcat(&local_188,DAT_00253150);\n    uStack464 = 0xd5ed;\n    wget_buffer_memcat(&local_188,&DAT_00041128,1);\n  }\n  if (local_1ad == '\\0') {\n    if (DAT_00253412 == '\\0') {\n      uStack464 = 0xd8cd;\n      local_1a8 = wget_iri_get_basename(local_1c0,&local_188,DAT_00253110,1);\n    }\n    else {\n      uStack464 = 0xd8a2;\n      local_1a8 = wget_iri_get_basename(local_1c0,&local_188,DAT_00253110,0);\n    }\n  }\n  else {\n    if (DAT_002533fb != '\\0') {\n      uStack464 = 0xd614;\n      cVar3 = wget_iri_supported(local_1c0);\n      if (cVar3 != '\\0') {\n        uStack464 = 0xd629;\n        uVar4 = wget_iri_scheme_get_name(*(undefined4 *)(local_1c0 + 0x5c));\n        uStack464 = 0xd63e;\n        wget_buffer_strcat(&local_188,uVar4);\n        uStack464 = 0xd659;\n        wget_buffer_memcat(&local_188,&DAT_00041128,1);\n      }\n    }\n    if (((DAT_002533fc != '\\0') && (*(long *)(local_1c0 + 0x20) != 0)) &&\n       (**(char **)(local_1c0 + 0x20) != '\\0')) {\n      uStack464 = 0xd6a3;\n      wget_buffer_strcat(&local_188,*(undefined8 *)(local_1c0 + 0x20));\n      uStack464 = 0xd6be;\n      wget_buffer_memcat(&local_188,&DAT_00041128,1);\n    }\n    if (DAT_002533a8 == 0) {\n      uStack464 = 0xd82e;\n      wget_iri_get_path(local_1c0,&local_188,DAT_00253110);\n    }\n    else {\n      uStack464 = 0xd6ea;\n      wget_buffer_init(local_168,local_148,0x100);\n      uStack464 = 0xd70a;\n      wget_iri_get_path(local_1c0,local_168,DAT_00253110);\n      local_1ac = 0;\n      local_1a0 = local_168[0];\n      while ((local_1ac < DAT_002533a8 && (local_1a0 != (char *)0x0))) {\n        __s = local_1a0;\n        if (*local_1a0 == '/') {\n          __s = local_1a0 + 1;\n        }\n        uStack464 = 0xd753;\n        local_1a0 = strchr(__s,0x2f);\n        local_1ac = local_1ac + 1;\n      }\n      if ((local_1a0 == (char *)0x0) && (local_168[0] != (char *)0x0)) {\n        uStack464 = 0xd7a3;\n        local_1a0 = strrchr(local_168[0],0x2f);\n        if (local_1a0 == (char *)0x0) {\n          local_1a0 = local_168[0];\n        }\n      }\n      if (local_1a0 != (char *)0x0) {\n        for (; *local_1a0 == '/'; local_1a0 = local_1a0 + 1) {\n        }\n        uStack464 = 0xd7fd;\n        wget_buffer_strcat(&local_188,local_1a0);\n      }\n      uStack464 = 0xd80c;\n      wget_buffer_deinit(local_168);\n    }\n    if (DAT_00253412 == '\\0') {\n      uStack464 = 0xd86c;\n      local_1a8 = wget_iri_get_query_as_filename(local_1c0,&local_188,DAT_00253110);\n    }\n    else {\n      local_1a8 = local_188;\n    }\n  }\n  lVar5 = local_1a8;\n  if (DAT_0025339c != 0) {\n    local_198 = local_180 * 3;\n    lVar1 = ((local_180 * 3 + 0x10U) / 0x10) * -0x10;\n    local_190 = auStack456 + lVar1;\n    *(undefined8 *)(auStack456 + lVar1 + -8) = 0xd969;\n    lVar5 = FUN_00027ecb(lVar5,auStack456 + lVar1,DAT_0025339c);\n    puVar2 = local_190;\n    if (local_1a8 != lVar5) {\n      *(undefined8 *)(auStack456 + lVar1 + -8) = 0xd98b;\n      wget_buffer_strcpy(&local_188,puVar2);\n      local_1a8 = local_188;\n    }\n  }\n  uStack464 = 0xd9b7;\n  wget_debug_printf(\"local filename = \\'%s\\'\\n\",local_1a8);\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_1a8;\n  }\n                    /* WARNING: Subroutine does not return */\n  uStack464 = 0xd9d2;\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is get_local_filename_real"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Type propagation algorithm not settling */\n\nvoid [MASK](int param_1,undefined8 param_2,undefined8 param_3,long param_4,undefined8 param_5,\n                 long param_6,uint param_7)\n\n{\n  uint16_t uVar1;\n  uint32_t uVar2;\n  int iVar3;\n  uint32_t uVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  long in_FS_OFFSET;\n  undefined local_38 [24];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar1 = ntohs(*(uint16_t *)(param_6 + 6));\n  pcVar5 = inet_ntoa((in_addr)((in_addr *)(param_4 + 4))->s_addr);\n  printf(\"%d bytes from %s: icmp_seq=%u\",(ulong)param_7,pcVar5,(ulong)uVar1);\n  if (param_1 != 0) {\n    printf(\" (DUP!)\");\n  }\n  putchar(10);\n  uVar2 = ntohl(*(uint32_t *)(param_6 + 8));\n  uVar6 = FUN_0000400a(local_38,0x10,uVar2);\n  printf(\"icmp_otime = %s\\n\",uVar6);\n  uVar2 = ntohl(*(uint32_t *)(param_6 + 0xc));\n  uVar6 = FUN_0000400a(local_38,0x10,uVar2);\n  printf(\"icmp_rtime = %s\\n\",uVar6);\n  uVar2 = ntohl(*(uint32_t *)(param_6 + 0x10));\n  uVar6 = FUN_0000400a(local_38,0x10,uVar2);\n  printf(\"icmp_ttime = %s\\n\",uVar6);\n  if ((DAT_00214a48 & 0x20) != 0) {\n    ntohl(*(uint32_t *)(param_6 + 8));\n    iVar3 = FUN_00003ff6();\n    if (iVar3 != 0) {\n      ntohl(*(uint32_t *)(param_6 + 8));\n      iVar3 = FUN_00003ff6();\n      if (iVar3 != 0) {\n        uVar2 = ntohl(*(uint32_t *)(param_6 + 0x10));\n        uVar4 = ntohl(*(uint32_t *)(param_6 + 8));\n        printf(\"difference = %d ms\\n\",(ulong)(uVar2 - uVar4));\n      }\n    }\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is print_timestamp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](int param_1,long *param_2,undefined8 *param_3)\n\n{\n  int iVar1;\n  ushort **ppuVar2;\n  size_t sVar3;\n  char *local_18;\n  \n  iVar1 = *(int *)(param_2 + 2);\n  if (iVar1 == 1) {\n    if ((*(uint *)(param_3 + 1) & 0x1000) == 0) {\n      if ((*(uint *)(param_3 + 1) & 0x2000) == 0) {\n        sVar3 = strlen((char *)param_2[4]);\n        dico_stream_write(*param_3,param_2[4],sVar3);\n      }\n      else {\n        local_18 = (char *)param_2[4];\n        iVar1 = strncmp(local_18,\"as\",2);\n        if ((iVar1 == 0) &&\n           ((ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[local_18[3]] & 0x2000) != 0 ||\n            (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[local_18[3]] & 4) != 0)))) {\n          dico_stream_write(*param_3,local_18,3);\n          local_18 = local_18 + 3;\n          while ((*local_18 != '\\0' &&\n                 (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[*local_18] & 0x2000) != 0))) {\n            dico_stream_write(*param_3,local_18,1);\n            local_18 = local_18 + 1;\n          }\n          sVar3 = strlen(PTR_DAT_00213430);\n          dico_stream_write(*param_3,PTR_DAT_00213430,sVar3);\n          sVar3 = strlen(local_18);\n          dico_stream_write(*param_3,local_18,sVar3);\n        }\n        else {\n          sVar3 = strlen(PTR_DAT_00213430);\n          dico_stream_write(*param_3,PTR_DAT_00213430,sVar3);\n        }\n      }\n    }\n  }\n  else if (((iVar1 != 0) && (iVar1 == 2)) && (*param_2 != 0)) {\n    *(uint *)(param_3 + 1) = *(uint *)(param_3 + 1) & 0xffffdfff;\n    if (param_1 == 0) {\n      iVar1 = strcmp(*(char **)param_2[1],\"pr\");\n      if ((iVar1 == 0) && ((*(uint *)(param_3 + 1) & 1) != 0)) {\n        *(uint *)(param_3 + 1) = *(uint *)(param_3 + 1) | 0x1000;\n      }\n      else if ((*(uint *)(param_3 + 1) & 0x1000) == 0) {\n        iVar1 = strcmp(*(char **)param_2[1],\"sn\");\n        if (iVar1 == 0) {\n          dico_stream_write(*param_3,&DAT_0000faaa,1);\n        }\n        else {\n          iVar1 = strcmp(*(char **)param_2[1],\"as\");\n          if (iVar1 == 0) {\n            *(uint *)(param_3 + 1) = *(uint *)(param_3 + 1) | 0x2000;\n          }\n          else {\n            iVar1 = strcmp(*(char **)param_2[1],\"er\");\n            if (iVar1 == 0) {\n              sVar3 = strlen(PTR_DAT_00213440);\n              dico_stream_write(*param_3,PTR_DAT_00213440,sVar3);\n            }\n          }\n        }\n      }\n    }\n    else {\n      iVar1 = strcmp(*(char **)param_2[1],\"pr\");\n      if ((iVar1 == 0) && ((*(uint *)(param_3 + 1) & 1) != 0)) {\n        *(uint *)(param_3 + 1) = *(uint *)(param_3 + 1) & 0xffffefff;\n      }\n      else if ((*(uint *)(param_3 + 1) & 0x1000) == 0) {\n        iVar1 = strcmp(*(char **)param_2[1],\"as\");\n        if (iVar1 == 0) {\n          sVar3 = strlen(PTR_DAT_00213438);\n          dico_stream_write(*param_3,PTR_DAT_00213438,sVar3);\n        }\n        else {\n          iVar1 = strcmp(*(char **)param_2[1],\"er\");\n          if (iVar1 == 0) {\n            sVar3 = strlen(PTR_DAT_00213448);\n            dico_stream_write(*param_3,PTR_DAT_00213448,sVar3);\n          }\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is print_text"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  return param_1;\n}\n\n",
        "output": "The predicted function name is ossl_check_const_OPENSSL_STRING_sk_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_14;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_00009ddc(&PTR_DAT_0021efc0,4,&local_14,param_2);\n  if (iVar1 != 0) {\n    *(undefined4 *)(param_1 + 4) = local_14;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1 != 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is parse_servername"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 *param_2)\n\n{\n  wget_fprintf(param_1,\"%llu,%llu,%s,%d,%d,%d,%lld,%lld,%lld,%lld,%d,%d,%lld,%s\\n\",param_2[6],\n               param_2[7],*(undefined8 *)*param_2,*(undefined4 *)(param_2 + 8),\n               *(byte *)(param_2 + 0xb) & 1 ^ 1,(int)*(char *)((long)param_2 + 0x49),param_2[1],\n               param_2[2],param_2[4] - param_2[3],param_2[5],(int)*(char *)(param_2 + 9),\n               *(undefined4 *)((long)param_2 + 0x44),param_2[0xc],param_2[10]);\n  return 0;\n}\n\n",
        "output": "The predicted function name is print_csv_entry"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,long param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  if (*(long *)(param_2 + 0x220) == 0) {\n    uVar2 = 1;\n  }\n  else {\n    iVar1 = FUN_000146a7(\"test/ssl_test.c\",0x15d,\"result->cipher\",*(undefined8 *)(param_1 + 0x98));\n    if (iVar1 == 0) {\n      uVar2 = 0;\n    }\n    else {\n      iVar1 = FUN_000147f4(\"test/ssl_test.c\",0x160,\"test_ctx->expected_cipher\",\"result->cipher\",\n                           *(undefined8 *)(param_2 + 0x220),*(undefined8 *)(param_1 + 0x98));\n      if (iVar1 == 0) {\n        uVar2 = 0;\n      }\n      else {\n        uVar2 = 1;\n      }\n    }\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is check_cipher"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  mu_sieve_log_action(param_1,\"VACATION\",0);\n  mu_sieve_is_dry_run(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is diag"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  char cVar1;\n  int iVar2;\n  \n  FUN_00002c45(param_2);\n  if ((*(int *)(param_1 + 4) < 0) || (0 < *(int *)(param_1 + 4))) {\n    FUN_0000349a(param_1,param_2);\n    iVar2 = __gmpz_cmp_ui(param_1,1);\n    if (iVar2 != 0) {\n      if (DAT_00215110 != '\\0') {\n        fwrite(\"[is number prime?] \",1,0x13,stderr);\n      }\n      cVar1 = FUN_00004f21(param_1);\n      if (cVar1 == '\\0') {\n        FUN_00006488(param_1,1,param_2);\n      }\n      else {\n        FUN_00002cd7(param_2,param_1);\n      }\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is mp_factor"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](char *param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  iVar1 = strcasecmp(param_1,\"rel\");\n  if (iVar1 == 0) {\n    uVar2 = 1;\n  }\n  else {\n    iVar1 = strcasecmp(param_1,\"exec\");\n    if (iVar1 == 0) {\n      uVar2 = 2;\n    }\n    else {\n      iVar1 = strcasecmp(param_1,\"dyn\");\n      if (iVar1 == 0) {\n        uVar2 = 3;\n      }\n      else {\n        iVar1 = strcasecmp(param_1,\"none\");\n        if (iVar1 == 0) {\n          uVar2 = 0;\n        }\n        else {\n          uVar2 = gettext(\"Unknown type: %s\\n\");\n          error(uVar2,param_1);\n          uVar2 = 0xffffffff;\n        }\n      }\n    }\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is elf_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1)\n\n{\n  return *(int *)(param_1 + 4) - 2U < 2;\n}\n\n",
        "output": "The predicted function name is renegotiate_op"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  int iVar3;\n  undefined4 uVar4;\n  uint uVar5;\n  Elf64_Phdr *pEVar6;\n  undefined8 uVar7;\n  long in_FS_OFFSET;\n  undefined8 uVar8;\n  undefined8 local_f8;\n  undefined8 local_f0;\n  undefined8 local_e8;\n  undefined8 local_e0;\n  undefined8 local_d8;\n  long local_c0;\n  uint local_b0;\n  uint local_ac;\n  undefined8 local_a8;\n  uchar *local_a0;\n  EVP_MD **local_98;\n  EVP_MD_CTX *local_90;\n  EVP_MD_CTX *local_88;\n  undefined8 *local_80;\n  undefined8 local_78;\n  undefined8 local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined4 local_26;\n  undefined2 local_22;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_98 = *(EVP_MD ***)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  local_a0 = (uchar *)0x0;\n  local_a8 = 0;\n  local_ac = 0;\n  *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"TEST_FAILURE\";\n  local_c0 = param_1;\n  local_90 = (EVP_MD_CTX *)EVP_MD_CTX_new();\n  iVar3 = FUN_00018f92(\"test/evp_test.c\",0x19a,\"mctx = EVP_MD_CTX_new()\",local_90);\n  if (iVar3 != 0) {\n    pEVar6 = (Elf64_Phdr *)local_98[4];\n    if (pEVar6 < Elf64_Phdr_ARRAY_00000040) {\n      pEVar6 = Elf64_Phdr_ARRAY_00000040;\n    }\n    local_a0 = (uchar *)CRYPTO_malloc((int)pEVar6,\"test/evp_test.c\",0x19e);\n    iVar3 = FUN_00018f92(\"test/evp_test.c\",0x19f,&DAT_0001c568,local_a0);\n    if (iVar3 != 0) {\n      iVar3 = EVP_DigestInit_ex(local_90,*local_98,(ENGINE *)0x0);\n      if (iVar3 == 0) {\n        *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + local_c0 + 0x17) = \"DIGESTINIT_ERROR\";\n      }\n      else {\n        if (0 < *(int *)(local_98 + 5)) {\n          OSSL_PARAM_construct_int(&local_f8,\"pad-type\",local_98 + 5);\n          local_78 = local_f8;\n          local_70 = local_f0;\n          local_68 = local_e8;\n          local_60 = local_e0;\n          local_58 = local_d8;\n          OSSL_PARAM_construct_end(&local_f8);\n          local_50 = local_f8;\n          local_48 = local_f0;\n          local_40 = local_e8;\n          local_38 = local_e0;\n          local_30 = local_d8;\n          uVar4 = EVP_MD_CTX_set_params(local_90,&local_78);\n          iVar3 = FUN_0001774f(\"test/evp_test.c\",0x1aa,\"EVP_MD_CTX_set_params(mctx, params)\",\n                               &DAT_0001c72b,uVar4,0);\n          if (iVar3 == 0) {\n            *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + local_c0 + 0x17) = \"PARAMS_ERROR\";\n            goto LAB_00007263;\n          }\n        }\n        iVar3 = FUN_000064e0(local_98[2],FUN_00006ba2,local_90);\n        if (iVar3 == 0) {\n          *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + local_c0 + 0x17) = \"DIGESTUPDATE_ERROR\";\n        }\n        else {\n          uVar5 = EVP_MD_get_flags(*local_98);\n          local_ac = (uint)((uVar5 & 2) != 0);\n          if (local_ac == 0) {\n            iVar3 = EVP_DigestFinal(local_90,local_a0,&local_b0);\n            if (iVar3 == 0) {\n              *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + local_c0 + 0x17) = \"DIGESTFINAL_ERROR\";\n              goto LAB_00007263;\n            }\n          }\n          else {\n            local_26 = 0x63756f74;\n            local_22 = 0x68;\n            local_88 = (EVP_MD_CTX *)EVP_MD_CTX_new();\n            iVar3 = FUN_00018f92(\"test/evp_test.c\",0x1b9,\"mctx_cpy = EVP_MD_CTX_new()\",local_88);\n            if (iVar3 == 0) goto LAB_00007263;\n            iVar3 = EVP_MD_CTX_copy(local_88,local_90);\n            if (iVar3 == 0) {\n              EVP_MD_CTX_free(local_88);\n              goto LAB_00007263;\n            }\n            iVar3 = EVP_DigestFinalXOF(local_88,&local_26,0);\n            if (iVar3 == 0) {\n              EVP_MD_CTX_free(local_88);\n              *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + local_c0 + 0x17) = \"DIGESTFINALXOF_ERROR\"\n              ;\n              goto LAB_00007263;\n            }\n            iVar3 = FUN_000190df(\"test/evp_test.c\",0x1c5,&DAT_0001c7b3,\"\\\"touch\\\"\",&local_26,\"touch\"\n                                );\n            if (iVar3 == 0) {\n              EVP_MD_CTX_free(local_88);\n              *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + local_c0 + 0x17) = \"DIGESTFINALXOF_ERROR\"\n              ;\n              goto LAB_00007263;\n            }\n            EVP_MD_CTX_free(local_88);\n            local_b0 = (uint)local_98[4];\n            iVar3 = EVP_DigestFinalXOF(local_90,local_a0,(ulong)local_98[4] & 0xffffffff);\n            if (iVar3 == 0) {\n              *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + local_c0 + 0x17) = \"DIGESTFINALXOF_ERROR\"\n              ;\n              goto LAB_00007263;\n            }\n          }\n          iVar3 = FUN_00017553(\"test/evp_test.c\",0x1d7,\"expected->output_len\",\"got_len\",\n                               (ulong)local_98[4] & 0xffffffff,local_b0);\n          if (iVar3 == 0) {\n            *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + local_c0 + 0x17) = \"DIGEST_LENGTH_MISMATCH\"\n            ;\n          }\n          else {\n            iVar3 = FUN_000060ba(local_c0,\"DIGEST_MISMATCH\",local_98[3],local_98[4],local_a0,\n                                 local_b0);\n            if (iVar3 != 0) {\n              *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + local_c0 + 0x17) = 0;\n              iVar3 = FUN_00006028(local_98[2]);\n              if ((iVar3 == 1) && (local_ac == 0)) {\n                local_80 = (undefined8 *)FUN_00006042(local_98[2],0);\n                iVar3 = FUN_00018f92(\"test/evp_test.c\",0x1e6,\n                                     \"inbuf = sk_EVP_TEST_BUFFER_value(expected->input, 0)\",local_80\n                                    );\n                if ((iVar3 == 0) && (*(int *)(local_80 + 3) == 0)) {\n                  OPENSSL_cleanse(local_a0,(ulong)local_b0);\n                  uVar1 = local_80[1];\n                  uVar2 = *local_80;\n                  uVar8 = 0x718f;\n                  uVar7 = EVP_MD_get0_name(local_98[1]);\n                  iVar3 = EVP_Q_digest(DAT_002241a8,uVar7,0,uVar2,uVar1,local_a0,&local_a8,uVar8);\n                  iVar3 = FUN_00019007(\"test/evp_test.c\",0x1ec,\n                                       \"EVP_Q_digest(libctx, EVP_MD_get0_name(expected->fetched_digest), NULL, inbuf->buf, inbuf->buflen, got, &size)\"\n                                       ,iVar3 != 0);\n                  if ((iVar3 == 0) ||\n                     (iVar3 = FUN_000194c5(\"test/evp_test.c\",0x1ee,&DAT_0001c568,\"expected->output\",\n                                           local_a0,local_a8,local_98[3],local_98[4]), iVar3 == 0))\n                  {\n                    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + local_c0 + 0x17) =\n                         \"EVP_Q_digest failed\";\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_00007263:\n  CRYPTO_free(local_a0);\n  EVP_MD_CTX_free(local_90);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is digest_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\ncode * [MASK](char *param_1)\n\n{\n  int iVar1;\n  code *local_10;\n  \n  local_10 = (code *)0x0;\n  iVar1 = strcasecmp(param_1,\"echo\");\n  if (iVar1 == 0) {\n    local_10 = FUN_00004663;\n  }\n  else {\n    iVar1 = strcasecmp(param_1,\"timestamp\");\n    if (iVar1 == 0) {\n      local_10 = FUN_00005c49;\n    }\n    else {\n      iVar1 = strcasecmp(param_1,\"address\");\n      if (iVar1 == 0) {\n        local_10 = FUN_00005a10;\n      }\n      else {\n        iVar1 = strcasecmp(param_1,\"mask\");\n        if (iVar1 == 0) {\n          local_10 = FUN_00005a10;\n        }\n        else {\n          error(1,0,\"unsupported packet type: %s\",param_1);\n        }\n      }\n    }\n  }\n  return local_10;\n}\n\n",
        "output": "The predicted function name is decode_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](ENGINE *param_1)\n\n{\n  int iVar1;\n  \n  DAT_00205350 = EVP_PKEY_meth_find(6);\n  if ((DAT_00205350 == (EVP_PKEY_METHOD *)0x0) ||\n     (DAT_00205348 = EVP_PKEY_meth_new(6,2), DAT_00205348 == (EVP_PKEY_METHOD *)0x0)) {\n    return 0;\n  }\n  EVP_PKEY_meth_set_init(DAT_00205348,FUN_0000386e);\n  EVP_PKEY_meth_set_cleanup(DAT_00205348,FUN_000038ae);\n  EVP_PKEY_meth_set_paramgen(DAT_00205348,FUN_000038ef,FUN_00003947);\n  EVP_PKEY_meth_set_keygen(DAT_00205348,FUN_000039aa,FUN_00003a02);\n  EVP_PKEY_meth_set_encrypt(DAT_00205348,FUN_00003a52,FUN_00003aaa);\n  EVP_PKEY_meth_set_decrypt(DAT_00205348,FUN_00003b0c,FUN_00003b64);\n  EVP_PKEY_meth_set_ctrl(DAT_00205348,FUN_00003bc6,FUN_00003c1c);\n  FUN_0000239a();\n  iVar1 = ENGINE_set_id(param_1,PTR_s_dasync_00205320);\n  if ((((iVar1 != 0) &&\n       (((iVar1 = ENGINE_set_name(param_1,PTR_s_Dummy_Async_engine_support_00205328), iVar1 != 0 &&\n         (iVar1 = ENGINE_set_pkey_meths(param_1,FUN_00002c82), iVar1 != 0)) &&\n        (iVar1 = ENGINE_set_digests(param_1,FUN_00002cde), iVar1 != 0)))) &&\n      (((iVar1 = ENGINE_set_ciphers(param_1,FUN_00002d42), iVar1 != 0 &&\n        (iVar1 = ENGINE_set_destroy_function(param_1,FUN_00002c5b), iVar1 != 0)) &&\n       (iVar1 = ENGINE_set_init_function(param_1,FUN_00002c3d), iVar1 != 0)))) &&\n     (iVar1 = ENGINE_set_finish_function(param_1,FUN_00002c4c), iVar1 != 0)) {\n    DAT_00205340 = EVP_MD_meth_new(0x40,0x41);\n    if (((DAT_00205340 == 0) || (iVar1 = EVP_MD_meth_set_result_size(DAT_00205340,0x14), iVar1 == 0)\n        ) || ((iVar1 = EVP_MD_meth_set_input_blocksize(DAT_00205340,0x40), iVar1 == 0 ||\n              ((((iVar1 = EVP_MD_meth_set_app_datasize(DAT_00205340,0x68), iVar1 == 0 ||\n                 (iVar1 = EVP_MD_meth_set_flags(DAT_00205340,8), iVar1 == 0)) ||\n                (iVar1 = EVP_MD_meth_set_init(DAT_00205340,FUN_00002fc5), iVar1 == 0)) ||\n               ((iVar1 = EVP_MD_meth_set_update(DAT_00205340,FUN_00002ff1), iVar1 == 0 ||\n                (iVar1 = EVP_MD_meth_set_final(DAT_00205340,FUN_00003031), iVar1 == 0)))))))) {\n      EVP_MD_meth_free(DAT_00205340);\n      DAT_00205340 = 0;\n    }\n    DAT_00205358 = EVP_CIPHER_meth_new(0x1a3,0x10,0x10);\n    if (((DAT_00205358 == 0) ||\n        (iVar1 = EVP_CIPHER_meth_set_iv_length(DAT_00205358,0x10), iVar1 == 0)) ||\n       (((iVar1 = EVP_CIPHER_meth_set_flags(DAT_00205358,0x800402), iVar1 == 0 ||\n         (((iVar1 = EVP_CIPHER_meth_set_init(DAT_00205358,FUN_000036f5), iVar1 == 0 ||\n           (iVar1 = EVP_CIPHER_meth_set_do_cipher(DAT_00205358,FUN_00003730), iVar1 == 0)) ||\n          (iVar1 = EVP_CIPHER_meth_set_cleanup(DAT_00205358,FUN_0000376d), iVar1 == 0)))) ||\n        ((iVar1 = EVP_CIPHER_meth_set_ctrl(DAT_00205358,FUN_000036b6), iVar1 == 0 ||\n         (iVar1 = EVP_CIPHER_meth_set_impl_ctx_size(DAT_00205358,0x1d0), iVar1 == 0)))))) {\n      EVP_CIPHER_meth_free(DAT_00205358);\n      DAT_00205358 = 0;\n    }\n    DAT_00205360 = EVP_CIPHER_meth_new(0x394,0x10,0x10);\n    if ((((DAT_00205360 == 0) ||\n         (iVar1 = EVP_CIPHER_meth_set_iv_length(DAT_00205360,0x10), iVar1 == 0)) ||\n        ((iVar1 = EVP_CIPHER_meth_set_flags(DAT_00205360,0xa00402), iVar1 == 0 ||\n         (((iVar1 = EVP_CIPHER_meth_set_init(DAT_00205360,FUN_000037d1), iVar1 == 0 ||\n           (iVar1 = EVP_CIPHER_meth_set_do_cipher(DAT_00205360,FUN_0000380c), iVar1 == 0)) ||\n          (iVar1 = EVP_CIPHER_meth_set_cleanup(DAT_00205360,FUN_00003849), iVar1 == 0)))))) ||\n       ((iVar1 = EVP_CIPHER_meth_set_ctrl(DAT_00205360,FUN_00003792), iVar1 == 0 ||\n        (iVar1 = EVP_CIPHER_meth_set_impl_ctx_size(DAT_00205360,0x1d0), iVar1 == 0)))) {\n      EVP_CIPHER_meth_free(DAT_00205360);\n      DAT_00205360 = 0;\n    }\n    return 1;\n  }\n  FUN_00002411(0,100,\"engines/e_dasync.c\",0xf1);\n  return 0;\n}\n\n",
        "output": "The predicted function name is bind_dasync"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return DAT_00205358;\n}\n\n",
        "output": "The predicted function name is dasync_aes_128_cbc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined4 param_1)\n\n{\n  FUN_00009e5e(&PTR_s_Ignore_0021f060,3,param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is ssl_session_ticket_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,char *param_3)\n\n{\n  code *pcVar1;\n  undefined8 uVar2;\n  size_t sVar3;\n  undefined8 uVar4;\n  long in_FS_OFFSET;\n  undefined local_68 [32];\n  undefined local_48 [40];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  pcVar1 = *(code **)(DAT_00202178 + 0xe8);\n  uVar2 = FUN_00000c70(param_1,local_48);\n  sVar3 = strlen(param_3);\n  uVar4 = FUN_00000c1f(DAT_00202178,DAT_00202180,param_3,sVar3,1,local_68);\n  (*pcVar1)(DAT_00202180,param_2,uVar4,uVar2);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is array_set_numeric"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,long param_2,undefined8 param_3)\n\n{\n  char cVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  undefined8 uVar3;\n  ulong local_90;\n  ulong local_88;\n  ulong local_80;\n  undefined local_78 [16];\n  undefined local_68 [16];\n  undefined local_58 [16];\n  undefined local_48 [16];\n  undefined local_38 [16];\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_00215110 != '\\0') {\n    fprintf(stderr,\"[pollard-rho (%lu)] \",param_2);\n  }\n  __gmpz_inits(local_38,local_28,0);\n  __gmpz_init_set_si(local_58,2);\n  __gmpz_init_set_si(local_78,2);\n  __gmpz_init_set_si(local_68,2);\n  __gmpz_init_set_ui(local_48,1);\n  local_90 = 1;\n  local_88 = 1;\nLAB_000068a4:\n  uVar3 = 0x68b8;\n  iVar2 = __gmpz_cmp_ui(param_1,1);\n  if (iVar2 != 0) {\nLAB_0000655d:\n    __gmpz_mul(local_38,local_78,local_78);\n    __gmpz_mod(local_78,local_38,param_1);\n    __gmpz_add_ui(local_78,local_78,param_2);\n    __gmpz_sub(local_38,local_68,local_78);\n    __gmpz_mul(local_28,local_48,local_38);\n    __gmpz_mod(local_48,local_28,param_1);\n    if (((uint)local_90 & 0x1f) == 1) {\n      __gmpz_gcd(local_38,local_48,param_1);\n      iVar2 = __gmpz_cmp_ui(local_38,1);\n      if (iVar2 != 0) goto LAB_000066ff;\n      __gmpz_set(local_58,local_78);\n    }\n    local_90 = local_90 - 1;\n    if (local_90 == 0) {\n      __gmpz_set(local_68,local_78);\n      local_90 = local_88;\n      for (local_80 = 0; local_80 < local_88; local_80 = local_80 + 1) {\n        __gmpz_mul(local_38,local_78,local_78);\n        __gmpz_mod(local_78,local_38,param_1);\n        __gmpz_add_ui(local_78,local_78,param_2);\n      }\n      __gmpz_set(local_58,local_78);\n      local_88 = local_88 << 1;\n    }\n    goto LAB_0000655d;\n  }\nLAB_000068c0:\n  __gmpz_clears(local_48,local_28,local_38,local_68,local_78,local_58,0,uVar3);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\nLAB_000066ff:\n  do {\n    __gmpz_mul(local_38,local_58,local_58);\n    __gmpz_mod(local_58,local_38,param_1);\n    __gmpz_add_ui(local_58,local_58,param_2);\n    __gmpz_sub(local_38,local_68,local_58);\n    __gmpz_gcd(local_38,local_38,param_1);\n    iVar2 = __gmpz_cmp_ui(local_38,1);\n  } while (iVar2 == 0);\n  __gmpz_divexact(param_1,param_1,local_38);\n  cVar1 = FUN_00004f21(local_38);\n  if (cVar1 == '\\x01') {\n    FUN_00002cd7(param_3,local_38);\n  }\n  else {\n    if (DAT_00215110 != '\\0') {\n      fwrite(\"[composite factor--restarting pollard-rho] \",1,0x2b,stderr);\n    }\n    FUN_00006488(local_38,param_2 + 1,param_3);\n  }\n  cVar1 = FUN_00004f21(param_1);\n  if (cVar1 != '\\0') {\n    uVar3 = 0x6854;\n    FUN_00002cd7(param_3,param_1);\n    goto LAB_000068c0;\n  }\n  __gmpz_mod(local_78,local_78,param_1);\n  __gmpz_mod(local_68,local_68,param_1);\n  __gmpz_mod(local_58,local_58,param_1);\n  goto LAB_000068a4;\n}\n\n",
        "output": "The predicted function name is mp_factor_using_pollard_rho"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  int iVar3;\n  undefined4 uVar4;\n  long in_FS_OFFSET;\n  undefined8 local_178;\n  undefined8 local_170;\n  undefined8 local_168;\n  undefined8 local_160;\n  undefined8 local_158;\n  undefined4 local_13c;\n  undefined8 *local_138;\n  undefined8 local_130;\n  undefined8 local_128;\n  undefined8 uStack288;\n  undefined8 uStack280;\n  undefined8 uStack272;\n  undefined8 uStack264;\n  undefined8 auStack256 [25];\n  undefined local_38 [24];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_138 = auStack256;\n  OSSL_PARAM_construct_utf8_string(&local_178,&DAT_000141e1,&DAT_00014269,0);\n  puVar2 = local_138;\n  local_128 = local_178;\n  uStack288 = local_170;\n  uStack280 = local_168;\n  uStack272 = local_160;\n  uStack264 = local_158;\n  local_138 = local_138 + 5;\n  OSSL_PARAM_construct_utf8_string(&local_178,\"digest\",\"sha256\",0);\n  uVar1 = local_170;\n  *puVar2 = local_178;\n  puVar2[1] = uVar1;\n  uVar1 = local_160;\n  puVar2[2] = local_168;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_158;\n  puVar2 = local_138;\n  local_138 = local_138 + 5;\n  OSSL_PARAM_construct_octet_string(&local_178,&DAT_00013cfa,&DAT_002192f0,0xe);\n  uVar1 = local_170;\n  *puVar2 = local_178;\n  puVar2[1] = uVar1;\n  uVar1 = local_160;\n  puVar2[2] = local_168;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_158;\n  puVar2 = local_138;\n  local_138 = local_138 + 5;\n  OSSL_PARAM_construct_octet_string(&local_178,&DAT_00013cfe,&DAT_00219300,0xc);\n  uVar1 = local_170;\n  *puVar2 = local_178;\n  puVar2[1] = uVar1;\n  uVar1 = local_160;\n  puVar2[2] = local_168;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_158;\n  puVar2 = local_138;\n  local_138 = local_138 + 5;\n  OSSL_PARAM_construct_octet_string(&local_178,&DAT_00013cf5,&DAT_00219310,0x10);\n  uVar1 = local_170;\n  *puVar2 = local_178;\n  puVar2[1] = uVar1;\n  uVar1 = local_160;\n  puVar2[2] = local_168;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_158;\n  puVar2 = local_138;\n  OSSL_PARAM_construct_end(&local_178);\n  *puVar2 = local_178;\n  puVar2[1] = local_170;\n  puVar2[2] = local_168;\n  puVar2[3] = local_160;\n  puVar2[4] = local_158;\n  local_130 = FUN_00002d68(\"SSKDF\");\n  iVar3 = FUN_0000e315(\"test/evp_kdf_test.c\",0x56e,\"kctx = get_kdfbyname(OSSL_KDF_NAME_SSKDF)\",\n                       local_130);\n  if (iVar3 != 0) {\n    uVar4 = EVP_KDF_derive(local_130,local_38,0x10,&local_128);\n    iVar3 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x56f,\n                         \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar4,0);\n    if (iVar3 != 0) {\n      iVar3 = FUN_0000e848(\"test/evp_kdf_test.c\",0x570,&DAT_00013c68,\"expected\",local_38,0x10,\n                           &DAT_00014bb0,0x10);\n      if (iVar3 != 0) {\n        local_13c = 1;\n        goto LAB_000091bd;\n      }\n    }\n  }\n  local_13c = 0;\nLAB_000091bd:\n  EVP_KDF_CTX_free(local_130);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_13c;\n}\n\n",
        "output": "The predicted function name is test_kdf_ss_hmac"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 *param_2,undefined8 param_3)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  lVar1 = FUN_00001b00(*param_2);\n  if (lVar1 == 0) {\n    if (param_2[2] == 0) {\n      uVar2 = 0;\n    }\n    else {\n      uVar2 = FUN_00002fe2(param_1,param_2,param_3);\n    }\n  }\n  else {\n    uVar2 = FUN_00002f50(param_1,lVar1,param_3);\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is outline_match"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](int param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  char *pcVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  long lVar6;\n  undefined4 local_44;\n  undefined8 local_40;\n  EVP_PKEY *local_38;\n  undefined8 local_30;\n  \n  local_40 = 0;\n  local_44 = 0;\n  local_38 = (EVP_PKEY *)0x0;\n  local_30 = 0;\n  if (param_1 == 0) {\n    pcVar3 = \"?provider=fake-rsa\";\n  }\n  else {\n    pcVar3 = \"?provider=default\";\n  }\n  uVar4 = OSSL_PROVIDER_load(DAT_002130d0,\"default\");\n  iVar1 = FUN_0000879a(\"test/provider_pkey_test.c\",0xc0,\n                       \"deflt = OSSL_PROVIDER_load(libctx, \\\"default\\\")\",uVar4);\n  if (iVar1 != 0) {\n    local_40 = FUN_00003dc0(DAT_002130d0);\n    iVar1 = FUN_0000879a(\"test/provider_pkey_test.c\",0xc3,\"fake_rsa = fake_rsa_start(libctx)\",\n                         local_40);\n    if (iVar1 != 0) {\n      uVar5 = OSSL_STORE_LOADER_fetch(DAT_002130d0,\"fake_rsa\",pcVar3);\n      iVar1 = FUN_0000879a(\"test/provider_pkey_test.c\",199,\n                           \"loader = OSSL_STORE_LOADER_fetch(libctx, \\\"fake_rsa\\\", propq)\",uVar5);\n      if (iVar1 != 0) {\n        OSSL_STORE_LOADER_free(uVar5);\n        local_30 = OSSL_STORE_open_ex(\"fake_rsa:test\",DAT_002130d0,pcVar3,0,0,0,0,0);\n        iVar1 = FUN_0000879a(\"test/provider_pkey_test.c\",0xcd,\n                             \"ctx = OSSL_STORE_open_ex(\\\"fake_rsa:test\\\", libctx, propq, NULL, NULL, NULL, NULL, NULL)\"\n                             ,local_30);\n        if (iVar1 != 0) {\n          while (((iVar1 = OSSL_STORE_eof(local_30), iVar1 == 0 &&\n                  (lVar6 = OSSL_STORE_load(local_30), lVar6 != 0)) && (local_38 == (EVP_PKEY *)0x0))\n                ) {\n            iVar1 = OSSL_STORE_INFO_get_type(lVar6);\n            if (iVar1 == 4) {\n              local_38 = (EVP_PKEY *)OSSL_STORE_INFO_get1_PKEY(lVar6);\n            }\n            OSSL_STORE_INFO_free(lVar6);\n          }\n          iVar1 = FUN_0000879a(\"test/provider_pkey_test.c\",0xd9,&DAT_0000e59e,local_38);\n          if (iVar1 != 0) {\n            uVar2 = EVP_PKEY_is_a(local_38,&DAT_0000e368);\n            iVar1 = FUN_00006d5b(\"test/provider_pkey_test.c\",0xd9,\"EVP_PKEY_is_a(pkey, \\\"RSA\\\")\",\n                                 &DAT_0000e5fc,uVar2,1);\n            if (iVar1 != 0) {\n              local_44 = 1;\n            }\n          }\n        }\n      }\n    }\n  }\n  FUN_00003e58(local_40);\n  OSSL_PROVIDER_unload(uVar4);\n  OSSL_STORE_close(local_30);\n  EVP_PKEY_free(local_38);\n  return local_44;\n}\n\n",
        "output": "The predicted function name is test_pkey_store"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  long lVar1;\n  \n  lVar1 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  CRYPTO_free(*(void **)(lVar1 + 0x38));\n  CRYPTO_free(*(void **)(lVar1 + 0x48));\n  CRYPTO_free(*(void **)(lVar1 + 0x58));\n  return;\n}\n\n",
        "output": "The predicted function name is pbe_test_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  BIO_METHOD *pBVar2;\n  BIO *bp;\n  ASN1_ITEM *it;\n  long in_FS_OFFSET;\n  undefined4 local_54;\n  BIO *local_50;\n  PKCS7 *local_48;\n  undefined8 local_38;\n  char *local_30;\n  undefined8 local_28;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_54 = 0;\n  local_50 = (BIO *)0x0;\n  local_48 = (PKCS7 *)0x0;\n  pBVar2 = BIO_s_mem();\n  bp = BIO_new(pBVar2);\n  iVar1 = FUN_000078e9(\"test/bio_memleak_test.c\",0xf5,\"bio = BIO_new(BIO_s_mem())\",bp);\n  if (iVar1 != 0) {\n    local_38 = 0xf;\n    local_30 = \"BIO mime test\\n\";\n    local_28 = 0xf;\n    BIO_ctrl(bp,0x72,0,&local_38);\n    BIO_set_flags(bp,0x200);\n    BIO_set_callback_ex(bp,FUN_00003815);\n    pBVar2 = BIO_s_mem();\n    local_50 = BIO_new(pBVar2);\n    iVar1 = FUN_000078e9(\"test/bio_memleak_test.c\",0xff,\"out = BIO_new(BIO_s_mem())\",local_50);\n    if (iVar1 != 0) {\n      local_48 = PKCS7_new();\n      iVar1 = FUN_000078e9(\"test/bio_memleak_test.c\",0x101,\"p7 = PKCS7_new()\",local_48);\n      if (iVar1 != 0) {\n        iVar1 = PKCS7_set_type(local_48,0x15);\n        iVar1 = FUN_0000795e(\"test/bio_memleak_test.c\",0x103,\"PKCS7_set_type(p7, NID_pkcs7_data)\",\n                             iVar1 != 0);\n        if (iVar1 != 0) {\n          DAT_002110c4 = 0;\n          it = (ASN1_ITEM *)PKCS7_it();\n          iVar1 = i2d_ASN1_bio_stream(local_50,(ASN1_VALUE *)local_48,bp,0x1080,it);\n          iVar1 = FUN_0000795e(\"test/bio_memleak_test.c\",0x10e,\n                               \"i2d_ASN1_bio_stream(out, (ASN1_VALUE*) p7, bio, SMIME_STREAM | SMIME_BINARY, ASN1_ITEM_rptr(PKCS7))\"\n                               ,iVar1 != 0);\n          if ((iVar1 != 0) &&\n             (iVar1 = FUN_00005eaa(\"test/bio_memleak_test.c\",0x111,\"error_callback_fired\",\n                                   &DAT_0000d347,DAT_002110c4,1), iVar1 != 0)) {\n            local_54 = 1;\n          }\n        }\n      }\n    }\n  }\n  BIO_free(bp);\n  BIO_free(local_50);\n  PKCS7_free(local_48);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_54;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_bio_i2d_ASN1_mime"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,undefined param_2)\n\n{\n  **(undefined **)(param_1 + 0x18) = param_2;\n  return *(undefined8 *)(param_1 + 0x10);\n}\n\n",
        "output": "The predicted function name is gcide_template_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined *param_1,undefined8 param_2)\n\n{\n  FUN_00004c6b(*param_1,param_1[1],param_2);\n  if ((DAT_00214a48 & 0x20) != 0) {\n    FUN_00004f47(param_1,0);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is print_icmp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void *param_1)\n\n{\n  CRYPTO_free(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is fake_rsa_keymgmt_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](void)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined *local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = &DAT_00211014;\n  local_18 = FUN_00002f25(0,&local_20,5);\n  iVar1 = FUN_00006efe(\"test/asn1_decode_test.c\",0xc0,&DAT_0000c841,local_18);\n  if (iVar1 == 0) {\n    FUN_00002f97(local_18);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1 != 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_invalid_template"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  wget_thread_mutex_init(&DAT_00253c68);\n  DAT_00253c60 = wget_vector_create(8,0);\n  wget_vector_set_destructor(DAT_00253c60,FUN_000125fa);\n  DAT_00253c78 = param_1;\n  return;\n}\n\n",
        "output": "The predicted function name is site_stats_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](int param_1)\n\n{\n  int iVar1;\n  BIO_METHOD *pBVar2;\n  BIO *b;\n  BIO *a;\n  BIO *a_00;\n  BIO *bp;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  undefined8 uVar4;\n  undefined4 local_8c;\n  X509 *local_88;\n  BIO *local_58;\n  undefined local_50;\n  undefined4 local_4c;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined2 local_30;\n  undefined local_2e;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_88 = (X509 *)0x0;\n  pBVar2 = BIO_s_mem();\n  b = BIO_new(pBVar2);\n  pBVar2 = BIO_s_mem();\n  a = BIO_new(pBVar2);\n  local_58 = (BIO *)0x0;\n  local_50 = 0x30;\n  local_4c = 0;\n  a_00 = (BIO *)ASN1_item_i2d_mem_bio(DAT_002130e8,DAT_002130f0);\n  local_48 = 0x746163696c707061;\n  local_40 = 0x35782d782f6e6f69;\n  local_38 = 0x65632d61632d3930;\n  local_30 = 0x7472;\n  local_2e = 0;\n  local_8c = 0;\n  if (((b != (BIO *)0x0) && (a != (BIO *)0x0)) && (a_00 != (BIO *)0x0)) {\n    local_58 = a;\n    BIO_set_callback_ex(b,FUN_00003386);\n    uVar4 = 0x3517;\n    BIO_set_callback_arg(b,(char *)&local_58);\n    if (param_1 == 0) {\n      bp = (BIO *)OSSL_HTTP_transfer(0,0,0,\"/path/result.crt\",0,0,0,b,a,0,0,0,0,&local_48,a_00,\n                                     &local_48,1,0x19000,0,0);\n    }\n    else {\n      bp = (BIO *)OSSL_HTTP_get(\"/will-be-redirected\",0,0,b,a,0,0,0,0,&local_48,1,0x19000,0,uVar4);\n    }\n    local_88 = d2i_X509_bio(bp,(X509 **)0x0);\n    BIO_free(bp);\n    iVar1 = FUN_0000a974(\"test/http_test.c\",0x92,\"rcert\",local_88);\n    if (iVar1 != 0) {\n      iVar1 = X509_cmp(DAT_002130f0,local_88);\n      iVar1 = FUN_00008f35(\"test/http_test.c\",0x92,\"X509_cmp(x509, rcert)\",&DAT_0000e0b3,iVar1,0);\n      if (iVar1 != 0) {\n        local_8c = 1;\n        goto LAB_0000365c;\n      }\n    }\n    local_8c = 0;\n  }\nLAB_0000365c:\n  X509_free(local_88);\n  BIO_free(a_00);\n  BIO_free(b);\n  BIO_free(a);\n  uVar4 = FUN_00002ee8(PTR_X509V3_conf_free_00212fd0);\n  uVar3 = FUN_00002eda(0);\n  OPENSSL_sk_pop_free(uVar3,uVar4);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_8c;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_http_x509"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00003658(param_1,0x30,\"dummy@example.com\",0x30,param_2,0);\n  return;\n}\n\n",
        "output": "The predicted function name is set_email2"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (DAT_002053a8 == (code *)0x0) {\n    EVP_PKEY_meth_get_encrypt(DAT_00205350,&DAT_002053a8,0);\n  }\n  if (DAT_002053a8 == (code *)0x0) {\n    uVar1 = 1;\n  }\n  else {\n    uVar1 = (*DAT_002053a8)(param_1);\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is dasync_rsa_encrypt_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  FUN_0000ae56(param_1 + 0x1f8,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is parse_expected_client_cert_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong [MASK](undefined8 param_1,ulong *param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  int iVar1;\n  ulong uVar2;\n  ulong local_20;\n  ulong local_18;\n  \n  local_20 = 0;\n  uVar2 = *param_2;\n  while( true ) {\n    do {\n      local_18 = uVar2;\n      if (local_18 <= local_20) {\n        return 0xffffffffffffffff;\n      }\n      uVar2 = local_18 + local_20 >> 1;\n      iVar1 = FUN_0000bf2c(param_1,param_3,param_2 + uVar2 * 7 + 7,param_4);\n    } while (iVar1 < 0);\n    if (iVar1 < 1) break;\n    local_20 = uVar2 + 1;\n    uVar2 = local_18;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is _idx_ref_locate"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,char *param_2,char *param_3,char *param_4,undefined8 param_5)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  int iVar3;\n  char *pcVar4;\n  long in_FS_OFFSET;\n  char *local_a8;\n  char *local_a0;\n  char local_78 [32];\n  char local_58 [72];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == 0) {\n    uVar1 = 0;\n  }\n  else {\n    uVar1 = *(undefined4 *)(param_1 + 0x90);\n  }\n  iVar2 = open(param_2,0);\n  if (iVar2 != -1) {\n    local_a8 = param_4;\n    if (param_4 == (char *)0x0) {\n      iVar3 = FUN_0001f4ae(\"user.mimetype\",local_58,0x40,iVar2);\n      if (iVar3 < 0) {\n        local_58[0] = '\\0';\n      }\n      else if (local_58[0] != '\\0') {\n        local_a8 = local_58;\n      }\n    }\n    local_a0 = param_3;\n    if (param_3 == (char *)0x0) {\n      iVar3 = FUN_0001f4ae(\"user.charset\",local_78,0x20,iVar2);\n      if (iVar3 < 0) {\n        local_78[0] = '\\0';\n      }\n      else if (local_78[0] != '\\0') {\n        local_a0 = local_78;\n      }\n    }\n    close(iVar2);\n    if (local_a8 == (char *)0x0) {\n      pcVar4 = strrchr(param_2,0x2e);\n      if (pcVar4 != (char *)0x0) {\n        iVar2 = wget_strcasecmp_ascii(pcVar4,\".html\");\n        if ((iVar2 == 0) || (iVar2 = wget_strcasecmp_ascii(pcVar4,&DAT_00041b66), iVar2 == 0)) {\n          FUN_0001ac47(param_1,uVar1,param_2,local_a0,param_5);\n        }\n        else {\n          iVar2 = wget_strcasecmp_ascii(pcVar4,&DAT_00041b6b);\n          if (iVar2 == 0) {\n            FUN_0001be54(param_1,param_2,local_a0,param_5);\n          }\n          else {\n            iVar2 = wget_strcasecmp_ascii(pcVar4,&DAT_00041b70);\n            if (iVar2 == 0) {\n              if (local_a0 == (char *)0x0) {\n                local_a0 = \"utf-8\";\n              }\n              FUN_0001b8b4(param_1,param_2,local_a0,param_5);\n            }\n          }\n        }\n      }\n    }\n    else {\n      iVar2 = wget_strcasecmp_ascii(local_a8,\"text/html\");\n      if ((iVar2 == 0) ||\n         (iVar2 = wget_strcasecmp_ascii(local_a8,\"application/xhtml+xml\"), iVar2 == 0)) {\n        FUN_0001ac47(param_1,uVar1,param_2,local_a0,param_5);\n      }\n      else {\n        iVar2 = wget_strcasecmp_ascii(local_a8,\"text/css\");\n        if (iVar2 == 0) {\n          FUN_0001be54(param_1,param_2,local_a0,param_5);\n        }\n        else {\n          iVar2 = wget_strcasecmp_ascii(local_a8,\"text/xml\");\n          if ((iVar2 == 0) ||\n             (iVar2 = wget_strcasecmp_ascii(local_a8,\"application/xml\"), iVar2 == 0)) {\n            if (local_a0 == (char *)0x0) {\n              local_a0 = \"utf-8\";\n            }\n            FUN_0001b1aa(param_1,param_2,local_a0,param_5);\n          }\n          else {\n            iVar2 = wget_strcasecmp_ascii(local_a8,\"application/atom+xml\");\n            if (iVar2 == 0) {\n              if (local_a0 == (char *)0x0) {\n                local_a0 = \"utf-8\";\n              }\n              FUN_0001b7d1(param_1,param_2,local_a0,param_5);\n            }\n            else {\n              iVar2 = wget_strcasecmp_ascii(local_a8,\"application/rss+xml\");\n              if (iVar2 == 0) {\n                if (local_a0 == (char *)0x0) {\n                  local_a0 = \"utf-8\";\n                }\n                FUN_0001b8b4(param_1,param_2,local_a0,param_5);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is parse_localfile"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  (**(code **)(DAT_00202118 + 0x38))(DAT_00202120,&PTR_s_readfile_002020c0);\n  return 1;\n}\n\n",
        "output": "The predicted function name is init_readfile"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](int param_1,int param_2)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  char *pcVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  long in_FS_OFFSET;\n  undefined8 local_d8;\n  undefined8 local_d0;\n  undefined8 local_c8;\n  undefined8 local_c0;\n  undefined8 local_b8;\n  int local_a0;\n  int local_9c;\n  undefined4 local_94;\n  undefined8 local_90;\n  undefined8 local_88;\n  void *local_80;\n  undefined8 local_78;\n  undefined8 local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_94 = 0;\n  local_90 = 0;\n  local_88 = 0;\n  if (param_1 == 0) {\n    pcVar4 = \"label\";\n  }\n  else {\n    pcVar4 = (char *)0x0;\n  }\n  if (param_2 == 0) {\n    pcVar3 = (char *)0x0;\n  }\n  else {\n    pcVar3 = \"sha256\";\n  }\n  local_a0 = param_2;\n  local_9c = param_1;\n  local_80 = (void *)FUN_000037e4(pcVar3,\"secret\",6,&DAT_00013cf5,pcVar4);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0xfe,\n                       \"params = construct_hkdf_params( has_digest ? \\\"sha256\\\" : NULL, \\\"secret\\\", 6, \\\"salt\\\", expand_only ? NULL : \\\"label\\\")\"\n                       ,local_80);\n  if (iVar1 != 0) {\n    local_88 = FUN_00002d68(&DAT_00013d1b);\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0xff,\"kctx = get_kdfbyname(OSSL_KDF_NAME_HKDF)\",\n                         local_88);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_88,local_80);\n      iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0x100,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        local_78 = EVP_KDF_CTX_gettable_params(local_88);\n        iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x104,\n                             \"gettables = EVP_KDF_CTX_gettable_params(kctx)\",local_78);\n        if (iVar1 != 0) {\n          local_70 = OSSL_PARAM_locate_const(local_78,&DAT_00013df6);\n          iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x105,\n                               \"p = OSSL_PARAM_locate_const(gettables, OSSL_KDF_PARAM_SIZE)\",\n                               local_70);\n          if (iVar1 != 0) {\n            OSSL_PARAM_construct_size_t(&local_d8,&DAT_00013df6,&local_90);\n            local_68 = local_d8;\n            local_60 = local_d0;\n            local_58 = local_c8;\n            local_50 = local_c0;\n            local_48 = local_b8;\n            OSSL_PARAM_construct_end(&local_d8);\n            local_40 = local_d8;\n            local_38 = local_d0;\n            local_30 = local_c8;\n            local_28 = local_c0;\n            local_20 = local_b8;\n            if (local_a0 == 0) {\n              uVar2 = EVP_KDF_CTX_get_params(local_88,&local_68);\n              iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x110,\n                                   \"EVP_KDF_CTX_get_params(kctx, params_get)\",&DAT_00013c2d,uVar2,0)\n              ;\n            }\n            else {\n              uVar2 = EVP_KDF_CTX_get_params(local_88,&local_68);\n              iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x10c,\n                                   \"EVP_KDF_CTX_get_params(kctx, params_get)\",&DAT_00013cc4,uVar2,1)\n              ;\n              if (iVar1 == 0) goto LAB_00003fb4;\n              if (local_9c == 0) {\n                uVar5 = 0xffffffffffffffff;\n              }\n              else {\n                uVar5 = 0x20;\n              }\n              iVar1 = FUN_0000db1e(\"test/evp_kdf_test.c\",0x10d,&DAT_00013e9e,\n                                   \"expand_only ? SHA256_DIGEST_LENGTH : SIZE_MAX\",local_90,uVar5);\n            }\n            if (iVar1 != 0) {\n              OSSL_PARAM_construct_end(&local_d8);\n              local_68 = local_d8;\n              local_60 = local_d0;\n              local_58 = local_c8;\n              local_50 = local_c0;\n              local_48 = local_b8;\n              uVar2 = EVP_KDF_CTX_get_params(local_88,&local_68);\n              iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x116,\n                                   \"EVP_KDF_CTX_get_params(kctx, params_get)\",&DAT_00013ea1,uVar2,\n                                   0xfffffffe);\n              if (iVar1 != 0) {\n                local_94 = 1;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_00003fb4:\n  EVP_KDF_CTX_free(local_88);\n  CRYPTO_free(local_80);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_94;\n}\n\n",
        "output": "The predicted function name is do_kdf_hkdf_gettables"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_00003407(1);\n  return;\n}\n\n",
        "output": "The predicted function name is test_http_get_x509"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  return *(undefined4 *)PTR_gcide_markup_yy_flex_debug_00212fe0;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyget_debug"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong [MASK](ulong param_1,ulong param_2)\n\n{\n  ulong uVar1;\n  ulong local_38;\n  ulong local_30;\n  \n  local_38 = param_2;\n  local_30 = param_1;\n  if ((param_2 & 1) == 0) {\n    local_38 = param_1;\n    local_30 = param_2;\n  }\n  if (local_30 != 0) {\n    local_38 = local_38 >> 1;\n    while( true ) {\n      for (; (local_30 & 1) == 0; local_30 = local_30 >> 1) {\n      }\n      uVar1 = (local_30 >> 1) - local_38;\n      if (uVar1 == 0) break;\n      local_30 = (long)uVar1 >> 0x3f;\n      local_38 = local_38 + (local_30 & uVar1);\n      local_30 = (uVar1 ^ local_30) - local_30;\n    }\n    local_38 = (local_30 & 0xfffffffffffffffe) + 1;\n  }\n  return local_38;\n}\n\n",
        "output": "The predicted function name is gcd_odd"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined4 *puVar3;\n  undefined4 local_14;\n  \n  iVar1 = FUN_00011e68(param_2);\n  if (iVar1 == 0) {\n    iVar1 = strcmp(param_2,\"scrypt\");\n    if (iVar1 == 0) {\n      local_14 = 1;\n    }\n    else {\n      iVar1 = strcmp(param_2,\"pbkdf2\");\n      if (iVar1 == 0) {\n        local_14 = 2;\n      }\n      else {\n        iVar1 = strcmp(param_2,\"pkcs12\");\n        if (iVar1 != 0) {\n          FUN_000170fc(\"test/evp_test.c\",0x853,\"Unknown pbe algorithm %s\",param_2);\n          return 0;\n        }\n        local_14 = 3;\n      }\n    }\n    puVar3 = (undefined4 *)CRYPTO_zalloc(0x68,\"test/evp_test.c\",0x856);\n    iVar1 = FUN_00018f92(\"test/evp_test.c\",0x856,\"pdat = OPENSSL_zalloc(sizeof(*pdat))\",puVar3);\n    if (iVar1 == 0) {\n      uVar2 = 0;\n    }\n    else {\n      *puVar3 = local_14;\n      *(undefined4 **)(\"EVP_PKEY_verify_recover_init\" + param_1) = puVar3;\n      uVar2 = 1;\n    }\n  }\n  else {\n    FUN_00016f06(\"test/evp_test.c\",0x848,\"skipping, \\'%s\\' is disabled\",param_2);\n    *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is pbe_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  OPENSSL_sk_new_null();\n  return;\n}\n\n",
        "output": "The predicted function name is sk_EVP_TEST_BUFFER_new_null"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](SSL *param_1,SSL_CTX *param_2,int param_3)\n\n{\n  int iVar1;\n  char *__s1;\n  void *pvVar2;\n  undefined8 uVar3;\n  \n  __s1 = (char *)SSL_get_servername(param_1);\n  pvVar2 = SSL_get_ex_data(param_1,DAT_002200e4);\n  if (__s1 == (char *)0x0) {\n    *(undefined4 *)((long)pvVar2 + 0x10) = 1;\n    uVar3 = 3;\n  }\n  else {\n    iVar1 = strcmp(__s1,\"server2\");\n    if (iVar1 == 0) {\n      SSL_set_SSL_CTX(param_1,param_2);\n      SSL_clear_options(param_1,0xffffffff);\n      uVar3 = SSL_CTX_get_options(param_2);\n      SSL_set_options(param_1,uVar3);\n      *(undefined4 *)((long)pvVar2 + 0x10) = 2;\n      uVar3 = 0;\n    }\n    else {\n      iVar1 = strcmp(__s1,\"server1\");\n      if (iVar1 == 0) {\n        *(undefined4 *)((long)pvVar2 + 0x10) = 1;\n        uVar3 = 0;\n      }\n      else if (param_3 == 0) {\n        uVar3 = 2;\n      }\n      else {\n        *(undefined4 *)((long)pvVar2 + 0x10) = 1;\n        uVar3 = 3;\n      }\n    }\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is select_server_ctx"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void *param_1)\n\n{\n  CRYPTO_free(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is fake_rsa_gen_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  int iVar3;\n  undefined4 uVar4;\n  long in_FS_OFFSET;\n  undefined8 local_128;\n  undefined8 local_120;\n  undefined8 local_118;\n  undefined8 local_110;\n  undefined8 local_108;\n  undefined4 local_f4;\n  undefined8 local_f0;\n  undefined8 *local_e8;\n  char *local_e0;\n  undefined8 local_d8;\n  undefined8 uStack208;\n  undefined8 uStack200;\n  undefined8 uStack192;\n  undefined8 uStack184;\n  undefined8 auStack176 [15];\n  undefined local_38 [24];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_f0 = 0;\n  local_e0 = \"id-smime-alg-CMS3DESwrap\";\n  local_e8 = auStack176;\n  OSSL_PARAM_construct_utf8_string(&local_128,\"digest\",&DAT_00014514,0);\n  puVar2 = local_e8;\n  local_d8 = local_128;\n  uStack208 = local_120;\n  uStack200 = local_118;\n  uStack192 = local_110;\n  uStack184 = local_108;\n  local_e8 = local_e8 + 5;\n  OSSL_PARAM_construct_octet_string(&local_128,&DAT_00013cfa,&DAT_00219440,0x14);\n  uVar1 = local_120;\n  *puVar2 = local_128;\n  puVar2[1] = uVar1;\n  uVar1 = local_110;\n  puVar2[2] = local_118;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_108;\n  puVar2 = local_e8;\n  local_e8 = local_e8 + 5;\n  OSSL_PARAM_construct_utf8_string(&local_128,\"cekalg\",local_e0,0);\n  uVar1 = local_120;\n  *puVar2 = local_128;\n  puVar2[1] = uVar1;\n  uVar1 = local_110;\n  puVar2[2] = local_118;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_108;\n  puVar2 = local_e8;\n  OSSL_PARAM_construct_end(&local_128);\n  *puVar2 = local_128;\n  puVar2[1] = local_120;\n  puVar2[2] = local_118;\n  puVar2[3] = local_110;\n  puVar2[4] = local_108;\n  local_f0 = FUN_00002d68(\"X942KDF-ASN1\");\n  iVar3 = FUN_0000e315(\"test/evp_kdf_test.c\",0x62a,\n                       \"kctx = get_kdfbyname(OSSL_KDF_NAME_X942KDF_ASN1)\",local_f0);\n  if (iVar3 != 0) {\n    uVar4 = EVP_KDF_derive(local_f0,local_38,0x18,&local_d8);\n    iVar3 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x62b,\n                         \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar4,0);\n    if (iVar3 != 0) {\n      iVar3 = FUN_0000e848(\"test/evp_kdf_test.c\",0x62c,&DAT_00013c68,\"expected\",local_38,0x18,\n                           &DAT_00014c10,0x18);\n      if (iVar3 != 0) {\n        local_f4 = 1;\n        goto LAB_00009edf;\n      }\n    }\n  }\n  local_f4 = 0;\nLAB_00009edf:\n  EVP_KDF_CTX_free(local_f0);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_f4;\n}\n\n",
        "output": "The predicted function name is test_kdf_x942_asn1"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  int iVar3;\n  undefined4 uVar4;\n  long in_FS_OFFSET;\n  undefined8 local_1c8;\n  undefined8 local_1c0;\n  undefined8 local_1b8;\n  undefined8 local_1b0;\n  undefined8 local_1a8;\n  undefined4 local_194;\n  undefined4 local_190;\n  undefined4 local_18c;\n  undefined8 *local_188;\n  undefined8 local_180;\n  undefined8 local_178;\n  undefined8 uStack368;\n  undefined8 uStack360;\n  undefined8 uStack352;\n  undefined8 uStack344;\n  undefined8 auStack336 [35];\n  undefined8 local_38;\n  undefined8 local_30;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_194 = 0;\n  local_190 = 0;\n  local_38 = 0;\n  local_30 = 0;\n  local_188 = auStack336;\n  OSSL_PARAM_construct_utf8_string(&local_1c8,\"cipher\",PTR_s_AES128_00219478,0);\n  puVar2 = local_188;\n  local_178 = local_1c8;\n  uStack368 = local_1c0;\n  uStack360 = local_1b8;\n  uStack352 = local_1b0;\n  uStack344 = local_1a8;\n  local_188 = local_188 + 5;\n  OSSL_PARAM_construct_utf8_string(&local_1c8,&DAT_000141e1,PTR_DAT_00219480,0);\n  uVar1 = local_1c0;\n  *puVar2 = local_1c8;\n  puVar2[1] = uVar1;\n  uVar1 = local_1b0;\n  puVar2[2] = local_1b8;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_1a8;\n  puVar2 = local_188;\n  local_188 = local_188 + 5;\n  OSSL_PARAM_construct_utf8_string(&local_1c8,&DAT_00013d10,PTR_s_COUNTER_00219488,0);\n  uVar1 = local_1c0;\n  *puVar2 = local_1c8;\n  puVar2[1] = uVar1;\n  uVar1 = local_1b0;\n  puVar2[2] = local_1b8;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_1a8;\n  puVar2 = local_188;\n  local_188 = local_188 + 5;\n  OSSL_PARAM_construct_octet_string(&local_1c8,&DAT_00013cfa,&DAT_00219290,0x10);\n  uVar1 = local_1c0;\n  *puVar2 = local_1c8;\n  puVar2[1] = uVar1;\n  uVar1 = local_1b0;\n  puVar2[2] = local_1b8;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_1a8;\n  puVar2 = local_188;\n  local_188 = local_188 + 5;\n  OSSL_PARAM_construct_octet_string(&local_1c8,&DAT_00013cfe,&DAT_002192a0,0x3c);\n  uVar1 = local_1c0;\n  *puVar2 = local_1c8;\n  puVar2[1] = uVar1;\n  uVar1 = local_1b0;\n  puVar2[2] = local_1b8;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_1a8;\n  puVar2 = local_188;\n  local_188 = local_188 + 5;\n  OSSL_PARAM_construct_int(&local_1c8,\"use-l\",&local_194);\n  uVar1 = local_1c0;\n  *puVar2 = local_1c8;\n  puVar2[1] = uVar1;\n  uVar1 = local_1b0;\n  puVar2[2] = local_1b8;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_1a8;\n  puVar2 = local_188;\n  local_188 = local_188 + 5;\n  OSSL_PARAM_construct_int(&local_1c8,\"use-separator\",&local_190);\n  uVar1 = local_1c0;\n  *puVar2 = local_1c8;\n  puVar2[1] = uVar1;\n  uVar1 = local_1b0;\n  puVar2[2] = local_1b8;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_1a8;\n  puVar2 = local_188;\n  OSSL_PARAM_construct_end(&local_1c8);\n  *puVar2 = local_1c8;\n  puVar2[1] = local_1c0;\n  puVar2[2] = local_1b8;\n  puVar2[3] = local_1b0;\n  puVar2[4] = local_1a8;\n  local_180 = FUN_00002d68(\"KBKDF\");\n  iVar3 = FUN_0000e315(\"test/evp_kdf_test.c\",0x544,&DAT_000141f4,local_180);\n  if (iVar3 != 0) {\n    uVar4 = EVP_KDF_derive(local_180,&local_38,0x10,&local_178);\n    iVar3 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x545,\n                         \"EVP_KDF_derive(kctx, result, sizeof(result), params)\",&DAT_00013c2d,uVar4,\n                         0);\n    if (iVar3 != 0) {\n      iVar3 = FUN_0000e848(\"test/evp_kdf_test.c\",0x546,\"result\",\"output\",&local_38,0x10,\n                           &DAT_002192e0,0x10);\n      if (iVar3 != 0) {\n        local_18c = 1;\n        goto LAB_00008e2c;\n      }\n    }\n  }\n  local_18c = 0;\nLAB_00008e2c:\n  EVP_KDF_CTX_free(local_180);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_18c;\n}\n\n",
        "output": "The predicted function name is test_kdf_kbkdf_fixedinfo"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = CRYPTO_zalloc(0xa8,\"test/helpers/handshake.c\",0x1f);\n  FUN_000146a7(\"test/helpers/handshake.c\",0x1f,\"ret = OPENSSL_zalloc(sizeof(*ret))\",uVar1);\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is HANDSHAKE_RESULT_new"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_2c;\n  undefined4 local_28;\n  undefined4 local_24;\n  undefined8 local_20;\n  void *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_24 = 0;\n  local_20 = 0;\n  local_2c = 1;\n  local_28 = 0;\n  local_18 = (void *)FUN_0000511d(\"passwordPASSWORDpassword\",\"sha256\",\n                                  \"saltSALTsaltSALTsaltSALTsaltSALTsalt\",&local_2c,&local_28);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x2b8,\"params\",local_18);\n  if (iVar1 != 0) {\n    local_20 = FUN_00002d68(\"PBKDF2\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x2b9,\"kctx = get_kdfbyname(OSSL_KDF_NAME_PBKDF2)\",\n                         local_20);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_20,local_18);\n      iVar1 = FUN_0000e3f6(\"test/evp_kdf_test.c\",699,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        local_24 = 1;\n      }\n    }\n  }\n  EVP_KDF_CTX_free(local_20);\n  CRYPTO_free(local_18);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_24;\n}\n\n",
        "output": "The predicted function name is test_kdf_pbkdf2_small_iterations"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  FUN_000286f2(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is my_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](char *param_1,char **param_2,undefined8 *param_3,undefined8 *param_4)\n\n{\n  char *pcVar1;\n  char cVar2;\n  int iVar3;\n  char *local_30;\n  char *local_28;\n  char *local_20;\n  \n  if ((param_1 != (char *)0x0) && (iVar3 = access(param_1,2), iVar3 == 0)) {\n    local_20 = *param_2;\n    local_30 = param_1;\n    for (local_28 = param_1; (*local_28 != '\\0' && (*local_28 == *local_20));\n        local_28 = local_28 + 1) {\n      if (*local_28 == '/') {\n        local_30 = local_28 + 1;\n      }\n      local_20 = local_20 + 1;\n    }\n    wget_buffer_reset(param_4);\n    while (*local_20 != '\\0') {\n      pcVar1 = local_20 + 1;\n      cVar2 = *local_20;\n      local_20 = pcVar1;\n      if (cVar2 == '/') {\n        wget_buffer_memcat(param_4,&DAT_00041f59,3);\n      }\n    }\n    wget_iri_escape_path(local_30,param_4);\n    wget_debug_printf(\"  %.*s -> %s\\n\",param_3[1] & 0xffffffff,*param_3,param_1);\n    wget_debug_printf(\"       -> %s\\n\",*param_4);\n    return;\n  }\n  wget_debug_printf(\"  %.*s -> %s\\n\",param_3[1] & 0xffffffff,*param_3,*param_4);\n  return;\n}\n\n",
        "output": "The predicted function name is convert_link_whole"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined param_1)\n\n{\n  long in_FS_OFFSET;\n  undefined local_11;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_11 = param_1;\n  FUN_0000c999(&local_11,1);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is text_add_chr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long *param_1,undefined8 param_2)\n\n{\n  long lVar1;\n  long lVar2;\n  long lVar3;\n  int iVar4;\n  long lVar5;\n  long lVar6;\n  long local_30;\n  long local_28;\n  \n  lVar1 = param_1[2];\n  lVar2 = *param_1;\n  lVar6 = param_1[1];\n  local_30 = lVar1;\n  do {\n    lVar3 = local_30;\n    local_30 = lVar3 + -1;\n    if (local_30 < 0) break;\n    iVar4 = __gmpz_cmp(local_30 * 0x10 + lVar2,param_2);\n  } while (0 < iVar4);\n  if ((local_30 < 0) || (iVar4 = __gmpz_cmp(local_30 * 0x10 + lVar2,param_2), iVar4 != 0)) {\n    lVar5 = FUN_0000b305(lVar2,(lVar1 + 1) * 0x10);\n    lVar6 = FUN_0000b305(lVar6,(lVar1 + 1) * 8);\n    __gmpz_init(lVar5 + lVar1 * 0x10);\n    lVar2 = lVar1;\n    while (local_28 = lVar2 + -1, local_30 < local_28) {\n      __gmpz_set(lVar5 + lVar2 * 0x10,local_28 * 0x10 + lVar5);\n      *(undefined8 *)(lVar6 + lVar2 * 8) = *(undefined8 *)(lVar6 + local_28 * 8);\n      lVar2 = local_28;\n    }\n    __gmpz_set(lVar3 * 0x10 + lVar5,param_2);\n    *(undefined8 *)(lVar6 + lVar3 * 8) = 1;\n    *param_1 = lVar5;\n    param_1[1] = lVar6;\n    param_1[2] = lVar1 + 1;\n  }\n  else {\n    *(long *)(lVar6 + local_30 * 8) = *(long *)(lVar6 + local_30 * 8) + 1;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is mp_factor_insert"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  long in_FS_OFFSET;\n  void *local_40;\n  void *local_38;\n  undefined8 local_30;\n  undefined8 *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = param_1;\n  local_28 = param_2;\n  iVar1 = FUN_00003449(param_1,&local_40,&local_38);\n  if (iVar1 == 0) {\n    iVar1 = mu_header_append(local_28[1],local_40,local_38);\n    free(local_40);\n    free(local_38);\n    if (iVar1 != 0) {\n      uVar2 = mu_strerror(iVar1);\n      uVar3 = mu_sieve_get_message_num(*local_28);\n      uVar4 = dgettext(\"mailutils\",\"%lu: can\\'t add header \\\"%s\\\": %s\");\n      mu_sieve_error(*local_28,uVar4,uVar3,local_30,uVar2);\n    }\n  }\n  else {\n    uVar2 = mu_strerror(iVar1);\n    uVar3 = mu_sieve_get_message_num(*local_28);\n    uVar4 = dgettext(\"mailutils\",\"%lu: can\\'t add header \\\"%s\\\": %s\");\n    mu_sieve_error(*local_28,uVar4,uVar3,local_30,uVar2);\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is add_header"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  undefined4 *ptr;\n  undefined8 uVar2;\n  EVP_MD *local_18;\n  \n  local_18 = (EVP_MD *)0x0;\n  iVar1 = strcmp(param_2,\"NULL\");\n  if (iVar1 != 0) {\n    iVar1 = FUN_00011e19(param_2);\n    if (iVar1 != 0) {\n      *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n      return 1;\n    }\n    local_18 = EVP_get_digestbyname(param_2);\n    if (local_18 == (EVP_MD *)0x0) {\n      return 0;\n    }\n  }\n  ptr = (undefined4 *)CRYPTO_zalloc(0x48,\"test/evp_test.c\",0xc80);\n  iVar1 = FUN_00018f92(\"test/evp_test.c\",0xc80,\"mdat = OPENSSL_zalloc(sizeof(*mdat))\",ptr);\n  if (iVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    *(EVP_MD **)(ptr + 2) = local_18;\n    uVar2 = EVP_MD_CTX_new();\n    *(undefined8 *)(ptr + 4) = uVar2;\n    iVar1 = FUN_00018f92(\"test/evp_test.c\",0xc83,\"mdat->ctx = EVP_MD_CTX_new()\",\n                         *(undefined8 *)(ptr + 4));\n    if (iVar1 == 0) {\n      CRYPTO_free(ptr);\n      uVar2 = 0;\n    }\n    else {\n      *ptr = param_3;\n      ptr[1] = param_4;\n      *(undefined4 **)(\"EVP_PKEY_verify_recover_init\" + param_1) = ptr;\n      uVar2 = 1;\n    }\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is digestsigver_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  EVP_CIPHER *pEVar1;\n  \n  pEVar1 = EVP_aes_128_cbc();\n  FUN_00003665(param_1,pEVar1);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_aes128_cbc_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](char **param_1,long param_2)\n\n{\n  char *pcVar1;\n  \n  if (param_2 == 8) {\n    pcVar1 = *param_1;\n    if (*pcVar1 == '\\x01') {\n      *param_1 = (char *)0x0;\n    }\n    else {\n      pcVar1 = (char *)0x0;\n    }\n  }\n  else {\n    pcVar1 = (char *)0x0;\n  }\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is fake_rsa_keymgmt_load"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid ** [MASK](void *param_1,void *param_2)\n\n{\n  void **__s;\n  void *pvVar1;\n  \n  __s = (void **)malloc(0x30);\n  if (__s != (void **)0x0) {\n    memset(__s,0,0x30);\n    pvVar1 = malloc((long)param_2 + 1);\n    *__s = pvVar1;\n    if (*__s == (void *)0x0) {\n      free(__s);\n      __s = (void **)0x0;\n    }\n    else {\n      memcpy(*__s,param_1,(size_t)param_2);\n      *(undefined *)((long)param_2 + (long)*__s) = 0;\n      __s[1] = param_2;\n      pvVar1 = (void *)utf8_strlen(*__s);\n      __s[2] = pvVar1;\n    }\n  }\n  return __s;\n}\n\n",
        "output": "The predicted function name is alloc_entry"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 *\n[MASK](long param_1,undefined8 param_2,undefined8 param_3,char *param_4,char *param_5)\n\n{\n  undefined8 *puVar1;\n  undefined8 *puVar2;\n  size_t sVar3;\n  long in_FS_OFFSET;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  char *local_60;\n  char *local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  long local_40;\n  undefined8 *local_30;\n  undefined8 *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_60 = param_5;\n  local_58 = param_4;\n  local_50 = param_3;\n  local_48 = param_2;\n  local_40 = param_1;\n  puVar2 = (undefined8 *)CRYPTO_malloc(200,\"test/evp_kdf_test.c\",0xc4);\n  local_30 = puVar2;\n  local_28 = puVar2;\n  if (puVar2 == (undefined8 *)0x0) {\n    puVar2 = (undefined8 *)0x0;\n  }\n  else {\n    if (local_40 != 0) {\n      local_30 = puVar2 + 5;\n      OSSL_PARAM_construct_utf8_string(&local_98,\"digest\",local_40,0);\n      *puVar2 = local_98;\n      puVar2[1] = local_90;\n      puVar2[2] = local_88;\n      puVar2[3] = local_80;\n      puVar2[4] = local_78;\n    }\n    sVar3 = strlen(local_58);\n    puVar2 = local_30;\n    local_30 = local_30 + 5;\n    OSSL_PARAM_construct_octet_string(&local_98,&DAT_00013cf5,local_58,sVar3);\n    puVar1 = local_30;\n    *puVar2 = local_98;\n    puVar2[1] = local_90;\n    puVar2[2] = local_88;\n    puVar2[3] = local_80;\n    puVar2[4] = local_78;\n    local_30 = local_30 + 5;\n    OSSL_PARAM_construct_octet_string(&local_98,&DAT_00013cfa,local_48,local_50);\n    puVar2 = local_30;\n    *puVar1 = local_98;\n    puVar1[1] = local_90;\n    puVar1[2] = local_88;\n    puVar1[3] = local_80;\n    puVar1[4] = local_78;\n    if (local_60 == (char *)0x0) {\n      local_30 = local_30 + 5;\n      OSSL_PARAM_construct_utf8_string(&local_98,&DAT_00013d10,\"EXTRACT_ONLY\",0);\n      *puVar2 = local_98;\n      puVar2[1] = local_90;\n      puVar2[2] = local_88;\n      puVar2[3] = local_80;\n      puVar2[4] = local_78;\n    }\n    else {\n      sVar3 = strlen(local_60);\n      puVar2 = local_30;\n      local_30 = local_30 + 5;\n      OSSL_PARAM_construct_octet_string(&local_98,&DAT_00013cfe,local_60,sVar3);\n      *puVar2 = local_98;\n      puVar2[1] = local_90;\n      puVar2[2] = local_88;\n      puVar2[3] = local_80;\n      puVar2[4] = local_78;\n    }\n    puVar2 = local_30;\n    OSSL_PARAM_construct_end(&local_98);\n    *puVar2 = local_98;\n    puVar2[1] = local_90;\n    puVar2[2] = local_88;\n    puVar2[3] = local_80;\n    puVar2[4] = local_78;\n    puVar2 = local_28;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar2;\n}\n\n",
        "output": "The predicted function name is construct_hkdf_params"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_00003aca();\n  return;\n}\n\n",
        "output": "The predicted function name is timestamp_finish"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  undefined4 uVar1;\n  long lVar2;\n  \n  lVar2 = FUN_0002066a(param_2,0x2b);\n  uVar1 = FUN_0002049c(param_1,lVar2,0,0x400);\n  if ((lVar2 != 0) && (lVar2 != 0)) {\n    (*wget_free)(lVar2);\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is parse_included_directories"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  *(byte *)(param_1 + 0x18) = *(byte *)(param_1 + 0x18) | 1;\n  return;\n}\n\n",
        "output": "The predicted function name is impl_action_reject"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  EVP_MD *pEVar3;\n  EVP_MD **ppEVar4;\n  EVP_MD *local_20;\n  \n  iVar1 = FUN_00011e19(param_2);\n  if (iVar1 == 0) {\n    pEVar3 = (EVP_MD *)EVP_MD_fetch(DAT_002241a8,param_2,0);\n    local_20 = pEVar3;\n    if ((pEVar3 == (EVP_MD *)0x0) &&\n       (local_20 = EVP_get_digestbyname(param_2), local_20 == (EVP_MD *)0x0)) {\n      return 0;\n    }\n    ppEVar4 = (EVP_MD **)CRYPTO_zalloc(0x30,\"test/evp_test.c\",0x163);\n    iVar1 = FUN_00018f92(\"test/evp_test.c\",0x163,\"mdat = OPENSSL_zalloc(sizeof(*mdat))\",ppEVar4);\n    if (iVar1 == 0) {\n      uVar2 = 0;\n    }\n    else {\n      *(EVP_MD ***)(\"EVP_PKEY_verify_recover_init\" + param_1) = ppEVar4;\n      *ppEVar4 = local_20;\n      ppEVar4[1] = pEVar3;\n      *(undefined4 *)(ppEVar4 + 5) = 0;\n      if (pEVar3 != (EVP_MD *)0x0) {\n        FUN_00016f06(\"test/evp_test.c\",0x16a,\"%s is fetched\",param_2);\n      }\n      uVar2 = 1;\n    }\n  }\n  else {\n    FUN_00016f06(\"test/evp_test.c\",0x15b,\"skipping, \\'%s\\' is disabled\",param_2);\n    *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is digest_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  if (param_2 == (char *)0x0) {\n    iVar1 = 0;\n  }\n  else {\n    iVar1 = atoi(param_2);\n  }\n  if ((iVar1 < 0) || (0xffff < iVar1)) {\n    uVar2 = gettext(\"Value out of range (0-65535): %s\\n\");\n    wget_error_printf(uVar2,param_2);\n    uVar2 = 0xffffffff;\n  }\n  else {\n    **(undefined2 **)(param_1 + 0x18) = (short)iVar1;\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is parse_uint16"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](SSL **param_1,SSL_CTX *param_2)\n\n{\n  int iVar1;\n  SSL *ssl;\n  SSL *local_20;\n  SSL *local_18;\n  \n  local_20 = (SSL *)0x0;\n  local_18 = (SSL *)0x0;\n  ssl = SSL_new(param_2);\n  iVar1 = FUN_000146a7(\"test/helpers/handshake.c\",0x2e2,\"ssl = SSL_new(ctx)\",ssl);\n  if (iVar1 != 0) {\n    local_18 = (SSL *)CRYPTO_zalloc((long)DAT_000183a8,\"test/helpers/handshake.c\",0x2e3);\n    iVar1 = FUN_000146a7(\"test/helpers/handshake.c\",0x2e3,\n                         \"write_buf = OPENSSL_zalloc(peer_buffer_size)\",local_18);\n    if (iVar1 != 0) {\n      local_20 = (SSL *)CRYPTO_zalloc((long)DAT_000183a8,\"test/helpers/handshake.c\",0x2e4);\n      iVar1 = FUN_000146a7(\"test/helpers/handshake.c\",0x2e4,\n                           \"read_buf = OPENSSL_zalloc(peer_buffer_size)\",local_20);\n      if (iVar1 != 0) {\n        *param_1 = ssl;\n        param_1[1] = local_18;\n        param_1[3] = local_20;\n        *(int *)(param_1 + 4) = DAT_000183a8;\n        *(undefined4 *)(param_1 + 2) = *(undefined4 *)(param_1 + 4);\n        return 1;\n      }\n    }\n  }\n  SSL_free(ssl);\n  CRYPTO_free(local_18);\n  CRYPTO_free(local_20);\n  return 0;\n}\n\n",
        "output": "The predicted function name is create_peer"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return 0;\n}\n\n",
        "output": "The predicted function name is void_test_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  return param_1;\n}\n\n",
        "output": "The predicted function name is ossl_check_OPENSSL_STRING_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 *param_1)\n\n{\n  *param_1 = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is dl_error_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined4 param_3)\n\n{\n  switch(param_3) {\n  case 0:\n    FUN_00007c46(param_2);\n    break;\n  case 1:\n    FUN_00007cfb(param_2);\n    break;\n  case 2:\n    FUN_00007ef6(param_1,param_2);\n    break;\n  case 3:\n    FUN_00007c46(param_2);\n    break;\n  case 4:\n    FUN_00007cfb(param_2);\n    break;\n  case 5:\n    FUN_00008365(param_2);\n    break;\n  case 6:\n    FUN_00012811(\"test/helpers/handshake.c\",0x476,\"Action after connection done\");\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is do_connect_step"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,char *param_2)\n\n{\n  char *pcVar1;\n  \n  CRYPTO_free(*(void **)(param_1 + 0x20));\n  pcVar1 = CRYPTO_strdup(param_2,\"test/helpers/ssl_test_ctx.c\",0x168);\n  *(char **)(param_1 + 0x20) = pcVar1;\n  FUN_000146a7(\"test/helpers/ssl_test_ctx.c\",0x168,\"ctx->srp_user\",*(undefined8 *)(param_1 + 0x20));\n  return;\n}\n\n",
        "output": "The predicted function name is parse_server_srp_user"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void *param_1,size_t param_2)\n\n{\n  realloc(param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyrealloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  undefined8 uVar1;\n  \n  if (DAT_00253d64 == 0) {\n    uVar1 = 0;\n  }\n  else {\n    FUN_000119c9();\n    FUN_0001fa1d(0);\n    uVar1 = 0xffffffff;\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is print_plugin_help"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,long param_2)\n\n{\n  FUN_0000c6ad(\"Client certificate\",*(undefined4 *)(param_2 + 0x1f8),*(undefined4 *)(param_1 + 0x78)\n              );\n  return;\n}\n\n",
        "output": "The predicted function name is check_client_cert_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  FUN_000091ea(param_1);\n  return 0;\n}\n\n",
        "output": "The predicted function name is gcide_free_db"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  undefined8 uVar3;\n  \n  puVar1 = *(undefined8 **)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  iVar2 = strcmp(param_2,\"Output\");\n  if (iVar2 == 0) {\n    uVar3 = FUN_000066e2(param_3,puVar1 + 1,puVar1 + 2);\n  }\n  else {\n    iVar2 = strncmp(param_2,\"Ctrl\",4);\n    if (iVar2 == 0) {\n      uVar3 = FUN_0000b5de(param_1,*puVar1,param_3);\n    }\n    else {\n      uVar3 = 0;\n    }\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is pkey_kdf_test_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1,long param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  \n  iVar1 = FUN_000147f4(\"test/ssl_test.c\",0xba,\"result->client_alpn_negotiated\",\n                       \"result->server_alpn_negotiated\",*(undefined8 *)(param_1 + 0x48),\n                       *(undefined8 *)(param_1 + 0x50));\n  iVar2 = FUN_000147f4(\"test/ssl_test.c\",0xbd,\"test_ctx->expected_alpn_protocol\",\n                       \"result->client_alpn_negotiated\",*(undefined8 *)(param_2 + 0x1d0),\n                       *(undefined8 *)(param_1 + 0x48));\n  return iVar2 != 0 && iVar1 != 0;\n}\n\n",
        "output": "The predicted function name is check_alpn"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1)\n\n{\n  return (*(uint *)(param_1 + 0x18) & 0x10) != 0;\n}\n\n",
        "output": "The predicted function name is is_tty_writable"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](int param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (param_1 == 0x14) {\nLAB_00004dd4:\n    uVar1 = 1;\n  }\n  else {\n    if (param_1 < 0x15) {\n      if (param_1 == 2) goto LAB_00004dd4;\n    }\n    else if ((param_1 == 0x16) || (param_1 == 0x54)) goto LAB_00004dd4;\n    uVar1 = 0;\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is nonexistent_file_errno"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](long param_1,long *param_2)\n\n{\n  long lVar1;\n  long lVar2;\n  int iVar3;\n  long *plVar4;\n  int local_4c;\n  int local_48;\n  int local_44;\n  int local_40;\n  \n  local_4c = -1;\n  *(byte *)(param_1 + 0x38) = *(byte *)(param_1 + 0x38) & 0xfe;\n  if (*(long *)(*(long *)(param_1 + 8) + 0x60) == 0) {\n    local_4c = FUN_000170ad(param_1,*param_2);\n  }\n  else {\n    lVar1 = *(long *)(*(long *)(param_1 + 8) + 0x18);\n    lVar2 = *(long *)(*(long *)(param_1 + 8) + 0x60);\n    local_48 = wget_vector_size(*(undefined8 *)(lVar1 + 8));\n    if (local_48 < 1) {\n      FUN_0000f8aa(*(undefined8 *)(*(long *)(param_1 + 8) + 0x40));\n      FUN_0001fa1d(4);\n      return -1;\n    }\n    local_48 = *(int *)(param_1 + 0x28) % local_48;\n    local_44 = 0;\n    while (((local_44 < DAT_00253390 && ((*(byte *)(lVar2 + 0x20) >> 1 & 1) != 1)) &&\n           (DAT_00253cf0 != '\\x01'))) {\n      iVar3 = DAT_00253398;\n      if (local_44 * 1000 <= DAT_00253398) {\n        iVar3 = local_44 * 1000;\n      }\n      wget_millisleep(iVar3);\n      if (DAT_00253cf0 != '\\0') break;\n      local_40 = 0;\nLAB_000173c7:\n      iVar3 = wget_vector_size();\n      if ((iVar3 <= local_40) || ((*(byte *)(lVar2 + 0x20) >> 1 & 1) == 1)) goto LAB_000173f4;\n      plVar4 = (long *)wget_vector_get(*(undefined8 *)(lVar1 + 8),local_48);\n      iVar3 = wget_vector_size(*(undefined8 *)(lVar1 + 8));\n      local_48 = (local_48 + 1) % iVar3;\n      if (((DAT_002533ea != '\\0') && (*(int *)(*plVar4 + 0x5c) != 1)) ||\n         (((*(int *)(*plVar4 + 0x5c) == 0 && (DAT_002533c8 != 0)) && (DAT_002533c8 != 1)))) {\nLAB_000173c3:\n        local_40 = local_40 + 1;\n        goto LAB_000173c7;\n      }\n      local_4c = FUN_000170ad();\n      if (local_4c == 0) {\n        FUN_0000e8bf(*plVar4);\n        if (param_2 == (long *)0x0) {\n          return 0;\n        }\n        *param_2 = *plVar4;\n        return 0;\n      }\n      if (local_4c != -8) goto LAB_000173c3;\n      local_44 = DAT_00253390;\nLAB_000173f4:\n      local_44 = local_44 + 1;\n    }\n  }\n  if (((local_4c == -6) || (local_4c == -7)) || (local_4c == -8)) {\n    wget_http_close(param_1 + 0x10);\n    if ((*(byte *)(*(long *)(param_1 + 8) + 0xa9) & 1) != 1) {\n      FUN_0000f8aa(*(undefined8 *)(*(long *)(param_1 + 8) + 0x40));\n      FUN_0001fa1d(5);\n    }\n  }\n  else if (((local_4c == -5) && (wget_http_close(param_1 + 0x10), DAT_0025341b != '\\x01')) &&\n          ((*(byte *)(*(long *)(param_1 + 8) + 0xa9) & 1) != 1)) {\n    FUN_0000f8aa(*(undefined8 *)(*(long *)(param_1 + 8) + 0x40));\n    FUN_0001fa1d(4);\n  }\n  return local_4c;\n}\n\n",
        "output": "The predicted function name is establish_connection"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  ushort local_a;\n  \n  for (local_a = 0; local_a < 3; local_a = local_a + 1) {\n    EVP_CIPHER_meth_free(*(undefined8 *)(&DAT_00204228 + (long)(int)(uint)local_a * 0x10));\n    *(undefined8 *)(&DAT_00204228 + (long)(int)(uint)local_a * 0x10) = 0;\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is free_cbc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  char **ppcVar1;\n  undefined4 uVar2;\n  int iVar3;\n  int iVar4;\n  undefined8 uVar5;\n  long lVar6;\n  char *pcVar7;\n  int *piVar8;\n  char **ppcVar9;\n  long in_FS_OFFSET;\n  int local_168;\n  int local_164;\n  int local_160;\n  int local_15c;\n  char *local_150;\n  char *local_148;\n  char *local_108;\n  char *local_100;\n  int local_f8;\n  undefined local_d8 [16];\n  undefined auStack200 [32];\n  char *local_a8;\n  undefined8 local_40;\n  char *local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  local_148 = (char *)0x0;\n  ppcVar1 = *(char ***)(param_1 + 0x18);\n  if (ppcVar1 == (char **)0x0) {\n    uVar5 = 0;\n  }\n  else {\n    memset(&local_108,0,0x28);\n    if (ppcVar1[3] == (char *)0x0) {\n      lVar6 = wget_vector_get(ppcVar1[2],0);\n      if (lVar6 == 0) {\n        uVar5 = 1;\n        goto LAB_00010604;\n      }\n      local_38 = ppcVar1[4];\n      local_40 = 0;\n      wget_strscpy(local_d8,lVar6,0x10);\n      wget_strscpy(auStack200,lVar6 + 0x10,0x81);\n      pcVar7 = (char *)wget_vector_create(1,0);\n      ppcVar1[3] = pcVar7;\n      wget_vector_add_memdup(ppcVar1[3],local_d8,0xa8);\n    }\n    if (*(long *)(param_1 + 0x30) == 0) {\n      uVar2 = wget_vector_size(ppcVar1[3]);\n      uVar5 = wget_vector_create(uVar2,0);\n      *(undefined8 *)(param_1 + 0x30) = uVar5;\n    }\n    else {\n      wget_vector_clear(*(undefined8 *)(param_1 + 0x30));\n    }\n    local_150 = ppcVar1[4];\n    iVar3 = wget_vector_size(ppcVar1[2]);\n    if (((iVar3 == 0) && (iVar3 = FUN_000410c0(*ppcVar1,local_d8), iVar3 == 0)) &&\n       (local_150 == local_a8)) {\n      uVar5 = 1;\n    }\n    else {\n      iVar3 = FUN_000410c0(*ppcVar1,local_d8);\n      pcVar7 = local_148;\n      if (((iVar3 == 0) &&\n          (local_148 = local_a8, pcVar7 = local_148, (long)local_150 < (long)local_a8)) &&\n         (iVar3 = wget_truncate(*ppcVar1,local_150), pcVar7 = local_150, iVar3 != 0)) {\n        pcVar7 = *ppcVar1;\n        uVar5 = gettext(\"Failed to truncate %s\\n from %llu to %llu bytes\\n\");\n        wget_error_printf(uVar5,pcVar7,local_a8,local_150);\n        pcVar7 = local_148;\n      }\n      local_148 = pcVar7;\n      iVar3 = wget_vector_size(ppcVar1[2]);\n      if ((iVar3 < 1) || (iVar3 = open(*ppcVar1,0), iVar3 == -1)) {\n        for (local_15c = 0; iVar3 = wget_vector_size(ppcVar1[3]), local_15c < iVar3;\n            local_15c = local_15c + 1) {\n          lVar6 = wget_vector_get(ppcVar1[3],local_15c);\n          if ((long)local_150 < *(long *)(lVar6 + 0xa0)) {\n            local_100 = local_150;\n          }\n          else {\n            local_100 = *(char **)(lVar6 + 0xa0);\n          }\n          local_f8 = local_15c + 1;\n          if (((long)local_148 < (long)(local_100 + (long)local_108)) &&\n             (uVar2 = wget_vector_add_memdup(*(undefined8 *)(param_1 + 0x30),&local_108,0x28),\n             (long)local_108 < (long)local_148)) {\n            ppcVar9 = (char **)wget_vector_get(*(undefined8 *)(param_1 + 0x30),uVar2);\n            *ppcVar9 = local_148;\n            ppcVar9[1] = local_100 + (long)local_108 + -(long)local_148;\n          }\n          local_108 = local_100 + (long)local_108;\n          local_150 = local_150 + -*(long *)(lVar6 + 0xa0);\n        }\n      }\n      else {\n        local_168 = -1;\n        for (local_164 = 0;\n            (piVar8 = __errno_location(), *piVar8 != 4 &&\n            (iVar4 = wget_vector_size(ppcVar1[2]), local_164 < iVar4)); local_164 = local_164 + 1) {\n          uVar5 = wget_vector_get(ppcVar1[2],local_164);\n          local_168 = FUN_0000fe05(uVar5);\n          if (local_168 != -1) break;\n        }\n        if (local_168 == 1) {\n          pcVar7 = *ppcVar1;\n          uVar5 = gettext(\"Checksum OK for \\'%s\\'\\n\");\n          wget_info_printf(uVar5,pcVar7);\n          close(iVar3);\n          uVar5 = 1;\n          goto LAB_00010604;\n        }\n        if (local_168 == -1) {\n          gettext(\"Failed to build checksum, assuming file to be OK\\n\");\n          wget_info_printf();\n          close(iVar3);\n          uVar5 = 1;\n          goto LAB_00010604;\n        }\n        pcVar7 = *ppcVar1;\n        uVar5 = gettext(\"Bad checksum for \\'%s\\'\\n\");\n        wget_info_printf(uVar5,pcVar7);\n        for (local_160 = 0;\n            (piVar8 = __errno_location(), *piVar8 != 4 &&\n            (iVar4 = wget_vector_size(), local_160 < iVar4)); local_160 = local_160 + 1) {\n          lVar6 = wget_vector_get(ppcVar1[3],local_160);\n          if ((long)local_150 < *(long *)(lVar6 + 0xa0)) {\n            local_100 = local_150;\n          }\n          else {\n            local_100 = *(char **)(lVar6 + 0xa0);\n          }\n          local_f8 = local_160 + 1;\n          iVar4 = FUN_0000fd54(lVar6,iVar3,local_108,local_100);\n          if (iVar4 != 1) {\n            uVar2 = wget_vector_size(ppcVar1[3]);\n            uVar5 = gettext(\"Piece %d/%d not OK - requeuing\\n\");\n            wget_info_printf(uVar5,local_160 + 1,uVar2);\n            wget_vector_add_memdup(*(undefined8 *)(param_1 + 0x30),&local_108,0x28);\n            wget_debug_printf(\"  need to download %llu bytes from pos=%llu\\n\",local_100,local_108);\n          }\n          local_108 = local_100 + (long)local_108;\n          local_150 = local_150 + -*(long *)(lVar6 + 0xa0);\n        }\n        close(iVar3);\n      }\n      uVar5 = 0;\n    }\n  }\nLAB_00010604:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar5;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is job_validate_file"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined4 param_2)\n\n{\n  OPENSSL_sk_value(param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is sk_EVP_TEST_BUFFER_value"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](long param_1)\n\n{\n  long lVar1;\n  byte *pbVar2;\n  char *__s;\n  \n  if ((*(short *)(param_1 + 0x50) < 8) || (0xff < *(short *)(param_1 + 0x50))) {\n    if (((*(ushort *)(param_1 + 0x52) & 0x80) == 0) || ((*(ushort *)(param_1 + 0x52) & 0x40) != 0))\n    {\n      switch(*(undefined2 *)(param_1 + 0x50)) {\n      default:\n        __s = \"black\";\n        break;\n      case 1:\n        __s = \"red\";\n        break;\n      case 2:\n        __s = \"yellow\";\n        break;\n      case 3:\n        __s = \"green\";\n        break;\n      case 4:\n        __s = \"cyan\";\n        break;\n      case 5:\n        __s = \"blue\";\n        break;\n      case 6:\n        __s = \"magenta\";\n        break;\n      case 7:\n        __s = \"white\";\n      }\n    }\n    else {\n      __s = (char *)malloc(8);\n      sprintf(__s,\"#%06x\",(ulong)(*(uint *)(param_1 + 0x58) & 0xffffff));\n    }\n  }\n  else {\n    lVar1 = dwg_rgb_palette();\n    pbVar2 = (byte *)(lVar1 + (long)*(short *)(param_1 + 0x50) * 3);\n    __s = (char *)malloc(8);\n    sprintf(__s,\"#%02x%02x%02x\",(ulong)*pbVar2,(ulong)pbVar2[1],(ulong)pbVar2[2]);\n  }\n  return __s;\n}\n\n",
        "output": "The predicted function name is entity_color"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined4 param_1,undefined8 param_2,long param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  \n  if (*(long *)(param_3 + 0x30) == -1) {\n    iVar1 = FUN_0001d290(param_1,param_2,param_3,param_4);\n    if (iVar1 != 0) {\n      *(undefined8 *)(param_3 + 0x30) = 0xfffffffffffffffe;\n      piVar2 = __errno_location();\n      *(long *)(param_3 + 8) = (long)*piVar2;\n    }\n  }\n  if (*(long *)(param_3 + 0x30) < 0) {\n    uVar3 = *(undefined8 *)(param_3 + 8);\n    piVar2 = __errno_location();\n    *piVar2 = (int)uVar3;\n    uVar3 = 0xffffffff;\n  }\n  else {\n    uVar3 = 0;\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is cache_fstatat"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,int param_3,int *param_4)\n\n{\n  close(param_3);\n  close(*param_4);\n  CRYPTO_free(param_4);\n  return;\n}\n\n",
        "output": "The predicted function name is wait_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00003658(param_1,0x30,param_2,0x30,\"dummy@example.com\",0);\n  return;\n}\n\n",
        "output": "The predicted function name is set_email3"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = atoi(param_2);\n  *(int *)(param_1 + 0xc) = iVar1;\n  return 1;\n}\n\n",
        "output": "The predicted function name is parse_test_max_fragment_size"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,long param_2)\n\n{\n  FUN_0000c6ad(\"Tmp key\",*(undefined4 *)(param_2 + 0x1dc),*(undefined4 *)(param_1 + 0x60));\n  return;\n}\n\n",
        "output": "The predicted function name is check_tmp_key"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  int iVar1;\n  long lVar2;\n  int local_20;\n  \n  if (DAT_00253c20 != 0) {\n    iVar1 = wget_vector_size(DAT_00253c30);\n    for (local_20 = 0; local_20 < iVar1; local_20 = local_20 + 1) {\n      lVar2 = wget_vector_get(DAT_00253c30,local_20);\n      if (*(long *)(lVar2 + 0x20) != 0) {\n        (**(code **)(lVar2 + 0x20))(lVar2);\n      }\n    }\n    wget_vector_free(&DAT_00253c30);\n    FUN_00010d84(&DAT_00253c38);\n    wget_vector_free(&DAT_00253c28);\n    DAT_00253c20 = 0;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is plugin_db_finalize"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined4 param_2)\n\n{\n  *(undefined4 *)(param_1 + 0x68) = param_2;\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_iterator_store_flags"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,char *param_2)\n\n{\n  char *pcVar1;\n  \n  CRYPTO_free(*(void **)(param_1 + 0x38));\n  pcVar1 = CRYPTO_strdup(param_2,\"test/helpers/ssl_test_ctx.c\",0x16e);\n  *(char **)(param_1 + 0x38) = pcVar1;\n  FUN_000146a7(\"test/helpers/ssl_test_ctx.c\",0x16e,\"ctx->session_ticket_app_data\",\n               *(undefined8 *)(param_1 + 0x38));\n  return;\n}\n\n",
        "output": "The predicted function name is parse_server_session_ticket_app_data"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,int param_2,int param_3)\n\n{\n  undefined8 uVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  if ((param_2 == 0) || (param_2 == param_3)) {\n    uVar1 = 1;\n  }\n  else {\n    if (param_3 == 0) {\n      pcVar2 = \"absent\";\n    }\n    else {\n      pcVar2 = OBJ_nid2ln(param_3);\n    }\n    pcVar3 = OBJ_nid2ln(param_2);\n    FUN_00012811(\"test/ssl_test.c\",0xe6,\"%s type mismatch, %s vs %s\\n\",param_1,pcVar3,pcVar2);\n    uVar1 = 0;\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is check_nid"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](int param_1,char *param_2)\n\n{\n  char cVar1;\n  int iVar2;\n  size_t sVar3;\n  char *__s;\n  FILE *__stream;\n  ssize_t sVar4;\n  char *pcVar5;\n  ulong uVar6;\n  long in_FS_OFFSET;\n  byte bVar7;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char local_78 [104];\n  long local_10;\n  \n  bVar7 = 0;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_a0 = (char *)0x0;\n  sVar3 = strlen(param_2);\n  __s = (char *)FUN_0000fbd8(sVar3 + 4);\n  *__s = '=';\n  strcpy(__s + 1,param_2);\n  uVar6 = 0xffffffffffffffff;\n  pcVar5 = __s;\n  do {\n    if (uVar6 == 0) break;\n    uVar6 = uVar6 - 1;\n    cVar1 = *pcVar5;\n    pcVar5 = pcVar5 + (ulong)bVar7 * -2 + 1;\n  } while (cVar1 != '\\0');\n  *(undefined2 *)(__s + (~uVar6 - 1)) = 0xa0d;\n  *(undefined *)((long)(__s + (~uVar6 - 1)) + 2) = 0;\n  __stream = fdopen(param_1,\"r\");\n  sVar3 = strlen(__s);\n  sVar4 = write(param_1,__s,sVar3);\n  if (sVar4 < 0) {\n    FUN_0000cdfd(\"write\");\n  }\n  while (pcVar5 = fgets(local_78,100,__stream), pcVar5 != (char *)0x0) {\n    iVar2 = strncmp(local_78,\"   Whois Server:\",0x10);\n    if ((iVar2 == 0) && (local_a0 == (char *)0x0)) {\n      for (local_98 = local_78; *local_98 != ':'; local_98 = local_98 + 1) {\n      }\n      do {\n        local_98 = local_98 + 1;\n      } while (*local_98 == ' ');\n      sVar3 = strlen(local_98);\n      local_a0 = (char *)FUN_0000fbd8(sVar3 + 1);\n      local_90 = local_a0;\n      while ((*local_98 != '\\n' && (*local_98 != '\\r'))) {\n        *local_90 = *local_98;\n        local_98 = local_98 + 1;\n        local_90 = local_90 + 1;\n      }\n      *local_90 = '\\0';\n    }\n    fputs(local_78,stdout);\n  }\n  iVar2 = ferror(__stream);\n  if (iVar2 != 0) {\n    FUN_0000cdfd(\"fgets\");\n  }\n  FUN_0000eb56(__s);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_a0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is query_crsnic"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  int iVar3;\n  undefined4 uVar4;\n  long in_FS_OFFSET;\n  undefined8 local_168;\n  undefined8 local_160;\n  undefined8 local_158;\n  undefined8 local_150;\n  undefined8 local_148;\n  undefined local_12d;\n  undefined4 local_12c;\n  undefined8 *local_128;\n  undefined8 local_120;\n  undefined8 local_118;\n  undefined8 uStack272;\n  undefined8 uStack264;\n  undefined8 uStack256;\n  undefined8 uStack248;\n  undefined8 auStack240 [25];\n  undefined local_28 [8];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_12d = 0x41;\n  local_128 = auStack240;\n  OSSL_PARAM_construct_utf8_string(&local_168,\"digest\",\"sha256\",0);\n  puVar2 = local_128;\n  local_118 = local_168;\n  uStack272 = local_160;\n  uStack264 = local_158;\n  uStack256 = local_150;\n  uStack248 = local_148;\n  local_128 = local_128 + 5;\n  OSSL_PARAM_construct_octet_string(&local_168,&DAT_00013cfa,&DAT_00219360,0x85);\n  uVar1 = local_160;\n  *puVar2 = local_168;\n  puVar2[1] = uVar1;\n  uVar1 = local_150;\n  puVar2[2] = local_158;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_148;\n  puVar2 = local_128;\n  local_128 = local_128 + 5;\n  OSSL_PARAM_construct_octet_string(&local_168,\"xcghash\",&DAT_00219400,0x20);\n  uVar1 = local_160;\n  *puVar2 = local_168;\n  puVar2[1] = uVar1;\n  uVar1 = local_150;\n  puVar2[2] = local_158;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_148;\n  puVar2 = local_128;\n  local_128 = local_128 + 5;\n  OSSL_PARAM_construct_octet_string(&local_168,\"session_id\",&DAT_00219420,0x20);\n  uVar1 = local_160;\n  *puVar2 = local_168;\n  puVar2[1] = uVar1;\n  uVar1 = local_150;\n  puVar2[2] = local_158;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_148;\n  puVar2 = local_128;\n  local_128 = local_128 + 5;\n  OSSL_PARAM_construct_utf8_string(&local_168,&DAT_00014312,&local_12d,1);\n  uVar1 = local_160;\n  *puVar2 = local_168;\n  puVar2[1] = uVar1;\n  uVar1 = local_150;\n  puVar2[2] = local_158;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_148;\n  puVar2 = local_128;\n  OSSL_PARAM_construct_end(&local_168);\n  *puVar2 = local_168;\n  puVar2[1] = local_160;\n  puVar2[2] = local_158;\n  puVar2[3] = local_150;\n  puVar2[4] = local_148;\n  local_120 = FUN_00002d68(\"SSHKDF\");\n  iVar3 = FUN_0000e315(\"test/evp_kdf_test.c\",0x5d3,\"kctx = get_kdfbyname(OSSL_KDF_NAME_SSHKDF)\",\n                       local_120);\n  if (iVar3 != 0) {\n    uVar4 = EVP_KDF_derive(local_120,local_28,8,&local_118);\n    iVar3 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x5d4,\n                         \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar4,0);\n    if (iVar3 != 0) {\n      iVar3 = FUN_0000e848(\"test/evp_kdf_test.c\",0x5d5,&DAT_00013c68,\"expected\",local_28,8,\n                           &DAT_00014c00,8);\n      if (iVar3 != 0) {\n        local_12c = 1;\n        goto LAB_000098ec;\n      }\n    }\n  }\n  local_12c = 0;\nLAB_000098ec:\n  EVP_KDF_CTX_free(local_120);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_12c;\n}\n\n",
        "output": "The predicted function name is test_kdf_sshkdf"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](undefined8 *param_1,undefined8 *param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = wget_strcmp(*param_1,*param_2);\n  if ((iVar1 == 0) && (iVar1 = wget_strcmp(param_1[1],param_2[1]), iVar1 == 0)) {\n    iVar1 = *(int *)(param_1 + 2) - *(int *)(param_2 + 2);\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is host_compare"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](long param_1,ulong param_2,int param_3)\n\n{\n  ulong local_10;\n  \n  local_10 = 0;\n  while( true ) {\n    if (param_2 <= local_10) {\n      return \"InvalidValue\";\n    }\n    if (param_3 == *(int *)(param_1 + local_10 * 0x10 + 8)) break;\n    local_10 = local_10 + 1;\n  }\n  return *(char **)(param_1 + local_10 * 0x10);\n}\n\n",
        "output": "The predicted function name is enum_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](size_t param_1)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(param_1);\n  if (pvVar1 == (void *)0x0) {\n    pvVar1 = (void *)FUN_0002785b();\n  }\n  return pvVar1;\n}\n\n",
        "output": "The predicted function name is my_malloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  wget_calloc_fn = FUN_000278b9;\n  wget_realloc_fn = FUN_000278f4;\n  wget_free = FUN_0002793d;\n  wget_malloc_fn = FUN_00027889;\n  return;\n}\n\n",
        "output": "The predicted function name is set_allocation_functions"
    }
]