[
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](BIO *param_1)\n\n{\n  DAT_002132fc = DAT_00213530;\n  DAT_00213304 = DAT_00213538;\n  DAT_0021330c = DAT_00213540;\n  BIO_write(param_1,&DAT_002132e0,0x30);\n  return 1;\n}\n\n",
        "output": "The predicted function name is send_hello_verify"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4\n[MASK](BIO *param_1,undefined param_2,undefined8 param_3,void *param_4,size_t param_5)\n\n{\n  ulong uVar1;\n  int iVar2;\n  undefined4 uVar3;\n  EVP_CIPHER *cipher;\n  long in_FS_OFFSET;\n  undefined8 local_128;\n  undefined8 local_120;\n  undefined8 local_118;\n  undefined8 local_110;\n  undefined8 local_108;\n  size_t local_f0;\n  void *local_e8;\n  undefined8 local_e0;\n  undefined local_d4 [4];\n  BIO *local_d0;\n  byte local_bd;\n  undefined4 local_bc;\n  undefined8 local_b8;\n  EVP_CIPHER_CTX *local_b0;\n  undefined8 local_a8;\n  uchar *local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  undefined8 local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined local_3a;\n  char local_39;\n  uchar local_38 [24];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_a8 = 0;\n  local_b8 = 0;\n  local_b0 = (EVP_CIPHER_CTX *)0x0;\n  local_bc = 0;\n  DAT_002135d0 = (undefined)((ulong)param_3 >> 0x28);\n  DAT_002135d1 = (undefined)((ulong)param_3 >> 0x20);\n  DAT_002135d2 = (undefined)((ulong)param_3 >> 0x18);\n  DAT_002135d3 = (undefined)((ulong)param_3 >> 0x10);\n  DAT_002135d4 = (undefined)((ulong)param_3 >> 8);\n  DAT_002135d5 = (undefined)param_3;\n  local_bd = ~((char)param_5 + 0x14U) & 0xf;\n  local_f0 = param_5;\n  local_e8 = param_4;\n  local_e0 = param_3;\n  local_d4[0] = param_2;\n  local_d0 = param_1;\n  local_a0 = (uchar *)CRYPTO_malloc((int)param_5 + (uint)local_bd + 0x15,\"test/bad_dtls_test.c\",\n                                    0x12d);\n  if (local_a0 == (uchar *)0x0) {\n    uVar3 = 0;\n  }\n  else {\n    memcpy(local_a0,local_e8,local_f0);\n    local_a8 = EVP_MAC_fetch(0,&DAT_0000e94d,0);\n    iVar2 = FUN_000090bd(\"test/bad_dtls_test.c\",0x135,\"hmac = EVP_MAC_fetch(NULL, \\\"HMAC\\\", NULL)\",\n                         local_a8);\n    if (iVar2 != 0) {\n      local_b8 = EVP_MAC_CTX_new(local_a8);\n      iVar2 = FUN_000090bd(\"test/bad_dtls_test.c\",0x136,\"ctx = EVP_MAC_CTX_new(hmac)\",local_b8);\n      if (iVar2 != 0) {\n        OSSL_PARAM_construct_utf8_string(&local_128,\"digest\",&DAT_0000e99d,0);\n        local_98 = local_128;\n        local_90 = local_120;\n        local_88 = local_118;\n        local_80 = local_110;\n        local_78 = local_108;\n        OSSL_PARAM_construct_end(&local_128);\n        local_70 = local_128;\n        local_68 = local_120;\n        local_60 = local_118;\n        local_58 = local_110;\n        local_50 = local_108;\n        local_3a = (undefined)(local_f0 >> 8);\n        local_39 = (char)local_f0;\n        iVar2 = EVP_MAC_init(local_b8,&DAT_00213574,0x14,&local_98);\n        if (iVar2 != 0) {\n          iVar2 = EVP_MAC_update(local_b8,&DAT_00213390,2);\n          if (iVar2 != 0) {\n            iVar2 = EVP_MAC_update(local_b8,&DAT_002135d0,6);\n            if (iVar2 != 0) {\n              iVar2 = EVP_MAC_update(local_b8,local_d4,1);\n              if (iVar2 != 0) {\n                iVar2 = EVP_MAC_update(local_b8,&DAT_00213392,2);\n                if (iVar2 != 0) {\n                  iVar2 = EVP_MAC_update(local_b8,&local_3a,2);\n                  if (iVar2 != 0) {\n                    iVar2 = EVP_MAC_update(local_b8,local_a0,local_f0);\n                    if (iVar2 != 0) {\n                      iVar2 = EVP_MAC_final(local_b8,local_a0 + local_f0,0,0x14);\n                      if (iVar2 != 0) {\n                        local_f0 = local_f0 + 0x14;\n                        do {\n                          uVar1 = local_f0 + 1;\n                          local_a0[local_f0] = local_bd;\n                          local_f0 = uVar1;\n                        } while ((uVar1 & 0xf) != 0);\n                        iVar2 = RAND_bytes(local_38,0x10);\n                        iVar2 = FUN_0000787a(\"test/bad_dtls_test.c\",0x14e,\n                                             \"RAND_bytes(iv, sizeof(iv))\",&DAT_0000e9a9,iVar2,0);\n                        if (iVar2 != 0) {\n                          local_b0 = EVP_CIPHER_CTX_new();\n                          iVar2 = FUN_000090bd(\"test/bad_dtls_test.c\",0x14f,\n                                               \"enc_ctx = EVP_CIPHER_CTX_new()\",local_b0);\n                          if (iVar2 != 0) {\n                            cipher = EVP_aes_128_cbc();\n                            EVP_CipherInit_ex(local_b0,cipher,(ENGINE *)0x0,&DAT_00213598,local_38,1\n                                             );\n                            iVar2 = FUN_00009132(\"test/bad_dtls_test.c\",0x151,\n                                                 \"EVP_CipherInit_ex(enc_ctx, EVP_aes_128_cbc(), NULL, enc_key, iv, 1)\"\n                                                );\n                            if (iVar2 != 0) {\n                              iVar2 = EVP_Cipher(local_b0,local_a0,local_a0,(uint)local_f0);\n                              iVar2 = FUN_000078f9(\"test/bad_dtls_test.c\",0x152,\n                                                   \"EVP_Cipher(enc_ctx, enc, enc, len)\",\n                                                   &DAT_0000e9a9,iVar2,0);\n                              if (iVar2 != 0) {\n                                BIO_write(local_d0,local_d4,1);\n                                BIO_write(local_d0,&DAT_00213392,2);\n                                BIO_write(local_d0,&DAT_00213390,2);\n                                BIO_write(local_d0,&DAT_002135d0,6);\n                                local_3a = (undefined)(local_f0 + 0x10 >> 8);\n                                local_39 = (char)local_f0 + '\\x10';\n                                BIO_write(local_d0,&local_3a,2);\n                                BIO_write(local_d0,local_38,0x10);\n                                BIO_write(local_d0,local_a0,(int)local_f0);\n                                local_bc = 1;\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    EVP_MAC_free(local_a8);\n    EVP_MAC_CTX_free(local_b8);\n    EVP_CIPHER_CTX_free(local_b0);\n    CRYPTO_free(local_a0);\n    uVar3 = local_bc;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is send_record"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](BIO *param_1)\n\n{\n  int iVar1;\n  \n  DAT_0021333b = DAT_002134c0;\n  DAT_00213343 = DAT_002134c8;\n  DAT_0021334b = DAT_002134d0;\n  DAT_00213353 = DAT_002134d8;\n  DAT_0021335c = DAT_002134e0;\n  DAT_00213364 = DAT_002134e8;\n  DAT_0021336c = DAT_002134f0;\n  DAT_00213374 = DAT_002134f8;\n  iVar1 = EVP_DigestUpdate(DAT_002135c8,&DAT_00213339,0x46);\n  if (iVar1 != 0) {\n    BIO_write(param_1,&DAT_00213320,0x5f);\n    BIO_write(param_1,&DAT_00213380,0x10);\n  }\n  return iVar1 != 0;\n}\n\n",
        "output": "The predicted function name is send_server_hello"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8\n[MASK](undefined8 param_1,undefined4 param_2,undefined8 param_3,undefined4 param_4,\n            undefined8 param_5,undefined4 param_6,uchar *param_7,int param_8)\n\n{\n  undefined8 uVar1;\n  long in_FS_OFFSET;\n  size_t local_20;\n  EVP_PKEY_CTX *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = EVP_PKEY_CTX_new_id(0x3fd,(ENGINE *)0x0);\n  local_20 = (size_t)param_8;\n  EVP_PKEY_derive_init(local_18);\n  uVar1 = EVP_md5_sha1();\n  EVP_PKEY_CTX_set_tls1_prf_md(local_18,uVar1);\n  EVP_PKEY_CTX_set1_tls1_prf_secret(local_18,&DAT_00213500,0x30);\n  EVP_PKEY_CTX_add1_tls1_prf_seed(local_18,param_1,param_2);\n  EVP_PKEY_CTX_add1_tls1_prf_seed(local_18,param_3,param_4);\n  EVP_PKEY_CTX_add1_tls1_prf_seed(local_18,param_5,param_6);\n  EVP_PKEY_derive(local_18,param_7,&local_20);\n  EVP_PKEY_CTX_free(local_18);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is do_PRF"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](BIO *param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  int local_3c;\n  undefined8 local_38;\n  long local_30;\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = BIO_ctrl(param_1,3,0,&local_38);\n  if (local_30 < 0) {\n    uVar2 = 0;\n  }\n  else {\n    iVar1 = FUN_00003567(local_28,local_38,local_30);\n    if (iVar1 == 0) {\n      uVar2 = 0;\n    }\n    else {\n      iVar1 = FUN_000036e5(local_28,&local_3c);\n      if ((iVar1 == 0) || (local_3c != 0x14)) {\n        uVar2 = 0;\n      }\n      else {\n        iVar1 = FUN_0000365d(local_28,&local_3c);\n        if ((iVar1 == 0) || (local_3c != 0x100)) {\n          uVar2 = 0;\n        }\n        else {\n          iVar1 = FUN_0000385b(local_28,10);\n          if (iVar1 == 0) {\n            uVar2 = 0;\n          }\n          else {\n            iVar1 = FUN_000036e5(local_28,&local_3c);\n            if ((iVar1 == 0) || (local_3c != 1)) {\n              uVar2 = 0;\n            }\n            else {\n              iVar1 = FUN_0000365d(local_28,&local_3c);\n              if ((iVar1 == 0) || (local_3c != 2)) {\n                uVar2 = 0;\n              }\n              else {\n                iVar1 = FUN_000036e5(local_28,&local_3c);\n                if ((iVar1 == 0) || (local_3c != 0x16)) {\n                  uVar2 = 0;\n                }\n                else {\n                  iVar1 = FUN_0000365d(local_28,&local_3c);\n                  if ((iVar1 == 0) || (local_3c != 0x100)) {\n                    uVar2 = 0;\n                  }\n                  else {\n                    iVar1 = FUN_0000365d(local_28,&local_3c);\n                    if ((iVar1 == 0) || (local_3c != 1)) {\n                      uVar2 = 0;\n                    }\n                    else {\n                      uVar2 = 1;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is validate_ccs"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  uchar local_68 [72];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  FUN_00003950(\"key expansion\",0xd,&DAT_002134c0,0x20,&DAT_002134a0,0x20,&DAT_00213560,0x68,param_2,\n               param_1);\n  iVar1 = EVP_DigestFinal_ex(DAT_002135c8,local_68,(uint *)0x0);\n  if (iVar1 == 0) {\n    uVar3 = 0;\n  }\n  else {\n    uVar3 = EVP_MD_CTX_get0_md(DAT_002135c8);\n    uVar2 = EVP_MD_get_size(uVar3);\n    FUN_00003950(\"server finished\",0xf,local_68,uVar2,0,0,&DAT_002133ac,0xc,param_2,param_1);\n    uVar3 = FUN_00003f99(param_2,0x16,0,&DAT_002133a0,0x18);\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is send_finished"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  long in_FS_OFFSET;\n  uchar *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = &DAT_00213260;\n  DAT_0021326f = DAT_002134e0;\n  DAT_00213277 = DAT_002134e8;\n  DAT_0021327f = DAT_002134f0;\n  DAT_00213287 = DAT_002134f8;\n  DAT_00213291 = DAT_00213500;\n  DAT_00213299 = DAT_00213508;\n  DAT_002132a1 = DAT_00213510;\n  DAT_002132a9 = DAT_00213518;\n  DAT_002132b1 = DAT_00213520;\n  DAT_002132b9 = DAT_00213528;\n  d2i_SSL_SESSION((SSL_SESSION **)0x0,&local_18,0x61);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is client_session"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](BIO *param_1)\n\n{\n  int iVar1;\n  long lVar2;\n  long in_FS_OFFSET;\n  int local_50;\n  int local_4c;\n  long local_48;\n  long local_40;\n  undefined local_38 [16];\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_4c = 0;\n  local_50 = 0;\n  local_40 = BIO_ctrl(param_1,3,0,&local_48);\n  if (local_40 < 0) {\n    iVar1 = 0;\n  }\n  else {\n    iVar1 = FUN_00003567(local_38,local_48,local_40);\n    if (iVar1 == 0) {\n      iVar1 = 0;\n    }\n    else {\n      iVar1 = FUN_000036e5(local_38,&local_50);\n      if ((iVar1 == 0) || (local_50 != 0x16)) {\n        iVar1 = 0;\n      }\n      else {\n        iVar1 = FUN_0000365d(local_38,&local_50);\n        if ((iVar1 == 0) || (local_50 != 0x100)) {\n          iVar1 = 0;\n        }\n        else {\n          iVar1 = FUN_0000385b(local_38,10);\n          if (iVar1 == 0) {\n            iVar1 = 0;\n          }\n          else {\n            iVar1 = FUN_000036e5(local_38,&local_50);\n            if ((iVar1 == 0) || (local_50 != 1)) {\n              iVar1 = 0;\n            }\n            else {\n              iVar1 = FUN_0000385b(local_38,0xb);\n              if (iVar1 == 0) {\n                iVar1 = 0;\n              }\n              else {\n                iVar1 = FUN_0000365d(local_38,&local_50);\n                if ((iVar1 == 0) || (local_50 != 0x100)) {\n                  iVar1 = 0;\n                }\n                else {\n                  iVar1 = FUN_0000380b(local_38,&DAT_002134a0,0x20);\n                  if (iVar1 == 0) {\n                    iVar1 = 0;\n                  }\n                  else {\n                    iVar1 = FUN_0000389e(local_38,local_28);\n                    if (iVar1 != 0) {\n                      iVar1 = FUN_000035a5(local_28,&DAT_002134e0,0x20);\n                      if (iVar1 != 0) {\n                        iVar1 = FUN_0000389e(local_38,local_28);\n                        if (iVar1 == 0) {\n                          iVar1 = 0;\n                          goto LAB_00003e63;\n                        }\n                        lVar2 = FUN_00003555(local_28);\n                        if (lVar2 != 0) {\n                          iVar1 = FUN_000035a5(local_28,&DAT_00213530,0x14);\n                          if (iVar1 == 0) {\n                            iVar1 = 0;\n                            goto LAB_00003e63;\n                          }\n                          local_4c = 1;\n                        }\n                        iVar1 = FUN_0000365d(local_38,&local_50);\n                        if (iVar1 != 0) {\n                          iVar1 = FUN_0000385b(local_38,local_50);\n                          if (iVar1 != 0) {\n                            iVar1 = FUN_000036e5(local_38,&local_50);\n                            if (iVar1 != 0) {\n                              iVar1 = FUN_0000385b(local_38,local_50);\n                              if (iVar1 != 0) {\n                                iVar1 = FUN_0000365d(local_38,&local_50);\n                                if (iVar1 != 0) {\n                                  iVar1 = FUN_0000385b(local_38,local_50);\n                                  if (iVar1 != 0) {\n                                    lVar2 = FUN_00003555(local_38);\n                                    if (lVar2 == 0) {\n                                      if (local_4c != 0) {\n                                        iVar1 = EVP_DigestUpdate(DAT_002135c8,\n                                                                 (void *)(local_48 + 0x19),\n                                                                 local_40 - 0x19);\n                                        if (iVar1 == 0) {\n                                          iVar1 = 0;\n                                          goto LAB_00003e63;\n                                        }\n                                      }\n                                      BIO_ctrl(param_1,1,0,(void *)0x0);\n                                      iVar1 = local_4c + 1;\n                                    }\n                                    else {\n                                      iVar1 = 0;\n                                    }\n                                    goto LAB_00003e63;\n                                  }\n                                }\n                                iVar1 = 0;\n                                goto LAB_00003e63;\n                              }\n                            }\n                            iVar1 = 0;\n                            goto LAB_00003e63;\n                          }\n                        }\n                        iVar1 = 0;\n                        goto LAB_00003e63;\n                      }\n                    }\n                    iVar1 = 0;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_00003e63:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar1;\n}\n\n",
        "output": "The predicted function name is validate_client_hello"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  code *pcVar1;\n  __pid_t _Var2;\n  int *piVar3;\n  \n  _Var2 = wait((void *)0x0);\n  if (_Var2 < 0) {\n    pcVar1 = *(code **)(DAT_00202178 + 0x80);\n    piVar3 = __errno_location();\n    (*pcVar1)(DAT_00202180,*piVar3);\n  }\n  FUN_00000c70((double)_Var2,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is do_wait"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  code *pcVar1;\n  __pid_t _Var2;\n  int iVar3;\n  __pid_t _Var4;\n  int *piVar5;\n  undefined8 uVar6;\n  long in_FS_OFFSET;\n  int local_48 [2];\n  undefined8 local_40;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  _Var2 = fork();\n  if (_Var2 < 0) {\n    pcVar1 = *(code **)(DAT_00202178 + 0x80);\n    piVar5 = __errno_location();\n    (*pcVar1)(DAT_00202180,*piVar5);\n  }\n  else if (_Var2 == 0) {\n    iVar3 = (**(code **)(DAT_00202178 + 0xa8))(DAT_00202180,&DAT_00001249,\"PROCINFO\",5,local_48);\n    if (iVar3 != 0) {\n      if (local_48[0] == 5) {\n        _Var4 = getpid();\n        FUN_00000ca6((double)_Var4,local_40,&DAT_00001270);\n        _Var4 = getppid();\n        FUN_00000ca6((double)_Var4,local_40,&DAT_00001274);\n      }\n      else if (*(int *)(DAT_00202178 + 0x18) != 0) {\n        pcVar1 = *(code **)(DAT_00202178 + 0x70);\n        uVar6 = gettext(\"fork: PROCINFO is not an array!\");\n        (*pcVar1)(DAT_00202180,uVar6);\n      }\n    }\n  }\n  FUN_00000c70((double)_Var2,param_2);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is do_fork"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  code *pcVar1;\n  int iVar2;\n  int *piVar3;\n  long in_FS_OFFSET;\n  __pid_t local_50;\n  undefined local_48 [8];\n  double local_40;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_50 = -1;\n  iVar2 = (**(code **)(DAT_00202178 + 0x98))(DAT_00202180,0,1,local_48);\n  if (iVar2 != 0) {\n    local_50 = waitpid((int)local_40,(int *)0x0,3);\n    if (local_50 < 0) {\n      pcVar1 = *(code **)(DAT_00202178 + 0x80);\n      piVar3 = __errno_location();\n      (*pcVar1)(DAT_00202180,*piVar3);\n    }\n  }\n  FUN_00000c70((double)local_50,param_2);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is do_waitpid"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,char *param_3)\n\n{\n  code *pcVar1;\n  undefined8 uVar2;\n  size_t sVar3;\n  undefined8 uVar4;\n  long in_FS_OFFSET;\n  undefined local_68 [32];\n  undefined local_48 [40];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  pcVar1 = *(code **)(DAT_00202178 + 0xe8);\n  uVar2 = FUN_00000c70(param_1,local_48);\n  sVar3 = strlen(param_3);\n  uVar4 = FUN_00000c1f(DAT_00202178,DAT_00202180,param_3,sVar3,1,local_68);\n  (*pcVar1)(DAT_00202180,param_2,uVar4,uVar2);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is array_set_numeric"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](uint param_1,undefined *param_2,undefined param_3,uint param_4,undefined8 param_5,\n                 undefined8 param_6,char *param_7,char *param_8,undefined8 param_9,char *param_10)\n\n{\n  char *pcVar1;\n  int iVar2;\n  size_t sVar3;\n  long lVar4;\n  undefined *puVar5;\n  long in_FS_OFFSET;\n  undefined8 uVar6;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  char local_35 [8];\n  char local_2d [13];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  DAT_0020a019 = param_3;\n  if (((DAT_0020a103 == '\\0') || (DAT_0020a102 == '\\x01')) || (sVar3 = strlen(param_7), 6 < sVar3))\n  {\n    local_35[0] = '\\0';\n  }\n  else {\n    sprintf(local_35,\" %-6s\",param_7);\n  }\n  if ((DAT_0020a102 == '\\x01') || (sVar3 = strlen(param_8), 0xb < sVar3)) {\n    local_2d[0] = '\\0';\n  }\n  else {\n    sprintf(local_2d,\" %10s\",param_8);\n  }\n  if (DAT_0020a106 == '\\0') {\n    lVar4 = 1;\n  }\n  else {\n    sVar3 = strlen(param_10);\n    if (sVar3 < 0xc) {\n      lVar4 = 0xe;\n    }\n    else {\n      sVar3 = strlen(param_10);\n      lVar4 = sVar3 + 2;\n    }\n  }\n  uVar6 = 0x236b;\n  local_40 = (char *)FUN_000069b0(lVar4);\n  if (DAT_0020a106 == '\\0') {\n    *local_40 = '\\0';\n  }\n  else {\n    uVar6 = 0x2399;\n    sprintf(local_40,\" %-12s\",param_10);\n  }\n  if (DAT_0020a105 == '\\0') {\n    puVar5 = &DAT_000073d6;\n  }\n  else {\n    puVar5 = &DAT_0020a018;\n  }\n  if (param_2 == (undefined *)0x0) {\n    param_2 = &DAT_000074ca;\n  }\n  iVar2 = asprintf(&local_50,\"%-8.*s%s %-12.*s %-*s%s%s %-8s%s\",(ulong)param_1,param_2,puVar5,\n                   (ulong)param_4,param_5,(ulong)DAT_0020a118,param_6,local_35,local_2d,param_9,\n                   local_40,uVar6);\n  if (iVar2 == -1) {\n    FUN_00006b51();\n  }\n  pcVar1 = local_50;\n  sVar3 = strlen(local_50);\n  pcVar1 = pcVar1 + sVar3;\n  do {\n    local_48 = pcVar1;\n    pcVar1 = local_48 + -1;\n  } while (*pcVar1 == ' ');\n  *local_48 = '\\0';\n  local_48 = pcVar1;\n  puts(local_50);\n  free(local_50);\n  free(local_40);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is print_line"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  \n  uVar1 = FUN_00002192(param_1);\n  uVar2 = gettext(\"system boot\");\n  FUN_00002228(0xffffffff,&DAT_000073d6,0x20,0xffffffff,uVar2,uVar1,&DAT_000073d6,&DAT_000073d6,\n               &DAT_000073d6,&DAT_000073d6);\n  return;\n}\n\n",
        "output": "The predicted function name is print_boottime"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  void *__ptr;\n  undefined8 uVar1;\n  long in_FS_OFFSET;\n  char local_1c [12];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  __ptr = (void *)FUN_000029a3(param_1);\n  sprintf(local_1c,\"%ld\",(long)*(int *)(param_1 + 4));\n  uVar1 = FUN_00002192(param_1);\n  FUN_00002228(0xffffffff,&DAT_000073d6,0x20,0x20,param_1 + 8,uVar1,&DAT_000073d6,local_1c,__ptr,\n               &DAT_000073d6);\n  free(__ptr);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is print_initspawn"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  size_t sVar5;\n  size_t sVar6;\n  long in_FS_OFFSET;\n  undefined local_229;\n  long local_228;\n  undefined4 *local_220;\n  char *local_218;\n  char *local_210;\n  undefined local_208 [72];\n  long local_1c0;\n  undefined4 local_16b;\n  char local_164 [12];\n  undefined4 local_158;\n  undefined auStack340 [44];\n  char local_128 [264];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_220 = &local_158;\n  sprintf(local_164,\"%ld\",(long)*(int *)(param_1 + 4));\n  if (*(char *)(param_1 + 8) != '/') {\n    local_158 = 0x7665642f;\n    auStack340._0_2_ = 0x2f;\n    local_220 = (undefined4 *)(auStack340 + 1);\n  }\n  FUN_00001feb(local_220,param_1 + 8,0x20);\n  iVar2 = FUN_00007270(&local_158,local_208);\n  if (iVar2 == 0) {\n    cVar1 = FUN_0000249e(local_208);\n    if (cVar1 == '\\0') {\n      local_229 = 0x2d;\n    }\n    else {\n      local_229 = 0x2b;\n    }\n    local_228 = local_1c0;\n  }\n  else {\n    local_229 = 0x3f;\n    local_228 = 0;\n  }\n  if (local_228 == 0) {\n    local_16b = 0x3f2020;\n  }\n  else {\n    uVar3 = FUN_0000204b(local_228,param_2);\n    sprintf((char *)&local_16b,\"%.*s\",6,uVar3);\n  }\n  if (*(char *)(param_1 + 0x4c) == '\\0') {\n    if (DAT_0020a168 == 0) {\n      DAT_0020a168 = 1;\n      free(DAT_0020a170);\n      DAT_0020a170 = (char *)FUN_000069b0(DAT_0020a168);\n    }\n    *DAT_0020a170 = '\\0';\n  }\n  else {\n    local_218 = (char *)0x0;\n    FUN_00001feb(local_128,param_1 + 0x4c,0x100);\n    pcVar4 = strchr(local_128,0x3a);\n    local_210 = pcVar4;\n    if (pcVar4 != (char *)0x0) {\n      local_210 = pcVar4 + 1;\n      *pcVar4 = '\\0';\n    }\n    if ((local_128[0] != '\\0') && (DAT_0020a100 != '\\0')) {\n      local_218 = (char *)FUN_00003b97(local_128);\n    }\n    if (local_218 == (char *)0x0) {\n      local_218 = local_128;\n    }\n    if (local_210 == (char *)0x0) {\n      sVar5 = strlen(local_218);\n      if (DAT_0020a168 < sVar5 + 3) {\n        sVar5 = strlen(local_218);\n        DAT_0020a168 = sVar5 + 3;\n        free(DAT_0020a170);\n        DAT_0020a170 = (char *)FUN_000069b0(DAT_0020a168);\n      }\n      sprintf(DAT_0020a170,\"(%s)\",local_218);\n    }\n    else {\n      sVar5 = strlen(local_218);\n      sVar6 = strlen(local_210);\n      if (DAT_0020a168 < sVar6 + sVar5 + 4) {\n        sVar5 = strlen(local_218);\n        sVar6 = strlen(local_210);\n        DAT_0020a168 = sVar6 + sVar5 + 4;\n        free(DAT_0020a170);\n        DAT_0020a170 = (char *)FUN_000069b0(DAT_0020a168);\n      }\n      sprintf(DAT_0020a170,\"(%s:%s)\",local_218,local_210);\n    }\n    if (local_218 != local_128) {\n      free(local_218);\n    }\n  }\n  pcVar4 = DAT_0020a170;\n  if (DAT_0020a170 == (char *)0x0) {\n    pcVar4 = \"\";\n  }\n  uVar3 = FUN_00002192(param_1);\n  FUN_00002228(0x20,param_1 + 0x2c,local_229,0x20,param_1 + 8,uVar3,&local_16b,local_164,pcVar4,\n               &DAT_000073d6);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is print_user"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](long param_1)\n\n{\n  char *pcVar1;\n  size_t sVar2;\n  char *__src;\n  \n  pcVar1 = (char *)gettext(&DAT_00007513);\n  sVar2 = strlen(pcVar1);\n  pcVar1 = (char *)FUN_000069b0(sVar2 + 5);\n  __src = (char *)gettext(&DAT_00007513);\n  strcpy(pcVar1,__src);\n  strncat(pcVar1,(char *)(param_1 + 0x28),4);\n  return pcVar1;\n}\n\n",
        "output": "The predicted function name is make_id_equals_comment"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  short sVar1;\n  short sVar2;\n  void *__ptr;\n  char *pcVar3;\n  size_t sVar4;\n  size_t sVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  long in_FS_OFFSET;\n  char local_3c [12];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  __ptr = (void *)FUN_000029a3(param_1);\n  sprintf(local_3c,\"%ld\",(long)*(int *)(param_1 + 4));\n  if (DAT_0020a178 == (char *)0x0) {\n    pcVar3 = (char *)gettext(\"term=\");\n    sVar4 = strlen(pcVar3);\n    pcVar3 = (char *)gettext(\"exit=\");\n    sVar5 = strlen(pcVar3);\n    DAT_0020a178 = (char *)FUN_000069b0(sVar5 + sVar4 + 0xe);\n  }\n  sVar1 = *(short *)(param_1 + 0x14e);\n  uVar6 = gettext(\"exit=\");\n  sVar2 = *(short *)(param_1 + 0x14c);\n  uVar7 = gettext(\"term=\");\n  sprintf(DAT_0020a178,\"%s%d %s%d\",uVar7,(ulong)(uint)(int)sVar2,uVar6,(ulong)(uint)(int)sVar1);\n  pcVar3 = DAT_0020a178;\n  uVar6 = FUN_00002192(param_1);\n  FUN_00002228(0xffffffff,&DAT_000073d6,0x20,0x20,param_1 + 8,uVar6,&DAT_000073d6,local_3c,__ptr,\n               pcVar3);\n  free(__ptr);\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is print_deadprocs"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1)\n\n{\n  return (*(uint *)(param_1 + 0x18) & 0x10) != 0;\n}\n\n",
        "output": "The predicted function name is is_tty_writable"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,short *param_2)\n\n{\n  void *__ptr;\n  char *__format;\n  short *local_38;\n  long local_30;\n  long local_20;\n  undefined *local_18;\n  \n  local_20 = 0;\n  local_18 = &DAT_000073d6;\n  local_38 = param_2;\n  local_30 = param_1;\n  while( true ) {\n    if (local_30 == 0) break;\n    if ((*(char *)(local_38 + 0x16) != '\\0') && (*local_38 == 7)) {\n      __ptr = (void *)FUN_00006c30(local_38);\n      printf(\"%s%s\",local_18,__ptr);\n      free(__ptr);\n      local_18 = &DAT_00007560;\n      local_20 = local_20 + 1;\n    }\n    local_38 = local_38 + 0xc0;\n    local_30 = local_30 + -1;\n  }\n  __format = (char *)gettext(\"\\n# users=%lu\\n\");\n  printf(__format,local_20);\n  return;\n}\n\n",
        "output": "The predicted function name is list_entries_who"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  undefined4 uVar1;\n  byte bVar2;\n  char cVar3;\n  int iVar4;\n  char *pcVar5;\n  size_t sVar6;\n  undefined8 uVar7;\n  ulong uVar8;\n  \n  iVar4 = *(int *)(param_1 + 4);\n  if (iVar4 < 0) {\n    iVar4 = iVar4 + 0xff;\n  }\n  bVar2 = (byte)((uint)iVar4 >> 8);\n  uVar1 = *(undefined4 *)(param_1 + 4);\n  if (DAT_0020a180 == (char *)0x0) {\n    pcVar5 = (char *)gettext(\"run-level\");\n    sVar6 = strlen(pcVar5);\n    DAT_0020a180 = (char *)FUN_000069b0(sVar6 + 3);\n  }\n  uVar7 = gettext(\"run-level\");\n  sprintf(DAT_0020a180,\"%s %c\",uVar7,(ulong)(byte)uVar1);\n  if (DAT_0020a188 == (char *)0x0) {\n    pcVar5 = (char *)gettext(\"last=\");\n    sVar6 = strlen(pcVar5);\n    DAT_0020a188 = (char *)FUN_000069b0(sVar6 + 2);\n  }\n  if (bVar2 == 0x4e) {\n    uVar8 = 0x53;\n  }\n  else {\n    uVar8 = (ulong)bVar2;\n  }\n  uVar7 = gettext(\"last=\");\n  sprintf(DAT_0020a188,\"%s%c\",uVar7,uVar8);\n  cVar3 = FUN_00003a71(bVar2);\n  pcVar5 = DAT_0020a188;\n  if (cVar3 == '\\0') {\n    pcVar5 = \"\";\n  }\n  uVar7 = FUN_00002192(param_1);\n  FUN_00002228(0xffffffff,&DAT_000073d6,0x20,0xffffffff,DAT_0020a180,uVar7,&DAT_000073d6,\n               &DAT_000073d6,pcVar5,&DAT_000073d6);\n  return;\n}\n\n",
        "output": "The predicted function name is print_runlevel"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  \n  uVar1 = FUN_00002192(param_1);\n  uVar2 = gettext(\"clock change\");\n  FUN_00002228(0xffffffff,&DAT_000073d6,0x20,0xffffffff,uVar2,uVar1,&DAT_000073d6,&DAT_000073d6,\n               &DAT_000073d6,&DAT_000073d6);\n  return;\n}\n\n",
        "output": "The predicted function name is print_clockchange"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  void *__ptr;\n  undefined8 uVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  char local_2c [12];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  __ptr = (void *)FUN_000029a3(param_1);\n  sprintf(local_2c,\"%ld\",(long)*(int *)(param_1 + 4));\n  uVar1 = FUN_00002192(param_1);\n  uVar2 = gettext(\"LOGIN\");\n  FUN_00002228(0xffffffff,uVar2,0x20,0x20,param_1 + 8,uVar1,&DAT_000073d6,local_2c,__ptr,\n               &DAT_000073d6);\n  free(__ptr);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is print_login"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined4 param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  long in_FS_OFFSET;\n  undefined8 local_30;\n  void *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_00006d5b(param_1,&local_30,&local_28,param_2);\n  if (iVar1 != 0) {\n    uVar2 = FUN_00005ba4(0,3,param_1);\n    piVar3 = __errno_location();\n    error(1,*piVar3,&DAT_0000759b,uVar2);\n  }\n  if (DAT_0020a101 == '\\0') {\n    FUN_000030af(local_30,local_28);\n  }\n  else {\n    FUN_00002f39(local_30,local_28);\n  }\n  free(local_28);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is who"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](char *param_1,int param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  ulong uVar3;\n  undefined8 uVar4;\n  int *piVar5;\n  long in_FS_OFFSET;\n  bool bVar6;\n  int local_22e0;\n  uint local_22dc;\n  long local_22d0;\n  ulong local_22c8;\n  undefined local_22b8 [656];\n  byte local_2028 [8200];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_22d0 = 0;\n  local_22dc = 0;\n  iVar1 = strcmp(param_1,\"-\");\n  bVar6 = iVar1 != 0;\n  if (bVar6) {\n    local_22e0 = open(param_1,0);\n    if (local_22e0 == -1) {\n      uVar4 = FUN_00005321(0,3,param_1);\n      piVar5 = __errno_location();\n      error(0,*piVar5,&DAT_00007786,uVar4);\n      uVar4 = 0;\n      goto LAB_0000244c;\n    }\n  }\n  else {\n    local_22e0 = 0;\n    DAT_0020a0e9 = 1;\n    FUN_00006265(0,0);\n  }\n  while( true ) {\n    uVar3 = FUN_000055d5(local_22e0,local_2028,0x2000);\n    if (uVar3 == 0) break;\n    if (uVar3 == 0xffffffffffffffff) {\n      uVar4 = FUN_00005321(0,3,param_1);\n      piVar5 = __errno_location();\n      error(0,*piVar5,&DAT_00007786,uVar4);\n      if (bVar6) {\n        close(local_22e0);\n      }\n      uVar4 = 0;\n      goto LAB_0000244c;\n    }\n    for (local_22c8 = 0; local_22c8 < uVar3; local_22c8 = local_22c8 + 1) {\n      local_22dc = local_22dc + local_2028[local_22c8];\n    }\n    local_22d0 = local_22d0 + uVar3;\n  }\n  if (bVar6) {\n    iVar1 = close(local_22e0);\n    if (iVar1 != 0) {\n      uVar4 = FUN_00005321(0,3,param_1);\n      piVar5 = __errno_location();\n      error(0,*piVar5,&DAT_00007786,uVar4);\n      uVar4 = 0;\n      goto LAB_0000244c;\n    }\n  }\n  uVar2 = (local_22dc & 0xffff) + (local_22dc >> 0x10);\n  uVar4 = FUN_00002a64(local_22d0,local_22b8,0,1,0x200);\n  printf(\"%d %s\",(ulong)((uVar2 & 0xffff) + ((int)uVar2 >> 0x10)),uVar4);\n  if (param_2 != 0) {\n    printf(\" %s\",param_1);\n  }\n  putchar_unlocked(10);\n  uVar4 = 1;\nLAB_0000244c:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar4;\n}\n\n",
        "output": "The predicted function name is sysv_sum_file"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](char *param_1,int param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  long in_FS_OFFSET;\n  bool bVar4;\n  uint local_2d0;\n  FILE *local_2c8;\n  long local_2c0;\n  undefined local_2b8 [664];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_2d0 = 0;\n  local_2c0 = 0;\n  iVar1 = strcmp(param_1,\"-\");\n  bVar4 = iVar1 != 0;\n  if (bVar4) {\n    local_2c8 = fopen(param_1,\"r\");\n    if (local_2c8 == (FILE *)0x0) {\n      uVar2 = FUN_00005321(0,3,param_1);\n      piVar3 = __errno_location();\n      error(0,*piVar3,&DAT_00007786,uVar2);\n      uVar2 = 0;\n      goto LAB_00002131;\n    }\n  }\n  else {\n    local_2c8 = stdin;\n    DAT_0020a0e9 = 1;\n    FUN_00006265(0,0);\n  }\n  FUN_0000280d(local_2c8,2);\n  while( true ) {\n    iVar1 = getc_unlocked(local_2c8);\n    if (iVar1 == -1) break;\n    local_2c0 = local_2c0 + 1;\n    local_2d0 = (local_2d0 & 1) * 0x8000 + ((int)local_2d0 >> 1) + iVar1 & 0xffff;\n  }\n  iVar1 = ferror_unlocked(local_2c8);\n  if (iVar1 == 0) {\n    if (bVar4) {\n      iVar1 = FUN_00006779(local_2c8);\n      if (iVar1 != 0) {\n        uVar2 = FUN_00005321(0,3,param_1);\n        piVar3 = __errno_location();\n        error(0,*piVar3,&DAT_00007786,uVar2);\n        uVar2 = 0;\n        goto LAB_00002131;\n      }\n    }\n    uVar2 = FUN_00002a64(local_2c0,local_2b8,0,1,0x400);\n    printf(\"%05d %5s\",(ulong)local_2d0,uVar2);\n    if (1 < param_2) {\n      printf(\" %s\",param_1);\n    }\n    putchar_unlocked(10);\n    uVar2 = 1;\n  }\n  else {\n    uVar2 = FUN_00005321(0,3,param_1);\n    piVar3 = __errno_location();\n    error(0,*piVar3,&DAT_00007786,uVar2);\n    if (bVar4) {\n      FUN_00006779(local_2c8);\n    }\n    uVar2 = 0;\n  }\nLAB_00002131:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is bsd_sum_file"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](byte *param_1,uint param_2)\n\n{\n  byte *local_10;\n  \n  local_10 = param_1;\n  while (*local_10 != 0) {\n    FUN_00008236(DAT_002448b0,*local_10 | param_2);\n    local_10 = local_10 + 1;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is attr_addstr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nuint [MASK](int param_1,char *param_2)\n\n{\n  int __fd;\n  uint uVar1;\n  DIR *__dirp;\n  int *piVar2;\n  long lVar3;\n  uint *puVar4;\n  \n  __fd = openat(param_1,param_2,0x30900);\n  if (__fd < 0) {\n    uVar1 = 0;\n  }\n  else {\n    __dirp = fdopendir(__fd);\n    if (__dirp == (DIR *)0x0) {\n      close(__fd);\n      uVar1 = 0;\n    }\n    else {\n      piVar2 = __errno_location();\n      *piVar2 = 0;\n      lVar3 = FUN_000046ad(__dirp);\n      puVar4 = (uint *)__errno_location();\n      uVar1 = *puVar4;\n      closedir(__dirp);\n      puVar4 = (uint *)__errno_location();\n      *puVar4 = uVar1;\n      if (lVar3 == 0) {\n        uVar1 = uVar1 & 0xffffff00 | (uint)(uVar1 == 0);\n      }\n      else {\n        uVar1 = 0;\n      }\n    }\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is is_empty_dir"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined [MASK](undefined8 param_1,undefined8 param_2,char param_3,undefined8 param_4)\n\n{\n  undefined8 uVar1;\n  void *__ptr;\n  undefined local_19;\n  \n  if (DAT_00225110 != '\\0') {\n    FUN_0000f862(param_1);\n  }\n  if (param_3 == '\\0') {\n    local_19 = FUN_00003b08(param_1,param_2,param_4);\n  }\n  else {\n    uVar1 = FUN_0000f7ab(param_1);\n    __ptr = (void *)FUN_0000ff4b(param_2,uVar1,0);\n    FUN_0000f862(__ptr);\n    local_19 = FUN_00003b08(param_1,__ptr,param_4);\n    free(__ptr);\n  }\n  return local_19;\n}\n\n",
        "output": "The predicted function name is movefile"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](long param_1)\n\n{\n  *(undefined8 *)(param_1 + 0x30) = 0xffffffffffffffff;\n  return param_1;\n}\n\n",
        "output": "The predicted function name is cache_stat_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](int param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined8 uVar3;\n  int *piVar4;\n  \n  cVar1 = FUN_00016bfc();\n  if (cVar1 == '\\0') {\n    iVar2 = FUN_000047a2(param_1,param_2,param_3,0x100);\n    if (iVar2 == 0) {\n      if ((*(uint *)(param_3 + 0x18) & 0xf000) == 0xa000) {\n        uVar3 = 0;\n      }\n      else {\n        iVar2 = faccessat(param_1,param_2,2,0x200);\n        if (iVar2 == 0) {\n          uVar3 = 0;\n        }\n        else {\n          piVar4 = __errno_location();\n          if (*piVar4 == 0xd) {\n            uVar3 = 1;\n          }\n          else {\n            uVar3 = 0xffffffff;\n          }\n        }\n      }\n    }\n    else {\n      uVar3 = 0xffffffff;\n    }\n  }\n  else {\n    uVar3 = 0;\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is write_protected_non_symlink"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong [MASK](long param_1,long param_2,long param_3)\n\n{\n  undefined2 uVar1;\n  bool bVar2;\n  char cVar3;\n  undefined uVar4;\n  int iVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  ulong uVar8;\n  undefined8 uVar9;\n  undefined8 uVar10;\n  long in_FS_OFFSET;\n  int local_e0;\n  uint local_dc;\n  uint local_d8;\n  undefined4 local_d4;\n  void *local_d0;\n  long local_c8 [19];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  switch(*(undefined2 *)(param_2 + 0x70)) {\n  default:\n    uVar9 = FUN_00013a0d(0,3,*(undefined8 *)(param_2 + 0x38));\n    uVar1 = *(undefined2 *)(param_2 + 0x70);\n    uVar10 = gettext(\"unexpected failure: fts_info=%d: %s\\nplease report to %s\");\n    error(0,0,uVar10,uVar1,uVar9,\"bug-coreutils@gnu.org\");\n                    /* WARNING: Subroutine does not return */\n    abort();\n  case 1:\n    if ((*(char *)(param_3 + 9) == '\\x01') ||\n       ((*(char *)(param_3 + 10) == '\\x01' &&\n        (cVar3 = FUN_000046ed(*(undefined4 *)(param_1 + 0x2c),*(undefined8 *)(param_2 + 0x30)),\n        cVar3 == '\\x01')))) {\n      if (*(long *)(param_2 + 0x58) == 0) {\n        uVar9 = FUN_0000f7ab(*(undefined8 *)(param_2 + 0x30));\n        cVar3 = FUN_0000464e(uVar9);\n        if (cVar3 != '\\0') {\n          uVar9 = FUN_000137cd(2,4,*(undefined8 *)(param_2 + 0x38));\n          uVar10 = FUN_000137cd(1,4,&DAT_0001dfb0);\n          uVar6 = FUN_000137cd(0,4,&DAT_0001dfb3);\n          uVar7 = gettext(\"refusing to remove %s or %s directory: skipping %s\");\n          error(0,0,uVar7,uVar6,uVar10,uVar9);\n          FUN_00004e1b(param_1,param_2);\n          uVar8 = 4;\n          break;\n        }\n        if (((*(long *)(param_3 + 0x10) != 0) &&\n            (*(long *)(param_2 + 0x80) == **(long **)(param_3 + 0x10))) &&\n           (*(long *)(param_2 + 0x78) == *(long *)(*(long *)(param_3 + 0x10) + 8))) {\n          iVar5 = strcmp(*(char **)(param_2 + 0x38),\"/\");\n          if (iVar5 == 0) {\n            uVar9 = FUN_00013893(4,*(undefined8 *)(param_2 + 0x38));\n            uVar10 = gettext(\"it is dangerous to operate recursively on %s\");\n            error(0,0,uVar10,uVar9);\n          }\n          else {\n            uVar9 = FUN_000137cd(1,4,&DAT_0001dfeb);\n            uVar10 = FUN_000137cd(0,4,*(undefined8 *)(param_2 + 0x38));\n            uVar6 = gettext(\"it is dangerous to operate recursively on %s (same as %s)\");\n            error(0,0,uVar6,uVar10,uVar9);\n          }\n          uVar9 = gettext(\"use --no-preserve-root to override this failsafe\");\n          error(0,0,uVar9);\n          FUN_00004e1b(param_1,param_2);\n          uVar8 = 4;\n          break;\n        }\n        if (*(char *)(param_3 + 0x18) != '\\0') {\n          bVar2 = false;\n          local_d0 = (void *)FUN_0000ff4b(*(undefined8 *)(param_2 + 0x30),&DAT_0001dfb0,0);\n          if ((local_d0 == (void *)0x0) || (iVar5 = FUN_0001d280(local_d0,local_c8), iVar5 != 0)) {\n            uVar9 = FUN_000137cd(1,4,*(undefined8 *)(param_2 + 0x30));\n            uVar10 = FUN_000137cd(0,4,local_d0);\n            uVar6 = gettext(\"failed to stat %s: skipping %s\");\n            error(0,0,uVar6,uVar10,uVar9);\n            bVar2 = true;\n          }\n          free(local_d0);\n          if ((bVar2) || (*(long *)(param_1 + 0x18) != local_c8[0])) {\n            if (!bVar2) {\n              uVar9 = FUN_00013893(4,*(undefined8 *)(param_2 + 0x38));\n              uVar10 = gettext(\"skipping %s, since it\\'s on a different device\");\n              error(0,0,uVar10,uVar9);\n              uVar9 = gettext(\"and --preserve-root=all is in effect\");\n              error(0,0,uVar9);\n            }\n            FUN_00004e1b(param_1,param_2);\n            uVar8 = 4;\n            break;\n          }\n        }\n      }\n      local_dc = FUN_000048e5(param_1,param_2,1,param_3,2,&local_e0);\n      if ((local_dc == 2) && (local_e0 == 4)) {\n        local_dc = FUN_00004ea4(param_1,param_2,param_3,1);\n        FUN_00004e1b(param_1,param_2);\n      }\n      if (local_dc != 2) {\n        FUN_00004e56(param_2);\n        FUN_00004e1b(param_1,param_2);\n      }\n      uVar8 = (ulong)local_dc;\n    }\n    else {\n      if (*(char *)(param_3 + 10) == '\\0') {\n        local_d4 = 0x15;\n      }\n      else {\n        local_d4 = 0x27;\n      }\n      uVar9 = FUN_00013893(4,*(undefined8 *)(param_2 + 0x38));\n      uVar10 = gettext(\"cannot remove %s\");\n      error(0,local_d4,uVar10,uVar9);\n      FUN_00004e56(param_2);\n      FUN_00004e1b(param_1,param_2);\n      uVar8 = 4;\n    }\n    break;\n  case 2:\n    uVar9 = FUN_00013a0d(0,3,*(undefined8 *)(param_2 + 0x38));\n    uVar10 = gettext(\n                    \"WARNING: Circular directory structure.\\nThis almost certainly means that you have a corrupted file system.\\nNOTIFY YOUR SYSTEM MANAGER.\\nThe following directory is part of the cycle:\\n  %s\\n\"\n                    );\n    error(0,0,uVar10,uVar9);\n    FUN_00004e1b(param_1,param_2);\n    uVar8 = 4;\n    break;\n  case 3:\n  case 4:\n  case 6:\n  case 8:\n  case 10:\n  case 0xb:\n  case 0xc:\n  case 0xd:\n    if ((((*(short *)(param_2 + 0x70) == 6) && (*(char *)(param_3 + 8) != '\\0')) &&\n        (0 < *(long *)(param_2 + 0x58))) && (*(long *)(param_2 + 0x78) != *(long *)(param_1 + 0x18))\n       ) {\n      FUN_00004e56(param_2);\n      uVar9 = FUN_00013893(4,*(undefined8 *)(param_2 + 0x38));\n      uVar10 = gettext(\"skipping %s, since it\\'s on a different device\");\n      error(0,0,uVar10,uVar9);\n      uVar8 = 4;\n    }\n    else {\n      if ((*(short *)(param_2 + 0x70) == 6) || (*(short *)(param_2 + 0x70) == 4)) {\n        uVar4 = 1;\n      }\n      else {\n        uVar4 = 0;\n      }\n      local_d8 = FUN_000048e5(param_1,param_2,uVar4,param_3,3,0);\n      if (local_d8 == 2) {\n        uVar8 = FUN_00004ea4(param_1,param_2,param_3,uVar4);\n      }\n      else {\n        uVar8 = (ulong)local_d8;\n      }\n    }\n    break;\n  case 7:\n    uVar9 = FUN_00013a0d(0,3,*(undefined8 *)(param_2 + 0x38));\n    uVar10 = gettext(\"traversal failed: %s\");\n    error(0,*(undefined4 *)(param_2 + 0x40),uVar10,uVar9);\n    FUN_00004e1b(param_1,param_2);\n    uVar8 = 4;\n  }\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar8;\n}\n\n",
        "output": "The predicted function name is rm_fts"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](long *param_1,long param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long lVar3;\n  int *piVar4;\n  undefined8 uVar5;\n  int local_34;\n  undefined4 local_30;\n  \n  local_34 = 2;\n  if (*param_1 != 0) {\n    local_30 = 0x218;\n    if (*(char *)(param_2 + 8) != '\\0') {\n      local_30 = 600;\n    }\n    uVar2 = FUN_00016fb9(param_1,local_30,0);\n    while( true ) {\n      lVar3 = FUN_00018221(uVar2);\n      if (lVar3 == 0) break;\n      iVar1 = FUN_000050eb(uVar2,lVar3,param_2);\n      if (((iVar1 != 2) && (iVar1 != 3)) && (iVar1 != 4)) {\n                    /* WARNING: Subroutine does not return */\n        __assert_fail(\"VALID_STATUS (s)\",\"src/remove.c\",0x261,\"rm\");\n      }\n      if ((iVar1 == 4) || ((iVar1 == 3 && (local_34 == 2)))) {\n        local_34 = iVar1;\n      }\n    }\n    piVar4 = __errno_location();\n    if (*piVar4 != 0) {\n      uVar5 = gettext(\"fts_read failed\");\n      piVar4 = __errno_location();\n      error(0,*piVar4,uVar5);\n      local_34 = 4;\n    }\n    iVar1 = FUN_00017d83(uVar2);\n    if (iVar1 != 0) {\n      uVar2 = gettext(\"fts_close failed\");\n      piVar4 = __errno_location();\n      error(0,*piVar4,uVar2);\n      local_34 = 4;\n    }\n  }\n  return local_34;\n}\n\n",
        "output": "The predicted function name is rm"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined *param_1)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  \n  *param_1 = 0;\n  param_1[10] = 1;\n  param_1[9] = 1;\n  param_1[8] = 0;\n  *(undefined4 *)(param_1 + 4) = 5;\n  param_1[0x19] = 0;\n  param_1[0x1a] = 0;\n  param_1[0x1b] = 1;\n  uVar1 = FUN_000140c7(&DAT_00225120);\n  *(undefined8 *)(param_1 + 0x10) = uVar1;\n  if (*(long *)(param_1 + 0x10) == 0) {\n    uVar1 = FUN_00013893(4,&DAT_0001d6e6);\n    uVar2 = gettext(\"failed to get attributes of %s\");\n    piVar3 = __errno_location();\n    error(1,*piVar3,uVar2,uVar1);\n  }\n  param_1[0x18] = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is rm_option_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](char *param_1,undefined4 param_2)\n\n{\n  char cVar1;\n  \n  if ((*param_1 != '\\0') && (cVar1 = FUN_00004daf(param_2), cVar1 != '\\0')) {\n    return 1;\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is ignorable_missing"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](int param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (param_1 == 0x14) {\nLAB_00004dd4:\n    uVar1 = 1;\n  }\n  else {\n    if (param_1 < 0x15) {\n      if (param_1 == 2) goto LAB_00004dd4;\n    }\n    else if ((param_1 == 0x16) || (param_1 == 0x54)) goto LAB_00004dd4;\n    uVar1 = 0;\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is nonexistent_file_errno"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined4 param_1,undefined8 param_2,long param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  \n  if (*(long *)(param_3 + 0x30) == -1) {\n    iVar1 = FUN_0001d290(param_1,param_2,param_3,param_4);\n    if (iVar1 != 0) {\n      *(undefined8 *)(param_3 + 0x30) = 0xfffffffffffffffe;\n      piVar2 = __errno_location();\n      *(long *)(param_3 + 8) = (long)*piVar2;\n    }\n  }\n  if (*(long *)(param_3 + 0x30) < 0) {\n    uVar3 = *(undefined8 *)(param_3 + 8);\n    piVar2 = __errno_location();\n    *piVar2 = (int)uVar3;\n    uVar3 = 0xffffffff;\n  }\n  else {\n    uVar3 = 0;\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is cache_fstatat"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,long param_2,long param_3,char param_4)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined8 uVar3;\n  char *__format;\n  int *piVar4;\n  undefined8 uVar5;\n  long in_FS_OFFSET;\n  undefined local_b8 [152];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_4 == '\\0') {\n    iVar2 = 0;\n  }\n  else {\n    iVar2 = 0x200;\n  }\n  iVar2 = unlinkat(*(int *)(param_1 + 0x2c),*(char **)(param_2 + 0x30),iVar2);\n  if (iVar2 == 0) {\n    if (*(char *)(param_3 + 0x1a) != '\\0') {\n      uVar3 = FUN_00013893(4,*(undefined8 *)(param_2 + 0x38));\n      if (param_4 == '\\0') {\n        __format = (char *)gettext(\"removed %s\\n\");\n      }\n      else {\n        __format = (char *)gettext(\"removed directory %s\\n\");\n      }\n      printf(__format,uVar3);\n    }\n    uVar3 = 2;\n    goto LAB_000050cb;\n  }\n  piVar4 = __errno_location();\n  if (*piVar4 == 0x1e) {\n    iVar2 = FUN_000149a7(*(undefined4 *)(param_1 + 0x2c),*(undefined8 *)(param_2 + 0x30),local_b8);\n    if (iVar2 != 0) {\n      piVar4 = __errno_location();\n      if (*piVar4 == 2) goto LAB_00004fd6;\n    }\n    piVar4 = __errno_location();\n    *piVar4 = 0x1e;\n  }\nLAB_00004fd6:\n  piVar4 = __errno_location();\n  cVar1 = FUN_00004de2(param_3,*piVar4);\n  if (cVar1 != '\\0') {\n    uVar3 = 2;\n    goto LAB_000050cb;\n  }\n  if (*(short *)(param_2 + 0x70) == 4) {\n    piVar4 = __errno_location();\n    if (*piVar4 != 0x27) {\n      piVar4 = __errno_location();\n      if (*piVar4 != 0x15) {\n        piVar4 = __errno_location();\n        if (*piVar4 != 0x14) {\n          piVar4 = __errno_location();\n          if (*piVar4 != 0x11) goto LAB_0000506f;\n        }\n      }\n    }\n    if ((*(int *)(param_2 + 0x40) == 1) || (*(int *)(param_2 + 0x40) == 0xd)) {\n      piVar4 = __errno_location();\n      *piVar4 = *(int *)(param_2 + 0x40);\n    }\n  }\nLAB_0000506f:\n  uVar3 = FUN_00013893(4,*(undefined8 *)(param_2 + 0x38));\n  uVar5 = gettext(\"cannot remove %s\");\n  piVar4 = __errno_location();\n  error(0,*piVar4,uVar5,uVar3);\n  FUN_00004e56(param_2);\n  uVar3 = 4;\nLAB_000050cb:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is excise"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00018921(param_1,param_2,4);\n  FUN_00018221(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is fts_skip_tree"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar [MASK](long param_1,undefined8 param_2,long param_3)\n\n{\n  long in_FS_OFFSET;\n  char local_57;\n  char local_56;\n  char local_55;\n  int local_54;\n  long local_50;\n  undefined local_48 [26];\n  undefined local_2e;\n  long local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_55 = FUN_0000c082(param_1,param_2,0,param_3,&local_57,&local_56);\n  if (local_55 != '\\0') {\n    if (local_57 == '\\0') {\n      local_50 = param_1;\n      if (local_56 != '\\0') {\n        local_50 = 0;\n      }\n    }\n    else {\n      local_50 = 0;\n      local_55 = '\\0';\n    }\n    if (local_50 != 0) {\n      FUN_000037e2(local_48);\n      local_2e = *(undefined *)(param_3 + 0x2e);\n      local_28 = local_50;\n      local_20 = 0;\n      local_54 = FUN_0000599b(&local_28,local_48);\n      if (((local_54 != 2) && (local_54 != 3)) && (local_54 != 4)) {\n                    /* WARNING: Subroutine does not return */\n        __assert_fail(\"VALID_STATUS (status)\",\"src/mv.c\",0xef,\"do_move\");\n      }\n      if (local_54 == 4) {\n        local_55 = '\\0';\n      }\n    }\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_55;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is do_move"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  long local_10;\n  \n  for (local_10 = *(long *)(param_1 + 8);\n      (-1 < *(long *)(local_10 + 0x58) && (*(long *)(local_10 + 0x20) == 0));\n      local_10 = *(long *)(local_10 + 8)) {\n    *(undefined8 *)(local_10 + 0x20) = 1;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is mark_ancestor_dirs"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  int iVar1;\n  char *pcVar2;\n  long in_FS_OFFSET;\n  undefined8 uVar3;\n  int local_1c8;\n  long local_1c0;\n  long local_1b8;\n  long local_1b0;\n  undefined4 local_1a8;\n  undefined4 local_1a4;\n  int local_1a0;\n  int local_19c;\n  int local_198;\n  undefined4 local_194;\n  undefined auStack400 [256];\n  char local_90 [128];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_1c0 = 0;\n  local_1b8 = 0;\n  do {\n    iVar1 = __isoc99_fscanf(stdin,\"%255s\",auStack400);\n    if (iVar1 != 1) {\n      if (local_1b8 != 0) {\n        (*wget_free)(local_1b8);\n        local_1b8 = 0;\n      }\n      if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return 0;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    if (local_1b8 != 0) {\n      (*wget_free)(local_1b8);\n      local_1b8 = 0;\n    }\n    iVar1 = wget_strncasecmp_ascii(auStack400,\"http://\",7);\n    if (iVar1 == 0) {\n      local_1b8 = wget_strdup(auStack400);\n    }\n    else {\n      iVar1 = wget_strncasecmp_ascii(auStack400,\"https://\",8);\n      if (iVar1 == 0) {\n        local_1b8 = wget_strdup(auStack400);\n      }\n      else {\n        local_1b8 = wget_aprintf(\"http://%s\",auStack400);\n      }\n    }\n    local_1a4 = 0;\n    local_1a8 = 0;\n    local_1a0 = -1;\n    local_194 = 0;\n    local_198 = 0;\n    local_19c = 0;\n    local_90[0] = '\\0';\n    for (local_1c8 = 0; local_1c8 < 5; local_1c8 = local_1c8 + 1) {\n      wget_http_free_response(&local_1c0);\n      if (local_1c8 == 0) {\n        pcVar2 = \"\";\n      }\n      else {\n        pcVar2 = \"  -> \";\n      }\n      uVar3 = 0x1a2b;\n      wget_info_printf(\"%s%s\\n\",pcVar2,local_1b8);\n      local_1c0 = wget_http_get(2000,local_1b8,0x7d4,\"User-Agent\",\"Mozilla/5.0\",0x7d4,\n                                \"Accept-Encoding\",\"gzip, br\",0x7d4,\"Accept\",\n                                \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\n                                0x7d4,\"Accept-Encoding\",\"gzip, br\",0x7da,0,0,uVar3);\n      if (local_1c0 == 0) {\n        wget_info_printf(\"  No connection / response\\n\");\n        break;\n      }\n      snprintf(local_90,0x80,\"%s\",*(undefined8 *)(local_1c0 + 0x30));\n      local_1a0 = (int)*(short *)(local_1c0 + 0xc0);\n      if (*(short *)(local_1c0 + 0xc0) == 200) {\n        iVar1 = wget_strncasecmp(local_1b8,\"https://\",8);\n        if (iVar1 == 0) {\n          local_194 = 1;\n        }\n        break;\n      }\n      if (*(long *)(local_1c0 + 0x48) == 0) {\n        wget_info_printf(\"  Response code %hd\\n\",(int)*(short *)(local_1c0 + 0xc0));\n        break;\n      }\n      local_19c = local_19c + 1;\n      wget_info_printf(\"  Response code %hd, %s\\n\",(int)*(short *)(local_1c0 + 0xc0),\n                       *(undefined8 *)(local_1c0 + 0x48));\n      local_1b0 = FUN_00001544(local_1b8,*(undefined8 *)(local_1c0 + 0x48));\n      if (local_1b0 == 0) {\n        wget_info_printf(\"  Failed to normalize \\'%s\\', \\'%s\\'\\n\",local_1b8,\n                         *(undefined8 *)(local_1c0 + 0x48));\n        break;\n      }\n      if (local_1b8 != 0) {\n        (*wget_free)(local_1b8);\n      }\n      local_1b8 = local_1b0;\n      iVar1 = wget_strncasecmp(local_1b0,\"https://\",8);\n      if (iVar1 != 0) {\n        local_198 = local_198 + 1;\n      }\n    }\n    wget_http_free_response(&local_1c0);\n    FUN_0000134a(&local_1a8);\n  } while( true );\n}\n\n",
        "output": "The predicted function name is downloader_thread"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](int param_1,int param_2)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  char *pcVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  long in_FS_OFFSET;\n  undefined8 local_d8;\n  undefined8 local_d0;\n  undefined8 local_c8;\n  undefined8 local_c0;\n  undefined8 local_b8;\n  int local_a0;\n  int local_9c;\n  undefined4 local_94;\n  undefined8 local_90;\n  undefined8 local_88;\n  void *local_80;\n  undefined8 local_78;\n  undefined8 local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_94 = 0;\n  local_90 = 0;\n  local_88 = 0;\n  if (param_1 == 0) {\n    pcVar4 = \"label\";\n  }\n  else {\n    pcVar4 = (char *)0x0;\n  }\n  if (param_2 == 0) {\n    pcVar3 = (char *)0x0;\n  }\n  else {\n    pcVar3 = \"sha256\";\n  }\n  local_a0 = param_2;\n  local_9c = param_1;\n  local_80 = (void *)FUN_000037e4(pcVar3,\"secret\",6,&DAT_00013cf5,pcVar4);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0xfe,\n                       \"params = construct_hkdf_params( has_digest ? \\\"sha256\\\" : NULL, \\\"secret\\\", 6, \\\"salt\\\", expand_only ? NULL : \\\"label\\\")\"\n                       ,local_80);\n  if (iVar1 != 0) {\n    local_88 = FUN_00002d68(&DAT_00013d1b);\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0xff,\"kctx = get_kdfbyname(OSSL_KDF_NAME_HKDF)\",\n                         local_88);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_88,local_80);\n      iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0x100,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        local_78 = EVP_KDF_CTX_gettable_params(local_88);\n        iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x104,\n                             \"gettables = EVP_KDF_CTX_gettable_params(kctx)\",local_78);\n        if (iVar1 != 0) {\n          local_70 = OSSL_PARAM_locate_const(local_78,&DAT_00013df6);\n          iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x105,\n                               \"p = OSSL_PARAM_locate_const(gettables, OSSL_KDF_PARAM_SIZE)\",\n                               local_70);\n          if (iVar1 != 0) {\n            OSSL_PARAM_construct_size_t(&local_d8,&DAT_00013df6,&local_90);\n            local_68 = local_d8;\n            local_60 = local_d0;\n            local_58 = local_c8;\n            local_50 = local_c0;\n            local_48 = local_b8;\n            OSSL_PARAM_construct_end(&local_d8);\n            local_40 = local_d8;\n            local_38 = local_d0;\n            local_30 = local_c8;\n            local_28 = local_c0;\n            local_20 = local_b8;\n            if (local_a0 == 0) {\n              uVar2 = EVP_KDF_CTX_get_params(local_88,&local_68);\n              iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x110,\n                                   \"EVP_KDF_CTX_get_params(kctx, params_get)\",&DAT_00013c2d,uVar2,0)\n              ;\n            }\n            else {\n              uVar2 = EVP_KDF_CTX_get_params(local_88,&local_68);\n              iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x10c,\n                                   \"EVP_KDF_CTX_get_params(kctx, params_get)\",&DAT_00013cc4,uVar2,1)\n              ;\n              if (iVar1 == 0) goto LAB_00003fb4;\n              if (local_9c == 0) {\n                uVar5 = 0xffffffffffffffff;\n              }\n              else {\n                uVar5 = 0x20;\n              }\n              iVar1 = FUN_0000db1e(\"test/evp_kdf_test.c\",0x10d,&DAT_00013e9e,\n                                   \"expand_only ? SHA256_DIGEST_LENGTH : SIZE_MAX\",local_90,uVar5);\n            }\n            if (iVar1 != 0) {\n              OSSL_PARAM_construct_end(&local_d8);\n              local_68 = local_d8;\n              local_60 = local_d0;\n              local_58 = local_c8;\n              local_50 = local_c0;\n              local_48 = local_b8;\n              uVar2 = EVP_KDF_CTX_get_params(local_88,&local_68);\n              iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x116,\n                                   \"EVP_KDF_CTX_get_params(kctx, params_get)\",&DAT_00013ea1,uVar2,\n                                   0xfffffffe);\n              if (iVar1 != 0) {\n                local_94 = 1;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_00003fb4:\n  EVP_KDF_CTX_free(local_88);\n  CRYPTO_free(local_80);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_94;\n}\n\n",
        "output": "The predicted function name is do_kdf_hkdf_gettables"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long lVar3;\n  long in_FS_OFFSET;\n  undefined8 local_1b8;\n  undefined8 local_1b0;\n  undefined8 local_1a8;\n  undefined8 local_1a0;\n  undefined8 local_198;\n  int local_17c;\n  int local_178;\n  int local_174;\n  undefined8 local_170;\n  undefined8 local_168 [4];\n  undefined8 uStack328;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_17c = 0;\n  local_48 = 0;\n  local_40 = 0;\n  local_38 = 0;\n  local_30 = 0;\n  for (local_178 = 0; local_178 < 3; local_178 = local_178 + 1) {\n    local_174 = 1;\n    OSSL_PARAM_construct_utf8_string(&local_1b8,\"cipher\",\"CAMELLIA-256-CBC\",0);\n    local_168[0] = local_1b8;\n    local_168[1] = local_1b0;\n    local_168[2] = local_1a8;\n    local_168[3] = local_1a0;\n    uStack328 = local_198;\n    lVar3 = (long)local_174;\n    local_174 = local_174 + 1;\n    OSSL_PARAM_construct_utf8_string(&local_1b8,&DAT_000141e1,&DAT_000141dc,0);\n    local_168[lVar3 * 5] = local_1b8;\n    local_168[lVar3 * 5 + 1] = local_1b0;\n    local_168[lVar3 * 5 + 2] = local_1a8;\n    local_168[lVar3 * 5 + 3] = local_1a0;\n    local_168[lVar3 * 5 + 4] = local_198;\n    lVar3 = (long)local_174;\n    local_174 = local_174 + 1;\n    OSSL_PARAM_construct_utf8_string(&local_1b8,&DAT_00013d10,\"FEEDBACK\",0);\n    local_168[lVar3 * 5] = local_1b8;\n    local_168[lVar3 * 5 + 1] = local_1b0;\n    local_168[lVar3 * 5 + 2] = local_1a8;\n    local_168[lVar3 * 5 + 3] = local_1a0;\n    local_168[lVar3 * 5 + 4] = local_198;\n    lVar3 = (long)local_174;\n    local_174 = local_174 + 1;\n    OSSL_PARAM_construct_octet_string(&local_1b8,&DAT_00013cfa,&DAT_00219160,0x20);\n    local_168[lVar3 * 5] = local_1b8;\n    local_168[lVar3 * 5 + 1] = local_1b0;\n    local_168[lVar3 * 5 + 2] = local_1a8;\n    local_168[lVar3 * 5 + 3] = local_1a0;\n    local_168[lVar3 * 5 + 4] = local_198;\n    lVar3 = (long)local_174;\n    local_174 = local_174 + 1;\n    OSSL_PARAM_construct_octet_string\n              (&local_1b8,&DAT_00013cf5,&DAT_00219180 + (long)local_178 * 5,5);\n    local_168[lVar3 * 5] = local_1b8;\n    local_168[lVar3 * 5 + 1] = local_1b0;\n    local_168[lVar3 * 5 + 2] = local_1a8;\n    local_168[lVar3 * 5 + 3] = local_1a0;\n    local_168[lVar3 * 5 + 4] = local_198;\n    lVar3 = (long)local_174;\n    local_174 = local_174 + 1;\n    OSSL_PARAM_construct_octet_string(&local_1b8,&DAT_00013be2,&DAT_00219560,0x10);\n    local_168[lVar3 * 5] = local_1b8;\n    local_168[lVar3 * 5 + 1] = local_1b0;\n    local_168[lVar3 * 5 + 2] = local_1a8;\n    local_168[lVar3 * 5 + 3] = local_1a0;\n    local_168[lVar3 * 5 + 4] = local_198;\n    lVar3 = (long)local_174;\n    OSSL_PARAM_construct_end(&local_1b8);\n    local_168[lVar3 * 5] = local_1b8;\n    local_168[lVar3 * 5 + 1] = local_1b0;\n    local_168[lVar3 * 5 + 2] = local_1a8;\n    local_168[lVar3 * 5 + 3] = local_1a0;\n    local_168[lVar3 * 5 + 4] = local_198;\n    local_170 = FUN_00002d68(\"KBKDF\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x420,&DAT_000141f4,local_170);\n    if (iVar1 == 0) {\nLAB_00007695:\n      local_17c = 0;\n    }\n    else {\n      uVar2 = EVP_KDF_derive(local_170,&local_48,0x20,local_168);\n      iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x422,\n                           \"EVP_KDF_derive(kctx, result, sizeof(result), params)\",&DAT_00013c2d,\n                           uVar2,0);\n      if ((iVar1 == 0) ||\n         (iVar1 = FUN_0000e848(\"test/evp_kdf_test.c\",0x424,\"result\",\"outputs[i]\",&local_48,0x20,\n                               &DAT_002191a0 + (long)local_178 * 0x20,0x20), iVar1 == 0))\n      goto LAB_00007695;\n      local_17c = 1;\n    }\n    EVP_KDF_CTX_free(local_170);\n    if (local_17c != 1) break;\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_17c;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_kdf_kbkdf_6803_256"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  long in_FS_OFFSET;\n  undefined8 local_38;\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = 0;\n  ptr = (void *)FUN_00002d87(\"sha256\",\"secret\",&DAT_00013be2);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x6d,\"params\",ptr);\n  if (iVar1 != 0) {\n    local_38 = FUN_00002d68(\"TLS1-PRF\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x6e,\"kctx = get_kdfbyname(OSSL_KDF_NAME_TLS1_PRF)\",\n                         local_38);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_38,ptr);\n      iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0x6f,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        uVar2 = EVP_KDF_derive(local_38,local_28,0,0);\n        iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x70,\"EVP_KDF_derive(kctx, out, 0, NULL)\",\n                             &DAT_00013c2d,uVar2,0);\n        if (iVar1 != 0) {\n          uVar2 = 1;\n          goto LAB_000032bd;\n        }\n      }\n    }\n  }\n  uVar2 = 0;\nLAB_000032bd:\n  EVP_KDF_CTX_free(local_38);\n  CRYPTO_free(ptr);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_tls1_prf_zero_output_size"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  size_t sVar3;\n  long lVar4;\n  long in_FS_OFFSET;\n  undefined8 local_1a8;\n  undefined8 local_1a0;\n  undefined8 local_198;\n  undefined8 local_190;\n  undefined8 local_188;\n  int local_178;\n  undefined4 local_174;\n  char *local_170;\n  char *local_168;\n  char *local_160;\n  undefined *local_158;\n  undefined8 local_150;\n  undefined8 local_148 [4];\n  undefined8 uStack296;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_170 = \"prf\";\n  local_168 = \"sha384\";\n  local_160 = \"test\";\n  local_158 = &DAT_00014269;\n  local_58 = 0;\n  local_50 = 0;\n  local_48 = 0;\n  local_40 = 0;\n  local_38 = 0;\n  local_30 = 0;\n  local_178 = 1;\n  OSSL_PARAM_construct_utf8_string(&local_1a8,\"digest\",\"sha384\",0);\n  local_148[0] = local_1a8;\n  local_148[1] = local_1a0;\n  local_148[2] = local_198;\n  local_148[3] = local_190;\n  uStack296 = local_188;\n  lVar4 = (long)local_178;\n  local_178 = local_178 + 1;\n  OSSL_PARAM_construct_utf8_string(&local_1a8,&DAT_000141e1,local_158,0);\n  local_148[lVar4 * 5] = local_1a8;\n  local_148[lVar4 * 5 + 1] = local_1a0;\n  local_148[lVar4 * 5 + 2] = local_198;\n  local_148[lVar4 * 5 + 3] = local_190;\n  local_148[lVar4 * 5 + 4] = local_188;\n  lVar4 = (long)local_178;\n  local_178 = local_178 + 1;\n  OSSL_PARAM_construct_octet_string(&local_1a8,&DAT_00013cfa,&DAT_00219240,0x20);\n  local_148[lVar4 * 5] = local_1a8;\n  local_148[lVar4 * 5 + 1] = local_1a0;\n  local_148[lVar4 * 5 + 2] = local_198;\n  local_148[lVar4 * 5 + 3] = local_190;\n  local_148[lVar4 * 5 + 4] = local_188;\n  sVar3 = strlen(local_170);\n  lVar4 = (long)local_178;\n  local_178 = local_178 + 1;\n  OSSL_PARAM_construct_octet_string(&local_1a8,&DAT_00013cf5,local_170,sVar3);\n  local_148[lVar4 * 5] = local_1a8;\n  local_148[lVar4 * 5 + 1] = local_1a0;\n  local_148[lVar4 * 5 + 2] = local_198;\n  local_148[lVar4 * 5 + 3] = local_190;\n  local_148[lVar4 * 5 + 4] = local_188;\n  sVar3 = strlen(local_160);\n  lVar4 = (long)local_178;\n  local_178 = local_178 + 1;\n  OSSL_PARAM_construct_octet_string(&local_1a8,&DAT_00013cfe,local_160,sVar3);\n  local_148[lVar4 * 5] = local_1a8;\n  local_148[lVar4 * 5 + 1] = local_1a0;\n  local_148[lVar4 * 5 + 2] = local_198;\n  local_148[lVar4 * 5 + 3] = local_190;\n  local_148[lVar4 * 5 + 4] = local_188;\n  lVar4 = (long)local_178;\n  OSSL_PARAM_construct_end(&local_1a8);\n  local_148[lVar4 * 5] = local_1a8;\n  local_148[lVar4 * 5 + 1] = local_1a0;\n  local_148[lVar4 * 5 + 2] = local_198;\n  local_148[lVar4 * 5 + 3] = local_190;\n  local_148[lVar4 * 5 + 4] = local_188;\n  local_150 = FUN_00002d68(\"KBKDF\");\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x508,&DAT_000141f4,local_150);\n  if (iVar1 != 0) {\n    uVar2 = EVP_KDF_derive(local_150,&local_58,0x30,local_148);\n    iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x509,\n                         \"EVP_KDF_derive(kctx, result, sizeof(result), params)\",&DAT_00013c2d,uVar2,\n                         0);\n    if (iVar1 != 0) {\n      iVar1 = FUN_0000e848(\"test/evp_kdf_test.c\",0x50a,\"result\",\"output\",&local_58,0x30,\n                           &DAT_00219260,0x30);\n      if (iVar1 != 0) {\n        local_174 = 1;\n        goto LAB_000089ad;\n      }\n    }\n  }\n  local_174 = 0;\nLAB_000089ad:\n  EVP_KDF_CTX_free(local_150);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_174;\n}\n\n",
        "output": "The predicted function name is test_kdf_kbkdf_8009_prf2"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  int iVar3;\n  undefined4 uVar4;\n  long in_FS_OFFSET;\n  undefined8 local_1c8;\n  undefined8 local_1c0;\n  undefined8 local_1b8;\n  undefined8 local_1b0;\n  undefined8 local_1a8;\n  undefined4 local_194;\n  undefined4 local_190;\n  undefined4 local_18c;\n  undefined8 *local_188;\n  undefined8 local_180;\n  undefined8 local_178;\n  undefined8 uStack368;\n  undefined8 uStack360;\n  undefined8 uStack352;\n  undefined8 uStack344;\n  undefined8 auStack336 [35];\n  undefined8 local_38;\n  undefined8 local_30;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_194 = 0;\n  local_190 = 0;\n  local_38 = 0;\n  local_30 = 0;\n  local_188 = auStack336;\n  OSSL_PARAM_construct_utf8_string(&local_1c8,\"cipher\",PTR_s_AES128_00219478,0);\n  puVar2 = local_188;\n  local_178 = local_1c8;\n  uStack368 = local_1c0;\n  uStack360 = local_1b8;\n  uStack352 = local_1b0;\n  uStack344 = local_1a8;\n  local_188 = local_188 + 5;\n  OSSL_PARAM_construct_utf8_string(&local_1c8,&DAT_000141e1,PTR_DAT_00219480,0);\n  uVar1 = local_1c0;\n  *puVar2 = local_1c8;\n  puVar2[1] = uVar1;\n  uVar1 = local_1b0;\n  puVar2[2] = local_1b8;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_1a8;\n  puVar2 = local_188;\n  local_188 = local_188 + 5;\n  OSSL_PARAM_construct_utf8_string(&local_1c8,&DAT_00013d10,PTR_s_COUNTER_00219488,0);\n  uVar1 = local_1c0;\n  *puVar2 = local_1c8;\n  puVar2[1] = uVar1;\n  uVar1 = local_1b0;\n  puVar2[2] = local_1b8;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_1a8;\n  puVar2 = local_188;\n  local_188 = local_188 + 5;\n  OSSL_PARAM_construct_octet_string(&local_1c8,&DAT_00013cfa,&DAT_00219290,0x10);\n  uVar1 = local_1c0;\n  *puVar2 = local_1c8;\n  puVar2[1] = uVar1;\n  uVar1 = local_1b0;\n  puVar2[2] = local_1b8;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_1a8;\n  puVar2 = local_188;\n  local_188 = local_188 + 5;\n  OSSL_PARAM_construct_octet_string(&local_1c8,&DAT_00013cfe,&DAT_002192a0,0x3c);\n  uVar1 = local_1c0;\n  *puVar2 = local_1c8;\n  puVar2[1] = uVar1;\n  uVar1 = local_1b0;\n  puVar2[2] = local_1b8;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_1a8;\n  puVar2 = local_188;\n  local_188 = local_188 + 5;\n  OSSL_PARAM_construct_int(&local_1c8,\"use-l\",&local_194);\n  uVar1 = local_1c0;\n  *puVar2 = local_1c8;\n  puVar2[1] = uVar1;\n  uVar1 = local_1b0;\n  puVar2[2] = local_1b8;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_1a8;\n  puVar2 = local_188;\n  local_188 = local_188 + 5;\n  OSSL_PARAM_construct_int(&local_1c8,\"use-separator\",&local_190);\n  uVar1 = local_1c0;\n  *puVar2 = local_1c8;\n  puVar2[1] = uVar1;\n  uVar1 = local_1b0;\n  puVar2[2] = local_1b8;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_1a8;\n  puVar2 = local_188;\n  OSSL_PARAM_construct_end(&local_1c8);\n  *puVar2 = local_1c8;\n  puVar2[1] = local_1c0;\n  puVar2[2] = local_1b8;\n  puVar2[3] = local_1b0;\n  puVar2[4] = local_1a8;\n  local_180 = FUN_00002d68(\"KBKDF\");\n  iVar3 = FUN_0000e315(\"test/evp_kdf_test.c\",0x544,&DAT_000141f4,local_180);\n  if (iVar3 != 0) {\n    uVar4 = EVP_KDF_derive(local_180,&local_38,0x10,&local_178);\n    iVar3 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x545,\n                         \"EVP_KDF_derive(kctx, result, sizeof(result), params)\",&DAT_00013c2d,uVar4,\n                         0);\n    if (iVar3 != 0) {\n      iVar3 = FUN_0000e848(\"test/evp_kdf_test.c\",0x546,\"result\",\"output\",&local_38,0x10,\n                           &DAT_002192e0,0x10);\n      if (iVar3 != 0) {\n        local_18c = 1;\n        goto LAB_00008e2c;\n      }\n    }\n  }\n  local_18c = 0;\nLAB_00008e2c:\n  EVP_KDF_CTX_free(local_180);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_18c;\n}\n\n",
        "output": "The predicted function name is test_kdf_kbkdf_fixedinfo"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  size_t sVar3;\n  long lVar4;\n  long in_FS_OFFSET;\n  undefined8 local_198;\n  undefined8 local_190;\n  undefined8 local_188;\n  undefined8 local_180;\n  undefined8 local_178;\n  int local_168;\n  undefined4 local_164;\n  char *local_160;\n  char *local_158;\n  char *local_150;\n  undefined *local_148;\n  undefined8 local_140;\n  undefined8 local_138 [4];\n  undefined8 uStack280;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_160 = \"prf\";\n  local_158 = \"sha256\";\n  local_150 = \"test\";\n  local_148 = &DAT_00014269;\n  local_48 = 0;\n  local_40 = 0;\n  local_38 = 0;\n  local_30 = 0;\n  local_168 = 1;\n  OSSL_PARAM_construct_utf8_string(&local_198,\"digest\",\"sha256\",0);\n  local_138[0] = local_198;\n  local_138[1] = local_190;\n  local_138[2] = local_188;\n  local_138[3] = local_180;\n  uStack280 = local_178;\n  lVar4 = (long)local_168;\n  local_168 = local_168 + 1;\n  OSSL_PARAM_construct_utf8_string(&local_198,&DAT_000141e1,local_148,0);\n  local_138[lVar4 * 5] = local_198;\n  local_138[lVar4 * 5 + 1] = local_190;\n  local_138[lVar4 * 5 + 2] = local_188;\n  local_138[lVar4 * 5 + 3] = local_180;\n  local_138[lVar4 * 5 + 4] = local_178;\n  lVar4 = (long)local_168;\n  local_168 = local_168 + 1;\n  OSSL_PARAM_construct_octet_string(&local_198,&DAT_00013cfa,&DAT_00219210,0x10);\n  local_138[lVar4 * 5] = local_198;\n  local_138[lVar4 * 5 + 1] = local_190;\n  local_138[lVar4 * 5 + 2] = local_188;\n  local_138[lVar4 * 5 + 3] = local_180;\n  local_138[lVar4 * 5 + 4] = local_178;\n  sVar3 = strlen(local_160);\n  lVar4 = (long)local_168;\n  local_168 = local_168 + 1;\n  OSSL_PARAM_construct_octet_string(&local_198,&DAT_00013cf5,local_160,sVar3);\n  local_138[lVar4 * 5] = local_198;\n  local_138[lVar4 * 5 + 1] = local_190;\n  local_138[lVar4 * 5 + 2] = local_188;\n  local_138[lVar4 * 5 + 3] = local_180;\n  local_138[lVar4 * 5 + 4] = local_178;\n  sVar3 = strlen(local_150);\n  lVar4 = (long)local_168;\n  local_168 = local_168 + 1;\n  OSSL_PARAM_construct_octet_string(&local_198,&DAT_00013cfe,local_150,sVar3);\n  local_138[lVar4 * 5] = local_198;\n  local_138[lVar4 * 5 + 1] = local_190;\n  local_138[lVar4 * 5 + 2] = local_188;\n  local_138[lVar4 * 5 + 3] = local_180;\n  local_138[lVar4 * 5 + 4] = local_178;\n  lVar4 = (long)local_168;\n  OSSL_PARAM_construct_end(&local_198);\n  local_138[lVar4 * 5] = local_198;\n  local_138[lVar4 * 5 + 1] = local_190;\n  local_138[lVar4 * 5 + 2] = local_188;\n  local_138[lVar4 * 5 + 3] = local_180;\n  local_138[lVar4 * 5 + 4] = local_178;\n  local_140 = FUN_00002d68(\"KBKDF\");\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x4dc,&DAT_000141f4,local_140);\n  if (iVar1 != 0) {\n    uVar2 = EVP_KDF_derive(local_140,&local_48,0x20,local_138);\n    iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x4dd,\n                         \"EVP_KDF_derive(kctx, result, sizeof(result), params)\",&DAT_00013c2d,uVar2,\n                         0);\n    if (iVar1 != 0) {\n      iVar1 = FUN_0000e848(\"test/evp_kdf_test.c\",0x4de,\"result\",\"output\",&local_48,0x20,\n                           &DAT_00219220,0x20);\n      if (iVar1 != 0) {\n        local_164 = 1;\n        goto LAB_000084f4;\n      }\n    }\n  }\n  local_164 = 0;\nLAB_000084f4:\n  EVP_KDF_CTX_free(local_140);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_164;\n}\n\n",
        "output": "The predicted function name is test_kdf_kbkdf_8009_prf1"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  long in_FS_OFFSET;\n  undefined8 local_30;\n  undefined local_1a [10];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = 0;\n  ptr = (void *)FUN_000037e4(\"sha256\",&DAT_00013cc4,1,&DAT_00013cf5,\"label\");\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x1c1,\"params\",ptr);\n  if (iVar1 != 0) {\n    local_30 = FUN_00002d68(&DAT_00013d1b);\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x1c2,\"kctx = get_kdfbyname(OSSL_KDF_NAME_HKDF)\",\n                         local_30);\n    if (iVar1 != 0) {\n      uVar2 = EVP_KDF_derive(local_30,local_1a,10,ptr);\n      iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x1c3,\n                           \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar2,0);\n      if (iVar1 != 0) {\n        uVar2 = 1;\n        goto LAB_00004a86;\n      }\n    }\n  }\n  uVar2 = 0;\nLAB_00004a86:\n  EVP_KDF_CTX_free(local_30);\n  CRYPTO_free(ptr);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_hkdf_1byte_key"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  undefined8 uVar3;\n  \n  ptr = (void *)FUN_000076f4(\"sha256\",&DAT_00013c6c,&DAT_00219201,1,&DAT_00014265,&DAT_00014260);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x467,\"params\",ptr);\n  if (iVar1 == 0) {\n    return 0;\n  }\n  uVar3 = FUN_00002d68(\"KBKDF\");\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x46c,&DAT_000141f4,uVar3);\n  if (iVar1 != 0) {\n    iVar1 = EVP_KDF_CTX_set_params(uVar3,ptr);\n    iVar1 = FUN_0000e3f6(\"test/evp_kdf_test.c\",0x46d,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                         iVar1 != 0);\n    if (iVar1 != 0) {\n      uVar2 = 1;\n      goto LAB_00007bca;\n    }\n  }\n  uVar2 = 0;\nLAB_00007bca:\n  EVP_KDF_CTX_free(uVar3);\n  CRYPTO_free(ptr);\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_kbkdf_invalid_mac"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  int iVar3;\n  undefined4 uVar4;\n  long in_FS_OFFSET;\n  undefined8 local_168;\n  undefined8 local_160;\n  undefined8 local_158;\n  undefined8 local_150;\n  undefined8 local_148;\n  undefined local_12d;\n  undefined4 local_12c;\n  undefined8 *local_128;\n  undefined8 local_120;\n  undefined8 local_118;\n  undefined8 uStack272;\n  undefined8 uStack264;\n  undefined8 uStack256;\n  undefined8 uStack248;\n  undefined8 auStack240 [25];\n  undefined local_28 [8];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_12d = 0x41;\n  local_128 = auStack240;\n  OSSL_PARAM_construct_utf8_string(&local_168,\"digest\",\"sha256\",0);\n  puVar2 = local_128;\n  local_118 = local_168;\n  uStack272 = local_160;\n  uStack264 = local_158;\n  uStack256 = local_150;\n  uStack248 = local_148;\n  local_128 = local_128 + 5;\n  OSSL_PARAM_construct_octet_string(&local_168,&DAT_00013cfa,&DAT_00219360,0x85);\n  uVar1 = local_160;\n  *puVar2 = local_168;\n  puVar2[1] = uVar1;\n  uVar1 = local_150;\n  puVar2[2] = local_158;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_148;\n  puVar2 = local_128;\n  local_128 = local_128 + 5;\n  OSSL_PARAM_construct_octet_string(&local_168,\"xcghash\",&DAT_00219400,0x20);\n  uVar1 = local_160;\n  *puVar2 = local_168;\n  puVar2[1] = uVar1;\n  uVar1 = local_150;\n  puVar2[2] = local_158;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_148;\n  puVar2 = local_128;\n  local_128 = local_128 + 5;\n  OSSL_PARAM_construct_octet_string(&local_168,\"session_id\",&DAT_00219420,0x20);\n  uVar1 = local_160;\n  *puVar2 = local_168;\n  puVar2[1] = uVar1;\n  uVar1 = local_150;\n  puVar2[2] = local_158;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_148;\n  puVar2 = local_128;\n  local_128 = local_128 + 5;\n  OSSL_PARAM_construct_utf8_string(&local_168,&DAT_00014312,&local_12d,1);\n  uVar1 = local_160;\n  *puVar2 = local_168;\n  puVar2[1] = uVar1;\n  uVar1 = local_150;\n  puVar2[2] = local_158;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_148;\n  puVar2 = local_128;\n  OSSL_PARAM_construct_end(&local_168);\n  *puVar2 = local_168;\n  puVar2[1] = local_160;\n  puVar2[2] = local_158;\n  puVar2[3] = local_150;\n  puVar2[4] = local_148;\n  local_120 = FUN_00002d68(\"SSHKDF\");\n  iVar3 = FUN_0000e315(\"test/evp_kdf_test.c\",0x5d3,\"kctx = get_kdfbyname(OSSL_KDF_NAME_SSHKDF)\",\n                       local_120);\n  if (iVar3 != 0) {\n    uVar4 = EVP_KDF_derive(local_120,local_28,8,&local_118);\n    iVar3 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x5d4,\n                         \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar4,0);\n    if (iVar3 != 0) {\n      iVar3 = FUN_0000e848(\"test/evp_kdf_test.c\",0x5d5,&DAT_00013c68,\"expected\",local_28,8,\n                           &DAT_00014c00,8);\n      if (iVar3 != 0) {\n        local_12c = 1;\n        goto LAB_000098ec;\n      }\n    }\n  }\n  local_12c = 0;\nLAB_000098ec:\n  EVP_KDF_CTX_free(local_120);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_12c;\n}\n\n",
        "output": "The predicted function name is test_kdf_sshkdf"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long lVar3;\n  long in_FS_OFFSET;\n  undefined8 local_1a8;\n  undefined8 local_1a0;\n  undefined8 local_198;\n  undefined8 local_190;\n  undefined8 local_188;\n  int local_16c;\n  int local_168;\n  int local_164;\n  undefined8 local_160;\n  undefined8 local_158 [4];\n  undefined8 uStack312;\n  undefined8 local_38;\n  undefined8 local_30;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_16c = 0;\n  local_38 = 0;\n  local_30 = 0;\n  for (local_168 = 0; local_168 < 3; local_168 = local_168 + 1) {\n    local_164 = 1;\n    OSSL_PARAM_construct_utf8_string(&local_1a8,\"cipher\",\"CAMELLIA-128-CBC\",0);\n    local_158[0] = local_1a8;\n    local_158[1] = local_1a0;\n    local_158[2] = local_198;\n    local_158[3] = local_190;\n    uStack312 = local_188;\n    lVar3 = (long)local_164;\n    local_164 = local_164 + 1;\n    OSSL_PARAM_construct_utf8_string(&local_1a8,&DAT_000141e1,&DAT_000141dc,0);\n    local_158[lVar3 * 5] = local_1a8;\n    local_158[lVar3 * 5 + 1] = local_1a0;\n    local_158[lVar3 * 5 + 2] = local_198;\n    local_158[lVar3 * 5 + 3] = local_190;\n    local_158[lVar3 * 5 + 4] = local_188;\n    lVar3 = (long)local_164;\n    local_164 = local_164 + 1;\n    OSSL_PARAM_construct_utf8_string(&local_1a8,&DAT_00013d10,\"FEEDBACK\",0);\n    local_158[lVar3 * 5] = local_1a8;\n    local_158[lVar3 * 5 + 1] = local_1a0;\n    local_158[lVar3 * 5 + 2] = local_198;\n    local_158[lVar3 * 5 + 3] = local_190;\n    local_158[lVar3 * 5 + 4] = local_188;\n    lVar3 = (long)local_164;\n    local_164 = local_164 + 1;\n    OSSL_PARAM_construct_octet_string(&local_1a8,&DAT_00013cfa,&DAT_00219100,0x10);\n    local_158[lVar3 * 5] = local_1a8;\n    local_158[lVar3 * 5 + 1] = local_1a0;\n    local_158[lVar3 * 5 + 2] = local_198;\n    local_158[lVar3 * 5 + 3] = local_190;\n    local_158[lVar3 * 5 + 4] = local_188;\n    lVar3 = (long)local_164;\n    local_164 = local_164 + 1;\n    OSSL_PARAM_construct_octet_string\n              (&local_1a8,&DAT_00013cf5,&DAT_00219110 + (long)local_168 * 5,5);\n    local_158[lVar3 * 5] = local_1a8;\n    local_158[lVar3 * 5 + 1] = local_1a0;\n    local_158[lVar3 * 5 + 2] = local_198;\n    local_158[lVar3 * 5 + 3] = local_190;\n    local_158[lVar3 * 5 + 4] = local_188;\n    lVar3 = (long)local_164;\n    local_164 = local_164 + 1;\n    OSSL_PARAM_construct_octet_string(&local_1a8,&DAT_00013be2,&DAT_00219550,0x10);\n    local_158[lVar3 * 5] = local_1a8;\n    local_158[lVar3 * 5 + 1] = local_1a0;\n    local_158[lVar3 * 5 + 2] = local_198;\n    local_158[lVar3 * 5 + 3] = local_190;\n    local_158[lVar3 * 5 + 4] = local_188;\n    lVar3 = (long)local_164;\n    OSSL_PARAM_construct_end(&local_1a8);\n    local_158[lVar3 * 5] = local_1a8;\n    local_158[lVar3 * 5 + 1] = local_1a0;\n    local_158[lVar3 * 5 + 2] = local_198;\n    local_158[lVar3 * 5 + 3] = local_190;\n    local_158[lVar3 * 5 + 4] = local_188;\n    local_160 = FUN_00002d68(\"KBKDF\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x3de,&DAT_000141f4,local_160);\n    if (iVar1 == 0) {\nLAB_0000714e:\n      local_16c = 0;\n    }\n    else {\n      uVar2 = EVP_KDF_derive(local_160,&local_38,0x10,local_158);\n      iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x3e0,\n                           \"EVP_KDF_derive(kctx, result, sizeof(result), params)\",&DAT_00013c2d,\n                           uVar2,0);\n      if ((iVar1 == 0) ||\n         (iVar1 = FUN_0000e848(\"test/evp_kdf_test.c\",0x3e2,\"result\",\"outputs[i]\",&local_38,0x10,\n                               &DAT_00219120 + (long)local_168 * 0x10,0x10), iVar1 == 0))\n      goto LAB_0000714e;\n      local_16c = 1;\n    }\n    EVP_KDF_CTX_free(local_160);\n    if (local_16c != 1) break;\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_16c;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_kdf_kbkdf_6803_128"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  undefined8 local_18;\n  \n  local_18 = 0;\n  ptr = (void *)FUN_00002d87(&DAT_00013c6c,\"secret\",&DAT_00013be2);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x5a,\"params\",ptr);\n  if (iVar1 != 0) {\n    local_18 = FUN_00002d68(\"TLS1-PRF\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x5b,\"kctx = get_kdfbyname(OSSL_KDF_NAME_TLS1_PRF)\",\n                         local_18);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_18,ptr);\n      iVar1 = FUN_0000e3f6(\"test/evp_kdf_test.c\",0x5c,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        uVar2 = 1;\n        goto LAB_0000316b;\n      }\n    }\n  }\n  uVar2 = 0;\nLAB_0000316b:\n  EVP_KDF_CTX_free(local_18);\n  CRYPTO_free(ptr);\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_tls1_prf_invalid_digest"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_00003bff(0,1);\n  return;\n}\n\n",
        "output": "The predicted function name is test_kdf_hkdf_gettables"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 *\n[MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n            char *param_5,char *param_6)\n\n{\n  undefined8 *puVar1;\n  size_t sVar2;\n  undefined8 *puVar3;\n  long in_FS_OFFSET;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  char *local_68;\n  char *local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 *local_30;\n  undefined8 *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_68 = param_6;\n  local_60 = param_5;\n  local_58 = param_4;\n  local_50 = param_3;\n  local_48 = param_2;\n  local_40 = param_1;\n  puVar1 = (undefined8 *)CRYPTO_malloc(0x118,\"test/evp_kdf_test.c\",0x431);\n  local_30 = puVar1;\n  if (puVar1 == (undefined8 *)0x0) {\n    puVar3 = (undefined8 *)0x0;\n    local_28 = puVar1;\n  }\n  else {\n    local_28 = puVar1 + 5;\n    OSSL_PARAM_construct_utf8_string(&local_98,\"digest\",local_40,0);\n    puVar3 = local_28;\n    *puVar1 = local_98;\n    puVar1[1] = local_90;\n    puVar1[2] = local_88;\n    puVar1[3] = local_80;\n    puVar1[4] = local_78;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_utf8_string(&local_98,&DAT_000141e1,local_48,0);\n    puVar1 = local_28;\n    *puVar3 = local_98;\n    puVar3[1] = local_90;\n    puVar3[2] = local_88;\n    puVar3[3] = local_80;\n    puVar3[4] = local_78;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_utf8_string(&local_98,&DAT_00013d10,\"COUNTER\",0);\n    puVar3 = local_28;\n    *puVar1 = local_98;\n    puVar1[1] = local_90;\n    puVar1[2] = local_88;\n    puVar1[3] = local_80;\n    puVar1[4] = local_78;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_octet_string(&local_98,&DAT_00013cfa,local_50,local_58);\n    *puVar3 = local_98;\n    puVar3[1] = local_90;\n    puVar3[2] = local_88;\n    puVar3[3] = local_80;\n    puVar3[4] = local_78;\n    sVar2 = strlen(local_60);\n    puVar1 = local_28;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_octet_string(&local_98,&DAT_00013cf5,local_60,sVar2);\n    *puVar1 = local_98;\n    puVar1[1] = local_90;\n    puVar1[2] = local_88;\n    puVar1[3] = local_80;\n    puVar1[4] = local_78;\n    sVar2 = strlen(local_68);\n    puVar1 = local_28;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_octet_string(&local_98,&DAT_00013cfe,local_68,sVar2);\n    puVar3 = local_28;\n    *puVar1 = local_98;\n    puVar1[1] = local_90;\n    puVar1[2] = local_88;\n    puVar1[3] = local_80;\n    puVar1[4] = local_78;\n    OSSL_PARAM_construct_end(&local_98);\n    *puVar3 = local_98;\n    puVar3[1] = local_90;\n    puVar3[2] = local_88;\n    puVar3[3] = local_80;\n    puVar3[4] = local_78;\n    puVar3 = local_30;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar3;\n}\n\n",
        "output": "The predicted function name is construct_kbkdf_params"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  long in_FS_OFFSET;\n  undefined8 local_38;\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = 0;\n  ptr = (void *)FUN_00002d87(\"sha256\",&DAT_00013cc3,&DAT_00013be2);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x80,\"params\",ptr);\n  if (iVar1 != 0) {\n    local_38 = FUN_00002d68(\"TLS1-PRF\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x81,\"kctx = get_kdfbyname(OSSL_KDF_NAME_TLS1_PRF)\",\n                         local_38);\n    if (iVar1 != 0) {\n      uVar2 = EVP_KDF_derive(local_38,local_28,0x10,ptr);\n      iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x82,\n                           \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar2,0);\n      if (iVar1 != 0) {\n        uVar2 = 1;\n        goto LAB_000033e8;\n      }\n    }\n  }\n  uVar2 = 0;\nLAB_000033e8:\n  EVP_KDF_CTX_free(local_38);\n  CRYPTO_free(ptr);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_tls1_prf_empty_secret"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  long in_FS_OFFSET;\n  undefined8 local_38;\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = 0;\n  ptr = (void *)FUN_00002d87(\"sha256\",&DAT_00013cc4,&DAT_00013be2);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x92,\"params\",ptr);\n  if (iVar1 != 0) {\n    local_38 = FUN_00002d68(\"TLS1-PRF\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x93,\"kctx = get_kdfbyname(OSSL_KDF_NAME_TLS1_PRF)\",\n                         local_38);\n    if (iVar1 != 0) {\n      uVar2 = EVP_KDF_derive(local_38,local_28,0x10,ptr);\n      iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x94,\n                           \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar2,0);\n      if (iVar1 != 0) {\n        uVar2 = 1;\n        goto LAB_00003513;\n      }\n    }\n  }\n  uVar2 = 0;\nLAB_00003513:\n  EVP_KDF_CTX_free(local_38);\n  CRYPTO_free(ptr);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_tls1_prf_1byte_secret"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  int iVar3;\n  undefined4 uVar4;\n  long in_FS_OFFSET;\n  undefined8 local_128;\n  undefined8 local_120;\n  undefined8 local_118;\n  undefined8 local_110;\n  undefined8 local_108;\n  undefined4 local_f4;\n  undefined8 local_f0;\n  undefined8 *local_e8;\n  char *local_e0;\n  undefined8 local_d8;\n  undefined8 uStack208;\n  undefined8 uStack200;\n  undefined8 uStack192;\n  undefined8 uStack184;\n  undefined8 auStack176 [15];\n  undefined local_38 [24];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_f0 = 0;\n  local_e0 = \"id-smime-alg-CMS3DESwrap\";\n  local_e8 = auStack176;\n  OSSL_PARAM_construct_utf8_string(&local_128,\"digest\",&DAT_00014514,0);\n  puVar2 = local_e8;\n  local_d8 = local_128;\n  uStack208 = local_120;\n  uStack200 = local_118;\n  uStack192 = local_110;\n  uStack184 = local_108;\n  local_e8 = local_e8 + 5;\n  OSSL_PARAM_construct_octet_string(&local_128,&DAT_00013cfa,&DAT_00219440,0x14);\n  uVar1 = local_120;\n  *puVar2 = local_128;\n  puVar2[1] = uVar1;\n  uVar1 = local_110;\n  puVar2[2] = local_118;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_108;\n  puVar2 = local_e8;\n  local_e8 = local_e8 + 5;\n  OSSL_PARAM_construct_utf8_string(&local_128,\"cekalg\",local_e0,0);\n  uVar1 = local_120;\n  *puVar2 = local_128;\n  puVar2[1] = uVar1;\n  uVar1 = local_110;\n  puVar2[2] = local_118;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_108;\n  puVar2 = local_e8;\n  OSSL_PARAM_construct_end(&local_128);\n  *puVar2 = local_128;\n  puVar2[1] = local_120;\n  puVar2[2] = local_118;\n  puVar2[3] = local_110;\n  puVar2[4] = local_108;\n  local_f0 = FUN_00002d68(\"X942KDF-ASN1\");\n  iVar3 = FUN_0000e315(\"test/evp_kdf_test.c\",0x62a,\n                       \"kctx = get_kdfbyname(OSSL_KDF_NAME_X942KDF_ASN1)\",local_f0);\n  if (iVar3 != 0) {\n    uVar4 = EVP_KDF_derive(local_f0,local_38,0x18,&local_d8);\n    iVar3 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x62b,\n                         \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar4,0);\n    if (iVar3 != 0) {\n      iVar3 = FUN_0000e848(\"test/evp_kdf_test.c\",0x62c,&DAT_00013c68,\"expected\",local_38,0x18,\n                           &DAT_00014c10,0x18);\n      if (iVar3 != 0) {\n        local_f4 = 1;\n        goto LAB_00009edf;\n      }\n    }\n  }\n  local_f4 = 0;\nLAB_00009edf:\n  EVP_KDF_CTX_free(local_f0);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_f4;\n}\n\n",
        "output": "The predicted function name is test_kdf_x942_asn1"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,long param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  if (param_1 == param_2) {\n    uVar2 = 1;\n  }\n  else {\n    uVar2 = EVP_KDF_get0_provider(param_2);\n    uVar3 = EVP_KDF_get0_provider(param_1);\n    iVar1 = FUN_0000e1a2(\"test/evp_kdf_test.c\",0x5e6,\"EVP_KDF_get0_provider(kdf1)\",\n                         \"EVP_KDF_get0_provider(kdf2)\",uVar3,uVar2);\n    if (iVar1 != 0) {\n      uVar2 = EVP_KDF_get0_name(param_2);\n      uVar3 = EVP_KDF_get0_name(param_1);\n      iVar1 = FUN_0000e462(\"test/evp_kdf_test.c\",0x5e7,\"EVP_KDF_get0_name(kdf1)\",\n                           \"EVP_KDF_get0_name(kdf2)\",uVar3,uVar2);\n      if (iVar1 != 0) {\n        return 1;\n      }\n    }\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdfs_same"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = 0;\n  local_30 = 0;\n  local_28 = 0;\n  local_20 = 0;\n  ptr = (void *)FUN_000076f4(\"sha256\",&DAT_00014269,&DAT_00219204,1,&DAT_00014265,&DAT_00014260);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x4ac,\"params\",ptr);\n  if (iVar1 == 0) {\n    uVar2 = 0;\n    goto LAB_0000806a;\n  }\n  uVar3 = FUN_00002d68(\"KBKDF\");\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x4b1,&DAT_000141f4,uVar3);\n  if (iVar1 == 0) {\nLAB_0000803b:\n    uVar2 = 0;\n  }\n  else {\n    iVar1 = EVP_KDF_CTX_set_params(uVar3,ptr);\n    iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0x4b2,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                         iVar1 != 0);\n    if (iVar1 == 0) goto LAB_0000803b;\n    uVar2 = EVP_KDF_derive(uVar3,&local_38,0,0);\n    iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x4b3,\"EVP_KDF_derive(kctx, result, 0, NULL)\",\n                         &DAT_00013c2d,uVar2,0);\n    if (iVar1 == 0) goto LAB_0000803b;\n    uVar2 = 1;\n  }\n  EVP_KDF_CTX_free(uVar3);\n  CRYPTO_free(ptr);\nLAB_0000806a:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_kbkdf_zero_output_size"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_2c;\n  undefined4 local_28;\n  undefined4 local_24;\n  undefined8 local_20;\n  void *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_24 = 0;\n  local_20 = 0;\n  local_2c = 0x1000;\n  local_28 = 0;\n  local_18 = (void *)FUN_0000511d(\"passwordPASSWORDpassword\",&DAT_00013c6c,\n                                  \"saltSALTsaltSALTsaltSALTsaltSALTsalt\",&local_2c,&local_28);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x31b,\"params\",local_18);\n  if (iVar1 != 0) {\n    local_20 = FUN_00002d68(\"PBKDF2\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x31c,\"kctx = get_kdfbyname(OSSL_KDF_NAME_PBKDF2)\",\n                         local_20);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_20,local_18);\n      iVar1 = FUN_0000e3f6(\"test/evp_kdf_test.c\",0x31e,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        local_24 = 1;\n      }\n    }\n  }\n  EVP_KDF_CTX_free(local_20);\n  CRYPTO_free(local_18);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_24;\n}\n\n",
        "output": "The predicted function name is test_kdf_pbkdf2_invalid_digest"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long in_FS_OFFSET;\n  undefined8 local_d8;\n  undefined8 local_d0;\n  undefined8 local_c8;\n  undefined8 local_c0;\n  undefined8 local_b8;\n  undefined4 local_a4;\n  undefined4 local_a0;\n  undefined4 local_9c;\n  undefined8 local_98;\n  void *local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  undefined8 local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined local_38 [40];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_9c = 0;\n  local_98 = 0;\n  local_a4 = 0x1000;\n  local_a0 = 1;\n  local_90 = (void *)FUN_0000511d(\"passwordPASSWORDpassword\",\"sha256\",\"saltSALT\",&local_a4,&local_a0\n                                 );\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x2d3,\"params\",local_90);\n  if (iVar1 != 0) {\n    local_98 = FUN_00002d68(\"PBKDF2\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x2d4,\"kctx = get_kdfbyname(OSSL_KDF_NAME_PBKDF2)\",\n                         local_98);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_98,local_90);\n      iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0x2d6,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        uVar2 = EVP_KDF_derive(local_98,local_38,0x19,0);\n        iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x2d7,\n                             \"EVP_KDF_derive(kctx, out, sizeof(out), NULL)\",&DAT_00013c2d,uVar2,0);\n        if (iVar1 != 0) {\n          local_a0 = 0;\n          OSSL_PARAM_construct_int(&local_d8,\"pkcs5\",&local_a0);\n          local_88 = local_d8;\n          local_80 = local_d0;\n          local_78 = local_c8;\n          local_70 = local_c0;\n          local_68 = local_b8;\n          OSSL_PARAM_construct_end(&local_d8);\n          local_60 = local_d8;\n          local_58 = local_d0;\n          local_50 = local_c8;\n          local_48 = local_c0;\n          local_40 = local_b8;\n          iVar1 = EVP_KDF_CTX_set_params(local_98,&local_88);\n          iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0x2df,\n                               \"EVP_KDF_CTX_set_params(kctx, mode_params)\",iVar1 != 0);\n          if (iVar1 != 0) {\n            uVar2 = EVP_KDF_derive(local_98,local_38,0x19,0);\n            iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x2e0,\n                                 \"EVP_KDF_derive(kctx, out, sizeof(out), NULL)\",&DAT_00013c2d,uVar2,\n                                 0);\n            if (iVar1 != 0) {\n              local_9c = 1;\n            }\n          }\n        }\n      }\n    }\n  }\n  EVP_KDF_CTX_free(local_98);\n  CRYPTO_free(local_90);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_9c;\n}\n\n",
        "output": "The predicted function name is test_kdf_pbkdf2_small_salt_pkcs5"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  int iVar3;\n  undefined4 uVar4;\n  long in_FS_OFFSET;\n  undefined8 local_128;\n  undefined8 local_120;\n  undefined8 local_118;\n  undefined8 local_110;\n  undefined8 local_108;\n  undefined4 local_ec;\n  undefined8 *local_e8;\n  undefined8 local_e0;\n  undefined8 local_d8;\n  undefined8 uStack208;\n  undefined8 uStack200;\n  undefined8 uStack192;\n  undefined8 uStack184;\n  undefined8 auStack176 [16];\n  undefined local_2e [14];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_e8 = auStack176;\n  OSSL_PARAM_construct_utf8_string(&local_128,\"digest\",\"sha224\",0);\n  puVar2 = local_e8;\n  local_d8 = local_128;\n  uStack208 = local_120;\n  uStack200 = local_118;\n  uStack192 = local_110;\n  uStack184 = local_108;\n  local_e8 = local_e8 + 5;\n  OSSL_PARAM_construct_octet_string(&local_128,&DAT_00013cfa,&DAT_00219020,0x38);\n  uVar1 = local_120;\n  *puVar2 = local_128;\n  puVar2[1] = uVar1;\n  uVar1 = local_110;\n  puVar2[2] = local_118;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_108;\n  puVar2 = local_e8;\n  local_e8 = local_e8 + 5;\n  OSSL_PARAM_construct_octet_string(&local_128,&DAT_00013cfe,&DAT_00219060,0x2f);\n  uVar1 = local_120;\n  *puVar2 = local_128;\n  puVar2[1] = uVar1;\n  uVar1 = local_110;\n  puVar2[2] = local_118;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_108;\n  puVar2 = local_e8;\n  OSSL_PARAM_construct_end(&local_128);\n  *puVar2 = local_128;\n  puVar2[1] = local_120;\n  puVar2[2] = local_118;\n  puVar2[3] = local_110;\n  puVar2[4] = local_108;\n  local_e0 = FUN_00002d68(\"SSKDF\");\n  iVar3 = FUN_0000e315(\"test/evp_kdf_test.c\",0x372,\"kctx = get_kdfbyname(OSSL_KDF_NAME_SSKDF)\",\n                       local_e0);\n  if (iVar3 != 0) {\n    uVar4 = EVP_KDF_derive(local_e0,local_2e,0xe,&local_d8);\n    iVar3 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x373,\n                         \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar4,0);\n    if (iVar3 != 0) {\n      iVar3 = FUN_0000e848(\"test/evp_kdf_test.c\",0x374,&DAT_00013c68,\"expected\",local_2e,0xe,\n                           &DAT_00014b00,0xe);\n      if (iVar3 != 0) {\n        local_ec = 1;\n        goto LAB_0000697b;\n      }\n    }\n  }\n  local_ec = 0;\nLAB_0000697b:\n  EVP_KDF_CTX_free(local_e0);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_ec;\n}\n\n",
        "output": "The predicted function name is test_kdf_ss_hash"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  int iVar3;\n  undefined4 uVar4;\n  long in_FS_OFFSET;\n  undefined8 local_1a8;\n  undefined8 local_1a0;\n  undefined8 local_198;\n  undefined8 local_190;\n  undefined8 local_188;\n  undefined4 local_174;\n  undefined8 local_170;\n  undefined8 *local_168;\n  undefined8 local_160;\n  undefined8 local_158;\n  undefined8 uStack336;\n  undefined8 uStack328;\n  undefined8 uStack320;\n  undefined8 uStack312;\n  undefined8 auStack304 [25];\n  undefined local_68 [72];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_170 = 0x14;\n  local_168 = auStack304;\n  OSSL_PARAM_construct_utf8_string(&local_1a8,&DAT_000141e1,\"KMAC128\",0);\n  puVar2 = local_168;\n  local_158 = local_1a8;\n  uStack336 = local_1a0;\n  uStack328 = local_198;\n  uStack320 = local_190;\n  uStack312 = local_188;\n  local_168 = local_168 + 5;\n  OSSL_PARAM_construct_octet_string(&local_1a8,&DAT_00013cfa,&DAT_00219320,0xe);\n  uVar1 = local_1a0;\n  *puVar2 = local_1a8;\n  puVar2[1] = uVar1;\n  uVar1 = local_190;\n  puVar2[2] = local_198;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_188;\n  puVar2 = local_168;\n  local_168 = local_168 + 5;\n  OSSL_PARAM_construct_octet_string(&local_1a8,&DAT_00013cfe,&DAT_00219330,0xc);\n  uVar1 = local_1a0;\n  *puVar2 = local_1a8;\n  puVar2[1] = uVar1;\n  uVar1 = local_190;\n  puVar2[2] = local_198;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_188;\n  puVar2 = local_168;\n  local_168 = local_168 + 5;\n  OSSL_PARAM_construct_octet_string(&local_1a8,&DAT_00013cf5,&DAT_00219340,0x10);\n  uVar1 = local_1a0;\n  *puVar2 = local_1a8;\n  puVar2[1] = uVar1;\n  uVar1 = local_190;\n  puVar2[2] = local_198;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_188;\n  puVar2 = local_168;\n  local_168 = local_168 + 5;\n  OSSL_PARAM_construct_size_t(&local_1a8,\"maclen\",&local_170);\n  uVar1 = local_1a0;\n  *puVar2 = local_1a8;\n  puVar2[1] = uVar1;\n  uVar1 = local_190;\n  puVar2[2] = local_198;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_188;\n  puVar2 = local_168;\n  OSSL_PARAM_construct_end(&local_1a8);\n  *puVar2 = local_1a8;\n  puVar2[1] = local_1a0;\n  puVar2[2] = local_198;\n  puVar2[3] = local_190;\n  puVar2[4] = local_188;\n  local_160 = FUN_00002d68(\"SSKDF\");\n  iVar3 = FUN_0000e315(\"test/evp_kdf_test.c\",0x59a,\"kctx = get_kdfbyname(OSSL_KDF_NAME_SSKDF)\",\n                       local_160);\n  if (iVar3 != 0) {\n    uVar4 = EVP_KDF_derive(local_160,local_68,0x40,&local_158);\n    iVar3 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x59b,\n                         \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar4,0);\n    if (iVar3 != 0) {\n      iVar3 = FUN_0000e848(\"test/evp_kdf_test.c\",0x59c,&DAT_00013c68,\"expected\",local_68,0x40,\n                           &DAT_00014bc0,0x40);\n      if (iVar3 != 0) {\n        local_174 = 1;\n        goto LAB_00009554;\n      }\n    }\n  }\n  local_174 = 0;\nLAB_00009554:\n  EVP_KDF_CTX_free(local_160);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_174;\n}\n\n",
        "output": "The predicted function name is test_kdf_ss_kmac"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long in_FS_OFFSET;\n  undefined8 local_d8;\n  undefined8 local_d0;\n  undefined8 local_c8;\n  undefined8 local_c0;\n  undefined8 local_b8;\n  undefined4 local_a4;\n  undefined4 local_a0;\n  undefined4 local_9c;\n  undefined8 local_98;\n  void *local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  undefined8 local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined local_38 [40];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_9c = 0;\n  local_98 = 0;\n  local_a4 = 1;\n  local_a0 = 1;\n  local_90 = (void *)FUN_0000511d(\"passwordPASSWORDpassword\",\"sha256\",\n                                  \"saltSALTsaltSALTsaltSALTsaltSALTsalt\",&local_a4,&local_a0);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x2f8,\"params\",local_90);\n  if (iVar1 != 0) {\n    local_98 = FUN_00002d68(\"PBKDF2\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x2f9,\"kctx = get_kdfbyname(OSSL_KDF_NAME_PBKDF2)\",\n                         local_98);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_98,local_90);\n      iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0x2fb,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        uVar2 = EVP_KDF_derive(local_98,local_38,0x19,0);\n        iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x2fc,\n                             \"EVP_KDF_derive(kctx, out, sizeof(out), NULL)\",&DAT_00013c2d,uVar2,0);\n        if (iVar1 != 0) {\n          local_a0 = 0;\n          OSSL_PARAM_construct_int(&local_d8,\"pkcs5\",&local_a0);\n          local_88 = local_d8;\n          local_80 = local_d0;\n          local_78 = local_c8;\n          local_70 = local_c0;\n          local_68 = local_b8;\n          OSSL_PARAM_construct_end(&local_d8);\n          local_60 = local_d8;\n          local_58 = local_d0;\n          local_50 = local_c8;\n          local_48 = local_c0;\n          local_40 = local_b8;\n          iVar1 = EVP_KDF_CTX_set_params(local_98,&local_88);\n          iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0x304,\n                               \"EVP_KDF_CTX_set_params(kctx, mode_params)\",iVar1 != 0);\n          if (iVar1 != 0) {\n            uVar2 = EVP_KDF_derive(local_98,local_38,0x19,0);\n            iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x305,\n                                 \"EVP_KDF_derive(kctx, out, sizeof(out), NULL)\",&DAT_00013c2d,uVar2,\n                                 0);\n            if (iVar1 != 0) {\n              local_9c = 1;\n            }\n          }\n        }\n      }\n    }\n  }\n  EVP_KDF_CTX_free(local_98);\n  CRYPTO_free(local_90);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_9c;\n}\n\n",
        "output": "The predicted function name is test_kdf_pbkdf2_small_iterations_pkcs5"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 *\n[MASK](long param_1,undefined8 param_2,undefined8 param_3,char *param_4,char *param_5)\n\n{\n  undefined8 *puVar1;\n  undefined8 *puVar2;\n  size_t sVar3;\n  long in_FS_OFFSET;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  char *local_60;\n  char *local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  long local_40;\n  undefined8 *local_30;\n  undefined8 *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_60 = param_5;\n  local_58 = param_4;\n  local_50 = param_3;\n  local_48 = param_2;\n  local_40 = param_1;\n  puVar2 = (undefined8 *)CRYPTO_malloc(200,\"test/evp_kdf_test.c\",0xc4);\n  local_30 = puVar2;\n  local_28 = puVar2;\n  if (puVar2 == (undefined8 *)0x0) {\n    puVar2 = (undefined8 *)0x0;\n  }\n  else {\n    if (local_40 != 0) {\n      local_30 = puVar2 + 5;\n      OSSL_PARAM_construct_utf8_string(&local_98,\"digest\",local_40,0);\n      *puVar2 = local_98;\n      puVar2[1] = local_90;\n      puVar2[2] = local_88;\n      puVar2[3] = local_80;\n      puVar2[4] = local_78;\n    }\n    sVar3 = strlen(local_58);\n    puVar2 = local_30;\n    local_30 = local_30 + 5;\n    OSSL_PARAM_construct_octet_string(&local_98,&DAT_00013cf5,local_58,sVar3);\n    puVar1 = local_30;\n    *puVar2 = local_98;\n    puVar2[1] = local_90;\n    puVar2[2] = local_88;\n    puVar2[3] = local_80;\n    puVar2[4] = local_78;\n    local_30 = local_30 + 5;\n    OSSL_PARAM_construct_octet_string(&local_98,&DAT_00013cfa,local_48,local_50);\n    puVar2 = local_30;\n    *puVar1 = local_98;\n    puVar1[1] = local_90;\n    puVar1[2] = local_88;\n    puVar1[3] = local_80;\n    puVar1[4] = local_78;\n    if (local_60 == (char *)0x0) {\n      local_30 = local_30 + 5;\n      OSSL_PARAM_construct_utf8_string(&local_98,&DAT_00013d10,\"EXTRACT_ONLY\",0);\n      *puVar2 = local_98;\n      puVar2[1] = local_90;\n      puVar2[2] = local_88;\n      puVar2[3] = local_80;\n      puVar2[4] = local_78;\n    }\n    else {\n      sVar3 = strlen(local_60);\n      puVar2 = local_30;\n      local_30 = local_30 + 5;\n      OSSL_PARAM_construct_octet_string(&local_98,&DAT_00013cfe,local_60,sVar3);\n      *puVar2 = local_98;\n      puVar2[1] = local_90;\n      puVar2[2] = local_88;\n      puVar2[3] = local_80;\n      puVar2[4] = local_78;\n    }\n    puVar2 = local_30;\n    OSSL_PARAM_construct_end(&local_98);\n    *puVar2 = local_98;\n    puVar2[1] = local_90;\n    puVar2[2] = local_88;\n    puVar2[3] = local_80;\n    puVar2[4] = local_78;\n    puVar2 = local_28;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar2;\n}\n\n",
        "output": "The predicted function name is construct_hkdf_params"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  undefined8 local_18;\n  \n  local_18 = 0;\n  ptr = (void *)FUN_000037e4(&DAT_00013c6c,\"secret\",6,&DAT_00013cf5,\"label\");\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x136,\"params\",ptr);\n  if (iVar1 != 0) {\n    local_18 = FUN_00002d68(&DAT_00013d1b);\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x137,\"kctx = get_kdfbyname(OSSL_KDF_NAME_HKDF)\",\n                         local_18);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_18,ptr);\n      iVar1 = FUN_0000e3f6(\"test/evp_kdf_test.c\",0x138,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        uVar2 = 1;\n        goto LAB_00004108;\n      }\n    }\n  }\n  uVar2 = 0;\nLAB_00004108:\n  EVP_KDF_CTX_free(local_18);\n  CRYPTO_free(ptr);\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_hkdf_invalid_digest"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 *\n[MASK](char *param_1,undefined8 param_2,char *param_3,undefined8 param_4,undefined8 param_5)\n\n{\n  undefined8 *puVar1;\n  size_t sVar2;\n  undefined8 *puVar3;\n  long in_FS_OFFSET;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  undefined8 local_60;\n  undefined8 local_58;\n  char *local_50;\n  undefined8 local_48;\n  char *local_40;\n  undefined8 *local_30;\n  undefined8 *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_60 = param_5;\n  local_58 = param_4;\n  local_50 = param_3;\n  local_48 = param_2;\n  local_40 = param_1;\n  local_30 = (undefined8 *)CRYPTO_malloc(0xf0,\"test/evp_kdf_test.c\",0x226);\n  local_28 = local_30;\n  if (local_30 == (undefined8 *)0x0) {\n    puVar3 = (undefined8 *)0x0;\n  }\n  else {\n    sVar2 = strlen(local_40);\n    puVar3 = local_28;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_octet_string(&local_98,&DAT_00013eb0,local_40,sVar2);\n    *puVar3 = local_98;\n    puVar3[1] = local_90;\n    puVar3[2] = local_88;\n    puVar3[3] = local_80;\n    puVar3[4] = local_78;\n    sVar2 = strlen(local_50);\n    puVar3 = local_28;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_octet_string(&local_98,&DAT_00013cf5,local_50,sVar2);\n    puVar1 = local_28;\n    *puVar3 = local_98;\n    puVar3[1] = local_90;\n    puVar3[2] = local_88;\n    puVar3[3] = local_80;\n    puVar3[4] = local_78;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_uint(&local_98,&DAT_00013eb5,local_58);\n    puVar3 = local_28;\n    *puVar1 = local_98;\n    puVar1[1] = local_90;\n    puVar1[2] = local_88;\n    puVar1[3] = local_80;\n    puVar1[4] = local_78;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_utf8_string(&local_98,\"digest\",local_48,0);\n    puVar1 = local_28;\n    *puVar3 = local_98;\n    puVar3[1] = local_90;\n    puVar3[2] = local_88;\n    puVar3[3] = local_80;\n    puVar3[4] = local_78;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_int(&local_98,\"pkcs5\",local_60);\n    puVar3 = local_28;\n    *puVar1 = local_98;\n    puVar1[1] = local_90;\n    puVar1[2] = local_88;\n    puVar1[3] = local_80;\n    puVar1[4] = local_78;\n    OSSL_PARAM_construct_end(&local_98);\n    *puVar3 = local_98;\n    puVar3[1] = local_90;\n    puVar3[2] = local_88;\n    puVar3[3] = local_80;\n    puVar3[4] = local_78;\n    puVar3 = local_30;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar3;\n}\n\n",
        "output": "The predicted function name is construct_pbkdf2_params"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  \n  uVar1 = EVP_KDF_fetch(param_1,param_2,0);\n  uVar2 = EVP_KDF_CTX_new(uVar1);\n  EVP_KDF_free(uVar1);\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is get_kdfbyname_libctx"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  int iVar1;\n  \n  iVar1 = FUN_000044b1(&DAT_00013d10,5);\n  if ((((iVar1 != 0) && (iVar1 = FUN_000044b1(&DAT_00013cfa,4), iVar1 != 0)) &&\n      (iVar1 = FUN_000044b1(&DAT_00013cf5,4), iVar1 != 0)) &&\n     (iVar1 = FUN_000044b1(&DAT_00013cfe,4), iVar1 != 0)) {\n    return 1;\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is test_kdf_hkdf_set_ctx_param_fail"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_00003bff(1,0);\n  return;\n}\n\n",
        "output": "The predicted function name is test_kdf_hkdf_gettables_no_digest"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  undefined8 uVar3;\n  \n  ptr = (void *)FUN_000076f4(&DAT_00013c6c,&DAT_00014269,&DAT_00219200,1,&DAT_00014265,&DAT_00014260\n                            );\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x451,\"params\",ptr);\n  if (iVar1 == 0) {\n    return 0;\n  }\n  uVar3 = FUN_00002d68(\"KBKDF\");\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x456,&DAT_000141f4,uVar3);\n  if (iVar1 != 0) {\n    iVar1 = EVP_KDF_CTX_set_params(uVar3,ptr);\n    iVar1 = FUN_0000e3f6(\"test/evp_kdf_test.c\",0x457,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                         iVar1 != 0);\n    if (iVar1 != 0) {\n      uVar2 = 1;\n      goto LAB_00007ac0;\n    }\n  }\n  uVar2 = 0;\nLAB_00007ac0:\n  EVP_KDF_CTX_free(uVar3);\n  CRYPTO_free(ptr);\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_kbkdf_invalid_digest"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long in_FS_OFFSET;\n  undefined4 local_54;\n  undefined4 local_50;\n  undefined4 local_4c;\n  undefined8 local_48;\n  void *local_40;\n  undefined local_38 [40];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_4c = 0;\n  local_48 = 0;\n  local_54 = 0x1000;\n  local_50 = 0;\n  local_40 = (void *)FUN_0000511d(\"passwordPASSWORDpassword\",\"sha256\",\n                                  \"saltSALTsaltSALTsaltSALTsaltSALTsalt\",&local_54,&local_50);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x266,\"params\",local_40);\n  if (iVar1 != 0) {\n    local_48 = FUN_00002d68(\"PBKDF2\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x267,\"kctx = get_kdfbyname(OSSL_KDF_NAME_PBKDF2)\",\n                         local_48);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_48,local_40);\n      iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0x268,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        uVar2 = EVP_KDF_derive(local_48,local_38,0xd,0);\n        iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x26a,\n                             \"EVP_KDF_derive(kctx, out, 112 / 8 - 1, NULL)\",&DAT_00013c2d,uVar2,0);\n        if (iVar1 != 0) {\n          local_4c = 1;\n        }\n      }\n    }\n  }\n  EVP_KDF_CTX_free(local_48);\n  CRYPTO_free(local_40);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_4c;\n}\n\n",
        "output": "The predicted function name is test_kdf_pbkdf2_small_output"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  int iVar3;\n  undefined4 uVar4;\n  long in_FS_OFFSET;\n  undefined8 local_128;\n  undefined8 local_120;\n  undefined8 local_118;\n  undefined8 local_110;\n  undefined8 local_108;\n  undefined4 local_ec;\n  undefined8 *local_e8;\n  undefined8 local_e0;\n  undefined8 local_d8;\n  undefined8 uStack208;\n  undefined8 uStack200;\n  undefined8 uStack192;\n  undefined8 uStack184;\n  undefined8 auStack176 [15];\n  undefined local_38 [24];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_e8 = auStack176;\n  OSSL_PARAM_construct_utf8_string(&local_128,\"cipher\",\"AES-128-CBC\",0);\n  puVar2 = local_e8;\n  local_d8 = local_128;\n  uStack208 = local_120;\n  uStack200 = local_118;\n  uStack192 = local_110;\n  uStack184 = local_108;\n  local_e8 = local_e8 + 5;\n  OSSL_PARAM_construct_octet_string(&local_128,&DAT_00013cfa,&DAT_00219460,0x10);\n  uVar1 = local_120;\n  *puVar2 = local_128;\n  puVar2[1] = uVar1;\n  uVar1 = local_110;\n  puVar2[2] = local_118;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_108;\n  puVar2 = local_e8;\n  local_e8 = local_e8 + 5;\n  OSSL_PARAM_construct_octet_string(&local_128,\"constant\",&DAT_00219470,5);\n  uVar1 = local_120;\n  *puVar2 = local_128;\n  puVar2[1] = uVar1;\n  uVar1 = local_110;\n  puVar2[2] = local_118;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_108;\n  puVar2 = local_e8;\n  OSSL_PARAM_construct_end(&local_128);\n  *puVar2 = local_128;\n  puVar2[1] = local_120;\n  puVar2[2] = local_118;\n  puVar2[3] = local_110;\n  puVar2[4] = local_108;\n  local_e0 = FUN_00002d68(\"KRB5KDF\");\n  iVar3 = FUN_0000e315(\"test/evp_kdf_test.c\",0x64e,\"kctx = get_kdfbyname(OSSL_KDF_NAME_KRB5KDF)\",\n                       local_e0);\n  if (iVar3 != 0) {\n    uVar4 = EVP_KDF_derive(local_e0,local_38,0x10,&local_d8);\n    iVar3 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x64f,\n                         \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar4,0);\n    if (iVar3 != 0) {\n      iVar3 = FUN_0000e848(\"test/evp_kdf_test.c\",0x650,&DAT_00013c68,\"expected\",local_38,0x10,\n                           &DAT_00014c30,0x10);\n      if (iVar3 != 0) {\n        local_ec = 1;\n        goto LAB_0000a19c;\n      }\n    }\n  }\n  local_ec = 0;\nLAB_0000a19c:\n  EVP_KDF_CTX_free(local_e0);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_ec;\n}\n\n",
        "output": "The predicted function name is test_kdf_krb5kdf"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_2c;\n  undefined4 local_28;\n  undefined4 local_24;\n  undefined8 local_20;\n  void *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_24 = 0;\n  local_20 = 0;\n  local_2c = 1;\n  local_28 = 0;\n  local_18 = (void *)FUN_0000511d(\"passwordPASSWORDpassword\",\"sha256\",\n                                  \"saltSALTsaltSALTsaltSALTsaltSALTsalt\",&local_2c,&local_28);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x2b8,\"params\",local_18);\n  if (iVar1 != 0) {\n    local_20 = FUN_00002d68(\"PBKDF2\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x2b9,\"kctx = get_kdfbyname(OSSL_KDF_NAME_PBKDF2)\",\n                         local_20);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_20,local_18);\n      iVar1 = FUN_0000e3f6(\"test/evp_kdf_test.c\",699,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        local_24 = 1;\n      }\n    }\n  }\n  EVP_KDF_CTX_free(local_20);\n  CRYPTO_free(local_18);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_24;\n}\n\n",
        "output": "The predicted function name is test_kdf_pbkdf2_small_iterations"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](undefined8 param_1,int param_2)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long in_FS_OFFSET;\n  undefined8 local_b8;\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  int local_84;\n  undefined8 local_80;\n  undefined4 local_74;\n  undefined8 local_70;\n  undefined local_68 [40];\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined local_12 [2];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_74 = 0;\n  local_70 = 0;\n  local_84 = param_2;\n  local_80 = param_1;\n  local_70 = FUN_00002d68(&DAT_00013d1b);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x175,\"kctx = get_kdfbyname(OSSL_KDF_NAME_HKDF)\",\n                       local_70);\n  if (iVar1 != 0) {\n    if (local_84 == 4) {\n      OSSL_PARAM_construct_utf8_string(&local_b8,local_80,&DAT_00013eac,0);\n    }\n    else {\n      OSSL_PARAM_construct_octet_string(&local_b8,local_80,local_12,2);\n    }\n    OSSL_PARAM_construct_end(&local_b8);\n    local_40 = local_b8;\n    local_38 = local_b0;\n    local_30 = local_a8;\n    local_28 = local_a0;\n    local_20 = local_98;\n    uVar2 = EVP_KDF_CTX_set_params(local_70,local_68);\n    iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x17d,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                         &DAT_00013c2d,uVar2,0);\n    if (iVar1 != 0) {\n      local_74 = 1;\n    }\n  }\n  EVP_KDF_CTX_free(local_70);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_74;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is do_kdf_hkdf_set_invalid_param"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long in_FS_OFFSET;\n  undefined8 local_b8;\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined4 local_88;\n  undefined4 local_84;\n  undefined8 local_80;\n  undefined8 local_78;\n  undefined8 local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined local_1a [10];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_84 = 0;\n  local_88 = 0;\n  local_80 = 0;\n  local_80 = FUN_00002d68(&DAT_00013d1b);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x146,\"kctx = get_kdfbyname(OSSL_KDF_NAME_HKDF)\",\n                       local_80);\n  if (iVar1 != 0) {\n    OSSL_PARAM_construct_int(&local_b8,\"digest\",&local_88);\n    local_78 = local_b8;\n    local_70 = local_b0;\n    local_68 = local_a8;\n    local_60 = local_a0;\n    local_58 = local_98;\n    OSSL_PARAM_construct_end(&local_b8);\n    local_50 = local_b8;\n    local_48 = local_b0;\n    local_40 = local_a8;\n    local_38 = local_a0;\n    local_30 = local_98;\n    uVar2 = EVP_KDF_derive(local_80,local_1a,10,&local_78);\n    iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x14e,\n                         \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar2,0);\n    if (iVar1 != 0) {\n      local_84 = 1;\n    }\n  }\n  EVP_KDF_CTX_free(local_80);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_84;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_kdf_hkdf_derive_set_params_fail"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  FUN_00002d1a(0,param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is get_kdfbyname"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  long in_FS_OFFSET;\n  undefined8 local_38;\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = 0;\n  ptr = (void *)FUN_00002d87(\"sha256\",\"secret\",&DAT_00013cc4);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0xb8,\"params\",ptr);\n  if (iVar1 != 0) {\n    local_38 = FUN_00002d68(\"TLS1-PRF\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0xb9,\"kctx = get_kdfbyname(OSSL_KDF_NAME_TLS1_PRF)\",\n                         local_38);\n    if (iVar1 != 0) {\n      uVar2 = EVP_KDF_derive(local_38,local_28,0x10,ptr);\n      iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0xba,\n                           \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar2,0);\n      if (iVar1 != 0) {\n        uVar2 = 1;\n        goto LAB_000037a4;\n      }\n    }\n  }\n  uVar2 = 0;\nLAB_000037a4:\n  EVP_KDF_CTX_free(local_38);\n  CRYPTO_free(ptr);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_tls1_prf_1byte_seed"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  int iVar3;\n  undefined4 uVar4;\n  long in_FS_OFFSET;\n  undefined8 local_198;\n  undefined8 local_190;\n  undefined8 local_188;\n  undefined8 local_180;\n  undefined8 local_178;\n  undefined4 local_15c;\n  undefined8 *local_158;\n  undefined8 local_150;\n  undefined8 local_148;\n  undefined8 uStack320;\n  undefined8 uStack312;\n  undefined8 uStack304;\n  undefined8 uStack296;\n  undefined8 auStack288 [15];\n  undefined local_a8 [136];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_158 = auStack288;\n  OSSL_PARAM_construct_utf8_string(&local_198,\"digest\",\"sha512\",0);\n  puVar2 = local_158;\n  local_148 = local_198;\n  uStack320 = local_190;\n  uStack312 = local_188;\n  uStack304 = local_180;\n  uStack296 = local_178;\n  local_158 = local_158 + 5;\n  OSSL_PARAM_construct_octet_string(&local_198,&DAT_00013cfa,&DAT_002190a0,0x42);\n  uVar1 = local_190;\n  *puVar2 = local_198;\n  puVar2[1] = uVar1;\n  uVar1 = local_180;\n  puVar2[2] = local_188;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_178;\n  puVar2 = local_158;\n  local_158 = local_158 + 5;\n  OSSL_PARAM_construct_octet_string(&local_198,&DAT_00013cfe,&DAT_002190f0,0x10);\n  uVar1 = local_190;\n  *puVar2 = local_198;\n  puVar2[1] = uVar1;\n  uVar1 = local_180;\n  puVar2[2] = local_188;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_178;\n  puVar2 = local_158;\n  OSSL_PARAM_construct_end(&local_198);\n  *puVar2 = local_198;\n  puVar2[1] = local_190;\n  puVar2[2] = local_188;\n  puVar2[3] = local_180;\n  puVar2[4] = local_178;\n  local_150 = FUN_00002d68(\"X963KDF\");\n  iVar3 = FUN_0000e315(\"test/evp_kdf_test.c\",0x3a7,\"kctx = get_kdfbyname(OSSL_KDF_NAME_X963KDF)\",\n                       local_150);\n  if (iVar3 != 0) {\n    uVar4 = EVP_KDF_derive(local_150,local_a8,0x80,&local_148);\n    iVar3 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x3a8,\n                         \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar4,0);\n    if (iVar3 != 0) {\n      iVar3 = FUN_0000e848(\"test/evp_kdf_test.c\",0x3a9,&DAT_00013c68,\"expected\",local_a8,0x80,\n                           &DAT_00014b20,0x80);\n      if (iVar3 != 0) {\n        local_15c = 1;\n        goto LAB_00006c41;\n      }\n    }\n  }\n  local_15c = 0;\nLAB_00006c41:\n  EVP_KDF_CTX_free(local_150);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_15c;\n}\n\n",
        "output": "The predicted function name is test_kdf_x963"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 * [MASK](char *param_1,undefined8 param_2,char *param_3,undefined8 param_4)\n\n{\n  undefined8 *puVar1;\n  size_t sVar2;\n  undefined8 *puVar3;\n  long in_FS_OFFSET;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  undefined8 local_70;\n  undefined8 local_68;\n  undefined8 local_58;\n  char *local_50;\n  undefined8 local_48;\n  char *local_40;\n  undefined8 *local_30;\n  undefined8 *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_58 = param_4;\n  local_50 = param_3;\n  local_48 = param_2;\n  local_40 = param_1;\n  local_30 = (undefined8 *)CRYPTO_malloc(200,\"test/evp_kdf_test.c\",0x1df);\n  local_28 = local_30;\n  if (local_30 == (undefined8 *)0x0) {\n    puVar3 = (undefined8 *)0x0;\n  }\n  else {\n    sVar2 = strlen(local_40);\n    puVar3 = local_28;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_octet_string(&local_88,&DAT_00013eb0,local_40,sVar2);\n    *puVar3 = local_88;\n    puVar3[1] = local_80;\n    puVar3[2] = local_78;\n    puVar3[3] = local_70;\n    puVar3[4] = local_68;\n    sVar2 = strlen(local_50);\n    puVar3 = local_28;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_octet_string(&local_88,&DAT_00013cf5,local_50,sVar2);\n    puVar1 = local_28;\n    *puVar3 = local_88;\n    puVar3[1] = local_80;\n    puVar3[2] = local_78;\n    puVar3[3] = local_70;\n    puVar3[4] = local_68;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_uint(&local_88,&DAT_00013eb5,local_58);\n    puVar3 = local_28;\n    *puVar1 = local_88;\n    puVar1[1] = local_80;\n    puVar1[2] = local_78;\n    puVar1[3] = local_70;\n    puVar1[4] = local_68;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_utf8_string(&local_88,\"digest\",local_48,0);\n    puVar1 = local_28;\n    *puVar3 = local_88;\n    puVar3[1] = local_80;\n    puVar3[2] = local_78;\n    puVar3[3] = local_70;\n    puVar3[4] = local_68;\n    OSSL_PARAM_construct_end(&local_88);\n    *puVar1 = local_88;\n    puVar1[1] = local_80;\n    puVar1[2] = local_78;\n    puVar1[3] = local_70;\n    puVar1[4] = local_68;\n    puVar3 = local_30;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar3;\n}\n\n",
        "output": "The predicted function name is construct_pbkdf1_params"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  long in_FS_OFFSET;\n  undefined8 local_30;\n  undefined local_1a [10];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = 0;\n  ptr = (void *)FUN_000037e4(\"sha256\",\"secret\",6,&DAT_00013cf5,\"label\");\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x19c,\"params\",ptr);\n  if (iVar1 != 0) {\n    local_30 = FUN_00002d68(&DAT_00013d1b);\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x19d,\"kctx = get_kdfbyname(OSSL_KDF_NAME_HKDF)\",\n                         local_30);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_30,ptr);\n      iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0x19e,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        uVar2 = EVP_KDF_derive(local_30,local_1a,0,0);\n        iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x19f,\"EVP_KDF_derive(kctx, out, 0, NULL)\",\n                             &DAT_00013c2d,uVar2,0);\n        if (iVar1 != 0) {\n          uVar2 = 1;\n          goto LAB_00004818;\n        }\n      }\n    }\n  }\n  uVar2 = 0;\nLAB_00004818:\n  EVP_KDF_CTX_free(local_30);\n  CRYPTO_free(ptr);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_hkdf_zero_output_size"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_2c;\n  undefined4 local_28;\n  undefined4 local_24;\n  undefined8 local_20;\n  void *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_24 = 0;\n  local_20 = 0;\n  local_2c = 0x1000;\n  local_28 = 0;\n  local_18 = (void *)FUN_0000511d(\"passwordPASSWORDpassword\",\"sha256\",\"saltSALT\",&local_2c,&local_28\n                                 );\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x29f,\"params\",local_18);\n  if (iVar1 != 0) {\n    local_20 = FUN_00002d68(\"PBKDF2\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x2a0,\"kctx = get_kdfbyname(OSSL_KDF_NAME_PBKDF2)\",\n                         local_20);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_20,local_18);\n      iVar1 = FUN_0000e3f6(\"test/evp_kdf_test.c\",0x2a2,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        local_24 = 1;\n      }\n    }\n  }\n  EVP_KDF_CTX_free(local_20);\n  CRYPTO_free(local_18);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_24;\n}\n\n",
        "output": "The predicted function name is test_kdf_pbkdf2_small_salt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  long in_FS_OFFSET;\n  undefined8 local_38;\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = 0;\n  ptr = (void *)FUN_00002d87(\"sha256\",\"secret\",&DAT_00013cc3);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0xa5,\"params\",ptr);\n  if (iVar1 != 0) {\n    local_38 = FUN_00002d68(\"TLS1-PRF\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0xa6,\"kctx = get_kdfbyname(OSSL_KDF_NAME_TLS1_PRF)\",\n                         local_38);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_38,ptr);\n      iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0xa7,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        uVar2 = EVP_KDF_derive(local_38,local_28,0x10,0);\n        iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0xa8,\n                             \"EVP_KDF_derive(kctx, out, sizeof(out), NULL)\",&DAT_00013c2d,uVar2,0);\n        if (iVar1 != 0) {\n          uVar2 = 1;\n          goto LAB_00003679;\n        }\n      }\n    }\n  }\n  uVar2 = 0;\nLAB_00003679:\n  EVP_KDF_CTX_free(local_38);\n  CRYPTO_free(ptr);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_tls1_prf_empty_seed"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long in_FS_OFFSET;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined8 local_88;\n  undefined4 local_78;\n  undefined4 local_74;\n  undefined8 local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_74 = 0;\n  local_78 = 100;\n  local_70 = 0;\n  local_70 = FUN_00002d68(&DAT_00013d1b);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x15c,\"kctx = get_kdfbyname(OSSL_KDF_NAME_HKDF)\",\n                       local_70);\n  if (iVar1 != 0) {\n    OSSL_PARAM_construct_utf8_string(&local_a8,&DAT_00013d10,\"BADMODE\",0);\n    local_68 = local_a8;\n    local_60 = local_a0;\n    local_58 = local_98;\n    local_50 = local_90;\n    local_48 = local_88;\n    OSSL_PARAM_construct_end(&local_a8);\n    local_40 = local_a8;\n    local_38 = local_a0;\n    local_30 = local_98;\n    local_28 = local_90;\n    local_20 = local_88;\n    uVar2 = EVP_KDF_CTX_set_params(local_70,&local_68);\n    iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x161,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                         &DAT_00013c2d,uVar2,0);\n    if (iVar1 != 0) {\n      OSSL_PARAM_construct_int(&local_a8,&DAT_00013d10,&local_78);\n      local_68 = local_a8;\n      local_60 = local_a0;\n      local_58 = local_98;\n      local_50 = local_90;\n      local_48 = local_88;\n      uVar2 = EVP_KDF_CTX_set_params(local_70,&local_68);\n      iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x165,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           &DAT_00013c2d,uVar2,0);\n      if (iVar1 != 0) {\n        local_74 = 1;\n      }\n    }\n  }\n  EVP_KDF_CTX_free(local_70);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_74;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_kdf_hkdf_set_invalid_mode"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_00003bff(1,1);\n  return;\n}\n\n",
        "output": "The predicted function name is test_kdf_hkdf_gettables_expandonly"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = 0;\n  local_30 = 0;\n  local_28 = 0;\n  local_20 = 0;\n  ptr = (void *)FUN_000076f4(\"sha256\",&DAT_00014269,&DAT_00219203,1,&DAT_00014265,&DAT_00014260);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x496,\"params\",ptr);\n  if (iVar1 == 0) {\n    uVar2 = 0;\n    goto LAB_00007ed3;\n  }\n  uVar3 = FUN_00002d68(\"KBKDF\");\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x49a,&DAT_000141f4,uVar3);\n  if (iVar1 == 0) {\nLAB_00007ea4:\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = EVP_KDF_derive(uVar3,&local_38,0x20,ptr);\n    iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x49b,\n                         \"EVP_KDF_derive(kctx, result, sizeof(result), params)\",&DAT_00013c2d,uVar2,\n                         0);\n    if (iVar1 == 0) goto LAB_00007ea4;\n    uVar2 = 1;\n  }\n  EVP_KDF_CTX_free(uVar3);\n  CRYPTO_free(ptr);\nLAB_00007ed3:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_kbkdf_1byte_key"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  ASN1_OBJECT *o;\n  char *pcVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined4 local_24;\n  undefined8 local_20;\n  undefined8 local_18;\n  \n  local_20 = 0;\n  local_18 = 0;\n  local_24 = 1;\n  o = OBJ_nid2obj(0x45);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x5f0,\"obj = OBJ_nid2obj(NID_id_pbkdf2)\",o);\n  if (iVar1 == 0) {\nLAB_00009ad5:\n    local_24 = 0;\n  }\n  else {\n    local_20 = EVP_KDF_fetch(0,\"PBKDF2\",0);\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x5f1,\n                         \"kdf1 = EVP_KDF_fetch(NULL, OSSL_KDF_NAME_PBKDF2, NULL)\",local_20);\n    if (iVar1 == 0) goto LAB_00009ad5;\n    iVar1 = OBJ_obj2nid(o);\n    pcVar2 = OBJ_nid2sn(iVar1);\n    local_18 = EVP_KDF_fetch(0,pcVar2,0);\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x5f3,\n                         \"kdf2 = EVP_KDF_fetch(NULL, OBJ_nid2sn(OBJ_obj2nid(obj)), NULL)\",local_18);\n    if (iVar1 == 0) goto LAB_00009ad5;\n    iVar1 = FUN_00009921(local_20,local_18);\n    if (iVar1 == 0) goto LAB_00009ad5;\n  }\n  EVP_KDF_free(local_20);\n  EVP_KDF_free(local_18);\n  local_18 = 0;\n  uVar3 = EVP_KDF_fetch(0,\"TLS1-PRF\",0);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x5fb,\"kdf1 = EVP_KDF_fetch(NULL, SN_tls1_prf, NULL)\",\n                       uVar3);\n  if (iVar1 == 0) {\nLAB_00009b95:\n    local_24 = 0;\n  }\n  else {\n    local_18 = EVP_KDF_fetch(0,\"tls1-prf\",0);\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x5fc,\"kdf2 = EVP_KDF_fetch(NULL, LN_tls1_prf, NULL)\"\n                         ,local_18);\n    if (iVar1 == 0) goto LAB_00009b95;\n    iVar1 = FUN_00009921(uVar3,local_18);\n    if (iVar1 == 0) goto LAB_00009b95;\n  }\n  EVP_KDF_free(local_18);\n  pcVar2 = OBJ_nid2sn(0x3fd);\n  uVar4 = EVP_KDF_fetch(0,pcVar2,0);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x603,\n                       \"kdf2 = EVP_KDF_fetch(NULL, OBJ_nid2sn(NID_tls1_prf), NULL)\",uVar4);\n  if (iVar1 != 0) {\n    iVar1 = FUN_00009921(uVar3,uVar4);\n    if (iVar1 != 0) goto LAB_00009c11;\n  }\n  local_24 = 0;\nLAB_00009c11:\n  EVP_KDF_free(uVar3);\n  EVP_KDF_free(uVar4);\n  return local_24;\n}\n\n",
        "output": "The predicted function name is test_kdf_get_kdf"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  long in_FS_OFFSET;\n  undefined8 local_30;\n  undefined local_1a [10];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = 0;\n  ptr = (void *)FUN_000037e4(\"sha256\",\"secret\",6,&DAT_00013cc3,\"label\");\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x1d3,\"params\",ptr);\n  if (iVar1 != 0) {\n    local_30 = FUN_00002d68(&DAT_00013d1b);\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x1d4,\"kctx = get_kdfbyname(OSSL_KDF_NAME_HKDF)\",\n                         local_30);\n    if (iVar1 != 0) {\n      uVar2 = EVP_KDF_derive(local_30,local_1a,10,ptr);\n      iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x1d5,\n                           \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar2,0);\n      if (iVar1 != 0) {\n        uVar2 = 1;\n        goto LAB_00004bbd;\n      }\n    }\n  }\n  uVar2 = 0;\nLAB_00004bbd:\n  EVP_KDF_CTX_free(local_30);\n  CRYPTO_free(ptr);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_hkdf_empty_salt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  ulong uVar3;\n  long in_FS_OFFSET;\n  undefined4 local_88;\n  uint local_84;\n  undefined8 local_80;\n  void *local_78;\n  long local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  undefined local_58 [32];\n  undefined local_38;\n  undefined local_37;\n  undefined local_36;\n  undefined local_35;\n  undefined local_34;\n  undefined local_33;\n  undefined local_32;\n  undefined local_31;\n  undefined local_30;\n  undefined local_2f;\n  undefined local_2e;\n  undefined local_2d;\n  undefined local_2c;\n  undefined local_2b;\n  undefined local_2a;\n  undefined local_29;\n  undefined local_28;\n  undefined local_27;\n  undefined local_26;\n  undefined local_25;\n  undefined local_24;\n  undefined local_23;\n  undefined local_22;\n  undefined local_21;\n  undefined local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_84 = 0;\n  local_80 = 0;\n  local_88 = 0x1000;\n  local_60 = 0;\n  local_78 = (void *)0x0;\n  local_70 = 0;\n  local_68 = 0;\n  local_38 = 0xfb;\n  local_37 = 0x83;\n  local_36 = 0x4d;\n  local_35 = 0x36;\n  local_34 = 0x6d;\n  local_33 = 0xbc;\n  local_32 = 0x53;\n  local_31 = 0x87;\n  local_30 = 0x35;\n  local_2f = 0x1b;\n  local_2e = 0x34;\n  local_2d = 0x75;\n  local_2c = 0x95;\n  local_2b = 0x88;\n  local_2a = 0x32;\n  local_29 = 0x4f;\n  local_28 = 0x3e;\n  local_27 = 0x82;\n  local_26 = 0x81;\n  local_25 = 1;\n  local_24 = 0x21;\n  local_23 = 0x93;\n  local_22 = 100;\n  local_21 = 0;\n  local_20 = 0xcc;\n  local_60 = OSSL_LIB_CTX_new();\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x201,\"libctx = OSSL_LIB_CTX_new()\",local_60);\n  if (iVar1 != 0) {\n    local_70 = OSSL_PROVIDER_load(local_60,\"legacy\");\n    if (local_70 == 0) {\n      OSSL_LIB_CTX_free(local_60);\n      uVar3 = FUN_0000c6b6(\"test/evp_kdf_test.c\",0x208,\"PBKDF1 only available in legacy provider\");\n      goto LAB_00005107;\n    }\n    local_68 = OSSL_PROVIDER_load(local_60,\"default\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x20b,\n                         \"defprov = OSSL_PROVIDER_load(libctx, \\\"default\\\")\",local_68);\n    if (iVar1 != 0) {\n      local_78 = (void *)FUN_00004bfd(\"passwordPASSWORDpassword\",\"sha256\",\n                                      \"saltSALTsaltSALTsaltSALTsaltSALTsalt\",&local_88);\n      iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x212,\"params\",local_78);\n      if (iVar1 != 0) {\n        local_80 = FUN_00002d1a(local_60,\"PBKDF1\");\n        iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x213,\n                             \"kctx = get_kdfbyname_libctx(libctx, OSSL_KDF_NAME_PBKDF1)\",local_80);\n        if (iVar1 != 0) {\n          iVar1 = EVP_KDF_CTX_set_params(local_80,local_78);\n          iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0x214,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                               iVar1 != 0);\n          if (iVar1 != 0) {\n            uVar2 = EVP_KDF_derive(local_80,local_58,0x19,0);\n            iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x215,\n                                 \"EVP_KDF_derive(kctx, out, sizeof(out), NULL)\",&DAT_00013c2d,uVar2,\n                                 0);\n            if ((iVar1 != 0) &&\n               (iVar1 = FUN_0000e848(\"test/evp_kdf_test.c\",0x216,&DAT_00013c68,\"expected\",local_58,\n                                     0x19,&local_38,0x19), iVar1 != 0)) {\n              local_84 = 1;\n            }\n          }\n        }\n      }\n    }\n  }\n  EVP_KDF_CTX_free(local_80);\n  CRYPTO_free(local_78);\n  OSSL_PROVIDER_unload(local_68);\n  OSSL_PROVIDER_unload(local_70);\n  OSSL_LIB_CTX_free(local_60);\n  uVar3 = (ulong)local_84;\nLAB_00005107:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_kdf_pbkdf1"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 * [MASK](undefined8 param_1,char *param_2,char *param_3)\n\n{\n  undefined8 *puVar1;\n  size_t sVar2;\n  undefined8 *puVar3;\n  long in_FS_OFFSET;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  undefined8 local_70;\n  undefined8 local_68;\n  char *local_50;\n  char *local_48;\n  undefined8 local_40;\n  undefined8 *local_30;\n  undefined8 *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_50 = param_3;\n  local_48 = param_2;\n  local_40 = param_1;\n  puVar1 = (undefined8 *)CRYPTO_malloc(0xa0,\"test/evp_kdf_test.c\",0x28);\n  local_30 = puVar1;\n  if (puVar1 == (undefined8 *)0x0) {\n    puVar3 = (undefined8 *)0x0;\n    local_28 = puVar1;\n  }\n  else {\n    local_28 = puVar1 + 5;\n    OSSL_PARAM_construct_utf8_string(&local_88,\"digest\",local_40,0);\n    *puVar1 = local_88;\n    puVar1[1] = local_80;\n    puVar1[2] = local_78;\n    puVar1[3] = local_70;\n    puVar1[4] = local_68;\n    sVar2 = strlen(local_48);\n    puVar1 = local_28;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_octet_string(&local_88,\"secret\",local_48,sVar2);\n    *puVar1 = local_88;\n    puVar1[1] = local_80;\n    puVar1[2] = local_78;\n    puVar1[3] = local_70;\n    puVar1[4] = local_68;\n    sVar2 = strlen(local_50);\n    puVar1 = local_28;\n    local_28 = local_28 + 5;\n    OSSL_PARAM_construct_octet_string(&local_88,&DAT_00013be2,local_50,sVar2);\n    puVar3 = local_28;\n    *puVar1 = local_88;\n    puVar1[1] = local_80;\n    puVar1[2] = local_78;\n    puVar1[3] = local_70;\n    puVar1[4] = local_68;\n    OSSL_PARAM_construct_end(&local_88);\n    *puVar3 = local_88;\n    puVar3[1] = local_80;\n    puVar3[2] = local_78;\n    puVar3[3] = local_70;\n    puVar3[4] = local_68;\n    puVar3 = local_30;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar3;\n}\n\n",
        "output": "The predicted function name is construct_tls1_prf_params"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long in_FS_OFFSET;\n  undefined4 local_5c;\n  undefined4 local_58;\n  undefined4 local_54;\n  undefined8 local_50;\n  long local_48;\n  void *local_40;\n  undefined local_38 [40];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_54 = 0;\n  local_50 = 0;\n  local_48 = 0;\n  local_5c = 0x1000;\n  local_58 = 0;\n  local_40 = (void *)FUN_0000511d(\"passwordPASSWORDpassword\",\"sha256\",\n                                  \"saltSALTsaltSALTsaltSALTsaltSALTsalt\",&local_5c,&local_58);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x285,\"params\",local_40);\n  if (iVar1 != 0) {\n    local_50 = FUN_00002d68(\"PBKDF2\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x286,\"kctx = get_kdfbyname(OSSL_KDF_NAME_PBKDF2)\",\n                         local_50);\n    if (iVar1 != 0) {\n      iVar1 = EVP_KDF_CTX_set_params(local_50,local_40);\n      iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0x288,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                           iVar1 != 0);\n      if (iVar1 != 0) {\n        if (local_48 != 0) {\n          uVar2 = EVP_KDF_derive(local_50,local_38,local_48,0);\n          iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x289,\"EVP_KDF_derive(kctx, out, len, NULL)\",\n                               &DAT_00013c2d,uVar2,0);\n          if (iVar1 == 0) goto LAB_00005868;\n        }\n        local_54 = 1;\n      }\n    }\n  }\nLAB_00005868:\n  EVP_KDF_CTX_free(local_50);\n  CRYPTO_free(local_40);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_54;\n}\n\n",
        "output": "The predicted function name is test_kdf_pbkdf2_large_output"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long in_FS_OFFSET;\n  undefined4 local_74;\n  undefined4 local_70;\n  undefined4 local_6c;\n  undefined8 local_68;\n  void *local_60;\n  undefined local_58 [32];\n  undefined local_38;\n  undefined local_37;\n  undefined local_36;\n  undefined local_35;\n  undefined local_34;\n  undefined local_33;\n  undefined local_32;\n  undefined local_31;\n  undefined local_30;\n  undefined local_2f;\n  undefined local_2e;\n  undefined local_2d;\n  undefined local_2c;\n  undefined local_2b;\n  undefined local_2a;\n  undefined local_29;\n  undefined local_28;\n  undefined local_27;\n  undefined local_26;\n  undefined local_25;\n  undefined local_24;\n  undefined local_23;\n  undefined local_22;\n  undefined local_21;\n  undefined local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_6c = 0;\n  local_68 = 0;\n  local_74 = 0x1000;\n  local_70 = 0;\n  local_38 = 0x34;\n  local_37 = 0x8c;\n  local_36 = 0x89;\n  local_35 = 0xdb;\n  local_34 = 0xcb;\n  local_33 = 0xd3;\n  local_32 = 0x2b;\n  local_31 = 0x2f;\n  local_30 = 0x32;\n  local_2f = 0xd8;\n  local_2e = 0x14;\n  local_2d = 0xb8;\n  local_2c = 0x11;\n  local_2b = 0x6e;\n  local_2a = 0x84;\n  local_29 = 0xcf;\n  local_28 = 0x2b;\n  local_27 = 0x17;\n  local_26 = 0x34;\n  local_25 = 0x7e;\n  local_24 = 0xbc;\n  local_23 = 0x18;\n  local_22 = 0;\n  local_21 = 0x18;\n  local_20 = 0x1c;\n  local_60 = (void *)FUN_0000511d(\"passwordPASSWORDpassword\",\"sha256\",\n                                  \"saltSALTsaltSALTsaltSALTsaltSALTsalt\",&local_74,&local_70);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x24c,\"params\",local_60);\n  if (iVar1 != 0) {\n    local_68 = FUN_00002d68(\"PBKDF2\");\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x24d,\"kctx = get_kdfbyname(OSSL_KDF_NAME_PBKDF2)\",\n                         local_68);\n    if (iVar1 != 0) {\n      uVar2 = EVP_KDF_derive(local_68,local_58,0x19,local_60);\n      iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x24e,\n                           \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar2,0);\n      if (iVar1 != 0) {\n        iVar1 = FUN_0000e848(\"test/evp_kdf_test.c\",0x24f,&DAT_00013c68,\"expected\",local_58,0x19,\n                             &local_38,0x19);\n        if (iVar1 != 0) {\n          local_6c = 1;\n        }\n      }\n    }\n  }\n  EVP_KDF_CTX_free(local_68);\n  CRYPTO_free(local_60);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_6c;\n}\n\n",
        "output": "The predicted function name is test_kdf_pbkdf2"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  int iVar3;\n  undefined4 uVar4;\n  long in_FS_OFFSET;\n  undefined8 local_178;\n  undefined8 local_170;\n  undefined8 local_168;\n  undefined8 local_160;\n  undefined8 local_158;\n  undefined4 local_13c;\n  undefined8 *local_138;\n  undefined8 local_130;\n  undefined8 local_128;\n  undefined8 uStack288;\n  undefined8 uStack280;\n  undefined8 uStack272;\n  undefined8 uStack264;\n  undefined8 auStack256 [25];\n  undefined local_38 [24];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_138 = auStack256;\n  OSSL_PARAM_construct_utf8_string(&local_178,&DAT_000141e1,&DAT_00014269,0);\n  puVar2 = local_138;\n  local_128 = local_178;\n  uStack288 = local_170;\n  uStack280 = local_168;\n  uStack272 = local_160;\n  uStack264 = local_158;\n  local_138 = local_138 + 5;\n  OSSL_PARAM_construct_utf8_string(&local_178,\"digest\",\"sha256\",0);\n  uVar1 = local_170;\n  *puVar2 = local_178;\n  puVar2[1] = uVar1;\n  uVar1 = local_160;\n  puVar2[2] = local_168;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_158;\n  puVar2 = local_138;\n  local_138 = local_138 + 5;\n  OSSL_PARAM_construct_octet_string(&local_178,&DAT_00013cfa,&DAT_002192f0,0xe);\n  uVar1 = local_170;\n  *puVar2 = local_178;\n  puVar2[1] = uVar1;\n  uVar1 = local_160;\n  puVar2[2] = local_168;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_158;\n  puVar2 = local_138;\n  local_138 = local_138 + 5;\n  OSSL_PARAM_construct_octet_string(&local_178,&DAT_00013cfe,&DAT_00219300,0xc);\n  uVar1 = local_170;\n  *puVar2 = local_178;\n  puVar2[1] = uVar1;\n  uVar1 = local_160;\n  puVar2[2] = local_168;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_158;\n  puVar2 = local_138;\n  local_138 = local_138 + 5;\n  OSSL_PARAM_construct_octet_string(&local_178,&DAT_00013cf5,&DAT_00219310,0x10);\n  uVar1 = local_170;\n  *puVar2 = local_178;\n  puVar2[1] = uVar1;\n  uVar1 = local_160;\n  puVar2[2] = local_168;\n  puVar2[3] = uVar1;\n  puVar2[4] = local_158;\n  puVar2 = local_138;\n  OSSL_PARAM_construct_end(&local_178);\n  *puVar2 = local_178;\n  puVar2[1] = local_170;\n  puVar2[2] = local_168;\n  puVar2[3] = local_160;\n  puVar2[4] = local_158;\n  local_130 = FUN_00002d68(\"SSKDF\");\n  iVar3 = FUN_0000e315(\"test/evp_kdf_test.c\",0x56e,\"kctx = get_kdfbyname(OSSL_KDF_NAME_SSKDF)\",\n                       local_130);\n  if (iVar3 != 0) {\n    uVar4 = EVP_KDF_derive(local_130,local_38,0x10,&local_128);\n    iVar3 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x56f,\n                         \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar4,0);\n    if (iVar3 != 0) {\n      iVar3 = FUN_0000e848(\"test/evp_kdf_test.c\",0x570,&DAT_00013c68,\"expected\",local_38,0x10,\n                           &DAT_00014bb0,0x10);\n      if (iVar3 != 0) {\n        local_13c = 1;\n        goto LAB_000091bd;\n      }\n    }\n  }\n  local_13c = 0;\nLAB_000091bd:\n  EVP_KDF_CTX_free(local_130);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_13c;\n}\n\n",
        "output": "The predicted function name is test_kdf_ss_hmac"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = 0;\n  local_30 = 0;\n  local_28 = 0;\n  local_20 = 0;\n  ptr = (void *)FUN_000076f4(\"sha256\",&DAT_00014269,&DAT_00219202,0,&DAT_00014265,&DAT_00014260);\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x47e,\"params\",ptr);\n  if (iVar1 == 0) {\n    uVar2 = 0;\n    goto LAB_00007d77;\n  }\n  uVar3 = FUN_00002d68(\"KBKDF\");\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x483,&DAT_000141f4,uVar3);\n  if (iVar1 == 0) {\nLAB_00007d48:\n    uVar2 = 0;\n  }\n  else {\n    iVar1 = EVP_KDF_CTX_set_params(uVar3,ptr);\n    iVar1 = FUN_0000e38a(\"test/evp_kdf_test.c\",0x484,\"EVP_KDF_CTX_set_params(kctx, params)\",\n                         iVar1 != 0);\n    if (iVar1 == 0) goto LAB_00007d48;\n    uVar2 = EVP_KDF_derive(uVar3,&local_38,0x20,0);\n    iVar1 = FUN_0000c8d6(\"test/evp_kdf_test.c\",0x485,\n                         \"EVP_KDF_derive(kctx, result, sizeof(result), NULL)\",&DAT_00013c2d,uVar2,0)\n    ;\n    if (iVar1 == 0) goto LAB_00007d48;\n    uVar2 = 1;\n  }\n  EVP_KDF_CTX_free(uVar3);\n  CRYPTO_free(ptr);\nLAB_00007d77:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_kbkdf_empty_key"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  void *ptr;\n  long in_FS_OFFSET;\n  undefined8 local_30;\n  undefined local_1a [10];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = 0;\n  ptr = (void *)FUN_000037e4(\"sha256\",&DAT_00013cc3,0,&DAT_00013cf5,\"label\");\n  iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x1af,\"params\",ptr);\n  if (iVar1 != 0) {\n    local_30 = FUN_00002d68(&DAT_00013d1b);\n    iVar1 = FUN_0000e315(\"test/evp_kdf_test.c\",0x1b0,\"kctx = get_kdfbyname(OSSL_KDF_NAME_HKDF)\",\n                         local_30);\n    if (iVar1 != 0) {\n      uVar2 = EVP_KDF_derive(local_30,local_1a,10,ptr);\n      iVar1 = FUN_0000cad2(\"test/evp_kdf_test.c\",0x1b1,\n                           \"EVP_KDF_derive(kctx, out, sizeof(out), params)\",&DAT_00013c2d,uVar2,0);\n      if (iVar1 != 0) {\n        uVar2 = 1;\n        goto LAB_0000494f;\n      }\n    }\n  }\n  uVar2 = 0;\nLAB_0000494f:\n  EVP_KDF_CTX_free(local_30);\n  CRYPTO_free(ptr);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is test_kdf_hkdf_empty_key"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](double *param_1)\n\n{\n  long in_FS_OFFSET;\n  double in_stack_00000008;\n  double in_stack_00000010;\n  double in_stack_00000018;\n  double in_stack_00000020;\n  double in_stack_00000028;\n  double in_stack_00000030;\n  double local_88;\n  double local_80;\n  double local_78;\n  double local_68;\n  double local_60;\n  double local_58;\n  double local_48;\n  double local_40;\n  double local_38;\n  double local_28;\n  double local_20;\n  double local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (((in_stack_00000020 == 0.0) && (in_stack_00000028 == 0.0)) &&\n     (in_stack_00000030 == DAT_000067f0)) {\n    *param_1 = in_stack_00000008;\n    param_1[1] = in_stack_00000010;\n    param_1[2] = in_stack_00000018;\n  }\n  else if (((in_stack_00000020 == 0.0) && (in_stack_00000028 == 0.0)) &&\n          (in_stack_00000030 == DAT_000067f8)) {\n    *param_1 = in_stack_00000008;\n    param_1[1] = in_stack_00000010;\n    param_1[2] = in_stack_00000018;\n    *param_1 = (double)(DAT_00006800 ^ (ulong)*param_1);\n  }\n  else {\n    local_48 = in_stack_00000020;\n    local_40 = in_stack_00000028;\n    local_38 = in_stack_00000030;\n    FUN_0000542c(&local_68);\n    if ((DAT_00006820 <= (double)(DAT_00006810 & (ulong)local_68)) ||\n       (DAT_00006820 <= (double)(DAT_00006810 & (ulong)local_60))) {\n      local_28 = 0.0;\n      local_20 = 0.0;\n      local_18 = DAT_000067f0;\n      FUN_00005506(&local_28);\n      FUN_0000542c(&local_88);\n    }\n    else {\n      local_28 = 0.0;\n      local_20 = DAT_000067f0;\n      local_18 = 0.0;\n      FUN_00005506(0,&local_28);\n      FUN_0000542c(&local_88);\n    }\n    FUN_00005506(&local_28);\n    FUN_0000542c(&local_28);\n    *param_1 = local_78 * in_stack_00000018 +\n               in_stack_00000008 * local_88 + local_80 * in_stack_00000010;\n    param_1[1] = local_18 * in_stack_00000018 +\n                 in_stack_00000008 * local_28 + local_20 * in_stack_00000010;\n    param_1[2] = local_58 * in_stack_00000018 +\n                 in_stack_00000008 * local_68 + local_60 * in_stack_00000010;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is transform_OCS"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Removing unreachable block (ram,0x000046b9) */\n/* WARNING: Removing unreachable block (ram,0x000046d2) */\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid [MASK](long param_1)\n\n{\n  long lVar1;\n  ushort local_26;\n  int local_24;\n  \n  local_24 = 0;\n  DAT_002091f8 = (char *)dwg_model_x_min(param_1);\n  DAT_00209200 = (double)dwg_model_y_min(param_1);\n  DAT_00209208 = (double)dwg_model_x_max(param_1);\n  DAT_00209210 = (double)dwg_model_y_max(param_1);\n  DAT_00209218 = DAT_00209208 - (double)DAT_002091f8;\n  DAT_00209220 = DAT_00209210 - DAT_00209200;\n  _DAT_00209228 = DAT_000067d8;\n  printf(DAT_002091f8,DAT_00209200,DAT_00209218,DAT_00209220,\n         \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\\n<svg\\n   xmlns:svg=\\\"http://www.w3.org/2000/svg\\\"\\n   xmlns=\\\"http://www.w3.org/2000/svg\\\"\\n   xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\"\\n   version=\\\"1.1\\\" baseProfile=\\\"basic\\\"\\n   width=\\\"100%%\\\" height=\\\"100%%\\\"\\n   viewBox=\\\"%f %f %f %f\\\">\\n\"\n        );\n  if ((DAT_00209234 == 0) && (lVar1 = dwg_paper_space_ref(param_1), lVar1 != 0)) {\n    local_24 = FUN_00004363(lVar1);\n  }\n  if ((local_24 == 0) && (lVar1 = dwg_model_space_ref(param_1), lVar1 != 0)) {\n    FUN_00004363(lVar1);\n  }\n  puts(\"\\t<defs>\");\n  for (local_26 = 0; local_26 < *(ushort *)(param_1 + 3000); local_26 = local_26 + 1) {\n    lVar1 = *(long *)(*(long *)(param_1 + 0xbc0) + (ulong)local_26 * 8);\n    if (lVar1 != 0) {\n      FUN_00004363(lVar1);\n    }\n  }\n  puts(\"\\t</defs>\");\n  puts(\"</svg>\");\n  return;\n}\n\n",
        "output": "The predicted function name is output_SVG"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](double *param_1)\n\n{\n  double dVar1;\n  double in_stack_00000008;\n  double in_stack_00000010;\n  double in_stack_00000018;\n  \n  dVar1 = sqrt(in_stack_00000018 * in_stack_00000018 +\n               in_stack_00000008 * in_stack_00000008 + in_stack_00000010 * in_stack_00000010);\n  *param_1 = in_stack_00000008;\n  param_1[1] = in_stack_00000010;\n  param_1[2] = in_stack_00000018;\n  if ((DAT_000067f0 != dVar1) && (dVar1 != 0.0)) {\n    *param_1 = in_stack_00000008 / dVar1;\n    param_1[1] = in_stack_00000010 / dVar1;\n    param_1[2] = in_stack_00000018 / dVar1;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is normalize"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  char cVar1;\n  long in_FS_OFFSET;\n  undefined8 uVar2;\n  char *__format;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  cVar1 = FUN_00001be7();\n  if (cVar1 == '\\0') {\n    cVar1 = FUN_00001be7();\n    if (cVar1 == '\\0') {\n      cVar1 = FUN_00001c1d(param_1);\n      if (cVar1 == '\\0') {\n        FUN_000058cd(&local_28);\n        printf(\"\\t<!-- point-%d -->\\n\",(ulong)*(uint *)(param_1 + 0x14));\n        uVar2 = FUN_00001b1f(local_20);\n        __format = (char *)FUN_00001b03(local_28);\n        printf(__format,uVar2,\"\\t<circle id=\\\"dwg-object-%d\\\" cx=\\\"%f\\\" cy=\\\"%f\\\" r=\\\"0.1\\\"\\n\\t\",\n               (ulong)*(uint *)(param_1 + 0x14));\n        FUN_00001e87(*(undefined8 *)(param_1 + 0x38));\n      }\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is output_POINT"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  long lVar1;\n  char cVar2;\n  long in_FS_OFFSET;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  undefined8 uVar8;\n  undefined8 uVar9;\n  char *__format;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  undefined8 local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar1 = *(long *)(*(long *)(param_1 + 0x38) + 8);\n  local_50 = *(undefined8 *)(lVar1 + 0x20);\n  local_58 = *(undefined8 *)(lVar1 + 0x18);\n  local_40 = *(undefined8 *)(lVar1 + 0x30);\n  local_48 = *(undefined8 *)(lVar1 + 0x28);\n  local_30 = *(undefined8 *)(lVar1 + 0x40);\n  local_38 = *(undefined8 *)(lVar1 + 0x38);\n  local_20 = *(undefined8 *)(lVar1 + 0x50);\n  local_28 = *(undefined8 *)(lVar1 + 0x48);\n  cVar2 = FUN_00001b4b(local_58,local_50);\n  if (cVar2 == '\\0') {\n    cVar2 = FUN_00001b4b(local_48,local_40);\n    if (cVar2 == '\\0') {\n      cVar2 = FUN_00001b4b(local_38,local_30);\n      if (cVar2 == '\\0') {\n        cVar2 = FUN_00001b4b(local_28,local_20);\n        if (cVar2 == '\\0') {\n          cVar2 = FUN_00001c1d(param_1);\n          if (cVar2 == '\\0') {\n            FUN_0000558b(local_58,local_50,&local_98);\n            FUN_0000558b(local_48,local_40,&local_88);\n            FUN_0000558b(local_38,local_30,&local_78);\n            FUN_0000558b(local_28,local_20,&local_68);\n            printf(\"\\t<!-- solid-%d -->\\n\",(ulong)*(uint *)(param_1 + 0x14));\n            uVar3 = FUN_00001b1f(local_60);\n            uVar4 = FUN_00001b03(local_68);\n            uVar5 = FUN_00001b1f(local_70);\n            uVar6 = FUN_00001b03(local_78);\n            uVar7 = FUN_00001b1f(local_80);\n            uVar8 = FUN_00001b03(local_88);\n            uVar9 = FUN_00001b1f(local_90);\n            __format = (char *)FUN_00001b03(local_98);\n            printf(__format,uVar9,uVar8,uVar7,uVar6,uVar5,uVar4,uVar3,\n                   \"\\t<polygon id=\\\"dwg-object-%d\\\" points=\\\"%f,%f %f,%f %f,%f %f,%f\\\"\\n\\t\",\n                   (ulong)*(uint *)(param_1 + 0x14));\n            FUN_00001e87(*(undefined8 *)(param_1 + 0x38));\n          }\n        }\n      }\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is output_SOLID"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  long lVar1;\n  char cVar2;\n  undefined *puVar3;\n  \n  lVar1 = *(long *)(*(long *)(param_1 + 0x38) + 8);\n  cVar2 = FUN_00001be7();\n  if (cVar2 == '\\0') {\n    cVar2 = FUN_00001be7();\n    if (cVar2 == '\\0') {\n      cVar2 = FUN_00001be7();\n      if (cVar2 == '\\0') {\n        cVar2 = FUN_00001be7();\n        if (cVar2 == '\\0') {\n          cVar2 = FUN_00001c1d(param_1);\n          if (cVar2 == '\\0') {\n            printf(\"\\t<!-- 3dface-%d -->\\n\",(ulong)*(uint *)(param_1 + 0x14));\n            if (*(short *)(lVar1 + 0x70) == 0) {\n              printf(*(char **)(lVar1 + 0x10),*(undefined8 *)(lVar1 + 0x18),\n                     *(undefined8 *)(lVar1 + 0x28),*(undefined8 *)(lVar1 + 0x30),\n                     *(undefined8 *)(lVar1 + 0x40),*(undefined8 *)(lVar1 + 0x48),\n                     *(undefined8 *)(lVar1 + 0x58),*(undefined8 *)(lVar1 + 0x60),\n                     \"\\t<polygon id=\\\"dwg-object-%d\\\" points=\\\"%f,%f %f,%f %f,%f %f,%f\\\"\\n\\t\",\n                     (ulong)*(uint *)(param_1 + 0x14));\n            }\n            else {\n              printf(*(char **)(lVar1 + 0x10),*(undefined8 *)(lVar1 + 0x18),\n                     \"\\t<path id=\\\"dwg-object-%d\\\" d=\\\"M %f,%f\",(ulong)*(uint *)(param_1 + 0x14));\n              if ((*(ushort *)(lVar1 + 0x70) & 1) == 0) {\n                puVar3 = &DAT_0000629f;\n              }\n              else {\n                puVar3 = &DAT_0000629d;\n              }\n              printf(*(char **)(lVar1 + 0x28),*(undefined8 *)(lVar1 + 0x30),\" %s %f,%f\",puVar3);\n              if ((*(ushort *)(lVar1 + 0x70) & 2) == 0) {\n                puVar3 = &DAT_0000629f;\n              }\n              else {\n                puVar3 = &DAT_0000629d;\n              }\n              printf(*(char **)(lVar1 + 0x40),*(undefined8 *)(lVar1 + 0x48),\" %s %f,%f\",puVar3);\n              if ((*(ushort *)(lVar1 + 0x70) & 4) == 0) {\n                puVar3 = &DAT_0000629f;\n              }\n              else {\n                puVar3 = &DAT_0000629d;\n              }\n              printf(*(char **)(lVar1 + 0x58),*(undefined8 *)(lVar1 + 0x60),\" %s %f,%f\",puVar3);\n              if ((*(ushort *)(lVar1 + 0x70) & 8) == 0) {\n                puVar3 = &DAT_0000629f;\n              }\n              else {\n                puVar3 = &DAT_0000629d;\n              }\n              printf(*(char **)(lVar1 + 0x10),*(undefined8 *)(lVar1 + 0x18),\" %s %f,%f\\\"\\n\\t\",puVar3\n                    );\n            }\n            FUN_00001e87(*(undefined8 *)(param_1 + 0x38));\n          }\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is output_3DFACE"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](long *param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  bool bVar3;\n  int iVar4;\n  char *pcVar5;\n  int local_34;\n  long local_30;\n  char *local_28;\n  \n  bVar3 = false;\n  local_34 = 0;\n  if (param_1 == (long *)0x0) {\n    local_34 = 0;\n  }\n  else if (*param_1 == 0) {\n    local_34 = 0;\n  }\n  else {\n    lVar1 = *param_1;\n    if (*(int *)(lVar1 + 0x10) == 0x31) {\n      if (*(long *)(lVar1 + 0x38) == 0) {\n        fwrite(\"Found null obj->tio.object\\n\",1,0x1b,stderr);\n        local_34 = 0;\n      }\n      else if (*(long *)(*(long *)(lVar1 + 0x38) + 8) == 0) {\n        fwrite(\"Found null obj->tio.object->tio.BLOCK_HEADER\\n\",1,0x2d,stderr);\n        local_34 = 0;\n      }\n      else {\n        lVar2 = *(long *)(*(long *)(lVar1 + 0x38) + 8);\n        if (*(long *)(lVar2 + 0x10) != 0) {\n          if (**(uint **)(lVar1 + 0x58) < 0x1a) {\n            local_28 = (char *)FUN_00004ca4(*(undefined8 *)(lVar2 + 0x10),\n                                            *(undefined2 *)((long)*(uint **)(lVar1 + 0x58) + 0x1e));\n          }\n          else {\n            local_28 = (char *)FUN_00005071(*(undefined8 *)(lVar2 + 0x10));\n          }\n          if ((local_28 != (char *)0x0) && (pcVar5 = strstr(local_28,\"--\"), pcVar5 != (char *)0x0))\n          {\n            while (pcVar5 = strstr(local_28,\"--\"), pcVar5 != (char *)0x0) {\n              *pcVar5 = '_';\n              pcVar5[1] = '_';\n            }\n          }\n          if ((local_28 == (char *)0x0) || (iVar4 = strcmp(local_28,\"*Model_Space\"), iVar4 != 0)) {\n            bVar3 = true;\n            pcVar5 = local_28;\n            if (local_28 == (char *)0x0) {\n              pcVar5 = \"\";\n            }\n            printf(\"\\t<g id=\\\"symbol-%lX\\\" >\\n\\t\\t<!-- %s -->\\n\",param_1[4],pcVar5);\n          }\n          else {\n            printf(\"\\t<!-- %s -->\\n\",local_28);\n          }\n          if (local_28 != (char *)0x0) {\n            free(local_28);\n          }\n        }\n        for (local_30 = get_first_owned_entity(*param_1); local_30 != 0;\n            local_30 = get_next_owned_entity(*param_1,local_30)) {\n          iVar4 = FUN_000041de(local_30);\n          local_34 = local_34 + iVar4;\n        }\n        if (bVar3) {\n          puts(\"\\t</g>\");\n        }\n      }\n    }\n    else {\n      fwrite(\"Argument not a BLOCK_HEADER reference\\n\",1,0x26,stderr);\n      local_34 = 0;\n    }\n  }\n  return local_34;\n}\n\n",
        "output": "The predicted function name is output_BLOCK_HEADER"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  byte bVar3;\n  byte bVar4;\n  long lVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  char cVar8;\n  long in_FS_OFFSET;\n  undefined8 uVar9;\n  char *__format;\n  double dVar10;\n  undefined8 local_48;\n  undefined8 local_40;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar5 = *(long *)(*(long *)(param_1 + 0x38) + 8);\n  cVar8 = FUN_00001c1d(param_1);\n  if (cVar8 == '\\0') {\n    if ((*(long *)(lVar5 + 0x68) == 0) || (*(long *)(*(long *)(lVar5 + 0x68) + 0x10) == 0)) {\n      printf(\"\\n\\n<!-- WRONG INSERT(%u.%u.%lX) -->\\n\",(ulong)*(byte *)(param_1 + 0x40),\n             (ulong)*(byte *)(param_1 + 0x41),*(undefined8 *)(param_1 + 0x48));\n    }\n    else {\n      cVar8 = FUN_00001be7();\n      if (((cVar8 == '\\0') && (cVar8 = FUN_00001be7(), cVar8 == '\\0')) &&\n         (cVar8 = FUN_00001be7(), cVar8 == '\\0')) {\n        FUN_000058cd(&local_48);\n        printf(\"\\t<!-- insert-%d -->\\n\",(ulong)*(uint *)(param_1 + 0x14));\n        uVar6 = *(undefined8 *)(*(long *)(lVar5 + 0x68) + 0x10);\n        bVar3 = *(byte *)(*(long *)(lVar5 + 0x68) + 9);\n        bVar4 = *(byte *)(*(long *)(lVar5 + 0x68) + 8);\n        uVar7 = *(undefined8 *)(*(long *)(lVar5 + 0x68) + 0x20);\n        uVar1 = *(undefined8 *)(lVar5 + 0x30);\n        uVar2 = *(undefined8 *)(lVar5 + 0x28);\n        dVar10 = *(double *)(lVar5 + 0x40) * DAT_000067d0;\n        uVar9 = FUN_00001b1f(local_40);\n        __format = (char *)FUN_00001b03(local_48);\n        printf(__format,uVar9,dVar10,uVar2,uVar1,\n               \"\\t<use id=\\\"dwg-object-%d\\\" transform=\\\"translate(%f %f) rotate(%f) scale(%f %f)\\\" xlink:href=\\\"#symbol-%lX\\\" /><!-- block_header->handleref: %u.%u.%lX -->\\n\"\n               ,(ulong)*(uint *)(param_1 + 0x14),uVar7,(ulong)bVar4,(ulong)bVar3,uVar6);\n      }\n    }\n  }\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is output_INSERT"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  char cVar1;\n  long in_FS_OFFSET;\n  undefined8 uVar2;\n  char *pcVar3;\n  int local_54;\n  uint local_50;\n  uint local_4c;\n  long local_48;\n  undefined8 *local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48 = *(long *)(*(long *)(param_1 + 0x38) + 8);\n  cVar1 = FUN_00001c1d(param_1);\n  if ((((cVar1 == '\\0') &&\n       (local_4c = dwg_object_polyline_2d_get_numpoints(param_1,&local_54), local_4c != 0)) &&\n      (local_54 == 0)) &&\n     (((local_40 = (undefined8 *)dwg_object_polyline_2d_get_points(param_1,&local_54), local_54 == 0\n       && (cVar1 = FUN_00001b99(*local_40,local_40[1]), cVar1 == '\\0')) &&\n      (cVar1 = FUN_00001be7(), cVar1 == '\\0')))) {\n    local_28 = *local_40;\n    local_20 = local_40[1];\n    FUN_0000558b(local_28,local_20,&local_38);\n    printf(\"\\t<!-- polyline_2d-%d -->\\n\",(ulong)*(uint *)(param_1 + 0x14));\n    uVar2 = FUN_00001b1f(local_30);\n    pcVar3 = (char *)FUN_00001b03(local_38);\n    printf(pcVar3,uVar2,\"\\t<path id=\\\"dwg-object-%d\\\" d=\\\"M %f,%f\",(ulong)*(uint *)(param_1 + 0x14))\n    ;\n    for (local_50 = 1; local_50 < local_4c; local_50 = local_50 + 1) {\n      local_28 = local_40[(ulong)local_50 * 2];\n      local_20 = local_40[(ulong)local_50 * 2 + 1];\n      cVar1 = FUN_00001b4b(local_28,local_20);\n      if (cVar1 == '\\0') {\n        FUN_0000558b(local_28,local_20,&local_38);\n        uVar2 = FUN_00001b1f(local_30);\n        pcVar3 = (char *)FUN_00001b03(local_38);\n        printf(pcVar3,uVar2,\" L %f,%f\");\n      }\n    }\n    if ((*(ushort *)(local_48 + 0x30) & 1) != 0) {\n      printf(\" Z\");\n    }\n    printf(\"\\\"\\n\\t\");\n    FUN_00001e87(*(undefined8 *)(param_1 + 0x38));\n    free(local_40);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is output_POLYLINE_2D"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  undefined8 uVar1;\n  double dVar2;\n  double dVar3;\n  long lVar4;\n  char cVar5;\n  double dVar6;\n  \n  lVar4 = *(long *)(*(long *)(param_1 + 0x38) + 8);\n  cVar5 = FUN_00001be7();\n  if ((((cVar5 == '\\0') && (cVar5 = FUN_00001be7(), cVar5 == '\\0')) &&\n      (cVar5 = FUN_00001be7(), cVar5 == '\\0')) && (cVar5 = FUN_00001c1d(param_1), cVar5 == '\\0')) {\n    uVar1 = *(undefined8 *)(lVar4 + 0x20);\n    dVar2 = *(double *)(lVar4 + 0x28);\n    dVar3 = *(double *)(lVar4 + 0x50);\n    printf(\"\\t<!-- ellipse-%d -->\\n\",(ulong)*(uint *)(param_1 + 0x14));\n    printf(*(char **)(lVar4 + 0x20),*(undefined8 *)(lVar4 + 0x28),*(undefined8 *)(lVar4 + 0x30),\n           *(undefined8 *)(lVar4 + 0x50),*(undefined8 *)(lVar4 + 0x58),*(undefined8 *)(lVar4 + 0x60)\n           ,\"\\t<!-- sm_axis=(%f,%f,%f) axis_ratio=%f start_angle=%f end_angle=%f-->\\n\");\n    dVar6 = cos(*(double *)(lVar4 + 0x20));\n    printf(*(char **)(lVar4 + 8),*(undefined8 *)(lVar4 + 0x10),uVar1,dVar3 * dVar2,dVar6,\n           \"\\t<ellipse id=\\\"dwg-object-%d\\\" cx=\\\"%f\\\" cy=\\\"%f\\\" rx=\\\"%f\\\" ry=\\\"%f\\\" transform=\\\"rotate=(%f)\\\"\\n\\t\"\n           ,(ulong)*(uint *)(param_1 + 0x14));\n    FUN_00001e87(*(undefined8 *)(param_1 + 0x38));\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is output_ELLIPSE"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](long param_1)\n\n{\n  long lVar1;\n  byte *pbVar2;\n  char *__s;\n  \n  if ((*(short *)(param_1 + 0x50) < 8) || (0xff < *(short *)(param_1 + 0x50))) {\n    if (((*(ushort *)(param_1 + 0x52) & 0x80) == 0) || ((*(ushort *)(param_1 + 0x52) & 0x40) != 0))\n    {\n      switch(*(undefined2 *)(param_1 + 0x50)) {\n      default:\n        __s = \"black\";\n        break;\n      case 1:\n        __s = \"red\";\n        break;\n      case 2:\n        __s = \"yellow\";\n        break;\n      case 3:\n        __s = \"green\";\n        break;\n      case 4:\n        __s = \"cyan\";\n        break;\n      case 5:\n        __s = \"blue\";\n        break;\n      case 6:\n        __s = \"magenta\";\n        break;\n      case 7:\n        __s = \"white\";\n      }\n    }\n    else {\n      __s = (char *)malloc(8);\n      sprintf(__s,\"#%06x\",(ulong)(*(uint *)(param_1 + 0x58) & 0xffffff));\n    }\n  }\n  else {\n    lVar1 = dwg_rgb_palette();\n    pbVar2 = (byte *)(lVar1 + (long)*(short *)(param_1 + 0x50) * 3);\n    __s = (char *)malloc(8);\n    sprintf(__s,\"#%02x%02x%02x\",(ulong)*pbVar2,(ulong)pbVar2[1],(ulong)pbVar2[2]);\n  }\n  return __s;\n}\n\n",
        "output": "The predicted function name is entity_color"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbyte * [MASK](byte *param_1)\n\n{\n  byte bVar1;\n  int iVar2;\n  size_t sVar3;\n  undefined4 *puVar4;\n  ulong uVar5;\n  byte *pbVar6;\n  byte bVar7;\n  int local_30;\n  byte *local_28;\n  byte *local_20;\n  byte *local_18;\n  byte *local_10;\n  \n  bVar7 = 0;\n  if (param_1 == (byte *)0x0) {\n    local_28 = (byte *)0x0;\n  }\n  else {\n    sVar3 = strlen((char *)param_1);\n    local_30 = (int)sVar3 + 10;\n    local_28 = (byte *)calloc((long)local_30,1);\n    local_18 = local_28 + local_30;\n    local_20 = local_28;\n    for (local_10 = param_1; *local_10 != 0; local_10 = local_10 + 1) {\n      iVar2 = (int)local_28;\n      if ((long)local_18 - (long)local_20 < 9) {\n        local_30 = local_30 + 10;\n        local_28 = (byte *)realloc(local_28,(long)local_30);\n        local_20 = local_28 + ((int)local_20 - iVar2);\n        *local_20 = 0;\n        local_18 = local_28 + local_30;\n      }\n      bVar1 = *local_10;\n      if (bVar1 == 0x3c) {\n        uVar5 = 0xffffffffffffffff;\n        pbVar6 = local_20;\n        do {\n          if (uVar5 == 0) break;\n          uVar5 = uVar5 - 1;\n          bVar1 = *pbVar6;\n          pbVar6 = pbVar6 + (ulong)bVar7 * -2 + 1;\n        } while (bVar1 != 0);\n        *(undefined4 *)(local_20 + (~uVar5 - 1)) = 0x3b746c26;\n        *(undefined *)((long)(local_20 + (~uVar5 - 1)) + 4) = 0;\n        local_20 = local_20 + 4;\n      }\n      else if (bVar1 < 0x3d) {\n        if (bVar1 == 0x26) {\n          uVar5 = 0xffffffffffffffff;\n          pbVar6 = local_20;\n          do {\n            if (uVar5 == 0) break;\n            uVar5 = uVar5 - 1;\n            bVar1 = *pbVar6;\n            pbVar6 = pbVar6 + (ulong)bVar7 * -2 + 1;\n          } while (bVar1 != 0);\n          *(undefined4 *)(local_20 + (~uVar5 - 1)) = 0x706d6126;\n          *(undefined2 *)((long)(local_20 + (~uVar5 - 1)) + 4) = 0x3b;\n          local_20 = local_20 + 5;\n        }\n        else if (bVar1 == 0x27) {\n          uVar5 = 0xffffffffffffffff;\n          pbVar6 = local_20;\n          do {\n            if (uVar5 == 0) break;\n            uVar5 = uVar5 - 1;\n            bVar1 = *pbVar6;\n            pbVar6 = pbVar6 + (ulong)bVar7 * -2 + 1;\n          } while (bVar1 != 0);\n          *(undefined4 *)(local_20 + (~uVar5 - 1)) = 0x39332326;\n          *(undefined2 *)((long)(local_20 + (~uVar5 - 1)) + 4) = 0x3b;\n          local_20 = local_20 + 5;\n        }\n        else {\n          if (bVar1 != 0x22) goto LAB_00004fe1;\n          uVar5 = 0xffffffffffffffff;\n          pbVar6 = local_20;\n          do {\n            if (uVar5 == 0) break;\n            uVar5 = uVar5 - 1;\n            bVar1 = *pbVar6;\n            pbVar6 = pbVar6 + (ulong)bVar7 * -2 + 1;\n          } while (bVar1 != 0);\n          puVar4 = (undefined4 *)(local_20 + (~uVar5 - 1));\n          *puVar4 = 0x6f757126;\n          *(undefined2 *)(puVar4 + 1) = 0x3b74;\n          *(undefined *)((long)puVar4 + 6) = 0;\n          local_20 = local_20 + 6;\n        }\n      }\n      else if (bVar1 == 0x60) {\n        uVar5 = 0xffffffffffffffff;\n        pbVar6 = local_20;\n        do {\n          if (uVar5 == 0) break;\n          uVar5 = uVar5 - 1;\n          bVar1 = *pbVar6;\n          pbVar6 = pbVar6 + (ulong)bVar7 * -2 + 1;\n        } while (bVar1 != 0);\n        *(undefined4 *)(local_20 + (~uVar5 - 1)) = 0x36392326;\n        *(undefined2 *)((long)(local_20 + (~uVar5 - 1)) + 4) = 0x3b;\n        local_20 = local_20 + 5;\n      }\n      else if (bVar1 < 0x61) {\n        if (bVar1 == 0x3e) {\n          uVar5 = 0xffffffffffffffff;\n          pbVar6 = local_20;\n          do {\n            if (uVar5 == 0) break;\n            uVar5 = uVar5 - 1;\n            bVar1 = *pbVar6;\n            pbVar6 = pbVar6 + (ulong)bVar7 * -2 + 1;\n          } while (bVar1 != 0);\n          *(undefined4 *)(local_20 + (~uVar5 - 1)) = 0x3b746726;\n          *(undefined *)((long)(local_20 + (~uVar5 - 1)) + 4) = 0;\n          local_20 = local_20 + 4;\n        }\n        else {\nLAB_00004fe1:\n          if (*local_10 < 0x7f) {\n            if (0x13 < *local_10) {\n              *local_20 = *local_10;\n              local_20[1] = 0;\n              local_20 = local_20 + 1;\n            }\n          }\n          else {\n            sprintf((char *)local_20,\"&#x%X;\",(ulong)*local_10);\n            sVar3 = strlen((char *)local_20);\n            local_20[sVar3] = 0;\n            local_20 = local_20 + sVar3;\n          }\n        }\n      }\n      else if (bVar1 == 0x7b) {\n        uVar5 = 0xffffffffffffffff;\n        pbVar6 = local_20;\n        do {\n          if (uVar5 == 0) break;\n          uVar5 = uVar5 - 1;\n          bVar1 = *pbVar6;\n          pbVar6 = pbVar6 + (ulong)bVar7 * -2 + 1;\n        } while (bVar1 != 0);\n        puVar4 = (undefined4 *)(local_20 + (~uVar5 - 1));\n        *puVar4 = 0x32312326;\n        *(undefined2 *)(puVar4 + 1) = 0x3b33;\n        *(undefined *)((long)puVar4 + 6) = 0;\n        local_20 = local_20 + 6;\n      }\n      else {\n        if (bVar1 != 0x7d) goto LAB_00004fe1;\n        uVar5 = 0xffffffffffffffff;\n        pbVar6 = local_20;\n        do {\n          if (uVar5 == 0) break;\n          uVar5 = uVar5 - 1;\n          bVar1 = *pbVar6;\n          pbVar6 = pbVar6 + (ulong)bVar7 * -2 + 1;\n        } while (bVar1 != 0);\n        puVar4 = (undefined4 *)(local_20 + (~uVar5 - 1));\n        *puVar4 = 0x32312326;\n        *(undefined2 *)(puVar4 + 1) = 0x3b35;\n        *(undefined *)((long)puVar4 + 6) = 0;\n        local_20 = local_20 + 6;\n      }\n    }\n    *local_20 = 0;\n  }\n  return local_28;\n}\n\n",
        "output": "The predicted function name is htmlescape"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  char *__ptr;\n  char *__format;\n  \n  __format = (char *)FUN_00001cc0(param_1);\n  __ptr = (char *)FUN_00001d07(param_1);\n  printf(__format,\"      style=\\\"fill:none;stroke:%s;stroke-width:%.1fpx\\\" />\\n\",__ptr);\n  if (*__ptr == '#') {\n    free(__ptr);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is common_entity"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  undefined8 uVar1;\n  uint *puVar2;\n  long lVar3;\n  char cVar4;\n  long lVar5;\n  long lVar6;\n  char *pcVar7;\n  undefined8 uVar8;\n  undefined *puVar9;\n  long in_FS_OFFSET;\n  undefined8 uVar10;\n  undefined *local_70;\n  char *local_68;\n  undefined8 local_38;\n  undefined8 local_30;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  puVar2 = *(uint **)(param_1 + 0x58);\n  lVar3 = *(long *)(*(long *)(param_1 + 0x38) + 8);\n  if (*(long *)(lVar3 + 0x88) == 0) {\n    lVar5 = 0;\n  }\n  else {\n    lVar5 = dwg_ref_object_silent(puVar2,*(long *)(lVar3 + 0x88));\n  }\n  if (lVar5 == 0) {\n    lVar6 = 0;\n  }\n  else {\n    lVar6 = *(long *)(*(long *)(lVar5 + 0x38) + 8);\n  }\n  if ((((*(long *)(lVar3 + 0x78) != 0) && (cVar4 = FUN_00001c1d(param_1), cVar4 == '\\0')) &&\n      (cVar4 = FUN_00001b4b(*(undefined8 *)(lVar3 + 0x18),*(undefined8 *)(lVar3 + 0x20)),\n      cVar4 == '\\0')) && (cVar4 = FUN_00001be7(), cVar4 == '\\0')) {\n    if (*puVar2 < 0x1a) {\n      local_70 = (undefined *)\n                 FUN_00004ca4(*(undefined8 *)(lVar3 + 0x78),*(undefined2 *)((long)puVar2 + 0x1e));\n    }\n    else {\n      local_70 = (undefined *)FUN_00005071(*(undefined8 *)(lVar3 + 0x78));\n    }\n    if (((lVar6 == 0) || (*(int *)(lVar5 + 0x18) != 0x35)) ||\n       ((*(long *)(lVar6 + 0x58) == 0 ||\n        ((**(char **)(lVar6 + 0x58) == '\\0' ||\n         (pcVar7 = strcasestr(*(char **)(lVar6 + 0x58),\".ttf\"), pcVar7 == (char *)0x0)))))) {\n      local_68 = \"Courier\";\n    }\n    else {\n      pcVar7 = strcasestr(*(char **)(lVar6 + 0x58),\"Arial\");\n      if (pcVar7 == (char *)0x0) {\n        local_68 = \"Verdana\";\n      }\n      else {\n        local_68 = \"Arial\";\n      }\n    }\n    FUN_0000558b(*(undefined8 *)(lVar3 + 0x18),*(undefined8 *)(lVar3 + 0x20),&local_38);\n    puVar9 = local_70;\n    if (local_70 == (undefined *)0x0) {\n      puVar9 = &DAT_00005cc8;\n    }\n    uVar8 = FUN_00001d07(*(undefined8 *)(param_1 + 0x38));\n    uVar1 = *(undefined8 *)(lVar3 + 0x68);\n    uVar10 = FUN_00001b1f(local_30);\n    pcVar7 = (char *)FUN_00001b03(local_38);\n    printf(pcVar7,uVar10,uVar1,\n           \"\\t<text id=\\\"dwg-object-%d\\\" x=\\\"%f\\\" y=\\\"%f\\\" font-family=\\\"%s\\\" font-size=\\\"%f\\\" fill=\\\"%s\\\">%s</text>\\n\"\n           ,(ulong)*(uint *)(param_1 + 0x14),local_68,uVar8,puVar9);\n    free(local_70);\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is output_TEXT"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  char cVar1;\n  long in_FS_OFFSET;\n  undefined8 uVar2;\n  char *pcVar3;\n  int local_54;\n  uint local_50;\n  uint local_4c;\n  long local_48;\n  undefined8 *local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48 = *(long *)(*(long *)(param_1 + 0x38) + 8);\n  cVar1 = FUN_00001c1d(param_1);\n  if ((((cVar1 == '\\0') &&\n       (local_4c = dwg_ent_lwpline_get_numpoints(local_48,&local_54), local_4c != 0)) &&\n      (local_54 == 0)) &&\n     (((local_40 = (undefined8 *)dwg_ent_lwpline_get_points(local_48,&local_54), local_54 == 0 &&\n       (cVar1 = FUN_00001b99(*local_40,local_40[1]), cVar1 == '\\0')) &&\n      (cVar1 = FUN_00001be7(), cVar1 == '\\0')))) {\n    local_28 = *local_40;\n    local_20 = local_40[1];\n    FUN_0000558b(local_28,local_20,&local_38);\n    printf(\"\\t<!-- lwpolyline-%d -->\\n\",(ulong)*(uint *)(param_1 + 0x14));\n    uVar2 = FUN_00001b1f(local_30);\n    pcVar3 = (char *)FUN_00001b03(local_38);\n    printf(pcVar3,uVar2,\"\\t<path id=\\\"dwg-object-%d\\\" d=\\\"M %f,%f\",(ulong)*(uint *)(param_1 + 0x14))\n    ;\n    for (local_50 = 1; local_50 < local_4c; local_50 = local_50 + 1) {\n      local_28 = local_40[(ulong)local_50 * 2];\n      local_20 = local_40[(ulong)local_50 * 2 + 1];\n      cVar1 = FUN_00001b4b(local_28,local_20);\n      if (cVar1 == '\\0') {\n        FUN_0000558b(local_28,local_20,&local_38);\n        uVar2 = FUN_00001b1f(local_30);\n        pcVar3 = (char *)FUN_00001b03(local_38);\n        printf(pcVar3,uVar2,\" L %f,%f\");\n      }\n    }\n    if ((*(ushort *)(local_48 + 8) & 0x200) != 0) {\n      printf(\" Z\");\n    }\n    printf(\"\\\"\\n\\t\");\n    FUN_00001e87(*(undefined8 *)(param_1 + 0x38));\n    free(local_40);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is output_LWPOLYLINE"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Removing unreachable block (ram,0x00001b88) */\n\nundefined4 [MASK](void)\n\n{\n  return 0;\n}\n\n",
        "output": "The predicted function name is isnan_2BD"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\ndouble [MASK](double param_1)\n\n{\n  return param_1 - DAT_002091f8;\n}\n\n",
        "output": "The predicted function name is transform_X"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid [MASK](long param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  char cVar3;\n  uint uVar4;\n  long in_FS_OFFSET;\n  double dVar5;\n  double dVar6;\n  double dVar7;\n  double local_70;\n  double local_68;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar2 = *(long *)(*(long *)(param_1 + 0x38) + 8);\n  cVar3 = FUN_00001be7();\n  if (((cVar3 == '\\0') && (cVar3 = FUN_00001be7(), cVar3 == '\\0')) &&\n     (cVar3 = FUN_00001c1d(param_1), cVar3 == '\\0')) {\n    local_68 = DAT_000067c0 / *(double *)(lVar2 + 0x20);\n    dVar5 = DAT_000067c0 / *(double *)(lVar2 + 0x28);\n    dVar6 = DAT_000067c0 / *(double *)(lVar2 + 0x30);\n    uVar4 = (uint)(local_68 < 0.0);\n    _DAT_00209240 = DAT_002091f8;\n    _DAT_00209248 = DAT_00209200;\n    _DAT_00209258 = DAT_00209208;\n    _DAT_00209260 = DAT_00209200;\n    printf(\"\\t<!-- xline-%d -->\\n\",(ulong)*(uint *)(param_1 + 0x14));\n    local_70 = (*(double *)(&DAT_00209240 + (long)(int)uVar4 * 0x18) - *(double *)(lVar2 + 8)) *\n               local_68;\n    local_68 = (*(double *)(&DAT_00209240 + (long)(int)(1 - uVar4) * 0x18) - *(double *)(lVar2 + 8))\n               * local_68;\n    dVar7 = (*(double *)(&DAT_00209240 + (long)(int)(uint)(dVar5 < 0.0) * 0x18) -\n            *(double *)(lVar2 + 0x10)) * dVar5;\n    dVar5 = (*(double *)(&DAT_00209240 + (long)(int)(1 - (uint)(dVar5 < 0.0)) * 0x18) -\n            *(double *)(lVar2 + 0x10)) * dVar5;\n    if ((local_70 <= dVar5) && (dVar7 <= local_68)) {\n      if (local_70 < dVar7) {\n        local_70 = dVar7;\n      }\n      if (local_68 < dVar5) {\n        local_68 = dVar5;\n      }\n      if ((local_70 <=\n           (*(double *)(&DAT_00209250 + (long)(int)(1 - uVar4) * 0x18) - *(double *)(lVar2 + 0x18))\n           * dVar6) &&\n         ((*(double *)(&DAT_00209250 + (long)(int)uVar4 * 0x18) - *(double *)(lVar2 + 0x18)) * dVar6\n          <= local_68)) {\n        printf(\"\\t<path id=\\\"dwg-object-%d\\\" d=\\\"M %f,%f L %f,%f\\\"\\n\\t\",\n               (ulong)*(uint *)(param_1 + 0x14));\n        FUN_00001e87(*(undefined8 *)(param_1 + 0x38));\n      }\n    }\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is output_XLINE"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\ndouble [MASK](double param_1)\n\n{\n  return DAT_00209220 - (param_1 - DAT_00209200);\n}\n\n",
        "output": "The predicted function name is transform_Y"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](ushort *param_1)\n\n{\n  char cVar1;\n  ushort uVar2;\n  int iVar3;\n  undefined4 *puVar4;\n  size_t sVar5;\n  ulong uVar6;\n  char *pcVar7;\n  byte bVar8;\n  ushort *local_40;\n  int local_28;\n  char *local_20;\n  char *local_18;\n  ushort *local_10;\n  \n  bVar8 = 0;\n  local_28 = 0;\n  local_10 = param_1;\n  if (param_1 == (ushort *)0x0) {\n    local_20 = (char *)0x0;\n  }\n  else {\n    while (*local_10 != 0) {\n      local_28 = local_28 + 1;\n      local_10 = local_10 + 1;\n    }\n    local_28 = local_28 + 0x10;\n    local_20 = (char *)calloc((long)local_28,1);\n    local_18 = local_20;\n    for (local_40 = param_1; *local_40 != 0; local_40 = local_40 + 1) {\n      iVar3 = (int)local_18 - (int)local_20;\n      if (local_28 + -8 <= iVar3) {\n        local_28 = local_28 + 0x10;\n        local_20 = (char *)realloc(local_20,(long)local_28);\n        local_18 = local_20 + iVar3;\n        *local_18 = '\\0';\n      }\n      uVar2 = *local_40;\n      if (uVar2 == 0x3c) {\n        uVar6 = 0xffffffffffffffff;\n        pcVar7 = local_18;\n        do {\n          if (uVar6 == 0) break;\n          uVar6 = uVar6 - 1;\n          cVar1 = *pcVar7;\n          pcVar7 = pcVar7 + (ulong)bVar8 * -2 + 1;\n        } while (cVar1 != '\\0');\n        *(undefined4 *)(local_18 + (~uVar6 - 1)) = 0x3b746c26;\n        *(undefined *)((long)(local_18 + (~uVar6 - 1)) + 4) = 0;\n        local_18 = local_18 + 4;\n      }\n      else if (uVar2 < 0x3d) {\n        if (uVar2 == 0x26) {\n          uVar6 = 0xffffffffffffffff;\n          pcVar7 = local_18;\n          do {\n            if (uVar6 == 0) break;\n            uVar6 = uVar6 - 1;\n            cVar1 = *pcVar7;\n            pcVar7 = pcVar7 + (ulong)bVar8 * -2 + 1;\n          } while (cVar1 != '\\0');\n          *(undefined4 *)(local_18 + (~uVar6 - 1)) = 0x706d6126;\n          *(undefined2 *)((long)(local_18 + (~uVar6 - 1)) + 4) = 0x3b;\n          local_18 = local_18 + 5;\n        }\n        else if (uVar2 == 0x27) {\n          uVar6 = 0xffffffffffffffff;\n          pcVar7 = local_18;\n          do {\n            if (uVar6 == 0) break;\n            uVar6 = uVar6 - 1;\n            cVar1 = *pcVar7;\n            pcVar7 = pcVar7 + (ulong)bVar8 * -2 + 1;\n          } while (cVar1 != '\\0');\n          *(undefined4 *)(local_18 + (~uVar6 - 1)) = 0x39332326;\n          *(undefined2 *)((long)(local_18 + (~uVar6 - 1)) + 4) = 0x3b;\n          local_18 = local_18 + 5;\n        }\n        else {\n          if (uVar2 != 0x22) goto LAB_00005397;\n          uVar6 = 0xffffffffffffffff;\n          pcVar7 = local_18;\n          do {\n            if (uVar6 == 0) break;\n            uVar6 = uVar6 - 1;\n            cVar1 = *pcVar7;\n            pcVar7 = pcVar7 + (ulong)bVar8 * -2 + 1;\n          } while (cVar1 != '\\0');\n          puVar4 = (undefined4 *)(local_18 + (~uVar6 - 1));\n          *puVar4 = 0x6f757126;\n          *(undefined2 *)(puVar4 + 1) = 0x3b74;\n          *(undefined *)((long)puVar4 + 6) = 0;\n          local_18 = local_18 + 6;\n        }\n      }\n      else if (uVar2 == 0x60) {\n        uVar6 = 0xffffffffffffffff;\n        pcVar7 = local_18;\n        do {\n          if (uVar6 == 0) break;\n          uVar6 = uVar6 - 1;\n          cVar1 = *pcVar7;\n          pcVar7 = pcVar7 + (ulong)bVar8 * -2 + 1;\n        } while (cVar1 != '\\0');\n        *(undefined4 *)(local_18 + (~uVar6 - 1)) = 0x36392326;\n        *(undefined2 *)((long)(local_18 + (~uVar6 - 1)) + 4) = 0x3b;\n        local_18 = local_18 + 5;\n      }\n      else if (uVar2 < 0x61) {\n        if (uVar2 == 0x3e) {\n          uVar6 = 0xffffffffffffffff;\n          pcVar7 = local_18;\n          do {\n            if (uVar6 == 0) break;\n            uVar6 = uVar6 - 1;\n            cVar1 = *pcVar7;\n            pcVar7 = pcVar7 + (ulong)bVar8 * -2 + 1;\n          } while (cVar1 != '\\0');\n          *(undefined4 *)(local_18 + (~uVar6 - 1)) = 0x3b746726;\n          *(undefined *)((long)(local_18 + (~uVar6 - 1)) + 4) = 0;\n          local_18 = local_18 + 4;\n        }\n        else {\nLAB_00005397:\n          if (*local_40 < 0x7f) {\n            if (0x13 < *local_40) {\n              *local_18 = (char)*local_40;\n              local_18[1] = '\\0';\n              local_18 = local_18 + 1;\n            }\n          }\n          else {\n            sprintf(local_18,\"&#x%X;\",(ulong)*local_40);\n            sVar5 = strlen(local_18);\n            local_18[sVar5] = '\\0';\n            local_18 = local_18 + sVar5;\n          }\n        }\n      }\n      else if (uVar2 == 0x7b) {\n        uVar6 = 0xffffffffffffffff;\n        pcVar7 = local_18;\n        do {\n          if (uVar6 == 0) break;\n          uVar6 = uVar6 - 1;\n          cVar1 = *pcVar7;\n          pcVar7 = pcVar7 + (ulong)bVar8 * -2 + 1;\n        } while (cVar1 != '\\0');\n        puVar4 = (undefined4 *)(local_18 + (~uVar6 - 1));\n        *puVar4 = 0x32312326;\n        *(undefined2 *)(puVar4 + 1) = 0x3b33;\n        *(undefined *)((long)puVar4 + 6) = 0;\n        local_18 = local_18 + 6;\n      }\n      else {\n        if (uVar2 != 0x7d) goto LAB_00005397;\n        uVar6 = 0xffffffffffffffff;\n        pcVar7 = local_18;\n        do {\n          if (uVar6 == 0) break;\n          uVar6 = uVar6 - 1;\n          cVar1 = *pcVar7;\n          pcVar7 = pcVar7 + (ulong)bVar8 * -2 + 1;\n        } while (cVar1 != '\\0');\n        puVar4 = (undefined4 *)(local_18 + (~uVar6 - 1));\n        *puVar4 = 0x32312326;\n        *(undefined2 *)(puVar4 + 1) = 0x3b35;\n        *(undefined *)((long)puVar4 + 6) = 0;\n        local_18 = local_18 + 6;\n      }\n    }\n    *local_18 = '\\0';\n  }\n  return local_20;\n}\n\n",
        "output": "The predicted function name is htmlwescape"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\ndouble [MASK](long param_1)\n\n{\n  int iVar1;\n  double dVar2;\n  \n  iVar1 = dxf_cvt_lweight(*(undefined *)(param_1 + 0x92));\n  dVar2 = DAT_000067b8;\n  if (-1 < iVar1) {\n    dVar2 = (double)iVar1 * DAT_000067b0;\n  }\n  return dVar2;\n}\n\n",
        "output": "The predicted function name is entity_lweight"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  char cVar1;\n  long in_FS_OFFSET;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  char *__format;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  cVar1 = FUN_00001be7();\n  if (cVar1 == '\\0') {\n    cVar1 = FUN_00001be7();\n    if (cVar1 == '\\0') {\n      cVar1 = FUN_00001be7();\n      if (cVar1 == '\\0') {\n        cVar1 = FUN_00001c1d(param_1);\n        if (cVar1 == '\\0') {\n          FUN_000058cd(&local_48);\n          FUN_000058cd(&local_28);\n          printf(\"\\t<!-- line-%d -->\\n\",(ulong)*(uint *)(param_1 + 0x14));\n          uVar2 = FUN_00001b1f(local_20);\n          uVar3 = FUN_00001b03(local_28);\n          uVar4 = FUN_00001b1f(local_40);\n          __format = (char *)FUN_00001b03(local_48);\n          printf(__format,uVar4,uVar3,uVar2,\"\\t<path id=\\\"dwg-object-%d\\\" d=\\\"M %f,%f L %f,%f\\\"\\n\\t\"\n                 ,(ulong)*(uint *)(param_1 + 0x14));\n          FUN_00001e87(*(undefined8 *)(param_1 + 0x38));\n        }\n      }\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is output_LINE"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](double param_1,double param_2,double *param_3)\n\n{\n  long in_FS_OFFSET;\n  double in_stack_00000008;\n  double in_stack_00000010;\n  double in_stack_00000018;\n  double local_88;\n  double local_80;\n  ulong local_68;\n  ulong local_60;\n  double local_48;\n  double local_40;\n  double local_38;\n  double local_28;\n  double local_20;\n  double local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (((in_stack_00000008 == 0.0) && (in_stack_00000010 == 0.0)) &&\n     (in_stack_00000018 == DAT_000067f0)) {\n    *param_3 = param_1;\n    param_3[1] = param_2;\n  }\n  else if (((in_stack_00000008 == 0.0) && (in_stack_00000010 == 0.0)) &&\n          (in_stack_00000018 == DAT_000067f8)) {\n    *param_3 = param_1;\n    param_3[1] = param_2;\n    *param_3 = (double)(DAT_00006800 ^ (ulong)*param_3);\n  }\n  else {\n    local_48 = in_stack_00000008;\n    local_40 = in_stack_00000010;\n    local_38 = in_stack_00000018;\n    FUN_0000542c(&local_68);\n    if ((DAT_00006820 <= (double)(DAT_00006810 & local_68)) ||\n       (DAT_00006820 <= (double)(DAT_00006810 & local_60))) {\n      local_28 = 0.0;\n      local_20 = 0.0;\n      local_18 = DAT_000067f0;\n      FUN_00005506(&local_28);\n      FUN_0000542c(&local_88);\n    }\n    else {\n      local_28 = 0.0;\n      local_20 = DAT_000067f0;\n      local_18 = 0.0;\n      FUN_00005506(0,&local_28);\n      FUN_0000542c(&local_88);\n    }\n    FUN_00005506(&local_28);\n    FUN_0000542c(&local_28);\n    *param_3 = local_80 * param_2 + param_1 * local_88;\n    param_3[1] = local_20 * param_2 + param_1 * local_28;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is transform_OCS_2d"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](long param_1)\n\n{\n  undefined4 local_c;\n  \n  local_c = 1;\n  if (param_1 == 0) {\n    fwrite(\"object is NULL\\n\",1,0xf,stderr);\n    local_c = 0;\n  }\n  else {\n    switch(*(undefined4 *)(param_1 + 0x10)) {\n    default:\n      local_c = 0;\n      if (*(int *)(param_1 + 0x30) == 0) {\n        fprintf(stderr,\"%s ignored\\n\",*(undefined8 *)(param_1 + 0x20));\n      }\n      break;\n    case 1:\n      FUN_00001ef7(param_1);\n      break;\n    case 6:\n    case 0x22:\n      break;\n    case 7:\n      FUN_00003f96(param_1);\n      break;\n    case 0xf:\n      FUN_000039fa(param_1);\n      break;\n    case 0x11:\n      FUN_00002e4b(param_1);\n      break;\n    case 0x12:\n      FUN_00002ba3(param_1);\n      break;\n    case 0x13:\n      FUN_000021bf(param_1);\n      break;\n    case 0x1b:\n      FUN_00002cf9(param_1);\n      break;\n    case 0x1c:\n      FUN_000036ff(param_1);\n      break;\n    case 0x1f:\n      FUN_00003326(param_1);\n      break;\n    case 0x23:\n      FUN_00003140(param_1);\n      break;\n    case 0x28:\n      FUN_00002732(param_1);\n      break;\n    case 0x29:\n      FUN_0000236f(param_1);\n      break;\n    case 0x4d:\n      FUN_00003cc7(param_1);\n    }\n  }\n  return local_c;\n}\n\n",
        "output": "The predicted function name is output_object"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Removing unreachable block (ram,0x00001c0c) */\n\nundefined4 [MASK](void)\n\n{\n  return 0;\n}\n\n",
        "output": "The predicted function name is isnan_3BD"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Removing unreachable block (ram,0x00001bd6) */\n\nundefined4 [MASK](void)\n\n{\n  return 0;\n}\n\n",
        "output": "The predicted function name is isnan_2pt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  undefined8 uVar1;\n  long lVar2;\n  char cVar3;\n  long in_FS_OFFSET;\n  undefined8 uVar4;\n  char *__format;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar2 = *(long *)(*(long *)(param_1 + 0x38) + 8);\n  cVar3 = FUN_00001be7();\n  if (((cVar3 == '\\0') && (cVar3 = FUN_00001be7(), cVar3 == '\\0')) &&\n     (cVar3 = FUN_00001c1d(param_1), cVar3 == '\\0')) {\n    FUN_000058cd(&local_28);\n    printf(\"\\t<!-- circle-%d -->\\n\",(ulong)*(uint *)(param_1 + 0x14));\n    uVar1 = *(undefined8 *)(lVar2 + 0x20);\n    uVar4 = FUN_00001b1f(local_20);\n    __format = (char *)FUN_00001b03(local_28);\n    printf(__format,uVar4,uVar1,\"\\t<circle id=\\\"dwg-object-%d\\\" cx=\\\"%f\\\" cy=\\\"%f\\\" r=\\\"%f\\\"\\n\\t\",\n           (ulong)*(uint *)(param_1 + 0x14));\n    FUN_00001e87(*(undefined8 *)(param_1 + 0x38));\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is output_CIRCLE"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid [MASK](long param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  char cVar3;\n  uint uVar4;\n  long in_FS_OFFSET;\n  double dVar5;\n  double dVar6;\n  double dVar7;\n  double local_90;\n  double local_88;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar2 = *(long *)(*(long *)(param_1 + 0x38) + 8);\n  cVar3 = FUN_00001be7();\n  if (((cVar3 == '\\0') && (cVar3 = FUN_00001be7(), cVar3 == '\\0')) &&\n     (cVar3 = FUN_00001c1d(param_1), cVar3 == '\\0')) {\n    local_88 = DAT_000067c0 / *(double *)(lVar2 + 0x20);\n    dVar5 = DAT_000067c0 / *(double *)(lVar2 + 0x28);\n    dVar6 = DAT_000067c0 / *(double *)(lVar2 + 0x30);\n    uVar4 = (uint)(local_88 < 0.0);\n    _DAT_00209280 = DAT_002091f8;\n    _DAT_00209288 = DAT_00209200;\n    _DAT_00209298 = DAT_00209208;\n    _DAT_002092a0 = DAT_00209200;\n    printf(\"\\t<!-- ray-%d -->\\n\",(ulong)*(uint *)(param_1 + 0x14));\n    local_90 = (*(double *)(&DAT_00209280 + (long)(int)uVar4 * 0x18) - *(double *)(lVar2 + 8)) *\n               local_88;\n    local_88 = (*(double *)(&DAT_00209280 + (long)(int)(1 - uVar4) * 0x18) - *(double *)(lVar2 + 8))\n               * local_88;\n    dVar7 = (*(double *)(&DAT_00209280 + (long)(int)(uint)(dVar5 < 0.0) * 0x18) -\n            *(double *)(lVar2 + 0x10)) * dVar5;\n    dVar5 = (*(double *)(&DAT_00209280 + (long)(int)(1 - (uint)(dVar5 < 0.0)) * 0x18) -\n            *(double *)(lVar2 + 0x10)) * dVar5;\n    if ((local_90 <= dVar5) && (dVar7 <= local_88)) {\n      if (local_90 < dVar7) {\n        local_90 = dVar7;\n      }\n      if (local_88 < dVar5) {\n        local_88 = dVar5;\n      }\n      if ((local_90 <=\n           (*(double *)(&DAT_00209290 + (long)(int)(1 - uVar4) * 0x18) - *(double *)(lVar2 + 0x18))\n           * dVar6) &&\n         ((*(double *)(&DAT_00209290 + (long)(int)uVar4 * 0x18) - *(double *)(lVar2 + 0x18)) * dVar6\n          <= local_88)) {\n        printf(\"\\t<path id=\\\"dwg-object-%d\\\" d=\\\"M %f,%f L %f,%f\\\"\\n\\t\",\n               (ulong)*(uint *)(param_1 + 0x14));\n        FUN_00001e87(*(undefined8 *)(param_1 + 0x38));\n      }\n    }\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is output_RAY"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1)\n\n{\n  long lVar1;\n  bool bVar2;\n  \n  if (*(short *)(*(long *)(param_1 + 0x38) + 0x90) == 0) {\n    if ((*(long *)(*(long *)(param_1 + 0x38) + 0xe0) == 0) ||\n       (**(long **)(*(long *)(param_1 + 0x38) + 0xe0) == 0)) {\n      bVar2 = false;\n    }\n    else {\n      lVar1 = **(long **)(*(long *)(param_1 + 0x38) + 0xe0);\n      if (*(int *)(lVar1 + 0x18) == 0x33) {\n        bVar2 = *(char *)(*(long *)(*(long *)(lVar1 + 0x38) + 8) + 0x29) == '\\0';\n      }\n      else {\n        bVar2 = false;\n      }\n    }\n  }\n  else {\n    bVar2 = true;\n  }\n  return bVar2;\n}\n\n",
        "output": "The predicted function name is entity_invisible"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  double dVar1;\n  double dVar2;\n  double dVar3;\n  double dVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  long lVar7;\n  double dVar8;\n  double dVar9;\n  char cVar10;\n  bool bVar11;\n  long in_FS_OFFSET;\n  double dVar12;\n  double dVar13;\n  double dVar14;\n  double dVar15;\n  undefined8 uVar16;\n  undefined8 uVar17;\n  undefined8 uVar18;\n  char *__format;\n  double local_28;\n  double local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar7 = *(long *)(*(long *)(param_1 + 0x38) + 8);\n  cVar10 = FUN_00001be7();\n  if (((cVar10 == '\\0') && (cVar10 = FUN_00001be7(), cVar10 == '\\0')) &&\n     (cVar10 = FUN_00001c1d(param_1), cVar10 == '\\0')) {\n    FUN_000058cd(&local_28);\n    dVar8 = local_28;\n    dVar1 = *(double *)(lVar7 + 0x20);\n    dVar12 = cos(*(double *)(lVar7 + 0x48));\n    dVar9 = local_20;\n    dVar2 = *(double *)(lVar7 + 0x20);\n    dVar13 = sin(*(double *)(lVar7 + 0x48));\n    dVar3 = *(double *)(lVar7 + 0x20);\n    dVar14 = cos(*(double *)(lVar7 + 0x50));\n    dVar4 = *(double *)(lVar7 + 0x20);\n    dVar15 = sin(*(double *)(lVar7 + 0x50));\n    bVar11 = DAT_000067c8 <= *(double *)(lVar7 + 0x50) - *(double *)(lVar7 + 0x48);\n    printf(\"\\t<!-- arc-%d -->\\n\",(ulong)*(uint *)(param_1 + 0x14));\n    uVar16 = FUN_00001b1f(dVar15 * dVar4 + local_20);\n    uVar17 = FUN_00001b03(dVar14 * dVar3 + local_28);\n    uVar5 = *(undefined8 *)(lVar7 + 0x20);\n    uVar6 = *(undefined8 *)(lVar7 + 0x20);\n    uVar18 = FUN_00001b1f(dVar13 * dVar2 + dVar9);\n    __format = (char *)FUN_00001b03(dVar12 * dVar1 + dVar8);\n    printf(__format,uVar18,uVar6,uVar5,uVar17,uVar16,\n           \"\\t<path id=\\\"dwg-object-%d\\\" d=\\\"M %f,%f A %f,%f 0 %d,0 %f,%f\\\"\\n\\t\",\n           (ulong)*(uint *)(param_1 + 0x14),(ulong)bVar11);\n    FUN_00001e87(*(undefined8 *)(param_1 + 0x38));\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is output_ARC"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](double *param_1)\n\n{\n  double in_stack_00000008;\n  double in_stack_00000010;\n  double in_stack_00000018;\n  double in_stack_00000020;\n  double in_stack_00000028;\n  double in_stack_00000030;\n  \n  *param_1 = in_stack_00000030 * in_stack_00000010 - in_stack_00000028 * in_stack_00000018;\n  param_1[1] = in_stack_00000020 * in_stack_00000018 - in_stack_00000030 * in_stack_00000008;\n  param_1[2] = in_stack_00000028 * in_stack_00000008 - in_stack_00000020 * in_stack_00000010;\n  return;\n}\n\n",
        "output": "The predicted function name is cross"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](int param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long in_FS_OFFSET;\n  int local_b4;\n  int local_b0;\n  int local_ac;\n  int local_a8;\n  undefined4 local_a4;\n  EVP_CIPHER *local_a0;\n  undefined *local_98;\n  EVP_CIPHER_CTX *local_90;\n  uchar local_88 [64];\n  uchar local_48 [56];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_98 = (undefined *)0x0;\n  local_a4 = 0;\n  if (param_1 == 1) {\n    local_a0 = EVP_aes_192_cbc();\n    local_98 = &DAT_0000c7b0;\n  }\n  else if (param_1 == 2) {\n    local_a0 = EVP_aes_256_cbc();\n    local_98 = &DAT_0000c7d0;\n  }\n  else if (param_1 == 0) {\n    local_a0 = EVP_aes_128_cbc();\n    local_98 = &DAT_0000c790;\n  }\n  else {\n    local_a0 = (EVP_CIPHER *)0x0;\n  }\n  local_90 = EVP_CIPHER_CTX_new();\n  iVar1 = FUN_00006d04(\"test/afalgtest.c\",0x52,\"ctx = EVP_CIPHER_CTX_new()\",local_90);\n  if (iVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    iVar1 = EVP_CipherInit_ex(local_90,local_a0,DAT_002110c8,&DAT_0000c800,&DAT_0000c830,1);\n    iVar1 = FUN_00006d79(\"test/afalgtest.c\",0x55,\"EVP_CipherInit_ex(ctx, cipher, e, key, iv, 1)\",\n                         iVar1 != 0);\n    if (iVar1 != 0) {\n      iVar1 = EVP_CipherUpdate(local_90,local_88,&local_b4,(uchar *)\"Single block msg\\n\",0x11);\n      iVar1 = FUN_00006d79(\"test/afalgtest.c\",0x56,\n                           \"EVP_CipherUpdate(ctx, ebuf, &encl, in, BUFFER_SIZE)\",iVar1 != 0);\n      if (iVar1 != 0) {\n        iVar1 = EVP_CipherFinal_ex(local_90,local_88 + local_b4,&local_b0);\n        iVar1 = FUN_00006d79(\"test/afalgtest.c\",0x57,\"EVP_CipherFinal_ex(ctx, ebuf + encl, &encf)\",\n                             iVar1 != 0);\n        if (iVar1 != 0) {\n          local_b4 = local_b0 + local_b4;\n          iVar1 = FUN_00007237(\"test/afalgtest.c\",0x5b,\"enc_result\",&DAT_0000c664,local_98,0x11,\n                               local_88,0x11);\n          if (iVar1 != 0) {\n            iVar1 = EVP_CIPHER_CTX_reset(local_90);\n            iVar1 = FUN_00006d79(\"test/afalgtest.c\",0x5e,\"EVP_CIPHER_CTX_reset(ctx)\",iVar1 != 0);\n            if (iVar1 != 0) {\n              iVar1 = EVP_CipherInit_ex(local_90,local_a0,DAT_002110c8,&DAT_0000c800,&DAT_0000c830,0\n                                       );\n              iVar1 = FUN_00006d79(\"test/afalgtest.c\",0x5f,\n                                   \"EVP_CipherInit_ex(ctx, cipher, e, key, iv, 0)\",iVar1 != 0);\n              if (iVar1 != 0) {\n                iVar1 = EVP_CipherUpdate(local_90,local_48,&local_ac,local_88,local_b4);\n                iVar1 = FUN_00006d79(\"test/afalgtest.c\",0x60,\n                                     \"EVP_CipherUpdate(ctx, dbuf, &decl, ebuf, encl)\",iVar1 != 0);\n                if (iVar1 != 0) {\n                  iVar1 = EVP_CipherFinal_ex(local_90,local_48 + local_ac,&local_a8);\n                  iVar1 = FUN_00006d79(\"test/afalgtest.c\",0x61,\n                                       \"EVP_CipherFinal_ex(ctx, dbuf + decl, &decf)\",iVar1 != 0);\n                  if (iVar1 != 0) {\n                    local_ac = local_a8 + local_ac;\n                    iVar1 = FUN_000052c5(\"test/afalgtest.c\",0x65,&DAT_0000c728,\"BUFFER_SIZE\",\n                                         local_ac,0x11);\n                    if ((iVar1 != 0) &&\n                       (iVar1 = FUN_00007237(\"test/afalgtest.c\",0x66,&DAT_0000c730,&DAT_0000c72d,\n                                             local_48,0x11,\"Single block msg\\n\",0x11), iVar1 != 0))\n                    {\n                      local_a4 = 1;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    EVP_CIPHER_CTX_free(local_90);\n    uVar2 = local_a4;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_afalg_aes_cbc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](void)\n\n{\n  int iVar1;\n  EVP_CIPHER *cipher;\n  EVP_CIPHER_CTX *ctx;\n  int local_1c;\n  \n  local_1c = 0;\n  iVar1 = ENGINE_init(DAT_002110c8);\n  iVar1 = FUN_00006d79(\"test/afalgtest.c\",0x76,\"ENGINE_init(e)\",iVar1 != 0);\n  if (iVar1 == 0) {\n    local_1c = 0;\n  }\n  else {\n    cipher = ENGINE_get_cipher(DAT_002110c8,0x1a3);\n    ctx = EVP_CIPHER_CTX_new();\n    if ((cipher != (EVP_CIPHER *)0x0) && (ctx != (EVP_CIPHER_CTX *)0x0)) {\n      local_1c = EVP_EncryptInit_ex(ctx,cipher,DAT_002110c8,(uchar *)0x0,(uchar *)0x0);\n    }\n    FUN_00006d79(\"test/afalgtest.c\",0x7c,&DAT_0000c744,local_1c != 0);\n    EVP_CIPHER_CTX_free(ctx);\n    ENGINE_finish(DAT_002110c8);\n  }\n  return local_1c;\n}\n\n",
        "output": "The predicted function name is test_pr16743"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  long in_FS_OFFSET;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  ERR_new();\n  ERR_set_debug(\"test/errtest.c\",0x87,\"vdata_appends\");\n  ERR_set_error(0xf,0xc0100,0);\n  ERR_add_error_data(1,\"hello \");\n  ERR_add_error_data(1,\"world\");\n  ERR_peek_error_data(&local_18,0);\n  FUN_00007c13(\"test/errtest.c\",0x8b,&DAT_0000d434,\"\\\"hello world\\\"\",local_18,\"hello world\");\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is vdata_appends"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_20;\n  undefined4 local_1c;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = 0xffffffff;\n  local_18 = 0;\n  local_1c = 0;\n  ERR_new();\n  ERR_set_debug(\"test/errtest.c\",0x129,\"test_clear_error\");\n  ERR_set_error(0,0,\"hello %s\",\"world\");\n  ERR_peek_error_data(&local_18,&local_20);\n  iVar1 = FUN_00007c13(\"test/errtest.c\",299,&DAT_0000d434,\"\\\"hello world\\\"\",local_18,\"hello world\");\n  if (iVar1 != 0) {\n    iVar1 = FUN_00006087(\"test/errtest.c\",300,\"flags\",\"ERR_TXT_STRING | ERR_TXT_MALLOCED\",local_20,3\n                        );\n    if (iVar1 != 0) {\n      ERR_clear_error();\n      ERR_new();\n      ERR_set_debug(\"test/errtest.c\",0x131,\"test_clear_error\");\n      ERR_set_error(0,0,0);\n      ERR_peek_error_data(&local_18,&local_20);\n      iVar1 = FUN_00007c13(\"test/errtest.c\",0x133,&DAT_0000d434,&DAT_0000d569,local_18,&DAT_0000d568\n                          );\n      if (iVar1 != 0) {\n        iVar1 = FUN_00006087(\"test/errtest.c\",0x134,\"flags\",\"ERR_TXT_MALLOCED\",local_20,1);\n        if (iVar1 != 0) {\n          ERR_clear_error();\n          ERR_new();\n          ERR_set_debug(\"test/errtest.c\",0x139,\"test_clear_error\");\n          ERR_set_error(0,0,\"goodbye %s world\",\"cruel\");\n          ERR_peek_error_data(&local_18,&local_20);\n          iVar1 = FUN_00007c13(\"test/errtest.c\",0x13b,&DAT_0000d434,\"\\\"goodbye cruel world\\\"\",\n                               local_18,\"goodbye cruel world\");\n          if (iVar1 != 0) {\n            iVar1 = FUN_00006087(\"test/errtest.c\",0x13c,\"flags\",\"ERR_TXT_STRING | ERR_TXT_MALLOCED\",\n                                 local_20,3);\n            if (iVar1 != 0) {\n              ERR_clear_error();\n              ERR_new();\n              ERR_set_debug(\"test/errtest.c\",0x144,\"test_clear_error\");\n              ERR_set_error(0,0,0);\n              ERR_peek_error_data(&local_18,&local_20);\n              iVar1 = FUN_00007c13(\"test/errtest.c\",0x146,&DAT_0000d434,&DAT_0000d569,local_18,\n                                   &DAT_0000d568);\n              if (iVar1 != 0) {\n                iVar1 = FUN_00006087(\"test/errtest.c\",0x147,\"flags\",\"ERR_TXT_MALLOCED\",local_20,1);\n                if (iVar1 != 0) {\n                  ERR_clear_error();\n                  local_1c = 1;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  ERR_clear_error();\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_1c;\n}\n\n",
        "output": "The predicted function name is test_clear_error"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  undefined4 local_38;\n  undefined4 local_34;\n  undefined8 local_30;\n  undefined8 local_28;\n  char *local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = \"test/errtest.c\";\n  local_34 = 0x9f;\n  ERR_new();\n  ERR_set_debug(\"test/errtest.c\",0x9f,\"raised_error\");\n  ERR_set_error(1,0xc0103,\"calling exit()\");\n  local_18 = ERR_get_error_all(&local_30,&local_38,0,&local_28,0);\n  iVar1 = FUN_00007054(\"test/errtest.c\",0xa1,\"e = ERR_get_error_all(&f, &l, NULL, &data, NULL)\",\n                       &DAT_0000d3b7,local_18,0);\n  if (iVar1 != 0) {\n    uVar2 = FUN_000027da(local_18);\n    iVar1 = FUN_00006087(\"test/errtest.c\",0xa2,\"ERR_GET_REASON(e)\",\"ERR_R_INTERNAL_ERROR\",uVar2,\n                         0xc0103);\n    if (iVar1 != 0) {\n      iVar1 = FUN_00006087(\"test/errtest.c\",0xa4,&DAT_0000d4a5,&DAT_0000d4a0,local_38,local_34);\n      if (iVar1 != 0) {\n        iVar1 = FUN_00007c13(\"test/errtest.c\",0xa5,&DAT_0000d4ac,&DAT_0000d4a7,local_30,local_20);\n        if (iVar1 != 0) {\n          iVar1 = FUN_00007c13(\"test/errtest.c\",0xa7,&DAT_0000d434,\"\\\"calling exit()\\\"\",local_28,\n                               \"calling exit()\");\n          if (iVar1 != 0) {\n            uVar3 = 1;\n            goto LAB_00002e78;\n          }\n        }\n      }\n    }\n  }\n  uVar3 = 0;\nLAB_00002e78:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is raised_error"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  int *piVar1;\n  \n  piVar1 = __errno_location();\n  *piVar1 = 0x16;\n  ERR_get_error();\n  piVar1 = __errno_location();\n  FUN_00006087(\"test/errtest.c\",0x7e,\"errno\",\"EINVAL\",*piVar1,0x16);\n  return;\n}\n\n",
        "output": "The predicted function name is preserves_system_error"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  undefined uVar1;\n  int iVar2;\n  BIO_METHOD *type;\n  ulong uVar3;\n  size_t sVar4;\n  size_t sVar5;\n  long in_FS_OFFSET;\n  undefined8 uVar6;\n  undefined4 local_288;\n  char *local_278;\n  char *local_270;\n  BIO *local_268;\n  char *local_260;\n  char *local_258;\n  char *local_250;\n  ulong local_248;\n  ulong local_240;\n  char *local_238;\n  char *local_230;\n  char local_228 [520];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_260 = \"test_print_error_format\";\n  local_258 = \"test/errtest.c\";\n  local_250 = \":error:%08lX:%s:%s:%s:%s:%d\";\n  local_278 = (char *)0x0;\n  local_270 = (char *)0x0;\n  local_288 = 0;\n  local_268 = (BIO *)0x0;\n  ERR_set_mark();\n  ERR_new();\n  ERR_set_debug(local_258,0x25,\"test_print_error_format\");\n  ERR_set_error(2,1,0);\n  local_248 = ERR_peek_error();\n  iVar2 = FUN_000027da(local_248);\n  local_240 = (ulong)iVar2;\n  iVar2 = FUN_00006087(\"test/errtest.c\",0x48,\"reasoncode\",\"syserr\",local_240 & 0xffffffff,1);\n  if (iVar2 == 0) {\n    ERR_pop_to_mark();\n  }\n  else {\n    local_238 = \"system library\";\n    uVar6 = 0x294f;\n    local_230 = strerror(1);\n    BIO_snprintf(local_228,0x200,local_250,local_248,local_238,local_260,local_230,local_258,0x25,\n                 uVar6);\n    type = BIO_s_mem();\n    local_268 = BIO_new(type);\n    iVar2 = FUN_00007ac6(\"test/errtest.c\",0x5d,\"bio = BIO_new(BIO_s_mem())\",local_268);\n    if (iVar2 != 0) {\n      ERR_print_errors(local_268);\n      uVar3 = BIO_ctrl(local_268,3,0,&local_278);\n      iVar2 = FUN_00006283(\"test/errtest.c\",0x62,\"len = BIO_get_mem_data(bio, &out)\",&DAT_0000d3b7,\n                           uVar3 & 0xffffffff,0);\n      if (iVar2 != 0) {\n        for (local_270 = local_278; (*local_270 != ':' && (*local_270 != '\\0'));\n            local_270 = local_270 + 1) {\n          if (((*local_270 < '0') || ('9' < *local_270)) &&\n             ((*local_270 < 'A' || ('F' < *local_270)))) {\n            uVar1 = 0;\n          }\n          else {\n            uVar1 = 1;\n          }\n          iVar2 = FUN_00007b3b(\"test/errtest.c\",0x66,\"IS_HEX(*p)\",uVar1);\n          if (iVar2 == 0) goto LAB_00002ba3;\n        }\n        iVar2 = FUN_00007b3b(\"test/errtest.c\",0x69,\"*p != 0\",*local_270 != '\\0');\n        if (iVar2 != 0) {\n          sVar4 = strlen(local_228);\n          sVar5 = strlen(local_228);\n          iVar2 = FUN_00007df0(\"test/errtest.c\",0x6a,\"expected\",&DAT_0000d3f5,local_228,sVar5,\n                               local_270,sVar4);\n          if (iVar2 != 0) {\n            local_288 = 1;\n          }\n        }\n      }\n    }\n  }\nLAB_00002ba3:\n  BIO_free(local_268);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_288;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is test_print_error_format"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8\n[MASK](int param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,undefined8 param_5\n            ,undefined8 param_6,undefined4 param_7)\n\n{\n  if (-1 < param_1) {\n    if (param_1 < 2) {\n      FUN_000049e7(param_1 == 1,param_2,param_3,param_4,param_5,param_6,param_7);\n    }\n    else if (param_1 == 2) {\n      FUN_000051cd(param_4,param_5,param_6,param_7);\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is handler"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,ulong param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined8 uVar1;\n  \n  if (param_2 < 0xc) {\n    uVar1 = 0xffffffff;\n  }\n  else {\n    *(undefined8 *)(param_1 + 8) = 0;\n    FUN_000069ac(param_1,param_2,0x11,param_3,param_4);\n    uVar1 = 0;\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is icmp_address_encode"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  FUN_00003aca();\n  return;\n}\n\n",
        "output": "The predicted function name is timestamp_finish"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,byte *param_2,byte *param_3,int param_4)\n\n{\n  byte bVar1;\n  undefined8 uVar2;\n  uint *local_20;\n  \n  bVar1 = *param_2;\n  if (((DAT_00214a48 & 0x20) != 0) || (*(int *)(param_3 + 0x18) == *(int *)(DAT_00214a50 + 0x2c))) {\n    uVar2 = FUN_0000434f(param_1,0x10);\n    printf(\"%d bytes from %s: \",(ulong)(param_4 + (uint)(bVar1 & 0xf) * -4),uVar2);\n    FUN_0000be7b(uVar2);\n    for (local_20 = &DAT_00214700; local_20 < &DAT_002148e0; local_20 = local_20 + 8) {\n      if (*local_20 == (uint)*param_3) {\n        if (*(long *)(local_20 + 2) != 0) {\n          puts(*(char **)(local_20 + 2));\n        }\n        if (*(long *)(local_20 + 4) == 0) {\n          return;\n        }\n        (**(code **)(local_20 + 4))(param_3,*(undefined8 *)(local_20 + 6));\n        return;\n      }\n    }\n    printf(\"Bad ICMP type: %d\\n\",(ulong)*param_3);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is print_icmp_header"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Type propagation algorithm not settling */\n\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = inet_ntoa((in_addr)((in_addr *)(param_1 + 4))->s_addr);\n  printf(\"Parameter problem: IP address = %s\\n\",pcVar1);\n  FUN_00004f47(param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is print_parameterprob"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2)\n\n{\n  *(undefined8 *)(param_1 + 0x50) = param_2;\n  return;\n}\n\n",
        "output": "The predicted function name is ping_set_packetsize"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Type propagation algorithm not settling */\n\nvoid [MASK](int param_1,undefined8 param_2,undefined8 param_3,long param_4,undefined8 param_5,\n                 long param_6,uint param_7)\n\n{\n  uint16_t uVar1;\n  char *pcVar2;\n  \n  uVar1 = ntohs(*(uint16_t *)(param_6 + 6));\n  pcVar2 = inet_ntoa((in_addr)((in_addr *)(param_4 + 4))->s_addr);\n  printf(\"%d bytes from %s: icmp_seq=%u\",(ulong)param_7,pcVar2,(ulong)uVar1);\n  if (param_1 != 0) {\n    printf(\" (DUP!)\");\n  }\n  putchar(10);\n  pcVar2 = inet_ntoa(SUB84(*(undefined8 *)(param_6 + 8),0));\n  printf(\"icmp_mask = %s\",pcVar2);\n  putchar(10);\n  return;\n}\n\n",
        "output": "The predicted function name is print_address"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](byte *param_1,ulong param_2,byte **param_3,byte **param_4)\n\n{\n  byte bVar1;\n  short sVar2;\n  undefined2 uVar3;\n  long lVar4;\n  undefined8 uVar5;\n  byte *pbVar6;\n  \n  bVar1 = *param_1;\n  lVar4 = (long)(int)((uint)(bVar1 & 0xf) * 4);\n  if (param_2 < lVar4 + 8U) {\n    uVar5 = 0xffffffff;\n  }\n  else {\n    pbVar6 = param_1 + lVar4;\n    *param_3 = param_1;\n    *param_4 = pbVar6;\n    sVar2 = *(short *)(pbVar6 + 2);\n    *(undefined2 *)(pbVar6 + 2) = 0;\n    uVar3 = FUN_00006cfc(pbVar6,(int)param_2 + (uint)(bVar1 & 0xf) * -4);\n    *(undefined2 *)(pbVar6 + 2) = uVar3;\n    if (sVar2 == *(short *)(pbVar6 + 2)) {\n      uVar5 = 0;\n    }\n    else {\n      uVar5 = 1;\n    }\n  }\n  return uVar5;\n}\n\n",
        "output": "The predicted function name is icmp_generic_decode"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined *param_1,undefined8 param_2)\n\n{\n  FUN_00004c6b(*param_1,param_1[1],param_2);\n  if ((DAT_00214a48 & 0x20) != 0) {\n    FUN_00004f47(param_1,0);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is print_icmp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Type propagation algorithm not settling */\n\nvoid [MASK](undefined8 param_1)\n\n{\n  int iVar1;\n  char *pcVar2;\n  \n  FUN_000061e7(DAT_00214a50,0x11);\n  FUN_00006846(DAT_00214a50,FUN_00005af3,0);\n  FUN_00006871(DAT_00214a50,0xc);\n  FUN_000041e4(DAT_00214a50,1);\n  iVar1 = FUN_0000688c(DAT_00214a50,param_1);\n  if (iVar1 != 0) {\n    error(1,0,0xff00);\n  }\n  pcVar2 = inet_ntoa((in_addr)((in_addr *)(DAT_00214a50 + 0x2c))->s_addr);\n  printf(\"PING %s (%s): sending address mask request\\n\",*(undefined8 *)(DAT_00214a50 + 0x48),pcVar2)\n  ;\n  FUN_0000349f(DAT_00214a50,FUN_00005c2f);\n  return;\n}\n\n",
        "output": "The predicted function name is ping_address"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8\n[MASK](undefined *param_1,ulong param_2,undefined param_3,uint16_t param_4,uint16_t param_5)\n\n{\n  uint16_t uVar1;\n  undefined2 uVar2;\n  undefined8 uVar3;\n  \n  if (param_2 < 8) {\n    uVar3 = 0xffffffff;\n  }\n  else {\n    *param_1 = param_3;\n    param_1[1] = 0;\n    *(undefined2 *)(param_1 + 2) = 0;\n    uVar1 = htons(param_5);\n    *(uint16_t *)(param_1 + 6) = uVar1;\n    uVar1 = htons(param_4);\n    *(uint16_t *)(param_1 + 4) = uVar1;\n    uVar2 = FUN_00006cfc(param_1,param_2 & 0xffffffff);\n    *(undefined2 *)(param_1 + 2) = uVar2;\n    uVar3 = 0;\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is icmp_generic_encode"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Type propagation algorithm not settling */\n\nvoid [MASK](int param_1,undefined8 param_2,undefined8 param_3,long param_4,undefined8 param_5,\n                 long param_6,uint param_7)\n\n{\n  uint16_t uVar1;\n  uint32_t uVar2;\n  int iVar3;\n  uint32_t uVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  long in_FS_OFFSET;\n  undefined local_38 [24];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar1 = ntohs(*(uint16_t *)(param_6 + 6));\n  pcVar5 = inet_ntoa((in_addr)((in_addr *)(param_4 + 4))->s_addr);\n  printf(\"%d bytes from %s: icmp_seq=%u\",(ulong)param_7,pcVar5,(ulong)uVar1);\n  if (param_1 != 0) {\n    printf(\" (DUP!)\");\n  }\n  putchar(10);\n  uVar2 = ntohl(*(uint32_t *)(param_6 + 8));\n  uVar6 = FUN_0000400a(local_38,0x10,uVar2);\n  printf(\"icmp_otime = %s\\n\",uVar6);\n  uVar2 = ntohl(*(uint32_t *)(param_6 + 0xc));\n  uVar6 = FUN_0000400a(local_38,0x10,uVar2);\n  printf(\"icmp_rtime = %s\\n\",uVar6);\n  uVar2 = ntohl(*(uint32_t *)(param_6 + 0x10));\n  uVar6 = FUN_0000400a(local_38,0x10,uVar2);\n  printf(\"icmp_ttime = %s\\n\",uVar6);\n  if ((DAT_00214a48 & 0x20) != 0) {\n    ntohl(*(uint32_t *)(param_6 + 8));\n    iVar3 = FUN_00003ff6();\n    if (iVar3 != 0) {\n      ntohl(*(uint32_t *)(param_6 + 8));\n      iVar3 = FUN_00003ff6();\n      if (iVar3 != 0) {\n        uVar2 = ntohl(*(uint32_t *)(param_6 + 0x10));\n        uVar4 = ntohl(*(uint32_t *)(param_6 + 8));\n        printf(\"difference = %d ms\\n\",(ulong)(uVar2 - uVar4));\n      }\n    }\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is print_timestamp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  FUN_000069ac(param_1,param_2,8,param_3,param_4);\n  return;\n}\n\n",
        "output": "The predicted function name is icmp_echo_encode"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Type propagation algorithm not settling */\n\nvoid [MASK](undefined8 param_1)\n\n{\n  int iVar1;\n  char *pcVar2;\n  \n  FUN_000061e7(DAT_00214a50,0xd);\n  FUN_00006846(DAT_00214a50,FUN_00005d18,0);\n  FUN_00006871(DAT_00214a50,0x14);\n  iVar1 = FUN_0000688c(DAT_00214a50,param_1);\n  if (iVar1 != 0) {\n    error(1,0,\"unknown host\");\n  }\n  pcVar2 = inet_ntoa((in_addr)((in_addr *)(DAT_00214a50 + 0x2c))->s_addr);\n  printf(\"PING %s (%s): sending timestamp requests\\n\",*(undefined8 *)(DAT_00214a50 + 0x48),pcVar2);\n  FUN_0000349f(DAT_00214a50,FUN_00005f58);\n  return;\n}\n\n",
        "output": "The predicted function name is ping_timestamp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](long param_1)\n\n{\n  long lVar1;\n  \n  if ((*(int *)(param_1 + 4) == 0xd) || (*(int *)(param_1 + 4) == 0xe)) {\n    lVar1 = 0x14;\n  }\n  else if ((*(int *)(param_1 + 4) == 0x11) || (*(int *)(param_1 + 4) == 0x12)) {\n    lVar1 = 0xc;\n  }\n  else {\n    lVar1 = *(long *)(param_1 + 0x50) + 8;\n  }\n  return lVar1;\n}\n\n",
        "output": "The predicted function name is _ping_packetsize"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\n/* WARNING: Type propagation algorithm not settling */\n\nvoid [MASK](byte *param_1)\n\n{\n  byte bVar1;\n  uint16_t uVar2;\n  ushort uVar3;\n  uint16_t uVar4;\n  undefined *puVar5;\n  char *pcVar6;\n  ulong local_30;\n  byte *local_28;\n  ulong local_20;\n  \n  bVar1 = *param_1;\n  if ((DAT_00214a48 & 0x20) != 0) {\n    printf(\"IP Hdr Dump:\\n \");\n    for (local_20 = 0; local_20 < 0x14; local_20 = local_20 + 1) {\n      if ((local_20 & 1) == 0) {\n        puVar5 = &DAT_0000fbdd;\n      }\n      else {\n        puVar5 = &DAT_0000fbdb;\n      }\n      printf(\"%02x%s\",(ulong)param_1[local_20],puVar5);\n    }\n    putchar(10);\n  }\n  puts(\"Vr HL TOS  Len   ID Flg  off TTL Pro  cks      Src\\tDst\\tData\");\n  printf(\" %1x  %1x  %02x\",(ulong)(*param_1 >> 4),(ulong)(*param_1 & 0xf),(ulong)param_1[1]);\n  uVar2 = ntohs(*(uint16_t *)(param_1 + 4));\n  if (*(ushort *)(param_1 + 2) < 0x2001) {\n    uVar3 = *(ushort *)(param_1 + 2);\n  }\n  else {\n    uVar3 = ntohs(*(uint16_t *)(param_1 + 2));\n  }\n  printf(\" %04x %04x\",(ulong)uVar3,(ulong)uVar2);\n  uVar2 = ntohs(*(uint16_t *)(param_1 + 6));\n  uVar4 = ntohs(*(uint16_t *)(param_1 + 6));\n  printf(\"   %1x %04x\",(ulong)(uVar4 >> 0xd),(ulong)(uVar2 & 0x1fff));\n  uVar2 = ntohs(*(uint16_t *)(param_1 + 10));\n  printf(\"  %02x  %02x %04x\",(ulong)param_1[8],(ulong)param_1[9],(ulong)uVar2);\n  pcVar6 = inet_ntoa((in_addr)((in_addr *)(param_1 + 0xc))->s_addr);\n  printf(\" %s \",pcVar6);\n  pcVar6 = inet_ntoa((in_addr)((in_addr *)(param_1 + 0x10))->s_addr);\n  printf(\" %s \",pcVar6);\n  local_30 = (long)(int)((uint)(bVar1 & 0xf) << 2);\n  local_28 = param_1 + 0x14;\n  while (0x14 < local_30) {\n    printf(\"%02x\",(ulong)*local_28);\n    local_30 = local_30 - 1;\n    local_28 = local_28 + 1;\n  }\n  putchar(10);\n  return;\n}\n\n",
        "output": "The predicted function name is print_ip_header"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  FUN_00006a4c(param_1,param_2,param_3,param_4);\n  return;\n}\n\n",
        "output": "The predicted function name is icmp_echo_decode"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,int param_2)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  byte *pbVar3;\n  byte *pbVar4;\n  uint32_t *puVar5;\n  int iVar6;\n  int iVar7;\n  uint uVar8;\n  uint32_t uVar9;\n  undefined8 uVar10;\n  long in_FS_OFFSET;\n  int local_74;\n  uint local_58;\n  uint local_54;\n  uint32_t *local_48;\n  undefined local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48 = (uint32_t *)(param_1 + 0x14);\n  local_74 = param_2;\n  do {\n    if (local_74 < 0x15) {\n      if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    bVar1 = *(byte *)local_48;\n    if (bVar1 == 7) {\n      pbVar2 = (byte *)((long)local_48 + 1);\n      local_48 = (uint32_t *)((long)local_48 + 2);\n      local_74 = local_74 + -2;\n      local_58 = (uint)*(byte *)local_48;\n      if ((uint)*pbVar2 < (uint)*(byte *)local_48) {\n        local_58 = (uint)*pbVar2;\n      }\n      iVar7 = local_58 - 4;\n      iVar6 = local_74;\n      puVar5 = local_48;\n      if (0 < iVar7) {\n        if ((((iVar7 == DAT_00214980) && (local_48 == (uint32_t *)(param_1 + 0x16))) &&\n            (iVar6 = memcmp(local_48,&DAT_002149a0,(long)iVar7), iVar6 == 0)) &&\n           ((DAT_00214a48 & 1) == 0)) {\n          printf(\"\\t (same route)\");\n          iVar7 = local_58 - 1;\n          if ((int)(local_58 - 1) < 0) {\n            iVar7 = local_58 + 2;\n          }\n          iVar6 = local_74 + (iVar7 >> 2) * -4;\n          puVar5 = (uint32_t *)((long)local_48 + (long)((iVar7 >> 2) * 4));\n        }\n        else {\n          if (iVar7 < 0x28) {\n            DAT_00214980 = iVar7;\n            memmove(&DAT_002149a0,local_48,(long)iVar7);\n          }\n          else {\n            DAT_00214980 = 0;\n          }\n          printf(\"\\nRR: \");\n          local_54 = 0;\n          local_58 = iVar7;\n          while( true ) {\n            pbVar2 = (byte *)((long)local_48 + 1);\n            pbVar3 = (byte *)((long)local_48 + 2);\n            pbVar4 = (byte *)((long)local_48 + 3);\n            local_48 = local_48 + 1;\n            uVar9 = (uint)*(byte *)local_48 +\n                    ((uint)*pbVar4 + ((uint)*pbVar3 + (uint)*pbVar2 * 0x100) * 0x100) * 0x100;\n            if (uVar9 == 0) {\n              printf(\"\\t0.0.0.0\");\n            }\n            else {\n              uVar9 = htonl(uVar9);\n              uVar10 = FUN_0000453b(uVar9);\n              printf(\"\\t%s\",uVar10);\n              FUN_0000be7b(uVar10);\n            }\n            local_74 = local_74 + -4;\n            local_58 = local_58 + -4;\n            local_54 = local_54 + 4;\n            iVar6 = local_74;\n            puVar5 = local_48;\n            if ((int)local_58 < 1) goto LAB_000058b3;\n            if (0x27 < (int)local_54) break;\n            putchar(10);\n          }\n          printf(\"\\t (truncated route)\");\n        }\n      }\n    }\n    else {\n      iVar6 = local_74;\n      puVar5 = local_48;\n      if (bVar1 < 8) {\n        if (bVar1 == 0) {\n          local_74 = 0;\n          iVar6 = local_74;\n        }\n        else if (bVar1 == 1) {\n          printf(\"\\nNOP\");\n        }\n        else {\nLAB_0000588d:\n          printf(\"\\nunknown option %x\",(ulong)*(byte *)local_48);\n        }\n      }\n      else if ((bVar1 == 0x83) || (bVar1 == 0x89)) {\n        if (*(byte *)local_48 == 0x83) {\n          uVar8 = 0x4c;\n        }\n        else {\n          uVar8 = 0x53;\n        }\n        printf(\"\\n%cSRR: \",(ulong)uVar8);\n        local_74 = local_74 + -2;\n        local_54 = (uint)*(byte *)((long)local_48 + 1);\n        local_48 = (uint32_t *)((long)local_48 + 2);\n        iVar6 = local_74;\n        puVar5 = local_48;\n        if (4 < local_54) {\n          while( true ) {\n            pbVar2 = (byte *)((long)local_48 + 1);\n            pbVar3 = (byte *)((long)local_48 + 2);\n            pbVar4 = (byte *)((long)local_48 + 3);\n            local_48 = local_48 + 1;\n            uVar9 = (uint)*(byte *)local_48 +\n                    ((uint)*pbVar4 + ((uint)*pbVar3 + (uint)*pbVar2 * 0x100) * 0x100) * 0x100;\n            if (uVar9 == 0) {\n              printf(\"\\t0.0.0.0\");\n            }\n            else {\n              uVar9 = htonl(uVar9);\n              uVar10 = FUN_0000453b(uVar9);\n              printf(\"\\t%s\",uVar10);\n              FUN_0000be7b(uVar10);\n            }\n            local_74 = local_74 + -4;\n            local_54 = local_54 - 4;\n            iVar6 = local_74;\n            puVar5 = local_48;\n            if ((int)local_54 < 5) break;\n            putchar(10);\n          }\n        }\n      }\n      else {\n        if (bVar1 != 0x44) goto LAB_0000588d;\n        uVar8 = (uint)*(byte *)((long)local_48 + 1);\n        local_58 = (uint)*(byte *)(uint32_t *)((long)local_48 + 2);\n        if (uVar8 < local_58) {\n          local_58 = uVar8;\n        }\n        iVar6 = local_74 + -2;\n        puVar5 = (uint32_t *)((long)local_48 + 2);\n        if (8 < uVar8) {\n          bVar1 = *(byte *)((long)local_48 + 3);\n          local_48 = local_48 + 1;\n          local_74 = local_74 + -4;\n          printf(\"\\nTS:\");\n          local_54 = 5;\n          do {\n            if ((bVar1 & 0xf) == 0) {\nLAB_000057c3:\n              uVar9 = ntohl(*local_48);\n              uVar10 = FUN_0000400a(local_28,0x10,uVar9);\n              printf(\"\\t%s ms\",uVar10);\n              if ((DAT_00214a48 & 0x20) != 0) {\n                uVar9 = ntohl(*local_48);\n                printf(\" = 0x%08x\",(ulong)uVar9);\n              }\n              putchar(10);\n            }\n            else {\n              iVar7 = local_54;\n              if ((int)local_54 < 0) {\n                iVar7 = local_54 + 3;\n              }\n              if (((iVar7 >> 2) - (iVar7 >> 0x1f) & 1U) + (iVar7 >> 0x1f) != 1) goto LAB_000057c3;\n              uVar10 = FUN_0000453b(*local_48);\n              printf(\"\\t%s\",uVar10);\n              FUN_0000be7b();\n            }\n            local_48 = local_48 + 1;\n            local_54 = local_54 + 4;\n            local_74 = local_74 + -4;\n          } while ((int)local_54 < (int)local_58);\n          iVar6 = local_74;\n          puVar5 = local_48;\n          if ((bVar1 & 0xf0) != 0) {\n            printf(\"\\t(%u overflowing hosts)\",(ulong)(uint)((int)(uint)bVar1 >> 4));\n          }\n        }\n      }\n    }\nLAB_000058b3:\n    local_48 = puVar5;\n    local_74 = iVar6;\n    local_74 = local_74 + -1;\n    local_48 = (uint32_t *)((long)local_48 + 1);\n  } while( true );\n}\n\n",
        "output": "The predicted function name is print_ip_opt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nushort [MASK](ushort *param_1,int param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  int local_44;\n  ushort *local_28;\n  \n  uVar1 = 0;\n  local_28 = param_1;\n  for (local_44 = param_2; 1 < local_44; local_44 = local_44 + -2) {\n    uVar1 = uVar1 + *local_28;\n    local_28 = local_28 + 1;\n  }\n  if (local_44 == 1) {\n    uVar1 = uVar1 + *(byte *)local_28;\n  }\n  iVar2 = ((int)uVar1 >> 0x10) + (uVar1 & 0xffff);\n  if (*(long *)(in_FS_OFFSET + 0x28) != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return ~((short)iVar2 + (short)((uint)iVar2 >> 0x10));\n}\n\n",
        "output": "The predicted function name is icmp_cksum"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  *(undefined8 *)(param_1 + 0x60) = param_2;\n  *(undefined8 *)(param_1 + 0x68) = param_3;\n  return;\n}\n\n",
        "output": "The predicted function name is ping_set_event_handler"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,ulong param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  uint32_t uVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  timeval local_28;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 < 0x14) {\n    uVar2 = 0xffffffff;\n  }\n  else {\n    gettimeofday(&local_28,(__timezone_ptr_t)0x0);\n    uVar1 = htonl((int)(local_28.tv_usec / 1000) +\n                  (int)local_28.tv_sec * 1000 + (int)(local_28.tv_sec / 0x15180) * -86400000);\n    *(uint32_t *)(param_1 + 8) = uVar1;\n    *(uint32_t *)(param_1 + 0xc) = uVar1;\n    *(uint32_t *)(param_1 + 0x10) = uVar1;\n    FUN_000069ac(param_1,param_2,0xd,param_3,param_4);\n    uVar2 = 0;\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is icmp_timestamp_encode"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\ncode * [MASK](char *param_1)\n\n{\n  int iVar1;\n  code *local_10;\n  \n  local_10 = (code *)0x0;\n  iVar1 = strcasecmp(param_1,\"echo\");\n  if (iVar1 == 0) {\n    local_10 = FUN_00004663;\n  }\n  else {\n    iVar1 = strcasecmp(param_1,\"timestamp\");\n    if (iVar1 == 0) {\n      local_10 = FUN_00005c49;\n    }\n    else {\n      iVar1 = strcasecmp(param_1,\"address\");\n      if (iVar1 == 0) {\n        local_10 = FUN_00005a10;\n      }\n      else {\n        iVar1 = strcasecmp(param_1,\"mask\");\n        if (iVar1 == 0) {\n          local_10 = FUN_00005a10;\n        }\n        else {\n          error(1,0,\"unsupported packet type: %s\",param_1);\n        }\n      }\n    }\n  }\n  return local_10;\n}\n\n",
        "output": "The predicted function name is decode_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return 0;\n}\n\n",
        "output": "The predicted function name is ping_router"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8\n[MASK](int param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,undefined8 param_5\n            ,undefined8 param_6,undefined4 param_7)\n\n{\n  if (-1 < param_1) {\n    if (param_1 < 2) {\n      FUN_00005d9b(param_1 == 1,param_2,param_3,param_4,param_5,param_6,param_7);\n    }\n    else if (param_1 == 2) {\n      FUN_000051cd(param_4,param_5,param_6,param_7);\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is recv_timestamp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined4 param_2)\n\n{\n  *(undefined4 *)(param_1 + 4) = param_2;\n  return;\n}\n\n",
        "output": "The predicted function name is ping_set_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](int param_1,uint param_2,undefined8 param_3)\n\n{\n  int *local_10;\n  \n  local_10 = &DAT_002145c0;\n  while( true ) {\n    if ((int *)0x2146ff < local_10) {\n      printf(\"%s, Unknown Code: %d\\n\",param_3,(ulong)param_2);\n      return;\n    }\n    if ((param_1 == *local_10) && (param_2 == local_10[1])) break;\n    local_10 = local_10 + 4;\n  }\n  puts(*(char **)(local_10 + 2));\n  return;\n}\n\n",
        "output": "The predicted function name is print_icmp_code"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return 0;\n}\n\n",
        "output": "The predicted function name is address_finish"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8\n[MASK](int param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,undefined8 param_5\n            ,undefined8 param_6,undefined4 param_7)\n\n{\n  if (-1 < param_1) {\n    if (param_1 < 2) {\n      FUN_00005b76(param_1 == 1,param_2,param_3,param_4,param_5,param_6,param_7);\n    }\n    else if (param_1 == 2) {\n      FUN_000051cd(param_4,param_5,param_6,param_7);\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is recv_address"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](char *param_1)\n\n{\n  int iVar1;\n  undefined4 local_c;\n  \n  local_c = 0;\n  iVar1 = strcasecmp(param_1,\"tsonly\");\n  if (iVar1 == 0) {\n    local_c = 1;\n  }\n  else {\n    iVar1 = strcasecmp(param_1,\"tsaddr\");\n    if (iVar1 == 0) {\n      local_c = 2;\n    }\n    else {\n      error(1,0,\"unsupported timestamp type: %s\",param_1);\n    }\n  }\n  return local_c;\n}\n\n",
        "output": "The predicted function name is decode_ip_timestamp"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  if (DAT_002053a0 == (code *)0x0) {\n    EVP_PKEY_meth_get_keygen(DAT_00205350,0,&DAT_002053a0);\n  }\n  (*DAT_002053a0)(param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_rsa_keygen"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  EVP_MD *pEVar1;\n  code *pcVar2;\n  \n  FUN_00002e1a();\n  pEVar1 = EVP_sha1();\n  pcVar2 = (code *)EVP_MD_meth_get_init(pEVar1);\n  (*pcVar2)(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_sha1_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  if (DAT_002053d0 == (code *)0x0) {\n    EVP_PKEY_meth_get_ctrl(DAT_00205350,0,&DAT_002053d0);\n  }\n  (*DAT_002053d0)(param_1,param_2,param_3);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_rsa_ctrl_str"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  undefined8 *puVar2;\n  \n  puVar2 = (undefined8 *)EVP_CIPHER_CTX_get_cipher_data(param_1);\n  iVar1 = EVP_CIPHER_impl_ctx_size(param_2);\n  CRYPTO_clear_free(*puVar2,(long)iVar1,\"engines/e_dasync.c\",0x2ee);\n  return 1;\n}\n\n",
        "output": "The predicted function name is dasync_cipher_cleanup_helper"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  ENGINE *e;\n  \n  e = (ENGINE *)FUN_00002bb6();\n  if (e != (ENGINE *)0x0) {\n    ERR_set_mark();\n    ENGINE_add(e);\n    ENGINE_free(e);\n    ERR_pop_to_mark();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is engine_load_dasync_int"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,int param_3,int *param_4)\n\n{\n  close(param_3);\n  close(*param_4);\n  CRYPTO_free(param_4);\n  return;\n}\n\n",
        "output": "The predicted function name is wait_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined4 param_4)\n\n{\n  EVP_CIPHER *pEVar1;\n  \n  pEVar1 = EVP_aes_128_cbc_hmac_sha1();\n  FUN_0000333c(param_1,param_2,param_3,param_4,pEVar1);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_aes128_cbc_hmac_sha1_init_key"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                undefined8 param_5)\n\n{\n  uint uVar1;\n  int iVar2;\n  long lVar3;\n  code *pcVar4;\n  int local_1c;\n  uint local_18;\n  \n  local_1c = 1;\n  lVar3 = EVP_CIPHER_CTX_get_cipher_data(param_1);\n  uVar1 = *(uint *)(lVar3 + 8);\n  EVP_CIPHER_CTX_set_cipher_data(param_1);\n  if (uVar1 == 0) {\n    if (*(int *)(lVar3 + 0x1c8) != 0) {\n      if (*(int *)(lVar3 + 0x1c8) != 1) {\n        return -1;\n      }\n      pcVar4 = (code *)EVP_CIPHER_meth_get_ctrl(param_5);\n      (*pcVar4)(param_1,0x16,0xd,lVar3 + 0x28);\n    }\n    pcVar4 = (code *)EVP_CIPHER_meth_get_do_cipher(param_5);\n    local_1c = (*pcVar4)(param_1,param_2,param_3,param_4);\n  }\n  else {\n    if ((*(int *)(lVar3 + 0x1c8) != 0) && (uVar1 != *(uint *)(lVar3 + 0x1c8))) {\n      return -1;\n    }\n    for (local_18 = 0; local_18 < uVar1; local_18 = local_18 + 1) {\n      if (*(int *)(lVar3 + 0x1c8) != 0) {\n        pcVar4 = (code *)EVP_CIPHER_meth_get_ctrl(param_5);\n        (*pcVar4)(param_1,0x16,0xd,lVar3 + (ulong)local_18 * 0xd + 0x28);\n      }\n      if (local_1c == 0) {\nLAB_0000361c:\n        local_1c = 0;\n      }\n      else {\n        pcVar4 = (code *)EVP_CIPHER_meth_get_do_cipher(param_5);\n        iVar2 = (*pcVar4)(param_1,*(undefined8 *)(*(long *)(lVar3 + 0x18) + (ulong)local_18 * 8),\n                          *(undefined8 *)(*(long *)(lVar3 + 0x10) + (ulong)local_18 * 8),\n                          *(undefined8 *)(*(long *)(lVar3 + 0x20) + (ulong)local_18 * 8));\n        if (iVar2 == 0) goto LAB_0000361c;\n        local_1c = 1;\n      }\n    }\n    *(undefined4 *)(lVar3 + 8) = 0;\n  }\n  *(undefined4 *)(lVar3 + 0x1c8) = 0;\n  EVP_CIPHER_CTX_set_cipher_data(param_1,lVar3);\n  return local_1c;\n}\n\n",
        "output": "The predicted function name is dasync_cipher_helper"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  if (DAT_00205378 == (code *)0x0) {\n    EVP_PKEY_meth_get_init(DAT_00205350,&DAT_00205378);\n  }\n  (*DAT_00205378)(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_rsa_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong [MASK](undefined8 param_1,undefined8 *param_2,undefined8 param_3,int param_4)\n\n{\n  ulong uVar1;\n  undefined8 uVar2;\n  \n  if (param_2 == (undefined8 *)0x0) {\n    uVar1 = FUN_000024bb(param_3);\n  }\n  else {\n    if (param_4 != 0x40) {\n      *param_2 = 0;\n    }\n    else {\n      uVar2 = FUN_0000248d();\n      *param_2 = uVar2;\n    }\n    uVar1 = (ulong)(param_4 == 0x40);\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is dasync_digests"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  EVP_CIPHER_meth_free(DAT_00205358);\n  EVP_CIPHER_meth_free(DAT_00205360);\n  DAT_00205358 = 0;\n  DAT_00205360 = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is destroy_ciphers"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nENGINE * [MASK](void)\n\n{\n  int iVar1;\n  ENGINE *e;\n  \n  e = ENGINE_new();\n  if (e == (ENGINE *)0x0) {\n    e = (ENGINE *)0x0;\n  }\n  else {\n    iVar1 = FUN_000025ac(e);\n    if (iVar1 == 0) {\n      ENGINE_free(e);\n      e = (ENGINE *)0x0;\n    }\n  }\n  return e;\n}\n\n",
        "output": "The predicted function name is engine_dasync"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4\n[MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined4 param_4,\n            undefined8 param_5)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long *plVar3;\n  long lVar4;\n  code *pcVar5;\n  \n  plVar3 = (long *)EVP_CIPHER_CTX_get_cipher_data(param_1);\n  if ((*plVar3 == 0) && (iVar1 = EVP_CIPHER_impl_ctx_size(param_5), iVar1 != 0)) {\n    iVar1 = EVP_CIPHER_impl_ctx_size(param_5);\n    lVar4 = CRYPTO_zalloc((long)iVar1,\"engines/e_dasync.c\",0x2aa);\n    *plVar3 = lVar4;\n    if (*plVar3 == 0) {\n      FUN_00002411(0,0xc0100,\"engines/e_dasync.c\",0x2ad);\n      return 0;\n    }\n  }\n  *(undefined4 *)(plVar3 + 1) = 0;\n  *(undefined4 *)(plVar3 + 0x39) = 0;\n  EVP_CIPHER_CTX_set_cipher_data(param_1,*plVar3);\n  pcVar5 = (code *)EVP_CIPHER_meth_get_init(param_5);\n  uVar2 = (*pcVar5)(param_1,param_2,param_3,param_4);\n  EVP_CIPHER_CTX_set_cipher_data(param_1,plVar3);\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is dasync_cipher_init_key_helper"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  EVP_MD *pEVar1;\n  code *pcVar2;\n  \n  FUN_00002e1a();\n  pEVar1 = EVP_sha1();\n  pcVar2 = (code *)EVP_MD_meth_get_final(pEVar1);\n  (*pcVar2)(param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_sha1_final"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                 undefined8 param_5)\n\n{\n  if (DAT_002053b0 == (code *)0x0) {\n    EVP_PKEY_meth_get_encrypt(DAT_00205350,0,&DAT_002053b0);\n  }\n  (*DAT_002053b0)(param_1,param_2,param_3,param_4,param_5);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_rsa_encrypt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](undefined8 param_1,char *param_2)\n\n{\n  int iVar1;\n  \n  if ((param_2 != (char *)0x0) && (iVar1 = strcmp(param_2,PTR_s_dasync_00205320), iVar1 != 0)) {\n    return false;\n  }\n  iVar1 = FUN_000025ac(param_1);\n  return iVar1 != 0;\n}\n\n",
        "output": "The predicted function name is bind_helper"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  EVP_CIPHER *pEVar1;\n  \n  pEVar1 = EVP_aes_128_cbc();\n  FUN_00003665(param_1,pEVar1);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_aes128_cbc_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return DAT_00205358;\n}\n\n",
        "output": "The predicted function name is dasync_aes_128_cbc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  int iVar1;\n  ssize_t sVar2;\n  long in_FS_OFFSET;\n  undefined local_41;\n  code *local_40;\n  undefined8 local_38;\n  int *local_30;\n  long local_28;\n  undefined8 local_20;\n  int local_18;\n  int local_14;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = 0;\n  local_14 = 0;\n  local_41 = 0x58;\n  local_28 = ASYNC_get_current_job();\n  if (local_28 != 0) {\n    local_20 = ASYNC_get_wait_ctx(local_28);\n    iVar1 = ASYNC_WAIT_CTX_get_callback(local_20,&local_40,&local_38);\n    if ((iVar1 == 0) || (local_40 == (code *)0x0)) {\n      iVar1 = ASYNC_WAIT_CTX_get_fd(local_20,PTR_s_dasync_00205320,&local_18,&local_30);\n      if (iVar1 == 0) {\n        local_30 = (int *)CRYPTO_malloc(4,\"engines/e_dasync.c\",0x1fe);\n        if (local_30 == (int *)0x0) goto LAB_00002faf;\n        iVar1 = pipe(&local_18);\n        if (iVar1 != 0) {\n          CRYPTO_free(local_30);\n          goto LAB_00002faf;\n        }\n        *local_30 = local_14;\n        iVar1 = ASYNC_WAIT_CTX_set_wait_fd\n                          (local_20,PTR_s_dasync_00205320,local_18,local_30,FUN_00002dc9);\n        if (iVar1 == 0) {\n          FUN_00002dc9(local_20,PTR_s_dasync_00205320,local_18,local_30);\n          goto LAB_00002faf;\n        }\n      }\n      else {\n        local_14 = *local_30;\n      }\n      sVar2 = write(local_14,&local_41,1);\n      if (-1 < sVar2) {\n        ASYNC_pause_job();\n        read(local_18,&local_41,1);\n      }\n    }\n    else {\n      (*local_40)(local_38);\n      ASYNC_pause_job();\n    }\n  }\nLAB_00002faf:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is dummy_pause_job"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return DAT_00205360;\n}\n\n",
        "output": "The predicted function name is dasync_aes_128_cbc_hmac_sha1"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined4 param_2,undefined4 param_3,undefined8 param_4)\n\n{\n  EVP_CIPHER *pEVar1;\n  \n  pEVar1 = EVP_aes_128_cbc_hmac_sha1();\n  FUN_00003068(param_1,param_2,param_3,param_4,1,pEVar1);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_aes128_cbc_hmac_sha1_ctrl"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](ENGINE *param_1)\n\n{\n  int iVar1;\n  \n  DAT_00205350 = EVP_PKEY_meth_find(6);\n  if ((DAT_00205350 == (EVP_PKEY_METHOD *)0x0) ||\n     (DAT_00205348 = EVP_PKEY_meth_new(6,2), DAT_00205348 == (EVP_PKEY_METHOD *)0x0)) {\n    return 0;\n  }\n  EVP_PKEY_meth_set_init(DAT_00205348,FUN_0000386e);\n  EVP_PKEY_meth_set_cleanup(DAT_00205348,FUN_000038ae);\n  EVP_PKEY_meth_set_paramgen(DAT_00205348,FUN_000038ef,FUN_00003947);\n  EVP_PKEY_meth_set_keygen(DAT_00205348,FUN_000039aa,FUN_00003a02);\n  EVP_PKEY_meth_set_encrypt(DAT_00205348,FUN_00003a52,FUN_00003aaa);\n  EVP_PKEY_meth_set_decrypt(DAT_00205348,FUN_00003b0c,FUN_00003b64);\n  EVP_PKEY_meth_set_ctrl(DAT_00205348,FUN_00003bc6,FUN_00003c1c);\n  FUN_0000239a();\n  iVar1 = ENGINE_set_id(param_1,PTR_s_dasync_00205320);\n  if ((((iVar1 != 0) &&\n       (((iVar1 = ENGINE_set_name(param_1,PTR_s_Dummy_Async_engine_support_00205328), iVar1 != 0 &&\n         (iVar1 = ENGINE_set_pkey_meths(param_1,FUN_00002c82), iVar1 != 0)) &&\n        (iVar1 = ENGINE_set_digests(param_1,FUN_00002cde), iVar1 != 0)))) &&\n      (((iVar1 = ENGINE_set_ciphers(param_1,FUN_00002d42), iVar1 != 0 &&\n        (iVar1 = ENGINE_set_destroy_function(param_1,FUN_00002c5b), iVar1 != 0)) &&\n       (iVar1 = ENGINE_set_init_function(param_1,FUN_00002c3d), iVar1 != 0)))) &&\n     (iVar1 = ENGINE_set_finish_function(param_1,FUN_00002c4c), iVar1 != 0)) {\n    DAT_00205340 = EVP_MD_meth_new(0x40,0x41);\n    if (((DAT_00205340 == 0) || (iVar1 = EVP_MD_meth_set_result_size(DAT_00205340,0x14), iVar1 == 0)\n        ) || ((iVar1 = EVP_MD_meth_set_input_blocksize(DAT_00205340,0x40), iVar1 == 0 ||\n              ((((iVar1 = EVP_MD_meth_set_app_datasize(DAT_00205340,0x68), iVar1 == 0 ||\n                 (iVar1 = EVP_MD_meth_set_flags(DAT_00205340,8), iVar1 == 0)) ||\n                (iVar1 = EVP_MD_meth_set_init(DAT_00205340,FUN_00002fc5), iVar1 == 0)) ||\n               ((iVar1 = EVP_MD_meth_set_update(DAT_00205340,FUN_00002ff1), iVar1 == 0 ||\n                (iVar1 = EVP_MD_meth_set_final(DAT_00205340,FUN_00003031), iVar1 == 0)))))))) {\n      EVP_MD_meth_free(DAT_00205340);\n      DAT_00205340 = 0;\n    }\n    DAT_00205358 = EVP_CIPHER_meth_new(0x1a3,0x10,0x10);\n    if (((DAT_00205358 == 0) ||\n        (iVar1 = EVP_CIPHER_meth_set_iv_length(DAT_00205358,0x10), iVar1 == 0)) ||\n       (((iVar1 = EVP_CIPHER_meth_set_flags(DAT_00205358,0x800402), iVar1 == 0 ||\n         (((iVar1 = EVP_CIPHER_meth_set_init(DAT_00205358,FUN_000036f5), iVar1 == 0 ||\n           (iVar1 = EVP_CIPHER_meth_set_do_cipher(DAT_00205358,FUN_00003730), iVar1 == 0)) ||\n          (iVar1 = EVP_CIPHER_meth_set_cleanup(DAT_00205358,FUN_0000376d), iVar1 == 0)))) ||\n        ((iVar1 = EVP_CIPHER_meth_set_ctrl(DAT_00205358,FUN_000036b6), iVar1 == 0 ||\n         (iVar1 = EVP_CIPHER_meth_set_impl_ctx_size(DAT_00205358,0x1d0), iVar1 == 0)))))) {\n      EVP_CIPHER_meth_free(DAT_00205358);\n      DAT_00205358 = 0;\n    }\n    DAT_00205360 = EVP_CIPHER_meth_new(0x394,0x10,0x10);\n    if ((((DAT_00205360 == 0) ||\n         (iVar1 = EVP_CIPHER_meth_set_iv_length(DAT_00205360,0x10), iVar1 == 0)) ||\n        ((iVar1 = EVP_CIPHER_meth_set_flags(DAT_00205360,0xa00402), iVar1 == 0 ||\n         (((iVar1 = EVP_CIPHER_meth_set_init(DAT_00205360,FUN_000037d1), iVar1 == 0 ||\n           (iVar1 = EVP_CIPHER_meth_set_do_cipher(DAT_00205360,FUN_0000380c), iVar1 == 0)) ||\n          (iVar1 = EVP_CIPHER_meth_set_cleanup(DAT_00205360,FUN_00003849), iVar1 == 0)))))) ||\n       ((iVar1 = EVP_CIPHER_meth_set_ctrl(DAT_00205360,FUN_00003792), iVar1 == 0 ||\n        (iVar1 = EVP_CIPHER_meth_set_impl_ctx_size(DAT_00205360,0x1d0), iVar1 == 0)))) {\n      EVP_CIPHER_meth_free(DAT_00205360);\n      DAT_00205360 = 0;\n    }\n    return 1;\n  }\n  FUN_00002411(0,100,\"engines/e_dasync.c\",0xf1);\n  return 0;\n}\n\n",
        "output": "The predicted function name is bind_dasync"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (DAT_00205388 == (code *)0x0) {\n    EVP_PKEY_meth_get_paramgen(DAT_00205350,&DAT_00205388,0);\n  }\n  if (DAT_00205388 == (code *)0x0) {\n    uVar1 = 1;\n  }\n  else {\n    uVar1 = (*DAT_00205388)(param_1);\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is dasync_rsa_paramgen_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](undefined8 param_1,undefined8 *param_2,undefined8 *param_3,int param_4)\n\n{\n  undefined8 uVar1;\n  undefined4 local_c;\n  \n  local_c = 1;\n  if (param_2 == (undefined8 *)0x0) {\n    *param_3 = &DAT_002052e8;\n    local_c = 2;\n  }\n  else if (param_4 == 0x1a3) {\n    uVar1 = FUN_00002557();\n    *param_2 = uVar1;\n  }\n  else if (param_4 == 0x394) {\n    uVar1 = FUN_00002564();\n    *param_2 = uVar1;\n  }\n  else {\n    local_c = 0;\n    *param_2 = 0;\n  }\n  return local_c;\n}\n\n",
        "output": "The predicted function name is dasync_ciphers"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  if (DAT_00205338 == 0) {\n    DAT_00205338 = ERR_get_next_error_library();\n  }\n  if (DAT_0020533c == 0) {\n    ERR_load_strings(DAT_00205338,(ERR_STRING_DATA *)&DAT_00205300);\n    DAT_0020533c = 1;\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is ERR_load_DASYNC_strings"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined4 param_2,undefined8 param_3,undefined4 param_4)\n\n{\n  if (DAT_00205338 == 0) {\n    DAT_00205338 = ERR_get_next_error_library();\n  }\n  ERR_new();\n  ERR_set_debug(\"engines/e_dasync_err.c\",0x36,\"ERR_DASYNC_error\");\n  ERR_set_error(DAT_00205338,param_2,0);\n  ERR_set_debug(param_3,param_4,0);\n  return;\n}\n\n",
        "output": "The predicted function name is ERR_DASYNC_error"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 *param_2,undefined8 *param_3,int param_4)\n\n{\n  undefined8 uVar1;\n  \n  if (param_2 == (undefined8 *)0x0) {\n    *param_3 = &DAT_00003d64;\n    uVar1 = 1;\n  }\n  else if (param_4 == 6) {\n    *param_2 = DAT_00205348;\n    uVar1 = 1;\n  }\n  else {\n    *param_2 = 0;\n    uVar1 = 0;\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is dasync_pkey"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined4 param_2,undefined4 param_3,undefined8 param_4)\n\n{\n  if (DAT_002053c8 == (code *)0x0) {\n    EVP_PKEY_meth_get_ctrl(DAT_00205350,&DAT_002053c8,0);\n  }\n  (*DAT_002053c8)(param_1,param_2,param_3,param_4);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_rsa_ctrl"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (DAT_00205398 == (code *)0x0) {\n    EVP_PKEY_meth_get_keygen(DAT_00205350,&DAT_00205398,0);\n  }\n  if (DAT_00205398 == (code *)0x0) {\n    uVar1 = 1;\n  }\n  else {\n    uVar1 = (*DAT_00205398)(param_1);\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is dasync_rsa_keygen_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  EVP_MD *pEVar1;\n  code *pcVar2;\n  \n  FUN_00002e1a();\n  pEVar1 = EVP_sha1();\n  pcVar2 = (code *)EVP_MD_meth_get_update(pEVar1);\n  (*pcVar2)(param_1,param_2,param_3);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_sha1_update"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  if (DAT_00205380 == (code *)0x0) {\n    EVP_PKEY_meth_get_cleanup(DAT_00205350,&DAT_00205380);\n  }\n  (*DAT_00205380)(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_rsa_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  undefined8 uVar1;\n  \n  if (DAT_00205390 == (code *)0x0) {\n    EVP_PKEY_meth_get_paramgen(DAT_00205350,0,&DAT_00205390);\n  }\n  if (DAT_00205390 == (code *)0x0) {\n    uVar1 = 1;\n  }\n  else {\n    uVar1 = (*DAT_00205390)(param_1,param_2);\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is dasync_rsa_paramgen"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  DAT_00205348 = 0;\n  DAT_00205350 = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is destroy_pkey"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined4 param_2,undefined4 param_3,undefined8 param_4)\n\n{\n  EVP_CIPHER *pEVar1;\n  \n  pEVar1 = EVP_aes_128_cbc();\n  FUN_00003068(param_1,param_2,param_3,param_4,0,pEVar1);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_aes128_cbc_ctrl"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  FUN_0000249a();\n  FUN_00002571();\n  FUN_00002aa1();\n  FUN_000023e2();\n  return 1;\n}\n\n",
        "output": "The predicted function name is dasync_destroy"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return 1;\n}\n\n",
        "output": "The predicted function name is dasync_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  EVP_CIPHER *pEVar1;\n  \n  pEVar1 = EVP_aes_128_cbc_hmac_sha1();\n  FUN_00003665(param_1,pEVar1);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_aes128_cbc_hmac_sha1_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (DAT_002053a8 == (code *)0x0) {\n    EVP_PKEY_meth_get_encrypt(DAT_00205350,&DAT_002053a8,0);\n  }\n  if (DAT_002053a8 == (code *)0x0) {\n    uVar1 = 1;\n  }\n  else {\n    uVar1 = (*DAT_002053a8)(param_1);\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is dasync_rsa_encrypt_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                 undefined8 param_5)\n\n{\n  if (DAT_002053c0 == (code *)0x0) {\n    EVP_PKEY_meth_get_encrypt(DAT_00205350,0,&DAT_002053c0);\n  }\n  (*DAT_002053c0)(param_1,param_2,param_3,param_4,param_5);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_rsa_decrypt"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](undefined8 *param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  long lVar3;\n  \n  if (DAT_00205368 == 0) {\n    lVar3 = FUN_0000248d();\n    iVar1 = DAT_0020536c;\n    if (lVar3 != 0) {\n      DAT_0020536c = DAT_0020536c + 1;\n      uVar2 = EVP_MD_get_type(lVar3);\n      *(undefined4 *)(&DAT_00205370 + (long)iVar1 * 4) = uVar2;\n    }\n    *(undefined4 *)(&DAT_00205370 + (long)DAT_0020536c * 4) = 0;\n    DAT_00205368 = 1;\n  }\n  *param_1 = &DAT_00205370;\n  return DAT_0020536c;\n}\n\n",
        "output": "The predicted function name is dasync_digest_nids"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  EVP_CIPHER *pEVar1;\n  \n  pEVar1 = EVP_aes_128_cbc();\n  FUN_0000344b(param_1,param_2,param_3,param_4,pEVar1);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_aes128_cbc_cipher"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  EVP_CIPHER *pEVar1;\n  \n  pEVar1 = EVP_aes_128_cbc_hmac_sha1();\n  FUN_0000344b(param_1,param_2,param_3,param_4,pEVar1);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_aes128_cbc_hmac_sha1_cipher"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return DAT_00205340;\n}\n\n",
        "output": "The predicted function name is dasync_sha1"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](undefined8 param_1,undefined4 param_2,int param_3,void *param_4,int param_5,\n                undefined8 param_6)\n\n{\n  int iVar1;\n  void **ppvVar2;\n  void *__dest;\n  EVP_CIPHER *pEVar3;\n  code *pcVar4;\n  uint local_30;\n  \n  ppvVar2 = (void **)EVP_CIPHER_CTX_get_cipher_data(param_1);\n  if (ppvVar2 == (void **)0x0) {\n    return 0;\n  }\n  switch(param_2) {\n  case 8:\n    iVar1 = EVP_CIPHER_impl_ctx_size(param_6);\n    __dest = CRYPTO_malloc(iVar1,\"engines/e_dasync.c\",599);\n    if (__dest == (void *)0x0) {\n      return -1;\n    }\n    memcpy(__dest,*ppvVar2,(long)iVar1);\n    *ppvVar2 = __dest;\n    break;\n  default:\n    return 0;\n  case 0x16:\n    if ((param_5 == 0) || (param_3 != 0xd)) {\n      return -1;\n    }\n    if (0x1f < *(uint *)(ppvVar2 + 0x39)) {\n      return -1;\n    }\n    memcpy((void *)((long)ppvVar2 + (ulong)*(uint *)(ppvVar2 + 0x39) * 0xd + 0x28),param_4,0xd);\n    *(int *)(ppvVar2 + 0x39) = *(int *)(ppvVar2 + 0x39) + 1;\n    local_30 = (uint)CONCAT11(*(undefined *)((long)param_4 + 0xb),\n                              *(undefined *)((long)param_4 + 0xc));\n    iVar1 = EVP_CIPHER_CTX_is_encrypting(param_1);\n    if (iVar1 != 0) {\n      if (0x301 < CONCAT11(*(undefined *)((long)param_4 + 9),*(undefined *)((long)param_4 + 10))) {\n        if (local_30 < 0x10) {\n          return 0;\n        }\n        local_30 = local_30 - 0x10;\n      }\n      return (local_30 + 0x24 & 0xfffffff0) - local_30;\n    }\n    return 0x14;\n  case 0x17:\n    if (param_5 == 0) {\n      return -1;\n    }\n    EVP_CIPHER_CTX_set_cipher_data(param_1,*ppvVar2);\n    pEVar3 = EVP_aes_128_cbc_hmac_sha1();\n    pcVar4 = (code *)EVP_CIPHER_meth_get_ctrl(pEVar3);\n    iVar1 = (*pcVar4)(param_1,param_2,param_3,param_4);\n    EVP_CIPHER_CTX_set_cipher_data(param_1,ppvVar2);\n    return iVar1;\n  case 0x22:\n    *(int *)(ppvVar2 + 1) = param_3;\n    ppvVar2[3] = param_4;\n    break;\n  case 0x23:\n    *(int *)(ppvVar2 + 1) = param_3;\n    ppvVar2[2] = param_4;\n    break;\n  case 0x24:\n    *(int *)(ppvVar2 + 1) = param_3;\n    ppvVar2[4] = param_4;\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is dasync_cipher_ctrl_helper"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  EVP_MD_meth_free(DAT_00205340);\n  DAT_00205340 = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is destroy_digests"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined4 param_4)\n\n{\n  EVP_CIPHER *pEVar1;\n  \n  pEVar1 = EVP_aes_128_cbc();\n  FUN_0000333c(param_1,param_2,param_3,param_4,pEVar1);\n  return;\n}\n\n",
        "output": "The predicted function name is dasync_aes128_init_key"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (DAT_002053b8 == (code *)0x0) {\n    EVP_PKEY_meth_get_decrypt(DAT_00205350,&DAT_002053b8,0);\n  }\n  if (DAT_002053b8 == (code *)0x0) {\n    uVar1 = 1;\n  }\n  else {\n    uVar1 = (*DAT_002053b8)(param_1);\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is dasync_rsa_decrypt_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  if (DAT_0020533c != 0) {\n    ERR_unload_strings(DAT_00205338,(ERR_STRING_DATA *)&DAT_00205300);\n    DAT_0020533c = 0;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is ERR_unload_DASYNC_strings"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return 1;\n}\n\n",
        "output": "The predicted function name is dasync_finish"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 *param_1,undefined8 *param_2)\n\n{\n  DAT_00204310 = DAT_00204310 + 1;\n  utf8_strcasecmp(*param_1,*param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is compare_entry"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 *param_2,undefined8 param_3)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  lVar1 = FUN_00001b00(*param_2);\n  if (lVar1 == 0) {\n    if (param_2[2] == 0) {\n      uVar2 = 0;\n    }\n    else {\n      uVar2 = FUN_00002fe2(param_1,param_2,param_3);\n    }\n  }\n  else {\n    uVar2 = FUN_00002f50(param_1,lVar1,param_3);\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is outline_match"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,undefined8 *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  int local_160;\n  int local_15c;\n  ulong local_148;\n  long local_140;\n  undefined *local_110;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  param_2[1] = 0;\n  *param_2 = param_2[1];\n  if (*(long *)(param_1 + 0x38) != 0) {\n    local_160 = 0;\n    uVar2 = FUN_00002b0e(param_1,*(undefined8 *)(param_1 + 0x38),0);\n    local_110 = &DAT_000036a1;\n    iVar1 = wordsplit(uVar2,&local_148,0x2004e44);\n    if (iVar1 != 0) {\n      uVar2 = gettext(\"outline_lang: not enough memory\");\n      dico_log(4,0,uVar2);\n      uVar2 = 1;\n      goto LAB_00002f32;\n    }\n    if (local_148 != 0) {\n      for (local_15c = 0; (ulong)(long)local_15c < local_148; local_15c = local_15c + 1) {\n        if (local_160 == 0) {\n          iVar1 = strcmp(*(char **)(local_140 + (long)local_15c * 8),\":\");\n          if (iVar1 != 0) goto LAB_00002e40;\n          local_160 = 1;\n          free(*(void **)(local_140 + (long)local_15c * 8));\n        }\n        else {\nLAB_00002e40:\n          if (param_2[local_160] == 0) {\n            uVar2 = dico_list_create();\n            param_2[local_160] = uVar2;\n          }\n          dico_list_append(param_2[local_160],*(undefined8 *)(local_140 + (long)local_15c * 8));\n        }\n      }\n    }\n    local_148 = 0;\n    wordsplit_free(&local_148);\n  }\n  uVar2 = 0;\nLAB_00002f32:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is outline_lang"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void **param_1)\n\n{\n  void *local_18;\n  \n  fclose((FILE *)param_1[1]);\n  free(*param_1);\n  free(param_1[5]);\n  free(param_1[6]);\n  free(param_1[7]);\n  free(param_1[8]);\n  for (local_18 = (void *)0x0; local_18 < param_1[2]; local_18 = (void *)((long)local_18 + 1)) {\n    free(*(void **)((long)local_18 * 0x30 + (long)param_1[3]));\n    if (param_1[4] != (void *)0x0) {\n      free(*(void **)((long)local_18 * 0x30 + (long)param_1[4]));\n    }\n  }\n  free(param_1[3]);\n  free(param_1[4]);\n  free(param_1);\n  return 0;\n}\n\n",
        "output": "The predicted function name is outline_free_db"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void *param_1)\n\n{\n  if (*(int *)((long)param_1 + 8) == 1) {\n    dico_list_destroy((long)param_1 + 0x20);\n  }\n  free(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is outline_free_result"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong * [MASK](long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long *plVar3;\n  long in_FS_OFFSET;\n  long local_60;\n  ulong local_58;\n  long local_50;\n  long local_48;\n  long *local_40;\n  undefined local_38 [40];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_50 = param_1;\n  local_60 = dico_list_create();\n  if (local_60 == 0) {\n    uVar2 = gettext(\"outline_match_all: not enough memory\");\n    dico_log(4,0,uVar2);\n    plVar3 = (long *)0x0;\n  }\n  else {\n    iVar1 = dico_key_init(local_38,param_2,param_3);\n    if (iVar1 == 0) {\n      for (local_58 = 0; local_58 < *(ulong *)(local_50 + 0x10); local_58 = local_58 + 1) {\n        iVar1 = dico_key_match(local_38,*(undefined8 *)\n                                         (local_58 * 0x30 + *(long *)(local_50 + 0x18)));\n        if (iVar1 != 0) {\n          dico_list_append(local_60,*(long *)(local_50 + 0x18) + local_58 * 0x30);\n        }\n      }\n      dico_key_deinit(local_38);\n      DAT_00204310 = *(long *)(local_50 + 0x10);\n      local_48 = dico_list_count(local_60);\n      if (local_48 == 0) {\n        dico_list_destroy(&local_60);\n        plVar3 = (long *)0x0;\n      }\n      else {\n        local_40 = (long *)malloc(0x28);\n        if (local_40 == (long *)0x0) {\n          plVar3 = (long *)0x0;\n        }\n        else {\n          *local_40 = local_50;\n          *(undefined4 *)(local_40 + 1) = 1;\n          local_40[2] = local_48;\n          local_40[4] = local_60;\n          local_40[3] = DAT_00204310;\n          plVar3 = local_40;\n        }\n      }\n    }\n    else {\n      uVar2 = gettext(\"outline_match_all: key initialization failed\");\n      dico_log(4,0,uVar2);\n      plVar3 = (long *)0x0;\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return plVar3;\n}\n\n",
        "output": "The predicted function name is outline_match_all"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](long param_1,char *param_2,int param_3,size_t *param_4)\n\n{\n  size_t sVar1;\n  ulong uVar2;\n  char *pcVar3;\n  int local_1c;\n  \n  do {\n    do {\n      pcVar3 = fgets(param_2,param_3,*(FILE **)(param_1 + 8));\n      if (pcVar3 == (char *)0x0) {\n        return 0;\n      }\n      sVar1 = strlen(param_2);\n      uVar2 = FUN_0000164a(param_2);\n    } while (uVar2 == 0);\n    for (local_1c = 0; (param_2[local_1c] == '*' && ((ulong)(long)local_1c < uVar2));\n        local_1c = local_1c + 1) {\n    }\n  } while (local_1c == 0);\n  *param_4 = sVar1;\n  return local_1c;\n}\n\n",
        "output": "The predicted function name is find_header"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nsize_t [MASK](char *param_1)\n\n{\n  ushort **ppuVar1;\n  size_t local_10;\n  \n  local_10 = strlen(param_1);\n  while( true ) {\n    if (local_10 == 0) {\n      return 0;\n    }\n    ppuVar1 = __ctype_b_loc();\n    if (((*ppuVar1)[param_1[local_10 - 1]] & 0x2000) == 0) break;\n    local_10 = local_10 - 1;\n    param_1[local_10] = '\\0';\n  }\n  return local_10;\n}\n\n",
        "output": "The predicted function name is trimws"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  uint local_c;\n  \n  for (local_c = 0; local_c < 3; local_c = local_c + 1) {\n    dico_strategy_add(&PTR_s_exact_002041a0 + (long)(int)local_c * 7);\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is outline_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](int param_1)\n\n{\n  undefined8 uVar1;\n  \n  if ((((param_1 == 0x20) || (param_1 == 9)) || (param_1 == 0xd)) || (param_1 == 0xc)) {\n    uVar1 = 1;\n  }\n  else {\n    uVar1 = 0;\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is isws"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x18);\n}\n\n",
        "output": "The predicted function name is outline_compare_count"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 * [MASK](undefined8 param_1,code *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  undefined8 *local_18;\n  \n  DAT_00204310 = 0;\n  local_18 = (undefined8 *)malloc(0x28);\n  if (local_18 == (undefined8 *)0x0) {\n    local_18 = (undefined8 *)0x0;\n  }\n  else {\n    *local_18 = param_1;\n    iVar1 = (*param_2)(param_1,param_3,local_18);\n    if (iVar1 == 0) {\n      local_18[3] = DAT_00204310;\n    }\n    else {\n      free(local_18);\n      local_18 = (undefined8 *)0x0;\n    }\n  }\n  return local_18;\n}\n\n",
        "output": "The predicted function name is outline_match0"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (*(long *)(param_1 + 0x28) == 0) {\n    uVar1 = 0;\n  }\n  else {\n    uVar1 = FUN_00002b0e(param_1,*(undefined8 *)(param_1 + 0x28),0);\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is outline_info"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar ** [MASK](undefined8 param_1,int param_2,long param_3)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  int *piVar4;\n  char *pcVar5;\n  char **ppcVar6;\n  long in_FS_OFFSET;\n  int local_60;\n  int local_5c;\n  long local_58;\n  undefined8 local_50;\n  char **local_48;\n  long local_40;\n  FILE *local_38;\n  char **local_30;\n  char *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 == 2) {\n    local_38 = fopen(*(char **)(param_3 + 8),\"r\");\n    if (local_38 == (FILE *)0x0) {\n      uVar2 = *(undefined8 *)(param_3 + 8);\n      uVar3 = gettext(\"cannot open file %s\");\n      piVar4 = __errno_location();\n      dico_log(4,*piVar4,uVar3,uVar2);\n      ppcVar6 = (char **)0x0;\n    }\n    else {\n      local_30 = (char **)malloc(0x48);\n      if (local_30 == (char **)0x0) {\n        dico_log(4,0,\"not enough memory\");\n        fclose(local_38);\n        ppcVar6 = (char **)0x0;\n      }\n      else {\n        memset(local_30,0,0x48);\n        pcVar5 = strdup(*(char **)(param_3 + 8));\n        *local_30 = pcVar5;\n        local_30[1] = (char *)local_38;\n        local_58 = dico_list_create();\n        if (local_58 == 0) {\n          dico_log(4,0,\"not enough memory\");\n          fclose(local_38);\n          free(local_30);\n          ppcVar6 = (char **)0x0;\n        }\n        else {\n          local_5c = 0;\nLAB_0000294f:\n          local_48 = (char **)FUN_0000191a(local_30,&local_60);\n          if (local_48 != (char **)0x0) {\n            if (local_5c != 0) goto code_r0x00002826;\n            goto LAB_00002872;\n          }\n          local_28 = (char *)dico_list_count(local_58);\n          local_30[2] = local_28;\n          pcVar5 = (char *)calloc((size_t)local_28,0x30);\n          local_30[3] = pcVar5;\n          if (local_30[3] == (char *)0x0) {\n            dico_log(4,0,\"not enough memory\");\n            FUN_00002562(local_30);\n            ppcVar6 = (char **)0x0;\n          }\n          else {\n            local_50 = dico_list_iterator(local_58);\n            local_40 = 0;\n            local_48 = (char **)dico_iterator_first(local_50);\n            while (local_48 != (char **)0x0) {\n              ppcVar6 = (char **)(local_30[3] + local_40 * 0x30);\n              pcVar5 = local_48[1];\n              *ppcVar6 = *local_48;\n              ppcVar6[1] = pcVar5;\n              pcVar5 = local_48[3];\n              ppcVar6[2] = local_48[2];\n              ppcVar6[3] = pcVar5;\n              pcVar5 = local_48[5];\n              ppcVar6[4] = local_48[4];\n              ppcVar6[5] = pcVar5;\n              free(local_48);\n              local_40 = local_40 + 1;\n              local_48 = (char **)dico_iterator_next(local_50);\n            }\n            dico_iterator_destroy(&local_50);\n            dico_list_destroy(&local_58);\n            qsort(local_30[3],(size_t)local_28,0x30,FUN_00001bd2);\n            ppcVar6 = local_30;\n          }\n        }\n      }\n    }\n  }\n  else {\n    uVar2 = gettext(\"outline_open: wrong number of arguments\");\n    dico_log(4,0,uVar2);\n    ppcVar6 = (char **)0x0;\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return ppcVar6;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\ncode_r0x00002826:\n  if (local_5c == 1) {\n    if (local_60 == 2) {\n      dico_list_append(local_58,local_48);\n    }\n    else {\n      if (local_60 == 1) {\n        local_5c = 0;\nLAB_00002872:\n        if (local_60 == 1) {\n          iVar1 = strcasecmp(*local_48,\"info\");\n          if (iVar1 == 0) {\n            local_30[5] = (char *)local_48;\n            goto LAB_0000294f;\n          }\n          iVar1 = strcasecmp(*local_48,\"description\");\n          if (iVar1 == 0) {\n            local_30[6] = (char *)local_48;\n            goto LAB_0000294f;\n          }\n          iVar1 = strcasecmp(*local_48,\"languages\");\n          if (iVar1 == 0) {\n            local_30[7] = (char *)local_48;\n            goto LAB_0000294f;\n          }\n          iVar1 = strcasecmp(*local_48,\"mime\");\n          if (iVar1 == 0) {\n            local_30[8] = (char *)local_48;\n            goto LAB_0000294f;\n          }\n          iVar1 = strcasecmp(*local_48,\"dictionary\");\n          if (iVar1 == 0) {\n            local_5c = 1;\n          }\n        }\n        free(local_48);\n        goto LAB_0000294f;\n      }\n      free(local_48);\n    }\n  }\n  goto LAB_0000294f;\n}\n\n",
        "output": "The predicted function name is outline_init_db"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 *param_1,long param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  char **ppcVar2;\n  size_t sVar3;\n  \n  iVar1 = *(int *)(param_1 + 1);\n  if (iVar1 == 1) {\n    ppcVar2 = (char **)dico_list_item(param_1[4],param_2);\n    sVar3 = strlen(*ppcVar2);\n    dico_stream_write(param_3,*ppcVar2,sVar3);\n  }\n  else if (iVar1 == 0) {\n    ppcVar2 = (char **)(param_2 * 0x30 + param_1[4]);\n    sVar3 = strlen(*ppcVar2);\n    dico_stream_write(param_3,*ppcVar2,sVar3);\n  }\n  else if (iVar1 == 2) {\n    FUN_000032d6(param_3,*param_1,param_2 * 0x30 + param_1[4]);\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is outline_output_result"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar * [MASK](long param_1)\n\n{\n  char *__s;\n  char *pcVar1;\n  \n  if (*(long *)(param_1 + 0x30) == 0) {\n    __s = (char *)0x0;\n  }\n  else {\n    __s = (char *)FUN_00002b0e(param_1,*(undefined8 *)(param_1 + 0x30),0);\n    pcVar1 = strchr(__s,10);\n    if (pcVar1 != (char *)0x0) {\n      *pcVar1 = '\\0';\n    }\n  }\n  return __s;\n}\n\n",
        "output": "The predicted function name is outline_descr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](long param_1,int *param_2)\n\n{\n  int iVar1;\n  ushort **ppuVar2;\n  undefined8 uVar3;\n  long lVar4;\n  long in_FS_OFFSET;\n  long local_b8;\n  char *local_b0;\n  undefined8 local_a8;\n  long local_a0;\n  char local_98 [136];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_0000170d(param_1,local_98,0x80,&local_b8);\n  if (iVar1 == 0) {\n    lVar4 = 0;\n  }\n  else {\n    *param_2 = iVar1;\n    for (local_b0 = local_98 + iVar1; *local_b0 != '\\0'; local_b0 = local_b0 + 1) {\n      ppuVar2 = __ctype_b_loc();\n      if (((*ppuVar2)[*local_b0] & 0x2000) == 0) break;\n    }\n    local_a8 = FUN_0000169c(local_b0);\n    local_a0 = FUN_0000184b(local_b0,local_a8);\n    if (local_a0 == 0) {\n      lVar4 = 0;\n    }\n    else {\n      uVar3 = FUN_000017bc(param_1,local_98,0x80);\n      *(undefined8 *)(local_a0 + 0x18) = uVar3;\n      FUN_0000170d(param_1,local_98,0x80,&local_b8);\n      fseek(*(FILE **)(param_1 + 8),-local_b8,1);\n      lVar4 = ftell(*(FILE **)(param_1 + 8));\n      *(long *)(local_a0 + 0x20) = lVar4 - *(long *)(local_a0 + 0x18);\n      lVar4 = local_a0;\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return lVar4;\n}\n\n",
        "output": "The predicted function name is read_entry"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 * [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  undefined8 *local_18;\n  \n  DAT_00204310 = 0;\n  local_18 = (undefined8 *)malloc(0x28);\n  if (local_18 == (undefined8 *)0x0) {\n    local_18 = (undefined8 *)0x0;\n  }\n  else {\n    *local_18 = param_1;\n    iVar1 = FUN_00001f25(param_1,param_2,local_18);\n    if (iVar1 == 0) {\n      *(undefined4 *)(local_18 + 1) = 2;\n      local_18[3] = DAT_00204310;\n    }\n    else {\n      free(local_18);\n      local_18 = (undefined8 *)0x0;\n    }\n  }\n  return local_18;\n}\n\n",
        "output": "The predicted function name is outline_define"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid ** [MASK](void *param_1,void *param_2)\n\n{\n  void **__s;\n  void *pvVar1;\n  \n  __s = (void **)malloc(0x30);\n  if (__s != (void **)0x0) {\n    memset(__s,0,0x30);\n    pvVar1 = malloc((long)param_2 + 1);\n    *__s = pvVar1;\n    if (*__s == (void *)0x0) {\n      free(__s);\n      __s = (void **)0x0;\n    }\n    else {\n      memcpy(*__s,param_1,(size_t)param_2);\n      *(undefined *)((long)param_2 + (long)*__s) = 0;\n      __s[1] = param_2;\n      pvVar1 = (void *)utf8_strlen(*__s);\n      __s[2] = pvVar1;\n    }\n  }\n  return __s;\n}\n\n",
        "output": "The predicted function name is alloc_entry"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (*(long *)(param_1 + 0x40) == 0) {\n    uVar1 = 0;\n  }\n  else {\n    uVar1 = FUN_00002b0e(param_1,*(undefined8 *)(param_1 + 0x40),1);\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is outline_db_mime_header"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x10);\n}\n\n",
        "output": "The predicted function name is outline_result_count"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  dico_list_count(*(undefined8 *)(param_1 + 0x20));\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_result_count"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void *param_1)\n\n{\n  free(*(void **)((long)param_1 + 0x30));\n  free(param_1);\n  return 0;\n}\n\n",
        "output": "The predicted function name is free_ref"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  if (param_1 != 0) {\n    close(*(int *)(param_1 + 8));\n    FUN_0000b454(param_1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_idx_file_close"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return *(undefined8 *)PTR_gcide_markup_yyin_00212fc0;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyget_in"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong [MASK](long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  ulong uVar2;\n  long *plVar3;\n  ulong local_28;\n  ulong local_20;\n  \n  local_28 = 0;\n  uVar2 = *(ulong *)(param_1 + 0x28);\n  while( true ) {\n    do {\n      local_20 = uVar2;\n      if (local_20 <= local_28) {\n        return 0xffffffffffffffff;\n      }\n      uVar2 = local_20 + local_28 >> 1;\n      plVar3 = (long *)_idx_get_page(param_1,uVar2);\n      if (plVar3 == (long *)0x0) {\n        return 0xffffffffffffffff;\n      }\n      iVar1 = FUN_0000bf2c(param_1,param_2,plVar3 + 7,param_3);\n    } while (iVar1 < 0);\n    if (iVar1 == 0) {\n      return uVar2;\n    }\n    iVar1 = FUN_0000bf2c(param_1,param_2,plVar3 + (*plVar3 + -1) * 7 + 7,param_3);\n    if (iVar1 < 1) break;\n    local_28 = uVar2 + 1;\n    uVar2 = local_20;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is _idx_page_locate"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  FUN_000091ea(param_1);\n  return 0;\n}\n\n",
        "output": "The predicted function name is gcide_free_db"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 * [MASK](long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined8 uVar3;\n  long lVar4;\n  int *piVar5;\n  long in_FS_OFFSET;\n  undefined8 local_48;\n  long local_40;\n  undefined auStack56 [40];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_40 = FUN_0000a3c8(1);\n  if (local_40 == 0) {\n    puVar2 = (undefined4 *)0x0;\n  }\n  else {\n    iVar1 = dico_key_init(auStack56,param_2,param_3);\n    if (iVar1 == 0) {\n      local_48 = param_2;\n      gcide_idx_enumerate(*(undefined8 *)(param_1 + 0x50),FUN_0000a5a7,&local_48);\n      dico_key_deinit(auStack56);\n      lVar4 = dico_list_count(local_40);\n      if (lVar4 == 0) {\n        dico_list_destroy(&local_40);\n        puVar2 = (undefined4 *)0x0;\n      }\n      else {\n        puVar2 = (undefined4 *)calloc(1,0x28);\n        if (puVar2 == (undefined4 *)0x0) {\n          piVar5 = __errno_location();\n          dico_log(4,*piVar5,\"%s:%d:%s\",\"gcide.c\",0x217,\"gcide_match_all\");\n          dico_list_destroy(&local_40);\n        }\n        else {\n          *puVar2 = 0;\n          *(long *)(puVar2 + 2) = param_1;\n          *(long *)(puVar2 + 8) = local_40;\n          uVar3 = gcide_idx_defs(*(undefined8 *)(param_1 + 0x50));\n          *(undefined8 *)(puVar2 + 4) = uVar3;\n        }\n      }\n    }\n    else {\n      uVar3 = gettext(\"%s: key initialization failed\");\n      dico_log(4,0,uVar3,\"gcide_match_all\");\n      dico_list_destroy(&local_40);\n      puVar2 = (undefined4 *)0x0;\n    }\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return puVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is gcide_match_all"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  if (param_1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    if (*(long *)(param_1 + 0x48) == 0) {\n      do {\n        iVar1 = gcide_iterator_next(param_1);\n      } while (iVar1 == 0);\n      gcide_iterator_rewind(param_1);\n    }\n    uVar2 = *(undefined8 *)(param_1 + 0x48);\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is gcide_iterator_count"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,undefined param_2)\n\n{\n  **(undefined **)(param_1 + 0x18) = param_2;\n  return *(undefined8 *)(param_1 + 0x10);\n}\n\n",
        "output": "The predicted function name is gcide_template_name"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](char *param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  long in_FS_OFFSET;\n  undefined local_b8 [24];\n  uint local_a0;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_0000f6f0(param_1,local_b8);\n  if (iVar1 == 0) {\n    if ((local_a0 & 0xf000) == 0x4000) {\n      iVar1 = access(param_1,4);\n      if (iVar1 == 0) {\n        uVar2 = 0;\n      }\n      else {\n        uVar2 = gettext(\"gcide: `%s\\' is not readable\");\n        dico_log(4,0,uVar2,param_1);\n        uVar2 = 1;\n      }\n    }\n    else {\n      uVar2 = gettext(\"gcide: `%s\\' is not a directory\");\n      dico_log(4,0,uVar2,param_1);\n      uVar2 = 1;\n    }\n  }\n  else {\n    uVar2 = gettext(\"gcide: cannot stat `%s\\'\");\n    piVar3 = __errno_location();\n    dico_log(4,*piVar3,uVar2,param_1);\n    uVar2 = 1;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is gcide_check_dir"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  long lVar1;\n  \n  if (param_1 != 0) {\n    if (DAT_00215a00 == 0) {\n      lVar1 = 0;\n    }\n    else {\n      lVar1 = *(long *)(DAT_00215a00 + DAT_002159f0 * 8);\n    }\n    if (lVar1 == param_1) {\n      *(undefined8 *)(DAT_00215a00 + DAT_002159f0 * 8) = 0;\n    }\n    if (*(int *)(param_1 + 0x28) != 0) {\n      gcide_markup_yyfree(*(undefined8 *)(param_1 + 8));\n    }\n    gcide_markup_yyfree(param_1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yy_delete_buffer"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nint [MASK](long param_1)\n\n{\n  void *__ptr;\n  undefined8 uVar1;\n  int local_14;\n  \n  __ptr = (void *)dico_full_file_name(*(undefined8 *)(param_1 + 8),\"GCIDE.IDX\");\n  if (__ptr == (void *)0x0) {\n    dico_log(4,0xc,\"%s:%d:%s\",\"gcide.c\",0xcd,\"gcide_open_idx\");\n    local_14 = 1;\n  }\n  else {\n    local_14 = FUN_0000978f(param_1,__ptr);\n    if (local_14 == 1) {\n      local_14 = FUN_000093d5(__ptr,param_1);\n    }\n    if (local_14 == 0) {\n      uVar1 = gcide_idx_file_open(__ptr,*(undefined8 *)(param_1 + 0x48));\n      *(undefined8 *)(param_1 + 0x50) = uVar1;\n      if (*(long *)(param_1 + 0x50) == 0) {\n        local_14 = 1;\n      }\n    }\n    free(__ptr);\n  }\n  return local_14;\n}\n\n",
        "output": "The predicted function name is gcide_open_idx"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void *param_1)\n\n{\n  long lVar1;\n  void *__ptr;\n  \n  if (*(int *)(DAT_00215a78 + 0x10) == 1) {\n    __ptr = calloc(1,0x28);\n    if (__ptr == (void *)0x0) {\n      FUN_0000c95a(\"append_tag\");\n    }\n    *(undefined4 *)((long)__ptr + 0x10) = 1;\n    *(undefined8 *)((long)__ptr + 0x20) = *(undefined8 *)(DAT_00215a78 + 0x20);\n    lVar1 = dico_list_create();\n    if (lVar1 == 0) {\n      free(__ptr);\n      free(param_1);\n      FUN_0000c95a(\"append_tag\");\n    }\n    dico_list_set_free_item(lVar1,FUN_0000cc1e,0);\n    dico_list_append(lVar1,__ptr);\n    *(undefined4 *)(DAT_00215a78 + 0x10) = 2;\n    *(long *)(DAT_00215a78 + 0x20) = lVar1;\n  }\n  else if (*(int *)(DAT_00215a78 + 0x10) == 0) {\n    lVar1 = dico_list_create();\n    if (lVar1 == 0) {\n      free(param_1);\n      FUN_0000c95a(\"append_tag\");\n    }\n    dico_list_set_free_item(lVar1,FUN_0000cc1e,0);\n    *(undefined4 *)(DAT_00215a78 + 0x10) = 2;\n    *(long *)(DAT_00215a78 + 0x20) = lVar1;\n  }\n  dico_list_append(*(undefined8 *)(DAT_00215a78 + 0x20),param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is append_tag"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong [MASK](undefined8 param_1,ulong *param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  int iVar1;\n  ulong uVar2;\n  ulong local_20;\n  ulong local_18;\n  \n  local_20 = 0;\n  uVar2 = *param_2;\n  while( true ) {\n    do {\n      local_18 = uVar2;\n      if (local_18 <= local_20) {\n        return 0xffffffffffffffff;\n      }\n      uVar2 = local_18 + local_20 >> 1;\n      iVar1 = FUN_0000bf2c(param_1,param_3,param_2 + uVar2 * 7 + 7,param_4);\n    } while (iVar1 < 0);\n    if (iVar1 < 1) break;\n    local_20 = uVar2 + 1;\n    uVar2 = local_18;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is _idx_ref_locate"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,long param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = dico_key_match(param_2 + 0x10,*(undefined8 *)(param_1 + 0x30));\n  if ((iVar1 != 0) && (iVar1 = FUN_0000a46a(*(undefined8 *)(param_2 + 8),param_1), iVar1 != 0)) {\n    return 1;\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is match_key"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = DAT_00215a68;\n  FUN_0000ca59(0);\n  DAT_00215a68 = DAT_00215a60;\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is text_segment_finish"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 * [MASK](undefined8 param_1,ulong param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined8 *puVar4;\n  long in_FS_OFFSET;\n  undefined8 local_148;\n  undefined8 local_140;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = wordsplit_len(param_1,param_2,&local_148,0xe44);\n  if (iVar1 != 0) {\n    uVar2 = wordsplit_strerror(&local_148);\n    uVar3 = gettext(\"cannot parse line %.*s: %s\");\n    dico_log(4,0,uVar3,param_2 & 0xffffffff,param_1,uVar2);\n                    /* WARNING: Subroutine does not return */\n    longjmp((__jmp_buf_tag *)&DAT_00215a80,1);\n  }\n  puVar4 = (undefined8 *)calloc(1,0x28);\n  if (puVar4 == (undefined8 *)0x0) {\n    FUN_0000c95a(\"gcide alloc_tag\");\n  }\n  else {\n    *puVar4 = local_148;\n    puVar4[1] = local_140;\n    local_148 = 0;\n    local_140 = 0;\n  }\n  wordsplit_free(&local_148);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar4;\n}\n\n",
        "output": "The predicted function name is alloc_tag"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  DAT_00215a10 = *(undefined8 *)(*(long *)(DAT_00215a00 + DAT_002159f0 * 8) + 0x20);\n  DAT_00215a18 = *(undefined **)(*(long *)(DAT_00215a00 + DAT_002159f0 * 8) + 0x10);\n  *(undefined **)PTR_gcide_markup_yytext_00212f90 = DAT_00215a18;\n  *(undefined8 *)PTR_gcide_markup_yyin_00212fc0 = **(undefined8 **)(DAT_00215a00 + DAT_002159f0 * 8)\n  ;\n  DAT_00215a08 = *DAT_00215a18;\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yy_load_buffer_state"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  *(undefined8 *)PTR_gcide_markup_yyout_00212fd8 = param_1;\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyset_out"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (*(long *)(param_1 + 0x18) == 0) {\n    uVar1 = dico_list_iterator(*(undefined8 *)(param_1 + 0x20));\n    *(undefined8 *)(param_1 + 0x18) = uVar1;\n    if (*(long *)(param_1 + 0x18) == 0) {\n      uVar1 = 0;\n    }\n    else {\n      uVar1 = dico_iterator_first(*(undefined8 *)(param_1 + 0x18));\n    }\n  }\n  else {\n    uVar1 = dico_iterator_next(*(undefined8 *)(param_1 + 0x18));\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is gcide_result_ref"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](FILE **param_1,FILE *param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  FILE **ppFVar4;\n  undefined4 uVar5;\n  \n  piVar3 = __errno_location();\n  iVar1 = *piVar3;\n  gcide_markup_yy_flush_buffer(param_1);\n  *param_1 = param_2;\n  *(undefined4 *)((long)param_1 + 0x3c) = 1;\n  if (DAT_00215a00 == 0) {\n    ppFVar4 = (FILE **)0x0;\n  }\n  else {\n    ppFVar4 = *(FILE ***)(DAT_00215a00 + DAT_002159f0 * 8);\n  }\n  if (ppFVar4 != param_1) {\n    *(undefined4 *)((long)param_1 + 0x34) = 1;\n    *(undefined4 *)(param_1 + 7) = 0;\n  }\n  if (param_2 != (FILE *)0x0) {\n    iVar2 = fileno(param_2);\n    iVar2 = isatty(iVar2);\n    if (0 < iVar2) {\n      uVar5 = 1;\n      goto LAB_0000e78a;\n    }\n  }\n  uVar5 = 0;\nLAB_0000e78a:\n  *(undefined4 *)((long)param_1 + 0x2c) = uVar5;\n  piVar3 = __errno_location();\n  *piVar3 = iVar1;\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yy_init_buffer"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 *param_2)\n\n{\n  int iVar1;\n  __pid_t _Var2;\n  uint uVar3;\n  undefined8 uVar4;\n  int *piVar5;\n  long in_FS_OFFSET;\n  uint local_30;\n  __pid_t local_2c;\n  char *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_28 = PTR_s__home_xin_Downloads_gnu_projects_002133a0;\n  if (param_2[4] != 0) {\n    local_28 = (char *)param_2[4];\n  }\n  uVar4 = gettext(\"gcide_open_idx: creating index %s\");\n  dico_log(2,0,uVar4,param_1);\n  iVar1 = access(local_28,1);\n  if (iVar1 == 0) {\n    local_2c = fork();\n    if (local_2c == 0) {\n      execl(local_28,local_28,*param_2,param_2[1],0);\n    }\n    if (local_2c == -1) {\n      uVar4 = gettext(\"gcide_open_idx: fork failed\");\n      piVar5 = __errno_location();\n      dico_log(4,*piVar5,uVar4);\n      uVar4 = 1;\n    }\n    else {\n      _Var2 = waitpid(local_2c,(int *)&local_30,0);\n      if (local_2c == _Var2) {\n        if ((local_30 & 0x7f) == 0) {\n          uVar3 = (int)local_30 >> 8 & 0xff;\n          local_30 = uVar3;\n          if (uVar3 == 0) {\n            uVar4 = 0;\n          }\n          else {\n            uVar4 = gettext(\"gcide_open_idx: %s exited with status %d\");\n            dico_log(4,0,uVar4,local_28,uVar3);\n            uVar4 = 1;\n          }\n        }\n        else {\n          uVar4 = gettext(\"gcide_open_idx: %s failed\");\n          dico_log(4,0,uVar4,local_28);\n          uVar4 = 1;\n        }\n      }\n      else {\n        uVar4 = gettext(\"gcide_open_idx: %s failed\");\n        piVar5 = __errno_location();\n        dico_log(4,*piVar5,uVar4,local_28);\n        kill(local_2c,9);\n        uVar4 = 1;\n      }\n    }\n  }\n  else {\n    uVar4 = gettext(\"gcide_open_idx: cannot run %s\");\n    piVar5 = __errno_location();\n    dico_log(4,*piVar5,uVar4,local_28);\n    uVar4 = 1;\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is run_idxgcide"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  return *(undefined4 *)PTR_gcide_markup_yylineno_00212fc8;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyget_lineno"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 *param_1,void *param_2,size_t param_3)\n\n{\n  undefined8 uVar1;\n  ssize_t sVar2;\n  int *piVar3;\n  undefined8 uVar4;\n  size_t local_40;\n  void *local_28;\n  \n  local_40 = param_3;\n  local_28 = param_2;\n  do {\n    while( true ) {\n      if (local_40 == 0) {\n        return 0;\n      }\n      sVar2 = read(*(int *)(param_1 + 1),local_28,local_40);\n      if (sVar2 == -1) break;\n      if (sVar2 == 0) {\n        uVar1 = *param_1;\n        uVar4 = gettext(\"short read while reading from `%s\\'\");\n        piVar3 = __errno_location();\n        dico_log(4,*piVar3,uVar4,uVar1);\n        return 0xffffffff;\n      }\n      local_28 = (void *)((long)local_28 + sVar2);\n      local_40 = local_40 - sVar2;\n    }\n    piVar3 = __errno_location();\n  } while (*piVar3 == 0xb);\n  uVar1 = *param_1;\n  uVar4 = gettext(\"error reading from `%s\\'\");\n  piVar3 = __errno_location();\n  dico_log(4,*piVar3,uVar4,uVar1);\n  return 0xffffffff;\n}\n\n",
        "output": "The predicted function name is _idx_full_read"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 *param_1)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  \n  if (param_1 == (undefined8 *)0x0) {\n    uVar1 = 0xffffffff;\n  }\n  else {\n    param_1[5] = param_1[3];\n    param_1[6] = param_1[4];\n    param_1[10] = 0;\n    puVar2 = (undefined8 *)_idx_get_page(*param_1,param_1[5]);\n    if (puVar2 == (undefined8 *)0x0) {\n      uVar1 = 0xffffffff;\n    }\n    else {\n      param_1[7] = *puVar2;\n      uVar1 = 0;\n    }\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is gcide_iterator_rewind"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  dico_log(4,0xc,&DAT_000107ae,param_1);\n                    /* WARNING: Subroutine does not return */\n  longjmp((__jmp_buf_tag *)&DAT_00215a80,1);\n}\n\n",
        "output": "The predicted function name is memerr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong * [MASK](long param_1,char *param_2,size_t param_3)\n\n{\n  int iVar1;\n  long *__ptr;\n  int *piVar2;\n  void *pvVar3;\n  char *pcVar4;\n  long local_28;\n  long local_20;\n  long *local_18;\n  \n  *(undefined8 *)(param_1 + 0x58) = 0;\n  local_28 = FUN_0000c06d(param_1,param_2,param_3);\n  if (((local_28 == -1) ||\n      (local_18 = (long *)_idx_get_page(param_1,local_28), local_18 == (long *)0x0)) ||\n     (local_20 = FUN_0000bfaf(param_1,local_18,param_2,param_3), local_20 == -1)) {\n    return (long *)0x0;\n  }\n  while( true ) {\n    do {\n      if (local_20 != 0) {\n        iVar1 = FUN_0000bf2c(param_1,param_2,local_18 + (local_20 + -1) * 7 + 7,param_3);\n        if (0 < iVar1) goto LAB_0000c2cc;\n        local_20 = local_20 + -1;\n      }\n    } while (local_20 != 0);\n    if (local_28 == 0) break;\n    local_28 = local_28 + -1;\n    local_18 = (long *)_idx_get_page(param_1);\n    if (local_18 == (long *)0x0) {\n      return (long *)0x0;\n    }\n    local_20 = *local_18;\n  }\nLAB_0000c2cc:\n  if (local_20 == *local_18) {\n    local_28 = local_28 + 1;\n    local_20 = 0;\n  }\n  __ptr = (long *)malloc(0x70);\n  if (__ptr == (long *)0x0) {\n    piVar2 = __errno_location();\n    dico_log(4,*piVar2,\"%s:%d:%s\",\"idx.c\",0x19e,\"gcide_idx_locate\");\n    return (long *)0x0;\n  }\n  if (param_3 == 0) {\n    pcVar4 = strdup(param_2);\n    __ptr[1] = (long)pcVar4;\n  }\n  else {\n    pvVar3 = malloc(param_3);\n    __ptr[1] = (long)pvVar3;\n    if (__ptr[1] != 0) {\n      memcpy((void *)__ptr[1],param_2,param_3);\n    }\n  }\n  if (__ptr[1] != 0) {\n    __ptr[2] = param_3;\n    *__ptr = param_1;\n    __ptr[5] = local_28;\n    __ptr[3] = __ptr[5];\n    __ptr[6] = local_20;\n    __ptr[4] = __ptr[6];\n    __ptr[7] = *local_18;\n    __ptr[9] = 0;\n    __ptr[10] = __ptr[9];\n    __ptr[8] = *(long *)(param_1 + 0x58);\n    return __ptr;\n  }\n  piVar2 = __errno_location();\n  dico_log(4,*piVar2,\"%s:%d:%s\",\"idx.c\",0x1a9,\"gcide_idx_locate\");\n  free(__ptr);\n  return (long *)0x0;\n}\n\n",
        "output": "The predicted function name is gcide_idx_locate"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  dico_iterator_destroy(param_1 + 0x18);\n  dico_list_destroy(param_1 + 0x20);\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_free_result"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined param_1)\n\n{\n  long in_FS_OFFSET;\n  undefined local_11;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_11 = param_1;\n  FUN_0000c999(&local_11,1);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is text_add_chr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](undefined8 param_1,int param_2)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  lVar1 = gcide_markup_yyalloc(0x48);\n  if (lVar1 == 0) {\n    FUN_0000ed51(\"out of dynamic memory in yy_create_buffer()\");\n  }\n  *(long *)(lVar1 + 0x18) = (long)param_2;\n  uVar2 = gcide_markup_yyalloc(*(long *)(lVar1 + 0x18) + 2);\n  *(undefined8 *)(lVar1 + 8) = uVar2;\n  if (*(long *)(lVar1 + 8) == 0) {\n    FUN_0000ed51(\"out of dynamic memory in yy_create_buffer()\");\n  }\n  *(undefined4 *)(lVar1 + 0x28) = 1;\n  FUN_0000e6dd(lVar1,param_1);\n  return lVar1;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yy_create_buffer"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void *param_1,ulong param_2)\n\n{\n  size_t __size;\n  void *pvVar1;\n  \n  pvVar1 = DAT_00215a50;\n  __size = DAT_00215a58;\n  if (DAT_00215a58 - DAT_00215a60 < param_2) {\n    __size = DAT_00215a58 * 2;\n    pvVar1 = realloc(DAT_00215a50,__size);\n    if (pvVar1 == (void *)0x0) {\n      FUN_0000c95a(\"text_add\");\n    }\n  }\n  DAT_00215a58 = __size;\n  DAT_00215a50 = pvVar1;\n  memcpy((void *)((long)DAT_00215a50 + DAT_00215a60),param_1,param_2);\n  DAT_00215a60 = param_2 + DAT_00215a60;\n  return;\n}\n\n",
        "output": "The predicted function name is text_add_str"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x30);\n}\n\n",
        "output": "The predicted function name is gcide_idx_headwords"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined4 param_1)\n\n{\n  *(undefined4 *)PTR_gcide_markup_yy_flex_debug_00212fe0 = param_1;\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyset_debug"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  long lVar1;\n  \n  if (param_1 != 0) {\n    *(undefined8 *)(param_1 + 0x20) = 0;\n    **(undefined **)(param_1 + 8) = 0;\n    *(undefined *)(*(long *)(param_1 + 8) + 1) = 0;\n    *(undefined8 *)(param_1 + 0x10) = *(undefined8 *)(param_1 + 8);\n    *(undefined4 *)(param_1 + 0x30) = 1;\n    *(undefined4 *)(param_1 + 0x40) = 0;\n    if (DAT_00215a00 == 0) {\n      lVar1 = 0;\n    }\n    else {\n      lVar1 = *(long *)(DAT_00215a00 + DAT_002159f0 * 8);\n    }\n    if (lVar1 == param_1) {\n      FUN_0000e524();\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yy_flush_buffer"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,code *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  ulong *puVar2;\n  int local_1c;\n  ulong local_18;\n  \n  local_18 = 0;\n  while( true ) {\n    if (*(ulong *)(param_1 + 0x28) <= local_18) {\n      return 0;\n    }\n    puVar2 = (ulong *)_idx_get_page(param_1,local_18);\n    if (puVar2 == (ulong *)0x0) break;\n    local_1c = 0;\n    while (((ulong)(long)local_1c < *puVar2 &&\n           (iVar1 = (*param_2)(puVar2 + (long)local_1c * 7 + 7,param_3), iVar1 == 0))) {\n      local_1c = local_1c + 1;\n    }\n    local_18 = local_18 + 1;\n  }\n  return 0xffffffff;\n}\n\n",
        "output": "The predicted function name is gcide_idx_enumerate"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  undefined8 uVar1;\n  \n  while ((DAT_00215a00 != 0 && (*(long *)(DAT_00215a00 + DAT_002159f0 * 8) != 0))) {\n    if (DAT_00215a00 == 0) {\n      uVar1 = 0;\n    }\n    else {\n      uVar1 = *(undefined8 *)(DAT_00215a00 + DAT_002159f0 * 8);\n    }\n    gcide_markup_yy_delete_buffer(uVar1);\n    *(undefined8 *)(DAT_00215a00 + DAT_002159f0 * 8) = 0;\n    yypop_buffer_state();\n  }\n  gcide_markup_yyfree(DAT_00215a00);\n  DAT_00215a00 = 0;\n  FUN_0000ee45();\n  return 0;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yylex_destroy"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](undefined8 *param_1)\n\n{\n  long lVar1;\n  \n  if (param_1 == (undefined8 *)0x0) {\n    lVar1 = 0;\n  }\n  else {\n    lVar1 = _idx_get_page(*param_1,param_1[5]);\n    if (lVar1 == 0) {\n      lVar1 = 0;\n    }\n    else {\n      lVar1 = lVar1 + param_1[6] * 0x38 + 0x38;\n    }\n  }\n  return lVar1;\n}\n\n",
        "output": "The predicted function name is gcide_iterator_ref"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  FUN_0000a186(param_1,0);\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_info"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined * [MASK](char *param_1,ulong *param_2)\n\n{\n  undefined *puVar1;\n  int local_24;\n  undefined **local_20;\n  undefined **local_18;\n  ulong local_10;\n  \n  local_18 = (undefined **)0x0;\n  local_10 = 0;\n  if ((*param_1 == 's') && (param_1[1] == '\\0')) {\n    *param_2 = 1;\n    puVar1 = &DAT_000112b2;\n  }\n  else {\n    for (local_20 = &PTR_DAT_002146e0; *local_20 != (undefined *)0x0; local_20 = local_20 + 2) {\n      for (local_24 = 0; (param_1[local_24] != '\\0' && (param_1[local_24] == (*local_20)[local_24]))\n          ; local_24 = local_24 + 1) {\n      }\n      if ((*local_20)[local_24] == '\\0') {\n        if (local_10 < (ulong)(long)local_24) {\n          local_10 = (ulong)local_24;\n          local_18 = local_20;\n        }\n      }\n      else if ((local_10 != 0) && (local_24 == 0)) break;\n    }\n    if (local_10 == 0) {\n      puVar1 = (undefined *)0x0;\n    }\n    else {\n      *param_2 = local_10;\n      puVar1 = local_18[1];\n    }\n  }\n  return puVar1;\n}\n\n",
        "output": "The predicted function name is gcide_grk_to_utf8"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  long lVar1;\n  \n  FUN_0000ea24();\n  if (DAT_00215a00 == 0) {\n    lVar1 = 0;\n  }\n  else {\n    lVar1 = *(long *)(DAT_00215a00 + DAT_002159f0 * 8);\n  }\n  if (lVar1 != param_1) {\n    if ((DAT_00215a00 != 0) && (*(long *)(DAT_00215a00 + DAT_002159f0 * 8) != 0)) {\n      *DAT_00215a18 = DAT_00215a08;\n      *(undefined **)(*(long *)(DAT_00215a00 + DAT_002159f0 * 8) + 0x10) = DAT_00215a18;\n      *(undefined8 *)(*(long *)(DAT_00215a00 + DAT_002159f0 * 8) + 0x20) = DAT_00215a10;\n    }\n    *(long *)(DAT_002159f0 * 8 + DAT_00215a00) = param_1;\n    FUN_0000e524();\n    DAT_00215a28 = 1;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yy_switch_to_buffer"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 * [MASK](undefined8 param_1,undefined8 *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  code *pcVar2;\n  long lVar3;\n  int *piVar4;\n  undefined8 uVar5;\n  undefined4 *local_28;\n  \n  pcVar2 = (code *)FUN_0000a2cb(*param_2);\n  local_28 = (undefined4 *)0x0;\n  if (pcVar2 == (code *)0x0) {\n    local_28 = (undefined4 *)FUN_0000a607(param_1,param_2,param_3);\n  }\n  else {\n    lVar3 = (*pcVar2)(param_1,param_3);\n    if (lVar3 != 0) {\n      local_28 = (undefined4 *)calloc(1,0x28);\n      if (local_28 == (undefined4 *)0x0) {\n        piVar4 = __errno_location();\n        dico_log(4,*piVar4,\"%s:%d:%s\",\"gcide.c\",0x231,\"gcide_match\");\n        gcide_iterator_free(lVar3);\n        local_28 = (undefined4 *)0x0;\n      }\n      else {\n        *local_28 = 0;\n        *(undefined8 *)(local_28 + 2) = param_1;\n        uVar5 = FUN_0000a3c8(1);\n        *(undefined8 *)(local_28 + 8) = uVar5;\n        if (*(long *)(local_28 + 8) == 0) {\n          free(local_28);\n          gcide_iterator_free(lVar3);\n          local_28 = (undefined4 *)0x0;\n        }\n        else {\n          do {\n            uVar5 = gcide_iterator_ref(lVar3);\n            FUN_0000a46a(*(undefined8 *)(local_28 + 8),uVar5);\n            iVar1 = gcide_iterator_next(lVar3);\n          } while (iVar1 == 0);\n          uVar5 = gcide_iterator_compare_count(lVar3);\n          *(undefined8 *)(local_28 + 4) = uVar5;\n          gcide_iterator_free(lVar3);\n        }\n      }\n    }\n  }\n  return local_28;\n}\n\n",
        "output": "The predicted function name is gcide_match"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void *param_1)\n\n{\n  if (param_1 != (void *)0x0) {\n    free(*(void **)((long)param_1 + 8));\n    free(param_1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_iterator_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return *(undefined8 *)PTR_gcide_markup_yytext_00212f90;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyget_text"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  *(undefined8 *)PTR_gcide_markup_yyin_00212fc0 = param_1;\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyset_in"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  if (((param_1 != 0) && (1 < *(uint *)(param_1 + 0x10))) && (*(uint *)(param_1 + 0x10) == 2)) {\n    dico_list_destroy(param_1 + 0x20);\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is free_tag"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long *param_1)\n\n{\n  int iVar1;\n  \n  FUN_0000cc6f(param_1);\n  dico_list_append(DAT_00215a70,DAT_00215a78);\n  DAT_00215a78 = param_1;\n  if ((*param_1 != 0) && (iVar1 = strcmp(*(char **)param_1[1],\"grk\"), iVar1 == 0)) {\n    DAT_00215b58 = 1;\n    return;\n  }\n  DAT_00215b58 = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is push_tag"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  size_t sVar1;\n  long in_FS_OFFSET;\n  long local_30;\n  long local_20;\n  char *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = param_1;\n  while (*(char *)(local_30 + DAT_00215a50) != '\\0') {\n    local_18 = (char *)gcide_grk_to_utf8(DAT_00215a50 + local_30,&local_20);\n    if (local_18 == (char *)0x0) {\n      FUN_0000ca59((int)*(char *)(local_30 + DAT_00215a50));\n      local_30 = local_30 + 1;\n    }\n    else {\n      sVar1 = strlen(local_18);\n      FUN_0000c999(local_18,sVar1);\n      local_30 = local_30 + local_20;\n    }\n  }\n  FUN_0000caa1();\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is greek_translit"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nlong [MASK](int param_1)\n\n{\n  long lVar1;\n  int *piVar2;\n  \n  lVar1 = dico_list_create();\n  if (lVar1 == 0) {\n    piVar2 = __errno_location();\n    dico_log(4,*piVar2,\"%s:%d:%s\",\"gcide.c\",0x1ca,\"gcide_create_result_list\");\n    lVar1 = 0;\n  }\n  else {\n    if (param_1 != 0) {\n      dico_list_set_comparator(lVar1,FUN_0000a34c,0);\n      dico_list_set_flags(lVar1,2);\n    }\n    dico_list_set_free_item(lVar1,FUN_0000a38d,0);\n  }\n  return lVar1;\n}\n\n",
        "output": "The predicted function name is gcide_create_result_list"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return *(undefined8 *)PTR_gcide_markup_yyout_00212fd8;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyget_out"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](int param_1,long *param_2,undefined8 *param_3)\n\n{\n  int iVar1;\n  ushort **ppuVar2;\n  size_t sVar3;\n  char *local_18;\n  \n  iVar1 = *(int *)(param_2 + 2);\n  if (iVar1 == 1) {\n    if ((*(uint *)(param_3 + 1) & 0x1000) == 0) {\n      if ((*(uint *)(param_3 + 1) & 0x2000) == 0) {\n        sVar3 = strlen((char *)param_2[4]);\n        dico_stream_write(*param_3,param_2[4],sVar3);\n      }\n      else {\n        local_18 = (char *)param_2[4];\n        iVar1 = strncmp(local_18,\"as\",2);\n        if ((iVar1 == 0) &&\n           ((ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[local_18[3]] & 0x2000) != 0 ||\n            (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[local_18[3]] & 4) != 0)))) {\n          dico_stream_write(*param_3,local_18,3);\n          local_18 = local_18 + 3;\n          while ((*local_18 != '\\0' &&\n                 (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[*local_18] & 0x2000) != 0))) {\n            dico_stream_write(*param_3,local_18,1);\n            local_18 = local_18 + 1;\n          }\n          sVar3 = strlen(PTR_DAT_00213430);\n          dico_stream_write(*param_3,PTR_DAT_00213430,sVar3);\n          sVar3 = strlen(local_18);\n          dico_stream_write(*param_3,local_18,sVar3);\n        }\n        else {\n          sVar3 = strlen(PTR_DAT_00213430);\n          dico_stream_write(*param_3,PTR_DAT_00213430,sVar3);\n        }\n      }\n    }\n  }\n  else if (((iVar1 != 0) && (iVar1 == 2)) && (*param_2 != 0)) {\n    *(uint *)(param_3 + 1) = *(uint *)(param_3 + 1) & 0xffffdfff;\n    if (param_1 == 0) {\n      iVar1 = strcmp(*(char **)param_2[1],\"pr\");\n      if ((iVar1 == 0) && ((*(uint *)(param_3 + 1) & 1) != 0)) {\n        *(uint *)(param_3 + 1) = *(uint *)(param_3 + 1) | 0x1000;\n      }\n      else if ((*(uint *)(param_3 + 1) & 0x1000) == 0) {\n        iVar1 = strcmp(*(char **)param_2[1],\"sn\");\n        if (iVar1 == 0) {\n          dico_stream_write(*param_3,&DAT_0000faaa,1);\n        }\n        else {\n          iVar1 = strcmp(*(char **)param_2[1],\"as\");\n          if (iVar1 == 0) {\n            *(uint *)(param_3 + 1) = *(uint *)(param_3 + 1) | 0x2000;\n          }\n          else {\n            iVar1 = strcmp(*(char **)param_2[1],\"er\");\n            if (iVar1 == 0) {\n              sVar3 = strlen(PTR_DAT_00213440);\n              dico_stream_write(*param_3,PTR_DAT_00213440,sVar3);\n            }\n          }\n        }\n      }\n    }\n    else {\n      iVar1 = strcmp(*(char **)param_2[1],\"pr\");\n      if ((iVar1 == 0) && ((*(uint *)(param_3 + 1) & 1) != 0)) {\n        *(uint *)(param_3 + 1) = *(uint *)(param_3 + 1) & 0xffffefff;\n      }\n      else if ((*(uint *)(param_3 + 1) & 0x1000) == 0) {\n        iVar1 = strcmp(*(char **)param_2[1],\"as\");\n        if (iVar1 == 0) {\n          sVar3 = strlen(PTR_DAT_00213438);\n          dico_stream_write(*param_3,PTR_DAT_00213438,sVar3);\n        }\n        else {\n          iVar1 = strcmp(*(char **)param_2[1],\"er\");\n          if (iVar1 == 0) {\n            sVar3 = strlen(PTR_DAT_00213448);\n            dico_stream_write(*param_3,PTR_DAT_00213448,sVar3);\n          }\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is print_text"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void **param_1)\n\n{\n  free(*param_1);\n  FUN_0000cc1e(param_1[2],0);\n  free(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_parse_tree_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,long param_2)\n\n{\n  utf8_strcasecmp(*(undefined8 *)(param_1 + 0x30),*(undefined8 *)(param_2 + 0x30));\n  return;\n}\n\n",
        "output": "The predicted function name is compare_ref"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar ** [MASK](char *param_1,char *param_2)\n\n{\n  int iVar1;\n  char **__ptr;\n  int *piVar2;\n  char *pcVar3;\n  undefined8 uVar4;\n  \n  __ptr = (char **)calloc(1,0x60);\n  if (__ptr == (char **)0x0) {\n    piVar2 = __errno_location();\n    dico_log(4,*piVar2,\"%s:%d:%s\",\"idx.c\",0x75,\"gcide_idx_file_open\");\n    __ptr = (char **)0x0;\n  }\n  else {\n    pcVar3 = strdup(param_1);\n    *__ptr = pcVar3;\n    if (*__ptr == (char *)0x0) {\n      piVar2 = __errno_location();\n      dico_log(4,*piVar2,\"%s:%d:%s\",\"idx.c\",0x7a,\"gcide_idx_file_open\");\n      free(__ptr);\n      __ptr = (char **)0x0;\n    }\n    else {\n      iVar1 = open(param_1,0);\n      if (iVar1 == -1) {\n        uVar4 = gettext(\"cannot open index file `%s\\'\");\n        piVar2 = __errno_location();\n        dico_log(4,*piVar2,uVar4,param_1);\n        free(__ptr);\n      }\n      *(int *)(__ptr + 1) = iVar1;\n      iVar1 = FUN_0000b5ea(__ptr);\n      if (iVar1 == 0) {\n        __ptr[8] = param_2;\n      }\n      else {\n        FUN_0000b454(__ptr);\n        __ptr = (char **)0x0;\n      }\n    }\n  }\n  return __ptr;\n}\n\n",
        "output": "The predicted function name is gcide_idx_file_open"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,long param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = *(int *)(param_1 + 0x10);\n  if (iVar1 == 1) {\n    *(long *)(param_1 + 0x20) = *(long *)(param_1 + 0x20) + param_2;\n  }\n  else if ((iVar1 != 0) && (iVar1 == 2)) {\n    dico_list_iterate(*(undefined8 *)(param_1 + 0x20),FUN_0000f0b8,param_2);\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is tag_fixup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](long param_1,char *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  long in_FS_OFFSET;\n  undefined4 local_bc;\n  undefined local_b8 [88];\n  long local_60;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_bc = 1;\n  iVar1 = access(param_2,4);\n  if (iVar1 == 0) {\n    iVar1 = FUN_0000f6f0(param_2,local_b8);\n    if (iVar1 == 0) {\n      if (local_60 < *(long *)(param_1 + 0x30)) {\n        uVar2 = gettext(\"gcide: index file older than database, reindexing\");\n        dico_log(2,0,uVar2);\n      }\n      else {\n        local_bc = 0;\n      }\n    }\n    else {\n      uVar2 = gettext(\"gcide: can\\'t stat `%s\\'\");\n      piVar3 = __errno_location();\n      dico_log(4,*piVar3,uVar2,param_2);\n    }\n  }\n  else {\n    piVar3 = __errno_location();\n    if (*piVar3 != 2) {\n      uVar2 = gettext(\"gcide_open_idx: cannot access %s\");\n      piVar3 = __errno_location();\n      dico_log(4,*piVar3,uVar2,param_2);\n      local_bc = 0xffffffff;\n    }\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_bc;\n}\n\n",
        "output": "The predicted function name is gcide_access_idx"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,ulong param_2)\n\n{\n  undefined8 uVar1;\n  ulong local_18;\n  \n  local_18 = 0;\n  while( true ) {\n    if (*(ulong *)(param_1 + 0x48) <= local_18) {\n      return 0;\n    }\n    if (param_2 == **(ulong **)(*(long *)(param_1 + 0x50) + local_18 * 8)) break;\n    local_18 = local_18 + 1;\n  }\n  uVar1 = *(undefined8 *)(*(long *)(param_1 + 0x50) + local_18 * 8);\n  FUN_0000bb5f(param_1,param_2 & 0xffffffff);\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is _cache_find_page"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  uint local_c;\n  \n  for (local_c = 0; local_c < 2; local_c = local_c + 1) {\n    dico_strategy_add(&PTR_s_exact_002133c0 + (long)(int)local_c * 7);\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is gcide_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return *(undefined8 *)PTR_gcide_markup_yyleng_00212fd0;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyget_leng"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x10);\n}\n\n",
        "output": "The predicted function name is gcide_compare_count"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void **param_1)\n\n{\n  void *local_10;\n  \n  free(*param_1);\n  for (local_10 = (void *)0x0; local_10 < param_1[9]; local_10 = (void *)((long)local_10 + 1)) {\n    free(*(void **)(*(long *)((long)param_1[10] + (long)local_10 * 8) + 0x10));\n    free(*(void **)((long)param_1[10] + (long)local_10 * 8));\n  }\n  free(param_1[10]);\n  free(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is _free_index"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nchar ** [MASK](undefined8 param_1,undefined4 param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  char *pcVar4;\n  size_t sVar5;\n  char **ppcVar6;\n  long lVar7;\n  long in_FS_OFFSET;\n  undefined4 local_1a4;\n  char *local_1a0;\n  char *local_198;\n  char *local_190;\n  word *local_188;\n  char **local_180;\n  char *local_178 [2];\n  undefined4 local_168;\n  char **local_160;\n  char *local_148;\n  undefined8 local_140;\n  undefined4 local_138;\n  char **local_130;\n  char *local_118;\n  undefined8 local_110;\n  undefined4 local_108;\n  char **local_100;\n  char *local_e8;\n  undefined8 local_e0;\n  undefined4 local_d8;\n  word **local_d0;\n  char *local_b8;\n  undefined8 local_b0;\n  undefined4 local_a8;\n  undefined4 *local_a0;\n  undefined8 local_98;\n  char *local_88;\n  undefined8 local_80;\n  undefined4 local_78;\n  undefined4 *local_70;\n  undefined8 local_68;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_1a0 = (char *)0x0;\n  local_198 = (char *)0x0;\n  local_190 = (char *)0x0;\n  local_188 = &Elf64_Ehdr_00000000.e_type;\n  local_1a4 = 0;\n  ppcVar6 = local_178;\n  for (lVar7 = 0x2a; lVar7 != 0; lVar7 = lVar7 + -1) {\n    *ppcVar6 = (char *)0x0;\n    ppcVar6 = ppcVar6 + 1;\n  }\n  local_178[0] = \"dbdir\";\n  local_178[1] = \"\\x01\\x01\";\n  local_168 = 5;\n  local_160 = &local_1a0;\n  local_148 = \"idxdir\";\n  local_140 = 6;\n  local_138 = 5;\n  local_130 = &local_198;\n  local_118 = \"index-program\";\n  local_110 = 0xd;\n  local_108 = 5;\n  local_100 = &local_190;\n  local_e8 = \"index-cache-size\";\n  local_e0 = 0x10;\n  local_d8 = 4;\n  local_d0 = &local_188;\n  local_b8 = \"suppress-pr\";\n  local_b0 = 0xb;\n  local_a8 = 2;\n  local_a0 = &local_1a4;\n  local_98 = 1;\n  local_88 = \"debug-lex\";\n  local_80 = 9;\n  local_78 = 2;\n  local_70 = &local_1a4;\n  local_68 = 2;\n  iVar1 = dico_parseopt(local_178,param_2,param_3,0,0);\n  if (iVar1 == 0) {\n    if (local_1a0 == (char *)0x0) {\n      uVar2 = gettext(\"gcide_init_db: database directory not given\");\n      dico_log(4,0,uVar2);\n      ppcVar6 = (char **)0x0;\n    }\n    else if ((local_198 == (char *)0x0) && (local_198 = strdup(local_1a0), local_198 == (char *)0x0)\n            ) {\n      piVar3 = __errno_location();\n      dico_log(4,*piVar3,\"%s:%d:%s\",\"gcide.c\",0xff,\"gcide_init_db\");\n      free(local_1a0);\n      ppcVar6 = (char **)0x0;\n    }\n    else {\n      local_180 = (char **)calloc(1,0x58);\n      if (local_180 == (char **)0x0) {\n        piVar3 = __errno_location();\n        dico_log(4,*piVar3,\"%s:%d:%s\",\"gcide.c\",0x107,\"gcide_init_db\");\n        free(local_1a0);\n        free(local_198);\n        ppcVar6 = (char **)0x0;\n      }\n      else {\n        *local_180 = local_1a0;\n        local_180[1] = local_198;\n        local_180[9] = (char *)local_188;\n        *(undefined4 *)(local_180 + 5) = local_1a4;\n        iVar1 = FUN_00009281(*local_180);\n        if ((iVar1 == 0) && (iVar1 = FUN_00009281(local_180[1]), iVar1 == 0)) {\n          pcVar4 = (char *)dico_full_file_name(*local_180,\"CIDE.A\");\n          local_180[2] = pcVar4;\n          pcVar4 = local_180[2];\n          sVar5 = strlen(local_180[2]);\n          local_180[3] = pcVar4 + (sVar5 - 1);\n          iVar1 = FUN_0000960d(local_180);\n          if (iVar1 == 0) {\n            local_180[4] = local_190;\n            iVar1 = FUN_000098e7(local_180);\n            ppcVar6 = local_180;\n            if (iVar1 != 0) {\n              FUN_000091ea(local_180);\n              ppcVar6 = (char **)0x0;\n            }\n          }\n          else {\n            FUN_000091ea(local_180);\n            ppcVar6 = (char **)0x0;\n          }\n        }\n        else {\n          FUN_000091ea(local_180);\n          ppcVar6 = (char **)0x0;\n        }\n      }\n    }\n  }\n  else {\n    ppcVar6 = (char **)0x0;\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return ppcVar6;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is gcide_init_db"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return 1;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yywrap"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong * [MASK](undefined8 *param_1,long param_2)\n\n{\n  undefined8 uVar1;\n  int iVar2;\n  long lVar3;\n  __off_t _Var4;\n  undefined8 uVar5;\n  int *piVar6;\n  ulong *puVar7;\n  ulong local_48;\n  \n  lVar3 = FUN_0000bc4d(param_1,param_2);\n  if (lVar3 == 0) {\n    lVar3 = param_1[3] * (param_2 + 1);\n    _Var4 = lseek(*(int *)(param_1 + 1),lVar3,0);\n    if (lVar3 == _Var4) {\n      lVar3 = FUN_0000b93e(param_1);\n      if (lVar3 == 0) {\n        puVar7 = (ulong *)0x0;\n      }\n      else {\n        iVar2 = FUN_0000b4eb(param_1,*(undefined8 *)(lVar3 + 0x10),param_1[3]);\n        if (iVar2 == 0) {\n          *(int *)(lVar3 + 8) = *(int *)(lVar3 + 8) + 1;\n          puVar7 = *(ulong **)(lVar3 + 0x10);\n          for (local_48 = 0; local_48 < *puVar7; local_48 = local_48 + 1) {\n            puVar7[local_48 * 7 + 0xd] = puVar7[local_48 * 7 + 7] + (long)puVar7;\n          }\n        }\n        else {\n          puVar7 = (ulong *)0x0;\n        }\n      }\n    }\n    else {\n      uVar1 = *param_1;\n      uVar5 = gettext(\"seek error on `%s\\' while positioning to %lu\");\n      piVar6 = __errno_location();\n      dico_log(4,*piVar6,uVar5,uVar1,lVar3);\n      puVar7 = (ulong *)0x0;\n    }\n  }\n  else {\n    puVar7 = *(ulong **)(lVar3 + 0x10);\n  }\n  return puVar7;\n}\n\n",
        "output": "The predicted function name is _idx_get_page"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  long lVar1;\n  int iVar2;\n  char *__name;\n  int *piVar3;\n  undefined8 uVar4;\n  long in_FS_OFFSET;\n  int local_cc;\n  long local_c8;\n  long local_60;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  local_c8 = 0;\n  local_cc = 0;\n  do {\n    if (s_ABCDEFGHIJKLMNOPQRSTUVWXYZ_00213370[local_cc] == '\\0') {\n      *(long *)(param_1 + 0x30) = local_c8;\n      uVar4 = 0;\nLAB_00009771:\n      if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n      return uVar4;\n    }\n    __name = (char *)FUN_000093b3(param_1,(int)s_ABCDEFGHIJKLMNOPQRSTUVWXYZ_00213370[local_cc]);\n    iVar2 = access(__name,4);\n    if (iVar2 != 0) {\n      uVar4 = gettext(\"gcide: `%s\\' is not readable\");\n      dico_log(4,0,uVar4,__name);\n      uVar4 = 1;\n      goto LAB_00009771;\n    }\n    iVar2 = FUN_0000f6f0(__name);\n    if (iVar2 != 0) {\n      uVar4 = gettext(\"gcide: can\\'t stat `%s\\'\");\n      piVar3 = __errno_location();\n      dico_log(4,*piVar3,uVar4,__name);\n      uVar4 = 1;\n      goto LAB_00009771;\n    }\n    if (local_c8 < local_60) {\n      local_c8 = local_60;\n    }\n    local_cc = local_cc + 1;\n  } while( true );\n}\n\n",
        "output": "The predicted function name is gcide_check_files"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](void)\n\n{\n  return *(undefined4 *)PTR_gcide_markup_yy_flex_debug_00212fe0;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyget_debug"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid ** [MASK](undefined8 param_1,long param_2,undefined4 param_3)\n\n{\n  int iVar1;\n  void *pvVar2;\n  undefined8 uVar3;\n  void **ppvVar4;\n  \n  DAT_00215a4c = 0;\n  DAT_00215a48 = 0;\n  DAT_00215a38 = param_1;\n  DAT_00215a40 = param_2;\n  iVar1 = _setjmp((__jmp_buf_tag *)&DAT_00215a80);\n  if (iVar1 != 0) {\n    free(DAT_00215a50);\n    dico_list_destroy(&DAT_00215a70);\n    FUN_0000cc1e(DAT_00215a78,0);\n  }\n  DAT_00215a58 = (void *)(param_2 * 2);\n  DAT_00215a50 = malloc((size_t)DAT_00215a58);\n  if (DAT_00215a50 == (void *)0x0) {\n    FUN_0000c95a(\"gcide_markup_parse\");\n  }\n  DAT_00215a68 = 0;\n  DAT_00215a60 = 0;\n  DAT_00215a70 = dico_list_create();\n  if (DAT_00215a70 == 0) {\n    FUN_0000c95a(\"gcide_markup_parse\");\n  }\n  dico_list_set_free_item(DAT_00215a70,FUN_0000cc1e,0);\n  DAT_00215a78 = calloc(1,0x28);\n  if (DAT_00215a78 == (void *)0x0) {\n    FUN_0000c95a(\"gcide_markup_parse\");\n  }\n  *(undefined4 *)PTR_gcide_markup_yy_flex_debug_00212fe0 = param_3;\n  DAT_00215a24 = 1;\n  do {\n    iVar1 = gcide_markup_yylex();\n  } while (iVar1 != 0);\n  pvVar2 = DAT_00215a78;\n  if (DAT_00215a60 != DAT_00215a68) {\n    pvVar2 = calloc(1,0x28);\n    if (pvVar2 == (void *)0x0) {\n      FUN_0000c95a(\"gcide lexer\");\n    }\n    *(undefined4 *)((long)pvVar2 + 0x10) = 1;\n    uVar3 = FUN_0000caa1();\n    *(undefined8 *)((long)pvVar2 + 0x20) = uVar3;\n    FUN_0000cc6f(pvVar2);\n    pvVar2 = DAT_00215a78;\n  }\n  do {\n    DAT_00215a78 = pvVar2;\n    pvVar2 = (void *)dico_list_pop(DAT_00215a70);\n  } while (pvVar2 != (void *)0x0);\n  dico_list_destroy(&DAT_00215a70);\n  if (DAT_00215a78 == (void *)0x0) {\n    free(DAT_00215a50);\n    ppvVar4 = (void **)0x0;\n  }\n  else {\n    FUN_0000f1f4(DAT_00215a78,0);\n    ppvVar4 = (void **)malloc(0x18);\n    if (ppvVar4 == (void **)0x0) {\n      FUN_0000c95a(\"gcide_markup_parse\");\n    }\n    *ppvVar4 = DAT_00215a50;\n    ppvVar4[1] = DAT_00215a58;\n    ppvVar4[2] = DAT_00215a78;\n    FUN_0000f0b8(ppvVar4[2],DAT_00215a50);\n  }\n  return ppvVar4;\n}\n\n",
        "output": "The predicted function name is gcide_markup_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  \n  if ((DAT_00215a00 == 0) || (*(long *)(DAT_00215a00 + DAT_002159f0 * 8) == 0)) {\n    FUN_0000ea24();\n    puVar1 = (undefined8 *)(DAT_00215a00 + DAT_002159f0 * 8);\n    uVar2 = gcide_markup_yy_create_buffer(*(undefined8 *)PTR_gcide_markup_yyin_00212fc0,0x4000);\n    *puVar1 = uVar2;\n  }\n  if (DAT_00215a00 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = *(undefined8 *)(DAT_00215a00 + DAT_002159f0 * 8);\n  }\n  FUN_0000e6dd(uVar2,param_1);\n  FUN_0000e524();\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyrestart"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long *param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long *plVar3;\n  long local_20;\n  long local_18;\n  \n  if (param_1 == (long *)0x0) {\n    uVar2 = 0xffffffff;\n  }\n  else if ((param_1[9] == 0) || (param_1[10] != param_1[9] + -1)) {\n    if ((ulong)param_1[6] < param_1[7] - 1U) {\n      local_20 = param_1[5];\n      local_18 = param_1[6] + 1;\n    }\n    else {\n      if (param_1[5] == *(long *)(*param_1 + 0x28)) {\n        if (param_1[9] == 0) {\n          param_1[9] = param_1[10] + 1;\n        }\n        return 0xffffffff;\n      }\n      local_20 = param_1[5] + 1;\n      local_18 = 0;\n    }\n    plVar3 = (long *)_idx_get_page(*param_1,local_20);\n    if (plVar3 == (long *)0x0) {\n      uVar2 = 0xffffffff;\n    }\n    else {\n      if ((param_1[9] == 0) &&\n         (iVar1 = FUN_0000bf2c(*param_1,param_1[1],plVar3 + local_18 * 7 + 7,param_1[2]), iVar1 != 0\n         )) {\n        if (param_1[9] == 0) {\n          param_1[9] = param_1[10] + 1;\n        }\n        return 0xffffffff;\n      }\n      param_1[7] = *plVar3;\n      param_1[5] = local_20;\n      param_1[6] = local_18;\n      param_1[10] = param_1[10] + 1;\n      uVar2 = 0;\n    }\n  }\n  else {\n    uVar2 = 0xffffffff;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is gcide_iterator_next"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,undefined8 *param_2)\n\n{\n  int iVar1;\n  undefined8 *__ptr;\n  int *piVar2;\n  char *pcVar3;\n  undefined8 uVar4;\n  \n  __ptr = (undefined8 *)calloc(1,0x38);\n  if (__ptr != (undefined8 *)0x0) {\n    uVar4 = param_2[1];\n    *__ptr = *param_2;\n    __ptr[1] = uVar4;\n    uVar4 = param_2[3];\n    __ptr[2] = param_2[2];\n    __ptr[3] = uVar4;\n    uVar4 = param_2[5];\n    __ptr[4] = param_2[4];\n    __ptr[5] = uVar4;\n    __ptr[6] = param_2[6];\n    pcVar3 = strdup((char *)param_2[6]);\n    __ptr[6] = pcVar3;\n    if ((__ptr[6] == 0) ||\n       ((iVar1 = dico_list_append(param_1,__ptr), iVar1 != 0 &&\n        (piVar2 = __errno_location(), *piVar2 == 0xc)))) {\n      piVar2 = __errno_location();\n      dico_log(4,*piVar2,\"%s:%d:%s\",\"gcide.c\",0x1e1,\"gcide_result_list_append\");\n      free(__ptr);\n      uVar4 = 0xffffffff;\n    }\n    else {\n      uVar4 = 0;\n    }\n    return uVar4;\n  }\n  piVar2 = __errno_location();\n  dico_log(4,*piVar2,\"%s:%d:%s\",\"gcide.c\",0x1da,\"gcide_result_list_append\");\n  return 0xffffffff;\n}\n\n",
        "output": "The predicted function name is gcide_result_list_append"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 * [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  long lVar2;\n  int *piVar3;\n  undefined8 uVar4;\n  undefined4 *local_20;\n  \n  local_20 = (undefined4 *)0x0;\n  lVar2 = FUN_0000a214(param_1,param_2);\n  if (lVar2 != 0) {\n    local_20 = (undefined4 *)calloc(1,0x28);\n    if (local_20 == (undefined4 *)0x0) {\n      piVar3 = __errno_location();\n      dico_log(4,*piVar3,\"%s:%d:%s\",\"gcide.c\",0x253,\"gcide_define\");\n      gcide_iterator_free(lVar2);\n      local_20 = (undefined4 *)0x0;\n    }\n    else {\n      *local_20 = 1;\n      *(undefined8 *)(local_20 + 2) = param_1;\n      uVar4 = FUN_0000a3c8(0);\n      *(undefined8 *)(local_20 + 8) = uVar4;\n      if (*(long *)(local_20 + 8) == 0) {\n        free(local_20);\n        gcide_iterator_free(lVar2);\n        local_20 = (undefined4 *)0x0;\n      }\n      else {\n        do {\n          uVar4 = gcide_iterator_ref(lVar2);\n          FUN_0000a46a(*(undefined8 *)(local_20 + 8),uVar4);\n          iVar1 = gcide_iterator_next(lVar2);\n        } while (iVar1 == 0);\n        uVar4 = gcide_iterator_compare_count(lVar2);\n        *(undefined8 *)(local_20 + 4) = uVar4;\n        gcide_iterator_free(lVar2);\n      }\n    }\n  }\n  return local_20;\n}\n\n",
        "output": "The predicted function name is gcide_define"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](int *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  lVar1 = FUN_0000aaab(param_1);\n  if (lVar1 == 0) {\n    uVar2 = 1;\n  }\n  else {\n    if (*param_1 == 0) {\n      dico_stream_write(param_3,*(undefined8 *)(lVar1 + 0x30),*(long *)(lVar1 + 0x10) + -1);\n    }\n    else if (*param_1 == 1) {\n      uVar2 = FUN_0000af8d(param_3,*(undefined8 *)(param_1 + 2),lVar1);\n      return uVar2;\n    }\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is gcide_output_result"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,code **param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  iVar1 = (**param_2)(0,param_1,param_2[1]);\n  if (iVar1 == 0) {\n    if (*(int *)(param_1 + 0x10) == 2) {\n      dico_list_iterate(*(undefined8 *)(param_1 + 0x20),FUN_0000efba,param_2);\n      iVar1 = (**param_2)(1,param_1,param_2[1]);\n      if (iVar1 != 0) {\n        return 1;\n      }\n    }\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is inorder_helper"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](int param_1)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strchr(\"\\r\\n!,-./:;?\",param_1);\n  return pcVar1 != (char *)0x0;\n}\n\n",
        "output": "The predicted function name is _is_nl_or_punct"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,int param_2)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  int local_18;\n  \n  lVar1 = *(long *)(*(long *)(param_1 + 0x50) + (long)param_2 * 8);\n  *(int *)(lVar1 + 8) = *(int *)(lVar1 + 8) + 1;\n  if (param_2 != 0) {\n    local_18 = param_2 + -1;\n    while ((-1 < local_18 &&\n           (*(uint *)(*(long *)(*(long *)(param_1 + 0x50) + (long)local_18 * 8) + 8) <\n            *(uint *)(lVar1 + 8)))) {\n      local_18 = local_18 + -1;\n    }\n    local_18 = local_18 + 1;\n    if (local_18 != param_2) {\n      uVar2 = *(undefined8 *)(*(long *)(param_1 + 0x50) + (long)param_2 * 8);\n      *(undefined8 *)((long)param_2 * 8 + *(long *)(param_1 + 0x50)) =\n           *(undefined8 *)(*(long *)(param_1 + 0x50) + (long)local_18 * 8);\n      *(undefined8 *)((long)local_18 * 8 + *(long *)(param_1 + 0x50)) = uVar2;\n    }\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is _cache_promote"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined4 param_1)\n\n{\n  *(undefined4 *)PTR_gcide_markup_yylineno_00212fc8 = param_1;\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyset_lineno"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid * [MASK](undefined8 param_1,int param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  undefined8 uVar4;\n  void *pvVar5;\n  long in_FS_OFFSET;\n  long local_40;\n  void *local_38;\n  long local_30;\n  long local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = (void *)0x0;\n  local_30 = 0;\n  local_40 = dico_mapfile_stream_create(param_1,1);\n  if (local_40 == 0) {\n    uVar2 = gettext(\"cannot create stream `%s\\'\");\n    piVar3 = __errno_location();\n    dico_log(2,*piVar3,uVar2,param_1);\n    pvVar5 = (void *)0x0;\n  }\n  else {\n    iVar1 = dico_stream_open(local_40);\n    if (iVar1 == 0) {\n      if (param_2 == 0) {\n        iVar1 = dico_stream_size(local_40,&local_28);\n        if (iVar1 == 0) {\n          local_30 = local_28;\n          local_38 = malloc(local_28 + 1);\n          if (local_38 == (void *)0x0) {\n            uVar2 = gettext(\"cannot allocate dictionary information buffer\");\n            piVar3 = __errno_location();\n            dico_log(4,*piVar3,uVar2);\n          }\n          else {\n            iVar1 = dico_stream_read(local_40,local_38,local_30,0);\n            if (iVar1 == 0) {\n              *(undefined *)(local_30 + (long)local_38) = 0;\n            }\n            else {\n              uVar2 = dico_stream_strerror(local_40,iVar1);\n              uVar4 = gettext(\"read error in stream `%s\\': %s\");\n              dico_log(4,0,uVar4,param_1,uVar2);\n              free(local_38);\n              local_38 = (void *)0x0;\n            }\n          }\n        }\n        else {\n          uVar2 = dico_stream_strerror(local_40,iVar1);\n          uVar4 = gettext(\"cannot get size of stream `%s\\': %s\");\n          dico_log(4,0,uVar4,param_1,uVar2);\n        }\n      }\n      else {\n        iVar1 = dico_stream_getline(local_40,&local_38,&local_30,&local_28);\n        if (iVar1 == 0) {\n          dico_string_trim(local_38,local_28,FUN_00009e73);\n        }\n        else {\n          uVar2 = dico_stream_strerror(local_40,iVar1);\n          uVar4 = gettext(\"read error in stream `%s\\': %s\");\n          dico_log(4,0,uVar4,param_1,uVar2);\n        }\n      }\n      dico_stream_destroy(&local_40);\n      pvVar5 = local_38;\n    }\n    else {\n      uVar2 = dico_stream_strerror(local_40,iVar1);\n      uVar4 = gettext(\"cannot open stream `%s\\': %s\");\n      dico_log(4,0,uVar4,param_1,uVar2);\n      dico_stream_destroy(&local_40);\n      pvVar5 = (void *)0x0;\n    }\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return pvVar5;\n}\n\n",
        "output": "The predicted function name is read_info_file"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 *param_1,undefined4 param_2)\n\n{\n  void *__ptr;\n  undefined8 uVar1;\n  \n  __ptr = (void *)dico_full_file_name(*param_1,&DAT_0000fa46);\n  uVar1 = FUN_00009e9a(__ptr,param_2);\n  free(__ptr);\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is read_dictionary_info"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 *param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  int *piVar4;\n  long in_FS_OFFSET;\n  undefined local_b8 [48];\n  long local_88;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_0000b4eb(param_1,param_1 + 2,0x30);\n  if (iVar1 == 0) {\n    iVar1 = memcmp(param_1 + 2,\"GCIDEIDX\",8);\n    if (iVar1 == 0) {\n      iVar1 = FUN_0000f700(*(undefined4 *)(param_1 + 1),local_b8);\n      if (iVar1 == 0) {\n        if (param_1[3] * (param_1[5] + 1) == local_88) {\n          uVar2 = 0;\n        }\n        else {\n          uVar2 = *param_1;\n          uVar3 = gettext(\"index file `%s\\' is corrupted\");\n          dico_log(4,0,uVar3,uVar2);\n          uVar2 = 1;\n        }\n      }\n      else {\n        uVar2 = *param_1;\n        piVar4 = __errno_location();\n        dico_log(4,*piVar4,\"fstat `%s\\'\",uVar2);\n        uVar2 = 1;\n      }\n    }\n    else {\n      uVar2 = *param_1;\n      uVar3 = gettext(\"file `%s\\' is not a valid gcide index file\");\n      dico_log(4,0,uVar3,uVar2);\n      uVar2 = 1;\n    }\n  }\n  else {\n    uVar2 = 1;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is _open_index"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  FUN_0000a186(param_1,1);\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_descr"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void *param_1,size_t param_2)\n\n{\n  realloc(param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyrealloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](undefined8 param_1,long param_2,long param_3)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  int *piVar5;\n  undefined8 uVar6;\n  long lVar7;\n  undefined8 uVar8;\n  void *__ptr;\n  long in_FS_OFFSET;\n  undefined4 local_60;\n  undefined8 local_48;\n  undefined4 local_40;\n  undefined4 local_3c;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (*(int *)(param_2 + 0x38) != *(int *)(param_3 + 0x18)) {\n    if (*(long *)(param_2 + 0x40) != 0) {\n      dico_stream_close(*(undefined8 *)(param_2 + 0x40));\n      dico_stream_destroy(param_2 + 0x40);\n      *(undefined4 *)(param_2 + 0x38) = 0;\n    }\n    **(undefined **)(param_2 + 0x18) = (char)*(undefined4 *)(param_3 + 0x18);\n    uVar3 = dico_mapfile_stream_create(*(undefined8 *)(param_2 + 0x10),5);\n    *(undefined8 *)(param_2 + 0x40) = uVar3;\n    if (*(long *)(param_2 + 0x40) == 0) {\n      uVar3 = *(undefined8 *)(param_2 + 0x10);\n      uVar4 = gettext(\"cannot create stream `%s\\'\");\n      piVar5 = __errno_location();\n      dico_log(4,*piVar5,uVar4,uVar3);\n      local_60 = 1;\n      goto LAB_0000b328;\n    }\n    iVar1 = dico_stream_open(*(undefined8 *)(param_2 + 0x40));\n    if (iVar1 != 0) {\n      uVar4 = dico_stream_strerror(*(undefined8 *)(param_2 + 0x40),iVar1);\n      uVar3 = *(undefined8 *)(param_2 + 0x10);\n      uVar6 = gettext(\"cannot open stream `%s\\': %s\");\n      dico_log(4,0,uVar6,uVar3,uVar4);\n      dico_stream_destroy(param_2 + 0x40);\n      local_60 = 1;\n      goto LAB_0000b328;\n    }\n    *(undefined4 *)(param_2 + 0x38) = *(undefined4 *)(param_3 + 0x18);\n  }\n  lVar7 = dico_stream_seek(*(undefined8 *)(param_2 + 0x40),*(undefined8 *)(param_3 + 0x20),0);\n  if (lVar7 < 0) {\n    uVar2 = dico_stream_last_error(*(undefined8 *)(param_2 + 0x40));\n    uVar6 = dico_stream_strerror(*(undefined8 *)(param_2 + 0x40),uVar2);\n    uVar3 = *(undefined8 *)(param_3 + 0x20);\n    uVar4 = *(undefined8 *)(param_2 + 0x10);\n    uVar8 = gettext(\"seek error on `%s\\' while positioning to %lu: %s\");\n    piVar5 = __errno_location();\n    dico_log(4,*piVar5,uVar8,uVar4,uVar3,uVar6);\n    local_60 = 1;\n  }\n  else {\n    __ptr = malloc(*(size_t *)(param_3 + 0x28));\n    if (__ptr == (void *)0x0) {\n      piVar5 = __errno_location();\n      dico_log(4,*piVar5,\"%s:%d:%s\",\"gcide.c\",0x2ef,\"output_def\");\n      local_60 = 1;\n    }\n    else {\n      iVar1 = dico_stream_read(*(undefined8 *)(param_2 + 0x40),__ptr,*(undefined8 *)(param_3 + 0x28)\n                               ,0);\n      if (iVar1 == 0) {\n        lVar7 = gcide_markup_parse(__ptr,*(undefined8 *)(param_3 + 0x28),\n                                   *(uint *)(param_2 + 0x28) & 2);\n        if (lVar7 == 0) {\n          local_60 = dico_stream_write(param_1,__ptr,*(undefined8 *)(param_3 + 0x28));\n        }\n        else {\n          local_40 = *(undefined4 *)(param_2 + 0x28);\n          local_3c = 0;\n          local_48 = param_1;\n          gcide_parse_tree_inorder(lVar7,FUN_0000ab2b,&local_48);\n          gcide_parse_tree_free(lVar7);\n          local_60 = local_3c;\n        }\n        free(__ptr);\n      }\n      else {\n        uVar4 = dico_stream_strerror(*(undefined8 *)(param_2 + 0x40),iVar1);\n        uVar3 = *(undefined8 *)(param_2 + 0x10);\n        uVar6 = gettext(\"%s: read error: %s\");\n        dico_log(4,0,uVar6,uVar3,uVar4);\n        free(__ptr);\n        local_60 = 1;\n      }\n    }\n  }\nLAB_0000b328:\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_60;\n}\n\n",
        "output": "The predicted function name is output_def"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long *param_1,int *param_2)\n\n{\n  int iVar1;\n  long lVar2;\n  long in_FS_OFFSET;\n  int local_1c;\n  long *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 == (int *)0x0) {\n    local_1c = 0;\n  }\n  else {\n    local_1c = *param_2;\n  }\n  iVar1 = *(int *)(param_1 + 2);\n  local_18 = param_1;\n  if (iVar1 == 1) {\n    if (local_1c != 0) {\n      lVar2 = FUN_0000f12e(param_1[4]);\n      local_18[4] = lVar2;\n    }\n  }\n  else if ((iVar1 != 0) && (iVar1 == 2)) {\n    if ((*param_1 == 0) || (iVar1 = strcmp(*(char **)param_1[1],\"grk\"), iVar1 != 0)) {\n      local_1c = 0;\n    }\n    else {\n      local_1c = 1;\n    }\n    dico_list_iterate(local_18[4],FUN_0000f1f4,&local_1c);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is early_fixup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x38);\n}\n\n",
        "output": "The predicted function name is gcide_idx_defs"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](size_t param_1)\n\n{\n  malloc(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyalloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](long param_1)\n\n{\n  undefined4 uVar1;\n  \n  if (param_1 == 0) {\n    uVar1 = 0;\n  }\n  else {\n    uVar1 = *(undefined4 *)(param_1 + 0x68);\n  }\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is gcide_iterator_flags"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  long in_FS_OFFSET;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_28 = param_2;\n  local_20 = param_3;\n  FUN_0000efba(*(undefined8 *)(param_1 + 0x10),&local_28);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_parse_tree_inorder"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 * [MASK](long param_1)\n\n{\n  long lVar1;\n  void *pvVar2;\n  int *piVar3;\n  undefined8 *local_10;\n  \n  if (*(long *)(param_1 + 0x50) == 0) {\n    pvVar2 = calloc(*(size_t *)(param_1 + 0x40),8);\n    *(void **)(param_1 + 0x50) = pvVar2;\n    if (*(long *)(param_1 + 0x50) == 0) {\n      piVar3 = __errno_location();\n      dico_log(4,*piVar3,\"%s:%d:%s\",\"idx.c\",0xa9,\"_cache_alloc\");\n      return (undefined8 *)0x0;\n    }\n  }\n  if (*(ulong *)(param_1 + 0x48) < *(ulong *)(param_1 + 0x40)) {\n    if ((*(long *)(param_1 + 0x48) != 0) &&\n       (*(int *)(*(long *)(*(long *)(param_1 + 0x48) * 8 + -8 + *(long *)(param_1 + 0x50)) + 8) == 0\n       )) {\n      return *(undefined8 **)(*(long *)(param_1 + 0x48) * 8 + -8 + *(long *)(param_1 + 0x50));\n    }\n    local_10 = (undefined8 *)calloc(1,0x18);\n    if (local_10 == (undefined8 *)0x0) {\n      piVar3 = __errno_location();\n      dico_log(4,*piVar3,\"%s:%d:%s\",\"idx.c\",0xb3,\"_cache_alloc\");\n      return (undefined8 *)0x0;\n    }\n    pvVar2 = malloc(*(size_t *)(param_1 + 0x18));\n    local_10[2] = pvVar2;\n    if (local_10[2] == 0) {\n      piVar3 = __errno_location();\n      dico_log(4,*piVar3,\"%s:%d:%s\",\"idx.c\",0xb8,\"_cache_alloc\");\n      free(local_10);\n      return (undefined8 *)0x0;\n    }\n    lVar1 = *(long *)(param_1 + 0x48);\n    *(long *)(param_1 + 0x48) = lVar1 + 1;\n    *(undefined8 **)(*(long *)(param_1 + 0x50) + lVar1 * 8) = local_10;\n  }\n  else {\n    local_10 = *(undefined8 **)(*(long *)(param_1 + 0x48) * 8 + -8 + *(long *)(param_1 + 0x50));\n  }\n  *local_10 = 0;\n  *(undefined4 *)(local_10 + 1) = 0;\n  return local_10;\n}\n\n",
        "output": "The predicted function name is _cache_alloc"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x40);\n}\n\n",
        "output": "The predicted function name is gcide_iterator_compare_count"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1,undefined4 param_2)\n\n{\n  *(undefined4 *)(param_1 + 0x68) = param_2;\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_iterator_store_flags"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void *param_1)\n\n{\n  free(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is gcide_markup_yyfree"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2,char *param_3)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined8 uVar3;\n  long lVar4;\n  long in_FS_OFFSET;\n  int local_28;\n  char *local_20;\n  long local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  iVar1 = strcmp(param_2,\"Key\");\n  if (iVar1 == 0) {\n    uVar3 = FUN_000066e2(param_3,local_18 + 0x18,local_18 + 0x20);\n  }\n  else {\n    iVar1 = strcmp(param_2,\"Rounds\");\n    if (iVar1 == 0) {\n      iVar1 = atoi(param_3);\n      if (iVar1 < 0) {\n        uVar3 = 0xffffffff;\n      }\n      else {\n        *(int *)(local_18 + 0x40) = iVar1;\n        uVar3 = 1;\n      }\n    }\n    else {\n      iVar1 = strcmp(param_2,\"IV\");\n      if (iVar1 == 0) {\n        uVar3 = FUN_000066e2(param_3,local_18 + 0x30,local_18 + 0x48);\n      }\n      else {\n        iVar1 = strcmp(param_2,\"NextIV\");\n        if (iVar1 == 0) {\n          uVar3 = FUN_000066e2(param_3,local_18 + 0x38,local_18 + 0x48);\n        }\n        else {\n          iVar1 = strcmp(param_2,\"Plaintext\");\n          if (iVar1 == 0) {\n            uVar3 = FUN_000066e2(param_3,local_18 + 0x50,local_18 + 0x58);\n          }\n          else {\n            iVar1 = strcmp(param_2,\"Ciphertext\");\n            if (iVar1 == 0) {\n              uVar3 = FUN_000066e2(param_3,local_18 + 0x60,local_18 + 0x68);\n            }\n            else {\n              iVar1 = strcmp(param_2,\"KeyBits\");\n              if (iVar1 == 0) {\n                iVar1 = atoi(param_3);\n                if (iVar1 < 0) {\n                  uVar3 = 0xffffffff;\n                }\n                else {\n                  *(long *)(local_18 + 0x28) = (long)iVar1;\n                  uVar3 = 1;\n                }\n              }\n              else {\n                if (*(int *)(local_18 + 0x14) != 0) {\n                  iVar1 = strcmp(param_2,\"TLSAAD\");\n                  if (iVar1 == 0) {\n                    *(undefined4 *)(local_18 + 0xb0) = 1;\n                  }\n                  iVar2 = strcmp(param_2,\"AAD\");\n                  if ((iVar2 == 0) || (iVar1 == 0)) {\n                    for (local_28 = 0; local_28 < 4; local_28 = local_28 + 1) {\n                      if (*(long *)(local_18 + ((long)local_28 + 0xe) * 8) == 0) {\n                        uVar3 = FUN_000066e2(param_3,((long)local_28 + 0xe) * 8 + local_18,\n                                             ((long)local_28 + 0x12) * 8 + local_18);\n                        goto LAB_00007aac;\n                      }\n                    }\n                    uVar3 = 0xffffffff;\n                    goto LAB_00007aac;\n                  }\n                  iVar1 = strcmp(param_2,\"Tag\");\n                  if (iVar1 == 0) {\n                    uVar3 = FUN_000066e2(param_3,local_18 + 0xb8,local_18 + 200);\n                    goto LAB_00007aac;\n                  }\n                  iVar1 = strcmp(param_2,\"SetTagLate\");\n                  if (iVar1 == 0) {\n                    iVar1 = strcmp(param_3,\"TRUE\");\n                    if (iVar1 == 0) {\n                      *(undefined4 *)(local_18 + 0xd0) = 1;\n                    }\n                    else {\n                      iVar1 = strcmp(param_3,\"FALSE\");\n                      if (iVar1 != 0) {\n                        uVar3 = 0xffffffff;\n                        goto LAB_00007aac;\n                      }\n                      *(undefined4 *)(local_18 + 0xd0) = 0;\n                    }\n                    uVar3 = 1;\n                    goto LAB_00007aac;\n                  }\n                  iVar1 = strcmp(param_2,\"MACKey\");\n                  if (iVar1 == 0) {\n                    uVar3 = FUN_000066e2(param_3,local_18 + 0xd8,local_18 + 0xe0);\n                    goto LAB_00007aac;\n                  }\n                  iVar1 = strcmp(param_2,\"TLSVersion\");\n                  if (iVar1 == 0) {\n                    lVar4 = strtol(param_3,&local_20,0);\n                    *(int *)(local_18 + 0xb4) = (int)lVar4;\n                    if ((*param_3 == '\\0') || (*local_20 != '\\0')) {\n                      uVar3 = 0;\n                    }\n                    else {\n                      uVar3 = 1;\n                    }\n                    goto LAB_00007aac;\n                  }\n                }\n                iVar1 = strcmp(param_2,\"Operation\");\n                if (iVar1 == 0) {\n                  iVar1 = strcmp(param_3,\"ENCRYPT\");\n                  if (iVar1 == 0) {\n                    *(undefined4 *)(local_18 + 0x10) = 1;\n                  }\n                  else {\n                    iVar1 = strcmp(param_3,\"DECRYPT\");\n                    if (iVar1 != 0) {\n                      uVar3 = 0xffffffff;\n                      goto LAB_00007aac;\n                    }\n                    *(undefined4 *)(local_18 + 0x10) = 0;\n                  }\n                  uVar3 = 1;\n                }\n                else {\n                  iVar1 = strcmp(param_2,\"CTSMode\");\n                  if (iVar1 == 0) {\n                    *(char **)(local_18 + 0xc0) = param_3;\n                    uVar3 = 1;\n                  }\n                  else {\n                    uVar3 = 0;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_00007aac:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is cipher_test_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  void **ppvVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  ppvVar1 = *(void ***)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  EVP_MAC_free(ppvVar1[1]);\n  CRYPTO_free(*ppvVar1);\n  uVar2 = FUN_00005fc4(FUN_00009627);\n  uVar3 = FUN_00005fb6(ppvVar1[0x11]);\n  OPENSSL_sk_pop_free(uVar3,uVar2);\n  CRYPTO_free(ppvVar1[3]);\n  CRYPTO_free(ppvVar1[4]);\n  CRYPTO_free(ppvVar1[6]);\n  CRYPTO_free(ppvVar1[0xc]);\n  CRYPTO_free(ppvVar1[0xe]);\n  CRYPTO_free(ppvVar1[8]);\n  CRYPTO_free(ppvVar1[10]);\n  return;\n}\n\n",
        "output": "The predicted function name is mac_test_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](byte *param_1,ulong *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  ushort **ppuVar3;\n  byte *local_10;\n  \n  iVar1 = FUN_00019007(\"test/evp_test.c\",0x7fb,&DAT_0001d41a,*param_1 != 0);\n  if (iVar1 == 0) {\n    FUN_00016f06(\"test/evp_test.c\",0x7fc,\"Invalid empty integer value\");\n    uVar2 = 0xffffffff;\n  }\n  else {\n    *param_2 = 0;\n    for (local_10 = param_1; *local_10 != 0; local_10 = local_10 + 1) {\n      if (0x1999999999999999 < *param_2) {\n        FUN_000170fc(\"test/evp_test.c\",0x801,\"Integer overflow in string %s\",param_1);\n        return 0xffffffff;\n      }\n      *param_2 = *param_2 * 10;\n      ppuVar3 = __ctype_b_loc();\n      iVar1 = FUN_00019007(\"test/evp_test.c\",0x805,\"isdigit((unsigned char)*p)\",\n                           ((*ppuVar3)[*local_10] & 0x800) != 0);\n      if (iVar1 == 0) {\n        FUN_000170fc(\"test/evp_test.c\",0x806,\"Invalid character in string %s\",param_1);\n        return 0xffffffff;\n      }\n      *param_2 = *param_2 + (long)((char)*local_10 + -0x30);\n    }\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is parse_uint64"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](long param_1,char *param_2)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_3c;\n  long local_38;\n  long local_30;\n  char *local_28;\n  char *local_20;\n  long *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_3c = 0;\n  local_38 = 0;\n  local_30 = 0;\n  local_28 = (char *)0x0;\n  local_28 = CRYPTO_strdup(param_2,\"test/evp_test.c\",0xb87);\n  iVar1 = FUN_00018f92(\"test/evp_test.c\",0xb87,\"priv = OPENSSL_strdup(pair)\",local_28);\n  if (iVar1 != 0) {\n    local_20 = strchr(local_28,0x3a);\n    iVar1 = FUN_00018f92(\"test/evp_test.c\",0xb88,\"pub = strchr(priv, \\':\\')\",local_20);\n    if (iVar1 != 0) {\n      *local_20 = '\\0';\n      local_20 = local_20 + 1;\n      iVar1 = FUN_00010ea5(&local_38,local_28,DAT_002241b0);\n      iVar1 = FUN_00019007(\"test/evp_test.c\",0xb8e,\"find_key(&pk, priv, private_keys)\",iVar1 != 0);\n      if (iVar1 == 0) {\n        FUN_00016f06(\"test/evp_test.c\",0xb8f,\"Can\\'t find private key: %s\",local_28);\n        *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"MISSING_PRIVATE_KEY\";\n      }\n      else {\n        iVar1 = FUN_00010ea5(&local_30,local_20,DAT_002241b8);\n        iVar1 = FUN_00019007(\"test/evp_test.c\",0xb93,\"find_key(&pubk, pub, public_keys)\",iVar1 != 0)\n        ;\n        if (iVar1 == 0) {\n          FUN_00016f06(\"test/evp_test.c\",0xb94,\"Can\\'t find public key: %s\",local_20);\n          *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"MISSING_PUBLIC_KEY\";\n        }\n        else if ((local_38 == 0) && (local_30 == 0)) {\n          *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n          local_3c = 1;\n        }\n        else {\n          local_18 = (long *)CRYPTO_malloc(0x10,\"test/evp_test.c\",0xba0);\n          iVar1 = FUN_00018f92(\"test/evp_test.c\",0xba0,\"data = OPENSSL_malloc(sizeof(*data))\",\n                               local_18);\n          if (iVar1 != 0) {\n            *local_18 = local_38;\n            local_18[1] = local_30;\n            *(long **)(\"EVP_PKEY_verify_recover_init\" + param_1) = local_18;\n            local_3c = 1;\n            *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n          }\n        }\n      }\n      goto LAB_0000f85e;\n    }\n  }\n  *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"PARSING_ERROR\";\nLAB_0000f85e:\n  CRYPTO_free(local_28);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_3c;\n}\n\n",
        "output": "The predicted function name is keypair_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  int *piVar1;\n  int iVar2;\n  undefined8 uVar3;\n  uchar *out;\n  undefined8 uVar4;\n  EVP_MD *local_28;\n  \n  piVar1 = *(int **)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  local_28 = (EVP_MD *)0x0;\n  uVar3 = OSSL_LIB_CTX_set0_default(DAT_002241a8);\n  out = (uchar *)CRYPTO_malloc((int)*(undefined8 *)(piVar1 + 0x18),\"test/evp_test.c\",0x885);\n  iVar2 = FUN_00018f92(\"test/evp_test.c\",0x885,\"key = OPENSSL_malloc(expected->key_len)\");\n  if (iVar2 == 0) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"INTERNAL_ERROR\";\n    goto LAB_0000cd7e;\n  }\n  if (*piVar1 == 2) {\n    iVar2 = PKCS5_PBKDF2_HMAC(*(char **)(piVar1 + 0xe),(int)*(undefined8 *)(piVar1 + 0x10),\n                              *(uchar **)(piVar1 + 0x12),(int)*(undefined8 *)(piVar1 + 0x14),\n                              piVar1[0xb],*(EVP_MD **)(piVar1 + 0xc),\n                              (int)*(undefined8 *)(piVar1 + 0x18),out);\n    if (iVar2 == 0) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"PBKDF2_ERROR\";\n      goto LAB_0000cd7e;\n    }\n  }\n  else if (*piVar1 == 1) {\n    iVar2 = EVP_PBE_scrypt(*(undefined8 *)(piVar1 + 0xe),*(undefined8 *)(piVar1 + 0x10),\n                           *(undefined8 *)(piVar1 + 0x12),*(undefined8 *)(piVar1 + 0x14),\n                           *(undefined8 *)(piVar1 + 2),*(undefined8 *)(piVar1 + 4),\n                           *(undefined8 *)(piVar1 + 6),*(undefined8 *)(piVar1 + 8),out,\n                           *(undefined8 *)(piVar1 + 0x18));\n    if (iVar2 == 0) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"SCRYPT_ERROR\";\n      goto LAB_0000cd7e;\n    }\n  }\n  else if (*piVar1 == 3) {\n    uVar4 = EVP_MD_get0_name(*(undefined8 *)(piVar1 + 0xc));\n    local_28 = (EVP_MD *)EVP_MD_fetch(DAT_002241a8,uVar4,0);\n    if (local_28 == (EVP_MD *)0x0) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"PKCS12_ERROR\";\n      goto LAB_0000cd7e;\n    }\n    iVar2 = PKCS12_key_gen_uni(*(uchar **)(piVar1 + 0xe),(int)*(undefined8 *)(piVar1 + 0x10),\n                               *(uchar **)(piVar1 + 0x12),(int)*(undefined8 *)(piVar1 + 0x14),\n                               piVar1[10],piVar1[0xb],(int)*(undefined8 *)(piVar1 + 0x18),out,\n                               local_28);\n    if (iVar2 == 0) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"PKCS12_ERROR\";\n      goto LAB_0000cd7e;\n    }\n  }\n  iVar2 = FUN_000060ba(param_1,\"KEY_MISMATCH\",*(undefined8 *)(piVar1 + 0x16),\n                       *(undefined8 *)(piVar1 + 0x18),out,*(undefined8 *)(piVar1 + 0x18));\n  if (iVar2 != 0) {\n    *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n  }\nLAB_0000cd7e:\n  EVP_MD_free(local_28);\n  CRYPTO_free(out);\n  OSSL_LIB_CTX_set0_default(uVar3);\n  return 1;\n}\n\n",
        "output": "The predicted function name is pbe_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  return param_1;\n}\n\n",
        "output": "The predicted function name is ossl_check_OPENSSL_STRING_freefunc_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined4 param_2)\n\n{\n  OPENSSL_sk_value(param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is sk_EVP_TEST_BUFFER_value"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,undefined8 param_2,char *param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  size_t sVar5;\n  long in_FS_OFFSET;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  char *local_60;\n  undefined8 local_58;\n  long local_50;\n  int local_44;\n  char *local_40;\n  long local_38;\n  undefined8 local_30;\n  char *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  local_60 = param_3;\n  local_58 = param_2;\n  local_50 = param_1;\n  uVar3 = EVP_KDF_CTX_kdf(param_2);\n  local_30 = EVP_KDF_settable_ctx_params(uVar3);\n  local_28 = CRYPTO_strdup(local_60,\"test/evp_test.c\",0xab1);\n  iVar2 = FUN_00018f92(\"test/evp_test.c\",0xab1,\"name = OPENSSL_strdup(value)\",local_28);\n  if (iVar2 == 0) {\n    uVar3 = 0;\n    goto LAB_0000efb5;\n  }\n  pcVar4 = strchr(local_28,0x3a);\n  local_40 = pcVar4;\n  if (pcVar4 != (char *)0x0) {\n    local_40 = pcVar4 + 1;\n    *pcVar4 = '\\0';\n  }\n  if (local_40 == (char *)0x0) {\n    sVar5 = 0;\n  }\n  else {\n    sVar5 = strlen(local_40);\n  }\n  local_44 = OSSL_PARAM_allocate_from_text\n                       (*(undefined8 *)(local_38 + 0x338),local_30,local_28,local_40,sVar5,0);\n  *(long *)(local_38 + 0x338) = *(long *)(local_38 + 0x338) + 0x28;\n  puVar1 = *(undefined8 **)(local_38 + 0x338);\n  OSSL_PARAM_construct_end(&local_98);\n  *puVar1 = local_98;\n  puVar1[1] = local_90;\n  puVar1[2] = local_88;\n  puVar1[3] = local_80;\n  puVar1[4] = local_78;\n  if (local_44 == 0) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + local_50 + 0x17) = \"KDF_PARAM_ERROR\";\n    CRYPTO_free(local_28);\n    uVar3 = 0;\n    goto LAB_0000efb5;\n  }\n  if (local_40 != (char *)0x0) {\n    iVar2 = strcmp(local_28,\"digest\");\n    if (iVar2 == 0) {\n      iVar2 = FUN_00011e19(local_40);\n      if (iVar2 != 0) {\n        FUN_00016f06(\"test/evp_test.c\",0xac1,\"skipping, \\'%s\\' is disabled\",local_40);\n        *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + local_50 + 7) = 1;\n      }\n    }\n  }\n  if (local_40 != (char *)0x0) {\n    iVar2 = strcmp(local_28,\"cipher\");\n    if (iVar2 != 0) {\n      iVar2 = strcmp(local_28,\"cekalg\");\n      if (iVar2 != 0) goto LAB_0000ef98;\n    }\n    iVar2 = FUN_00011e77(local_40);\n    if (iVar2 != 0) {\n      FUN_00016f06(\"test/evp_test.c\",0xac9,\"skipping, \\'%s\\' is disabled\",local_40);\n      *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + local_50 + 7) = 1;\n    }\n  }\nLAB_0000ef98:\n  CRYPTO_free(local_28);\n  uVar3 = 1;\nLAB_0000efb5:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is kdf_test_ctrl"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  undefined8 uVar4;\n  char *pcVar5;\n  char *pcVar6;\n  undefined *puVar7;\n  int local_28;\n  ulong local_20;\n  long local_18;\n  \n  puVar1 = *(undefined8 **)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  local_28 = 0;\n  if (puVar1[3] == 0) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"NO_KEY\";\n    uVar4 = 0;\n  }\n  else {\n    if (((puVar1[6] == 0) && (iVar2 = EVP_CIPHER_get_iv_length(*puVar1), iVar2 != 0)) &&\n       (iVar2 = EVP_CIPHER_get_mode(*puVar1), iVar2 != 0x10002)) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"NO_IV\";\n      return 0;\n    }\n    if (((*(int *)((long)puVar1 + 0x14) == 0) || (puVar1[0x17] != 0)) ||\n       (*(int *)(puVar1 + 0x16) != 0)) {\n      local_20 = 0;\n      while (local_20 < 2) {\n        *(undefined **)(\"EVP_CIPHER_CTX_set_flags\" + param_1 + 1) = &DAT_002241c0;\n        for (local_18 = -1; local_18 != 2; local_18 = local_18 + 1) {\n          if (local_18 == -1) {\n            if (local_28 == 0) {\n              puVar7 = &DAT_0001cc92;\n            }\n            else {\n              puVar7 = &DAT_0001cc91;\n            }\n            if (local_20 == 0) {\n              pcVar5 = \"aligned\";\n            }\n            else {\n              pcVar5 = \"misaligned\";\n            }\n            BIO_snprintf(&DAT_002241c0,0x40,\"%s in-place, %sfragmented\",pcVar5,puVar7);\n          }\n          else {\n            if (local_28 == 0) {\n              puVar7 = &DAT_0001cc92;\n            }\n            else {\n              puVar7 = &DAT_0001cc91;\n            }\n            if (local_18 == 0) {\n              pcVar5 = \"aligned\";\n            }\n            else {\n              pcVar5 = \"misaligned\";\n            }\n            if (local_20 == 0) {\n              pcVar6 = \"aligned\";\n            }\n            else {\n              pcVar6 = \"misaligned\";\n            }\n            BIO_snprintf(&DAT_002241c0,0x40,\"%s output and %s input, %sfragmented\",pcVar6,pcVar5,\n                         puVar7);\n          }\n          if ((*(int *)(puVar1 + 2) != 0) &&\n             (iVar2 = FUN_00007ac2(param_1,1,local_20,local_18,local_28), iVar2 != 1)) {\n            if (iVar2 < 0) {\n              return 0;\n            }\n            return 1;\n          }\n          if ((*(int *)(puVar1 + 2) != 1) &&\n             (iVar2 = FUN_00007ac2(param_1,0,local_20,local_18,local_28), iVar2 != 1)) {\n            if (iVar2 < 0) {\n              return 0;\n            }\n            return 1;\n          }\n        }\n        if ((local_20 == 1) && (local_28 == 0)) {\n          if ((((*(int *)((long)puVar1 + 0x14) == 7) || (*(int *)((long)puVar1 + 0x14) == 2)) ||\n              ((*(int *)((long)puVar1 + 0x14) == -1 &&\n               (iVar2 = EVP_CIPHER_get_mode(*puVar1), iVar2 == 0)))) ||\n             ((((uVar3 = EVP_CIPHER_get_flags(*puVar1), (uVar3 & 0x4000) != 0 ||\n                (iVar2 = EVP_CIPHER_get_mode(*puVar1), iVar2 == 0x10004)) ||\n               (iVar2 = EVP_CIPHER_get_mode(*puVar1), iVar2 == 0x10001)) ||\n              (iVar2 = EVP_CIPHER_get_mode(*puVar1), iVar2 == 0x10002)))) break;\n          local_20 = 0;\n          local_28 = 1;\n        }\n        else {\n          local_20 = local_20 + 1;\n        }\n      }\n      *(undefined8 *)(\"EVP_CIPHER_CTX_set_flags\" + param_1 + 1) = 0;\n      uVar4 = 1;\n    }\n    else {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"NO_TAG\";\n      uVar4 = 0;\n    }\n  }\n  return uVar4;\n}\n\n",
        "output": "The predicted function name is cipher_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  undefined4 *ptr;\n  undefined8 uVar2;\n  EVP_MD *local_18;\n  \n  local_18 = (EVP_MD *)0x0;\n  iVar1 = strcmp(param_2,\"NULL\");\n  if (iVar1 != 0) {\n    iVar1 = FUN_00011e19(param_2);\n    if (iVar1 != 0) {\n      *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n      return 1;\n    }\n    local_18 = EVP_get_digestbyname(param_2);\n    if (local_18 == (EVP_MD *)0x0) {\n      return 0;\n    }\n  }\n  ptr = (undefined4 *)CRYPTO_zalloc(0x48,\"test/evp_test.c\",0xc80);\n  iVar1 = FUN_00018f92(\"test/evp_test.c\",0xc80,\"mdat = OPENSSL_zalloc(sizeof(*mdat))\",ptr);\n  if (iVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    *(EVP_MD **)(ptr + 2) = local_18;\n    uVar2 = EVP_MD_CTX_new();\n    *(undefined8 *)(ptr + 4) = uVar2;\n    iVar1 = FUN_00018f92(\"test/evp_test.c\",0xc83,\"mdat->ctx = EVP_MD_CTX_new()\",\n                         *(undefined8 *)(ptr + 4));\n    if (iVar1 == 0) {\n      CRYPTO_free(ptr);\n      uVar2 = 0;\n    }\n    else {\n      *ptr = param_3;\n      ptr[1] = param_4;\n      *(undefined4 **)(\"EVP_PKEY_verify_recover_init\" + param_1) = ptr;\n      uVar2 = 1;\n    }\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is digestsigver_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  return param_1;\n}\n\n",
        "output": "The predicted function name is ossl_check_OPENSSL_STRING_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  EVP_DigestVerifyUpdate(param_1,param_2,param_3);\n  return;\n}\n\n",
        "output": "The predicted function name is digestverify_update_fn"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0000fe57(param_1,param_2,1,1);\n  return;\n}\n\n",
        "output": "The predicted function name is oneshot_digestverify_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  if (*(long *)(*(long *)(\"EVP_PKEY_verify_recover_init\" + param_1) + 8) == 0) {\n    FUN_00009bff(param_1);\n  }\n  else {\n    FUN_0000a19f(param_1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is mac_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  int iVar1;\n  int iVar2;\n  ulong uVar3;\n  undefined8 uVar4;\n  \n  uVar3 = ERR_peek_last_error();\n  iVar1 = FUN_00005fd2(uVar3);\n  iVar2 = FUN_00005ffc(uVar3);\n  if ((((iVar1 == 6) && (iVar2 == 0x9c)) || ((iVar1 == 6 && (iVar2 == 0x72)))) || (iVar2 == 0x8010c)\n     ) {\n    ERR_clear_error();\n    uVar4 = 1;\n  }\n  else if ((iVar1 == 0x10) && ((iVar2 == 0x81 || (iVar2 == 0x8d)))) {\n    ERR_clear_error();\n    uVar4 = 1;\n  }\n  else {\n    uVar4 = 0;\n  }\n  return uVar4;\n}\n\n",
        "output": "The predicted function name is key_unsupported"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  EVP_PKEY_CTX *local_28;\n  uchar *local_20;\n  EVP_PKEY_CTX **local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = *(EVP_PKEY_CTX ***)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  local_20 = (uchar *)0x0;\n  local_28 = (EVP_PKEY_CTX *)0x0;\n  iVar1 = FUN_00015d6d(DAT_002241a8,3,0,0);\n  if (iVar1 == 0) {\n    iVar1 = EVP_PKEY_derive(*local_18,(uchar *)0x0,(size_t *)&local_28);\n    if (iVar1 < 1) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"INTERNAL_ERROR\";\n      goto LAB_0000f5b5;\n    }\n    if ((local_28 == (EVP_PKEY_CTX *)0xffffffffffffffff) || (local_28 == (EVP_PKEY_CTX *)0x0)) {\n      local_28 = local_18[2];\n    }\n    else {\n      local_28 = (EVP_PKEY_CTX *)((long)local_18[2] * 2);\n    }\n  }\n  else {\n    local_28 = local_18[2];\n  }\n  if (local_28 == (EVP_PKEY_CTX *)0x0) {\n    iVar1 = 1;\n  }\n  else {\n    iVar1 = (int)local_28;\n  }\n  local_20 = (uchar *)CRYPTO_malloc(iVar1,\"test/evp_test.c\",0xb5b);\n  iVar1 = FUN_00018f92(\"test/evp_test.c\",0xb5b,\"got = OPENSSL_malloc(got_len == 0 ? 1 : got_len)\",\n                       local_20);\n  if (iVar1 == 0) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"INTERNAL_ERROR\";\n  }\n  else {\n    iVar1 = EVP_PKEY_derive(*local_18,local_20,(size_t *)&local_28);\n    if (iVar1 < 1) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KDF_DERIVE_ERROR\";\n    }\n    else {\n      iVar1 = FUN_000194c5(\"test/evp_test.c\",0xb63,\"expected->output\",&DAT_0001c568,local_18[1],\n                           local_18[2],local_20,local_28);\n      if (iVar1 == 0) {\n        *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KDF_MISMATCH\";\n      }\n      else {\n        *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n      }\n    }\n  }\nLAB_0000f5b5:\n  CRYPTO_free(local_20);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is pkey_kdf_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return 0;\n}\n\n",
        "output": "The predicted function name is is_pkey_disabled"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  char **ptr;\n  char *pcVar4;\n  undefined4 local_24;\n  size_t local_20;\n  \n  local_24 = 0;\n  iVar1 = FUN_00011e59(param_2);\n  if (iVar1 == 0) {\n    pcVar3 = (char *)EVP_MAC_fetch(DAT_002241a8,param_2,0);\n    if (pcVar3 == (char *)0x0) {\n      local_20 = strlen(param_2);\n      if ((0xc < local_20) &&\n         (iVar1 = strcmp(param_2 + (local_20 - 0xc),\" by EVP_PKEY\"), iVar1 == 0)) {\n        local_20 = local_20 - 0xc;\n      }\n      iVar1 = strncmp(param_2,\"HMAC\",local_20);\n      if (iVar1 == 0) {\n        local_24 = 0x357;\n      }\n      else {\n        iVar1 = strncmp(param_2,\"CMAC\",local_20);\n        if (iVar1 == 0) {\n          local_24 = 0x37e;\n        }\n        else {\n          iVar1 = strncmp(param_2,\"Poly1305\",local_20);\n          if (iVar1 == 0) {\n            local_24 = 0x425;\n          }\n          else {\n            iVar1 = strncmp(param_2,\"SipHash\",local_20);\n            if (iVar1 != 0) {\n              return 0;\n            }\n            local_24 = 0x426;\n          }\n        }\n      }\n    }\n    ptr = (char **)CRYPTO_zalloc(0x98,\"test/evp_test.c\",0x49d);\n    iVar1 = FUN_00018f92(\"test/evp_test.c\",0x49d,\"mdat = OPENSSL_zalloc(sizeof(*mdat))\",ptr);\n    if (iVar1 == 0) {\n      uVar2 = 0;\n    }\n    else {\n      *(undefined4 *)(ptr + 2) = local_24;\n      pcVar4 = CRYPTO_strdup(param_2,\"test/evp_test.c\",0x4a1);\n      *ptr = pcVar4;\n      iVar1 = FUN_00018f92(\"test/evp_test.c\",0x4a1,\"mdat->mac_name = OPENSSL_strdup(alg)\",*ptr);\n      if (iVar1 == 0) {\n        CRYPTO_free(ptr);\n        uVar2 = 0;\n      }\n      else {\n        ptr[1] = pcVar3;\n        pcVar3 = (char *)OPENSSL_sk_new_null();\n        ptr[0x11] = pcVar3;\n        iVar1 = FUN_00018f92(\"test/evp_test.c\",0x4a7,\"mdat->controls = sk_OPENSSL_STRING_new_null()\"\n                             ,ptr[0x11]);\n        if (iVar1 == 0) {\n          CRYPTO_free(*ptr);\n          CRYPTO_free(ptr);\n          uVar2 = 0;\n        }\n        else {\n          *(undefined4 *)((long)ptr + 0x94) = 0xffffffff;\n          *(undefined4 *)(ptr + 0x12) = *(undefined4 *)((long)ptr + 0x94);\n          *(char ***)(\"EVP_PKEY_verify_recover_init\" + param_1) = ptr;\n          uVar2 = 1;\n        }\n      }\n    }\n  }\n  else {\n    FUN_00016f06(\"test/evp_test.c\",0x480,\"skipping, \\'%s\\' is disabled\",param_2);\n    *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is mac_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  undefined8 uVar3;\n  \n  puVar1 = *(undefined8 **)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  iVar2 = strcmp(param_2,\"Output\");\n  if (iVar2 == 0) {\n    uVar3 = FUN_000066e2(param_3,puVar1 + 1,puVar1 + 2);\n  }\n  else {\n    iVar2 = strncmp(param_2,\"Ctrl\",4);\n    if (iVar2 == 0) {\n      uVar3 = FUN_0000b5de(param_1,*puVar1,param_3);\n    }\n    else {\n      uVar3 = 0;\n    }\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is pkey_kdf_test_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  EVP_MD *pEVar3;\n  EVP_MD **ppEVar4;\n  EVP_MD *local_20;\n  \n  iVar1 = FUN_00011e19(param_2);\n  if (iVar1 == 0) {\n    pEVar3 = (EVP_MD *)EVP_MD_fetch(DAT_002241a8,param_2,0);\n    local_20 = pEVar3;\n    if ((pEVar3 == (EVP_MD *)0x0) &&\n       (local_20 = EVP_get_digestbyname(param_2), local_20 == (EVP_MD *)0x0)) {\n      return 0;\n    }\n    ppEVar4 = (EVP_MD **)CRYPTO_zalloc(0x30,\"test/evp_test.c\",0x163);\n    iVar1 = FUN_00018f92(\"test/evp_test.c\",0x163,\"mdat = OPENSSL_zalloc(sizeof(*mdat))\",ppEVar4);\n    if (iVar1 == 0) {\n      uVar2 = 0;\n    }\n    else {\n      *(EVP_MD ***)(\"EVP_PKEY_verify_recover_init\" + param_1) = ppEVar4;\n      *ppEVar4 = local_20;\n      ppEVar4[1] = pEVar3;\n      *(undefined4 *)(ppEVar4 + 5) = 0;\n      if (pEVar3 != (EVP_MD *)0x0) {\n        FUN_00016f06(\"test/evp_test.c\",0x16a,\"%s is fetched\",param_2);\n      }\n      uVar2 = 1;\n    }\n  }\n  else {\n    FUN_00016f06(\"test/evp_test.c\",0x15b,\"skipping, \\'%s\\' is disabled\",param_2);\n    *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is digest_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0000fe57(param_1,param_2,0,1);\n  return;\n}\n\n",
        "output": "The predicted function name is oneshot_digestsign_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0000fe57(param_1,param_2,1,0);\n  return;\n}\n\n",
        "output": "The predicted function name is digestverify_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0000b38a(param_1,param_2,1,PTR_EVP_PKEY_verify_recover_init_00223fb0,\n               PTR_EVP_PKEY_verify_recover_00223fd8);\n  return;\n}\n\n",
        "output": "The predicted function name is verify_recover_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  void *ptr;\n  \n  ptr = *(void **)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  EVP_MD_CTX_free(*(undefined8 *)((long)ptr + 0x10));\n  FUN_00006094(*(undefined8 *)((long)ptr + 0x20),FUN_000061a0);\n  CRYPTO_free(*(void **)((long)ptr + 0x28));\n  CRYPTO_free(*(void **)((long)ptr + 0x38));\n  CRYPTO_free(ptr);\n  *(undefined8 *)(\"EVP_PKEY_verify_recover_init\" + param_1) = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is digestsigver_test_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  EVP_DigestSignUpdate(param_1,param_2,param_3);\n  return;\n}\n\n",
        "output": "The predicted function name is digestsign_update_fn"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  EVP_PKEY_CTX **ptr;\n  EVP_PKEY_CTX *pEVar3;\n  \n  iVar1 = FUN_00011e68(param_2);\n  if (iVar1 == 0) {\n    ptr = (EVP_PKEY_CTX **)CRYPTO_zalloc(0x18,\"test/evp_test.c\",0xb1c);\n    iVar1 = FUN_00018f92(\"test/evp_test.c\",0xb1c,\"kdata = OPENSSL_zalloc(sizeof(*kdata))\",ptr);\n    if (iVar1 == 0) {\n      uVar2 = 0;\n    }\n    else {\n      pEVar3 = (EVP_PKEY_CTX *)EVP_PKEY_CTX_new_from_name(DAT_002241a8,param_2,0);\n      *ptr = pEVar3;\n      if ((*ptr != (EVP_PKEY_CTX *)0x0) && (iVar1 = EVP_PKEY_derive_init(*ptr), 0 < iVar1)) {\n        *(EVP_PKEY_CTX ***)(\"EVP_PKEY_verify_recover_init\" + param_1) = ptr;\n        return 1;\n      }\n      EVP_PKEY_CTX_free(*ptr);\n      CRYPTO_free(ptr);\n      uVar2 = 0;\n    }\n  }\n  else {\n    FUN_00016f06(\"test/evp_test.c\",0xb17,\"skipping, \\'%s\\' is disabled\",param_2);\n    *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is pkey_kdf_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void **param_1)\n\n{\n  void **ppvVar1;\n  void **local_20;\n  \n  local_20 = param_1;\n  while (local_20 != (void **)0x0) {\n    ppvVar1 = (void **)local_20[2];\n    EVP_PKEY_free((EVP_PKEY *)local_20[1]);\n    CRYPTO_free(*local_20);\n    CRYPTO_free(local_20);\n    local_20 = ppvVar1;\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is free_key_list"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined8 local_30;\n  void *local_28;\n  EVP_PKEY_CTX *local_20;\n  EVP_PKEY_CTX **local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = *(EVP_PKEY_CTX ***)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  local_28 = (void *)0x0;\n  local_20 = (EVP_PKEY_CTX *)0x0;\n  iVar1 = (*(code *)local_18[1])(*local_18,0,&local_30,local_18[2],local_18[3]);\n  if (0 < iVar1) {\n    local_28 = CRYPTO_malloc((int)local_30,\"test/evp_test.c\",0x6f2);\n    iVar1 = FUN_00018f92(\"test/evp_test.c\",0x6f2,\"got = OPENSSL_malloc(got_len)\",local_28);\n    if (iVar1 != 0) {\n      iVar1 = (*(code *)local_18[1])(*local_18,local_28,&local_30,local_18[2],local_18[3]);\n      if (iVar1 < 1) {\n        *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KEYOP_ERROR\";\n      }\n      else {\n        iVar1 = FUN_000060ba(param_1,\"KEYOP_MISMATCH\",local_18[4],local_18[5],local_28,local_30);\n        if (iVar1 != 0) {\n          *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n          CRYPTO_free(local_28);\n          local_28 = (void *)0x0;\n          local_20 = EVP_PKEY_CTX_dup(*local_18);\n          iVar1 = FUN_00018f92(\"test/evp_test.c\",0x705,\"copy = EVP_PKEY_CTX_dup(expected->ctx)\",\n                               local_20);\n          if (iVar1 == 0) {\n            *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"INTERNAL_ERROR\";\n          }\n          else {\n            iVar1 = (*(code *)local_18[1])(local_20,0,&local_30,local_18[2],local_18[3]);\n            if (0 < iVar1) {\n              local_28 = CRYPTO_malloc((int)local_30,\"test/evp_test.c\",0x70b);\n              iVar1 = FUN_00018f92(\"test/evp_test.c\",0x70b,\"got = OPENSSL_malloc(got_len)\",local_28)\n              ;\n              if (iVar1 != 0) {\n                iVar1 = (*(code *)local_18[1])(local_20,local_28,&local_30,local_18[2],local_18[3]);\n                if (iVar1 < 1) {\n                  *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KEYOP_ERROR\";\n                }\n                else {\n                  FUN_000060ba(param_1,\"KEYOP_MISMATCH\",local_18[4],local_18[5],local_28,local_30);\n                }\n                goto LAB_0000bacc;\n              }\n            }\n            *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KEYOP_LENGTH_ERROR\";\n          }\n        }\n      }\n      goto LAB_0000bacc;\n    }\n  }\n  *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KEYOP_LENGTH_ERROR\";\nLAB_0000bacc:\n  CRYPTO_free(local_28);\n  EVP_PKEY_CTX_free(local_20);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is pkey_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  long lVar1;\n  int iVar2;\n  \n  lVar1 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  iVar2 = FUN_000064e0(*(undefined8 *)(lVar1 + 0x20),FUN_0001059c,*(undefined8 *)(lVar1 + 0x10));\n  if (iVar2 == 0) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DIGESTUPDATE_ERROR\";\n  }\n  else {\n    iVar2 = EVP_DigestVerifyFinal\n                      (*(EVP_MD_CTX **)(lVar1 + 0x10),*(uchar **)(lVar1 + 0x38),\n                       *(size_t *)(lVar1 + 0x40));\n    if (iVar2 < 1) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"VERIFY_ERROR\";\n    }\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is digestverify_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nuint [MASK](long param_1,char *param_2,undefined8 param_3,undefined8 param_4,\n                 undefined8 param_5,undefined8 param_6)\n\n{\n  int iVar1;\n  uint local_c;\n  \n  if (*(long *)(\"EVP_CIPHER_CTX_set_flags\" + param_1 + 9) != 0) {\n    iVar1 = strcmp(*(char **)(\"EVP_CIPHER_CTX_set_flags\" + param_1 + 9),param_2);\n    if (iVar1 == 0) {\n      iVar1 = FUN_0001957f(\"test/evp_test.c\",0x69,\"expected\",&DAT_0001c568,param_3,param_4,param_5,\n                           param_6);\n      local_c = (uint)(iVar1 == 0);\n      goto LAB_00006186;\n    }\n  }\n  local_c = FUN_000194c5(\"test/evp_test.c\",0x6b,\"expected\",&DAT_0001c568,param_3,param_4,param_5,\n                         param_6);\nLAB_00006186:\n  if (local_c == 0) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = param_2;\n  }\n  return local_c;\n}\n\n",
        "output": "The predicted function name is memory_err_compare"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined8 uVar2;\n  int local_2c;\n  long local_28;\n  int *local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = *(int **)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  uVar2 = 0x100bc;\n  iVar1 = strcmp(param_2,\"Key\");\n  if (iVar1 == 0) {\n    local_28 = 0;\n    local_2c = 0;\n    if (*(long *)(local_20 + 2) == 0) {\n      local_18 = 0;\n    }\n    else {\n      uVar2 = 0x100f0;\n      local_18 = EVP_MD_get0_name(*(undefined8 *)(local_20 + 2));\n    }\n    if (*local_20 != 0) {\n      uVar2 = 0x1011f;\n      local_2c = FUN_00010ea5(&local_28,param_3,DAT_002241b8);\n    }\n    if (local_2c == 0) {\n      uVar2 = 0x10142;\n      local_2c = FUN_00010ea5(&local_28,param_3,DAT_002241b0);\n    }\n    if ((local_2c == 0) || (local_28 == 0)) {\n      *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n      uVar2 = 1;\n    }\n    else if (*local_20 == 0) {\n      iVar1 = EVP_DigestSignInit_ex\n                        (*(undefined8 *)(local_20 + 4),local_20 + 6,local_18,DAT_002241a8,0,local_28\n                         ,0,uVar2);\n      if (iVar1 == 0) {\n        *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DIGESTSIGNINIT_ERROR\";\n      }\n      uVar2 = 1;\n    }\n    else {\n      iVar1 = EVP_DigestVerifyInit_ex\n                        (*(undefined8 *)(local_20 + 4),local_20 + 6,local_18,DAT_002241a8,0,local_28\n                         ,0);\n      if (iVar1 == 0) {\n        *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DIGESTVERIFYINIT_ERROR\";\n      }\n      uVar2 = 1;\n    }\n  }\n  else {\n    iVar1 = strcmp(param_2,\"Input\");\n    if (iVar1 == 0) {\n      if (local_20[1] == 0) {\n        uVar2 = FUN_000061e9(param_3,local_20 + 8);\n      }\n      else {\n        uVar2 = FUN_000066e2(param_3,local_20 + 10,local_20 + 0xc);\n      }\n    }\n    else {\n      iVar1 = strcmp(param_2,\"Output\");\n      if (iVar1 == 0) {\n        uVar2 = FUN_000066e2(param_3,local_20 + 0xe,local_20 + 0x10);\n      }\n      else {\n        if (local_20[1] == 0) {\n          iVar1 = strcmp(param_2,\"Count\");\n          if (iVar1 == 0) {\n            uVar2 = FUN_00006443(param_3,*(undefined8 *)(local_20 + 8));\n            goto LAB_0001037f;\n          }\n          iVar1 = strcmp(param_2,\"Ncopy\");\n          if (iVar1 == 0) {\n            uVar2 = FUN_000062f7(param_3,*(undefined8 *)(local_20 + 8));\n            goto LAB_0001037f;\n          }\n        }\n        iVar1 = strcmp(param_2,\"Ctrl\");\n        if (iVar1 == 0) {\n          if (*(long *)(local_20 + 6) == 0) {\n            uVar2 = 0xffffffff;\n          }\n          else {\n            uVar2 = FUN_0000b5de(param_1,*(undefined8 *)(local_20 + 6),param_3);\n          }\n        }\n        else {\n          uVar2 = 0;\n        }\n      }\n    }\n  }\nLAB_0001037f:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is digestsigver_test_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong [MASK](long param_1,char *param_2,char *param_3)\n\n{\n  long lVar1;\n  int iVar2;\n  ulong uVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  \n  lVar1 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  iVar2 = strcmp(param_2,\"Key\");\n  if (iVar2 == 0) {\n    uVar3 = FUN_000066e2(param_3,lVar1 + 0x20,lVar1 + 0x28);\n  }\n  else {\n    iVar2 = strcmp(param_2,\"IV\");\n    if (iVar2 == 0) {\n      uVar3 = FUN_000066e2(param_3,lVar1 + 0x30,lVar1 + 0x38);\n    }\n    else {\n      iVar2 = strcmp(param_2,\"Custom\");\n      if (iVar2 == 0) {\n        uVar3 = FUN_000066e2(param_3,lVar1 + 0x60,lVar1 + 0x68);\n      }\n      else {\n        iVar2 = strcmp(param_2,\"Salt\");\n        if (iVar2 == 0) {\n          uVar3 = FUN_000066e2(param_3,lVar1 + 0x70,lVar1 + 0x78);\n        }\n        else {\n          iVar2 = strcmp(param_2,\"Algorithm\");\n          if (iVar2 == 0) {\n            pcVar4 = CRYPTO_strdup(param_3,\"test/evp_test.c\",0x4d6);\n            *(char **)(lVar1 + 0x18) = pcVar4;\n            if (*(long *)(lVar1 + 0x18) == 0) {\n              uVar3 = 0xffffffff;\n            }\n            else {\n              uVar3 = 1;\n            }\n          }\n          else {\n            iVar2 = strcmp(param_2,\"Input\");\n            if (iVar2 == 0) {\n              uVar3 = FUN_000066e2(param_3,lVar1 + 0x40,lVar1 + 0x48);\n            }\n            else {\n              iVar2 = strcmp(param_2,\"Output\");\n              if (iVar2 == 0) {\n                uVar3 = FUN_000066e2(param_3,lVar1 + 0x50,lVar1 + 0x58);\n              }\n              else {\n                iVar2 = strcmp(param_2,\"XOF\");\n                if (iVar2 == 0) {\n                  *(undefined4 *)(lVar1 + 0x80) = 1;\n                  uVar3 = (ulong)*(uint *)(lVar1 + 0x80);\n                }\n                else {\n                  iVar2 = strcmp(param_2,\"NoReinit\");\n                  if (iVar2 == 0) {\n                    *(undefined4 *)(lVar1 + 0x84) = 1;\n                    uVar3 = (ulong)*(uint *)(lVar1 + 0x84);\n                  }\n                  else {\n                    iVar2 = strcmp(param_2,\"Ctrl\");\n                    if (iVar2 == 0) {\n                      pcVar4 = CRYPTO_strdup(param_3,\"test/evp_test.c\",0x4e4);\n                      if (pcVar4 == (char *)0x0) {\n                        uVar3 = 0xffffffff;\n                      }\n                      else {\n                        uVar5 = FUN_00005f9a(pcVar4);\n                        uVar6 = FUN_00005fb6(*(undefined8 *)(lVar1 + 0x88));\n                        iVar2 = OPENSSL_sk_push(uVar6,uVar5);\n                        uVar3 = (ulong)(iVar2 != 0);\n                      }\n                    }\n                    else {\n                      iVar2 = strcmp(param_2,\"OutputSize\");\n                      if (iVar2 == 0) {\n                        iVar2 = atoi(param_3);\n                        *(int *)(lVar1 + 0x90) = iVar2;\n                        if (*(int *)(lVar1 + 0x90) < 0) {\n                          uVar3 = 0xffffffff;\n                        }\n                        else {\n                          uVar3 = 1;\n                        }\n                      }\n                      else {\n                        iVar2 = strcmp(param_2,\"BlockSize\");\n                        if (iVar2 == 0) {\n                          iVar2 = atoi(param_3);\n                          *(int *)(lVar1 + 0x94) = iVar2;\n                          if (*(int *)(lVar1 + 0x94) < 0) {\n                            uVar3 = 0xffffffff;\n                          }\n                          else {\n                            uVar3 = 1;\n                          }\n                        }\n                        else {\n                          uVar3 = 0;\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is mac_test_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2,undefined8 param_3)\n\n{\n  long lVar1;\n  int iVar2;\n  undefined8 uVar3;\n  \n  lVar1 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  iVar2 = strcmp(param_2,\"Input\");\n  if (iVar2 == 0) {\n    uVar3 = FUN_000066e2(param_3,lVar1,lVar1 + 8);\n  }\n  else {\n    iVar2 = strcmp(param_2,\"Output\");\n    if (iVar2 == 0) {\n      uVar3 = FUN_000066e2(param_3,lVar1 + 0x10,lVar1 + 0x18);\n    }\n    else {\n      uVar3 = 0;\n    }\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is encode_test_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  long local_28;\n  void *local_20;\n  long local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  local_20 = (void *)0x0;\n  iVar1 = EVP_DigestSign(*(undefined8 *)(local_18 + 0x10),0,&local_28,\n                         *(undefined8 *)(local_18 + 0x28),*(undefined8 *)(local_18 + 0x30));\n  if (iVar1 == 0) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DIGESTSIGN_LENGTH_ERROR\";\n  }\n  else {\n    local_20 = CRYPTO_malloc((int)local_28,\"test/evp_test.c\",0xd36);\n    iVar1 = FUN_00018f92(\"test/evp_test.c\",0xd36,\"got = OPENSSL_malloc(got_len)\",local_20);\n    if (iVar1 == 0) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"MALLOC_FAILURE\";\n    }\n    else {\n      local_28 = local_28 * 2;\n      iVar1 = EVP_DigestSign(*(undefined8 *)(local_18 + 0x10),local_20,&local_28,\n                             *(undefined8 *)(local_18 + 0x28),*(undefined8 *)(local_18 + 0x30));\n      if (iVar1 == 0) {\n        *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DIGESTSIGN_ERROR\";\n      }\n      else {\n        iVar1 = FUN_000060ba(param_1,\"SIGNATURE_MISMATCH\",*(undefined8 *)(local_18 + 0x38),\n                             *(undefined8 *)(local_18 + 0x40),local_20,local_28);\n        if (iVar1 != 0) {\n          *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n        }\n      }\n    }\n  }\n  CRYPTO_free(local_20);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is oneshot_digestsign_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  void **__s;\n  \n  __s = *(void ***)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  CRYPTO_free(*__s);\n  CRYPTO_free(__s[2]);\n  memset(__s,0,0x28);\n  return;\n}\n\n",
        "output": "The predicted function name is encode_test_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2,undefined8 param_3)\n\n{\n  long lVar1;\n  int iVar2;\n  undefined8 uVar3;\n  \n  lVar1 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  iVar2 = strcmp(param_2,\"N\");\n  if (iVar2 == 0) {\n    uVar3 = FUN_0000c400(param_3,lVar1 + 8);\n  }\n  else {\n    iVar2 = strcmp(param_2,\"p\");\n    if (iVar2 == 0) {\n      uVar3 = FUN_0000c400(param_3,lVar1 + 0x18);\n    }\n    else {\n      iVar2 = strcmp(param_2,\"r\");\n      if (iVar2 == 0) {\n        uVar3 = FUN_0000c400(param_3,lVar1 + 0x10);\n      }\n      else {\n        iVar2 = strcmp(param_2,\"maxmem\");\n        if (iVar2 == 0) {\n          uVar3 = FUN_0000c400(param_3,lVar1 + 0x20);\n        }\n        else {\n          uVar3 = 0;\n        }\n      }\n    }\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is scrypt_test_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  return param_1;\n}\n\n",
        "output": "The predicted function name is ossl_check_const_OPENSSL_STRING_sk_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  OPENSSL_sk_pop_free(param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is sk_EVP_TEST_BUFFER_pop_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  CRYPTO_free(*(void **)(\"EVP_PKEY_verify_recover_init\" + param_1));\n  *(undefined8 *)(\"EVP_PKEY_verify_recover_init\" + param_1) = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is keypair_test_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  undefined8 uVar3;\n  \n  puVar1 = *(undefined8 **)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  iVar2 = strcmp(param_2,\"Output\");\n  if (iVar2 == 0) {\n    uVar3 = FUN_000066e2(param_3,puVar1 + 1,puVar1 + 2);\n  }\n  else {\n    iVar2 = strncmp(param_2,\"Ctrl\",4);\n    if (iVar2 == 0) {\n      uVar3 = FUN_0000ed1c(param_1,*puVar1,param_3);\n    }\n    else {\n      uVar3 = 0;\n    }\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is kdf_test_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined4 [MASK](long param_1)\n\n{\n  long *plVar1;\n  int iVar2;\n  \n  plVar1 = *(long **)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  if ((*plVar1 == 0) || (plVar1[1] == 0)) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KEYPAIR_TYPE_MISMATCH\";\n  }\n  else {\n    iVar2 = EVP_PKEY_eq(*plVar1,plVar1[1]);\n    if (iVar2 == 1) {\n      *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n    }\n    else if (iVar2 == 0) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KEYPAIR_MISMATCH\";\n    }\n    else if (iVar2 == -1) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KEYPAIR_TYPE_MISMATCH\";\n    }\n    else {\n      if (iVar2 != -2) {\n        FUN_000170fc(\"test/evp_test.c\",0xbd3,\"Unexpected error in key comparison\");\n        return 0;\n      }\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"UNSUPPORTED_KEY_COMPARISON\";\n    }\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is keypair_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  undefined8 *puVar1;\n  long *local_18;\n  \n  puVar1 = *(undefined8 **)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  for (local_18 = puVar1 + 3; *local_18 != 0; local_18 = local_18 + 5) {\n    CRYPTO_free((void *)local_18[2]);\n  }\n  CRYPTO_free((void *)puVar1[1]);\n  EVP_KDF_CTX_free(*puVar1);\n  return;\n}\n\n",
        "output": "The predicted function name is kdf_test_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](undefined8 param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = OPENSSL_strcasecmp(param_1,&DAT_0001e546);\n  return iVar1 == 0;\n}\n\n",
        "output": "The predicted function name is is_digest_disabled"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1)\n\n{\n  OPENSSL_sk_num(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is sk_EVP_TEST_BUFFER_num"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  undefined8 *puVar1;\n  long lVar2;\n  int iVar3;\n  void *ptr;\n  \n  puVar1 = *(undefined8 **)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  lVar2 = puVar1[2];\n  iVar3 = EVP_KDF_CTX_set_params(*puVar1,puVar1 + 3);\n  if (iVar3 == 0) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KDF_CTRL_ERROR\";\n  }\n  else {\n    if (lVar2 == 0) {\n      iVar3 = 1;\n    }\n    else {\n      iVar3 = (int)lVar2;\n    }\n    ptr = CRYPTO_malloc(iVar3,\"test/evp_test.c\",0xae6);\n    iVar3 = FUN_00018f92(\"test/evp_test.c\",0xae6,\"got = OPENSSL_malloc(got_len == 0 ? 1 : got_len)\",\n                         ptr);\n    if (iVar3 == 0) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"INTERNAL_ERROR\";\n    }\n    else {\n      iVar3 = EVP_KDF_derive(*puVar1,ptr,lVar2,0);\n      if (iVar3 < 1) {\n        *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KDF_DERIVE_ERROR\";\n      }\n      else {\n        iVar3 = FUN_000060ba(param_1,\"KDF_MISMATCH\",puVar1[1],puVar1[2],ptr,lVar2);\n        if (iVar3 != 0) {\n          *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n        }\n      }\n    }\n    CRYPTO_free(ptr);\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is kdf_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long lVar3;\n  long in_FS_OFFSET;\n  undefined8 local_c8;\n  undefined8 local_c0;\n  undefined8 local_b8;\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_98;\n  long local_90;\n  undefined4 local_7c;\n  long *local_78;\n  long local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_68 = 0;\n  local_60 = 0;\n  local_58 = 0;\n  local_50 = 0;\n  local_48 = 0;\n  local_40 = 0;\n  local_38 = 0;\n  local_30 = 0;\n  local_28 = 0;\n  local_20 = 0;\n  local_7c = 0x100;\n  local_98 = param_2;\n  local_90 = param_1;\n  local_78 = (long *)CRYPTO_zalloc(0x990,\"test/evp_test.c\",0x97d);\n  iVar1 = FUN_00018f92(\"test/evp_test.c\",0x97d,\"rdata = OPENSSL_zalloc(sizeof(*rdata))\",local_78);\n  if (iVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    local_70 = EVP_RAND_fetch(DAT_002241a8,\"TEST-RAND\",\"-fips\");\n    if (local_70 != 0) {\n      lVar3 = EVP_RAND_CTX_new(local_70,0);\n      local_78[1] = lVar3;\n      EVP_RAND_free(local_70);\n      if (local_78[1] != 0) {\n        OSSL_PARAM_construct_uint(&local_c8,\"strength\",&local_7c);\n        local_68 = local_c8;\n        local_60 = local_c0;\n        local_58 = local_b8;\n        local_50 = local_b0;\n        local_48 = local_a8;\n        iVar1 = EVP_RAND_CTX_set_params(local_78[1],&local_68);\n        if ((iVar1 != 0) && (local_70 = EVP_RAND_fetch(DAT_002241a8,local_98,0), local_70 != 0)) {\n          lVar3 = EVP_RAND_CTX_new(local_70,local_78[1]);\n          *local_78 = lVar3;\n          EVP_RAND_free(local_70);\n          if (*local_78 != 0) {\n            *(undefined4 *)(local_78 + 2) = 0xffffffff;\n            *(long **)(\"EVP_PKEY_verify_recover_init\" + local_90) = local_78;\n            uVar2 = 1;\n            goto LAB_0000d668;\n          }\n        }\n      }\n    }\n    EVP_RAND_CTX_free(local_78[1]);\n    CRYPTO_free(local_78);\n    uVar2 = 0;\n  }\nLAB_0000d668:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is rand_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void)\n\n{\n  OPENSSL_sk_new_null();\n  return;\n}\n\n",
        "output": "The predicted function name is sk_EVP_TEST_BUFFER_new_null"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](undefined8 param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = OPENSSL_strncasecmp(&DAT_0001e54a,param_1,3);\n  return iVar1 == 0;\n}\n\n",
        "output": "The predicted function name is is_cipher_disabled"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  undefined8 *puVar1;\n  int local_14;\n  \n  puVar1 = *(undefined8 **)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  CRYPTO_free((void *)puVar1[4]);\n  CRYPTO_free((void *)puVar1[5]);\n  for (local_14 = 0; local_14 <= *(int *)(puVar1 + 2); local_14 = local_14 + 1) {\n    CRYPTO_free((void *)puVar1[(long)local_14 * 0x14 + 6]);\n    CRYPTO_free((void *)puVar1[(long)local_14 * 0x14 + 7]);\n    CRYPTO_free((void *)puVar1[(long)local_14 * 0x14 + 8]);\n    CRYPTO_free((void *)puVar1[(long)local_14 * 0x14 + 9]);\n    CRYPTO_free((void *)puVar1[(long)local_14 * 0x14 + 10]);\n    CRYPTO_free((void *)puVar1[(long)local_14 * 0x14 + 0xb]);\n    CRYPTO_free((void *)puVar1[(long)local_14 * 0x14 + 0xc]);\n    CRYPTO_free((void *)puVar1[(long)local_14 * 0x14 + 0xd]);\n    CRYPTO_free((void *)puVar1[(long)local_14 * 0x14 + 0xe]);\n    CRYPTO_free((void *)puVar1[(long)local_14 * 0x14 + 0xf]);\n  }\n  EVP_RAND_CTX_free(*puVar1);\n  EVP_RAND_CTX_free(puVar1[1]);\n  return;\n}\n\n",
        "output": "The predicted function name is rand_test_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](EVP_MD_CTX *param_1,void *param_2,size_t param_3)\n\n{\n  EVP_DigestUpdate(param_1,param_2,param_3);\n  return;\n}\n\n",
        "output": "The predicted function name is digest_update_fn"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  long lVar1;\n  int local_14;\n  \n  lVar1 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  CRYPTO_free(*(void **)(lVar1 + 0x18));\n  CRYPTO_free(*(void **)(lVar1 + 0x30));\n  CRYPTO_free(*(void **)(lVar1 + 0x38));\n  CRYPTO_free(*(void **)(lVar1 + 0x60));\n  CRYPTO_free(*(void **)(lVar1 + 0x50));\n  for (local_14 = 0; local_14 < 4; local_14 = local_14 + 1) {\n    CRYPTO_free(*(void **)(lVar1 + ((long)local_14 + 0xe) * 8));\n  }\n  CRYPTO_free(*(void **)(lVar1 + 0xb8));\n  CRYPTO_free(*(void **)(lVar1 + 0xd8));\n  EVP_CIPHER_free(*(undefined8 *)(lVar1 + 8));\n  return;\n}\n\n",
        "output": "The predicted function name is cipher_test_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1,EVP_PKEY_CTX *param_2,char *param_3)\n\n{\n  bool bVar1;\n  int iVar2;\n  char *__s;\n  char *pcVar3;\n  int local_1c;\n  \n  local_1c = 0;\n  __s = CRYPTO_strdup(param_3,\"test/evp_test.c\",0x4ff);\n  iVar2 = FUN_00018f92(\"test/evp_test.c\",0x4ff,\"tmpval = OPENSSL_strdup(value)\",__s);\n  if (iVar2 == 0) {\n    bVar1 = false;\n  }\n  else {\n    pcVar3 = strchr(__s,0x3a);\n    if (pcVar3 != (char *)0x0) {\n      *pcVar3 = '\\0';\n      local_1c = EVP_PKEY_CTX_ctrl_str(param_2,__s,pcVar3 + 1);\n    }\n    if (local_1c == -2) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"PKEY_CTRL_INVALID\";\n    }\n    else if (local_1c < 1) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"PKEY_CTRL_ERROR\";\n    }\n    else {\n      local_1c = 1;\n    }\n    CRYPTO_free(__s);\n    bVar1 = 0 < local_1c;\n  }\n  return bVar1;\n}\n\n",
        "output": "The predicted function name is mac_test_ctrl_pkey"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  EVP_PKEY_CTX *ctx;\n  EVP_PKEY_CTX **ppEVar3;\n  \n  iVar1 = OBJ_sn2nid(param_2);\n  if ((iVar1 == 0) && (iVar1 = OBJ_ln2nid(param_2), iVar1 == 0)) {\n    uVar2 = 0;\n  }\n  else {\n    iVar1 = FUN_00011e4a(param_2);\n    if (iVar1 == 0) {\n      ctx = (EVP_PKEY_CTX *)EVP_PKEY_CTX_new_from_name(DAT_002241a8,param_2,0);\n      iVar1 = FUN_00018f92(\"test/evp_test.c\",0xc03,\n                           \"genctx = EVP_PKEY_CTX_new_from_name(libctx, alg, NULL)\",ctx);\n      if (iVar1 != 0) {\n        iVar1 = EVP_PKEY_keygen_init(ctx);\n        if (iVar1 < 1) {\n          *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"KEYGEN_INIT_ERROR\";\n        }\n        else {\n          ppEVar3 = (EVP_PKEY_CTX **)CRYPTO_malloc(0x10,\"test/evp_test.c\",0xc0b);\n          iVar1 = FUN_00018f92(\"test/evp_test.c\",0xc0b,\"data = OPENSSL_malloc(sizeof(*data))\",\n                               ppEVar3);\n          if (iVar1 != 0) {\n            *ppEVar3 = ctx;\n            ppEVar3[1] = (EVP_PKEY_CTX *)0x0;\n            *(EVP_PKEY_CTX ***)(\"EVP_PKEY_verify_recover_init\" + param_1) = ppEVar3;\n            *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n            return 1;\n          }\n        }\n      }\n      EVP_PKEY_CTX_free(ctx);\n      uVar2 = 0;\n    }\n    else {\n      *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n      uVar2 = 1;\n    }\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is keygen_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nulong [MASK](long param_1,char *param_2,char *param_3)\n\n{\n  long lVar1;\n  int iVar2;\n  ulong uVar3;\n  \n  lVar1 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  iVar2 = strcmp(param_2,\"Input\");\n  if (iVar2 == 0) {\n    uVar3 = FUN_000061e9(param_3,lVar1 + 0x10);\n  }\n  else {\n    iVar2 = strcmp(param_2,\"Output\");\n    if (iVar2 == 0) {\n      uVar3 = FUN_000066e2(param_3,lVar1 + 0x18,lVar1 + 0x20);\n    }\n    else {\n      iVar2 = strcmp(param_2,\"Count\");\n      if (iVar2 == 0) {\n        uVar3 = FUN_00006443(param_3,*(undefined8 *)(lVar1 + 0x10));\n      }\n      else {\n        iVar2 = strcmp(param_2,\"Ncopy\");\n        if (iVar2 == 0) {\n          uVar3 = FUN_000062f7(param_3,*(undefined8 *)(lVar1 + 0x10));\n        }\n        else {\n          iVar2 = strcmp(param_2,\"Padding\");\n          if (iVar2 == 0) {\n            iVar2 = atoi(param_3);\n            *(int *)(lVar1 + 0x28) = iVar2;\n            uVar3 = (ulong)(0 < *(int *)(lVar1 + 0x28));\n          }\n          else {\n            uVar3 = 0;\n          }\n        }\n      }\n    }\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is digest_test_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = *(undefined8 *)(param_1 + 8);\n  *(undefined8 *)(param_1 + 8) = 0;\n  return uVar1;\n}\n\n",
        "output": "The predicted function name is take_value"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined4 *puVar3;\n  undefined4 local_14;\n  \n  iVar1 = FUN_00011e68(param_2);\n  if (iVar1 == 0) {\n    iVar1 = strcmp(param_2,\"scrypt\");\n    if (iVar1 == 0) {\n      local_14 = 1;\n    }\n    else {\n      iVar1 = strcmp(param_2,\"pbkdf2\");\n      if (iVar1 == 0) {\n        local_14 = 2;\n      }\n      else {\n        iVar1 = strcmp(param_2,\"pkcs12\");\n        if (iVar1 != 0) {\n          FUN_000170fc(\"test/evp_test.c\",0x853,\"Unknown pbe algorithm %s\",param_2);\n          return 0;\n        }\n        local_14 = 3;\n      }\n    }\n    puVar3 = (undefined4 *)CRYPTO_zalloc(0x68,\"test/evp_test.c\",0x856);\n    iVar1 = FUN_00018f92(\"test/evp_test.c\",0x856,\"pdat = OPENSSL_zalloc(sizeof(*pdat))\",puVar3);\n    if (iVar1 == 0) {\n      uVar2 = 0;\n    }\n    else {\n      *puVar3 = local_14;\n      *(undefined4 **)(\"EVP_PKEY_verify_recover_init\" + param_1) = puVar3;\n      uVar2 = 1;\n    }\n  }\n  else {\n    FUN_00016f06(\"test/evp_test.c\",0x848,\"skipping, \\'%s\\' is disabled\",param_2);\n    *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n",
        "output": "The predicted function name is pbe_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1)\n\n{\n  return param_1;\n}\n\n",
        "output": "The predicted function name is ossl_check_OPENSSL_STRING_sk_type"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nbool [MASK](long param_1,EVP_PKEY_CTX *param_2,char *param_3)\n\n{\n  int iVar1;\n  char *__s;\n  char *pcVar2;\n  int local_1c;\n  char *local_18;\n  \n  local_1c = 0;\n  __s = CRYPTO_strdup(param_3,\"test/evp_test.c\",0x6c4);\n  iVar1 = FUN_00018f92(\"test/evp_test.c\",0x6c4,\"tmpval = OPENSSL_strdup(value)\",__s);\n  if (iVar1 != 0) {\n    pcVar2 = strchr(__s,0x3a);\n    local_18 = pcVar2;\n    if (pcVar2 != (char *)0x0) {\n      local_18 = pcVar2 + 1;\n      *pcVar2 = '\\0';\n      local_1c = EVP_PKEY_CTX_ctrl_str(param_2,__s,local_18);\n    }\n    if (local_1c == -2) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"PKEY_CTRL_INVALID\";\n      local_1c = 1;\n    }\n    else if ((local_18 != (char *)0x0) && (local_1c < 1)) {\n      iVar1 = FUN_00011e19(local_18);\n      if ((iVar1 == 0) && (iVar1 = FUN_00011e77(local_18), iVar1 == 0)) {\n        *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"PKEY_CTRL_ERROR\";\n        local_1c = 1;\n      }\n      else {\n        FUN_00016f06(\"test/evp_test.c\",0x6d0,\"skipping, \\'%s\\' is disabled\",local_18);\n        *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n        local_1c = 1;\n      }\n    }\n    CRYPTO_free(__s);\n    return 0 < local_1c;\n  }\n  return false;\n}\n\n",
        "output": "The predicted function name is pkey_test_ctrl"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](undefined8 param_1,code *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  undefined8 *puVar2;\n  int local_1c;\n  ulong local_18;\n  \n  local_1c = 0;\n  do {\n    iVar1 = FUN_00006028(param_1);\n    if (iVar1 <= local_1c) {\n      return 1;\n    }\n    puVar2 = (undefined8 *)FUN_00006042(param_1,local_1c);\n    for (local_18 = 0; local_18 < (ulong)puVar2[2]; local_18 = local_18 + 1) {\n      iVar1 = (*param_2)(param_3,*puVar2,puVar2[1]);\n      if (iVar1 < 1) {\n        return 0;\n      }\n    }\n    local_1c = local_1c + 1;\n  } while( true );\n}\n\n",
        "output": "The predicted function name is evp_test_buffer_do"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void **param_1)\n\n{\n  if (param_1 != (void **)0x0) {\n    CRYPTO_free(*param_1);\n    CRYPTO_free(param_1);\n  }\n  return;\n}\n\n",
        "output": "The predicted function name is evp_test_buffer_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0000b38a(param_1,param_2,0,PTR_EVP_PKEY_sign_init_00223fc8,PTR_EVP_PKEY_sign_00223fd0);\n  return;\n}\n\n",
        "output": "The predicted function name is sign_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0000fe57(param_1,param_2,0,0);\n  return;\n}\n\n",
        "output": "The predicted function name is digestsign_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  size_t local_30;\n  uchar *local_28;\n  EVP_PKEY_CTX *local_20;\n  EVP_PKEY_CTX **local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = (EVP_PKEY_CTX *)0x0;\n  local_18 = *(EVP_PKEY_CTX ***)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  local_28 = (uchar *)0x0;\n  local_20 = EVP_PKEY_CTX_dup(*local_18);\n  iVar1 = FUN_00018f92(\"test/evp_test.c\",0x7b3,\"dctx = EVP_PKEY_CTX_dup(expected->ctx)\",local_20);\n  if (iVar1 == 0) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DERIVE_ERROR\";\n  }\n  else {\n    iVar1 = EVP_PKEY_derive(local_20,(uchar *)0x0,&local_30);\n    if (0 < iVar1) {\n      iVar1 = FUN_0001881a(\"test/evp_test.c\",0x7b9,\"got_len\",&DAT_0001c72b,local_30,0);\n      if (iVar1 != 0) {\n        local_28 = (uchar *)CRYPTO_malloc((int)local_30,\"test/evp_test.c\",0x7bd);\n        iVar1 = FUN_00018f92(\"test/evp_test.c\",0x7bd,\"got = OPENSSL_malloc(got_len)\",local_28);\n        if (iVar1 == 0) {\n          *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DERIVE_ERROR\";\n        }\n        else {\n          iVar1 = EVP_PKEY_derive(local_20,local_28,&local_30);\n          if (iVar1 < 1) {\n            *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DERIVE_ERROR\";\n          }\n          else {\n            iVar1 = FUN_000060ba(param_1,\"SHARED_SECRET_MISMATCH\",local_18[4],local_18[5],local_28,\n                                 local_30);\n            if (iVar1 != 0) {\n              *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n            }\n          }\n        }\n        goto LAB_0000c3c1;\n      }\n    }\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DERIVE_ERROR\";\n  }\nLAB_0000c3c1:\n  CRYPTO_free(local_28);\n  EVP_PKEY_CTX_free(local_20);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is pderive_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  long lVar1;\n  \n  lVar1 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  FUN_00006094(*(undefined8 *)(lVar1 + 0x10),FUN_000061a0);\n  CRYPTO_free(*(void **)(lVar1 + 0x18));\n  EVP_MD_free(*(undefined8 *)(lVar1 + 8));\n  return;\n}\n\n",
        "output": "The predicted function name is digest_test_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](void *param_1)\n\n{\n  CRYPTO_free(param_1);\n  return;\n}\n\n",
        "output": "The predicted function name is openssl_free"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](undefined8 param_1,undefined8 param_2)\n\n{\n  OPENSSL_sk_push(param_1,param_2);\n  return;\n}\n\n",
        "output": "The predicted function name is sk_EVP_TEST_BUFFER_push"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  EVP_PKEY_CTX **ppEVar1;\n  int iVar2;\n  \n  ppEVar1 = *(EVP_PKEY_CTX ***)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  iVar2 = EVP_PKEY_verify(*ppEVar1,(uchar *)ppEVar1[4],(size_t)ppEVar1[5],(uchar *)ppEVar1[2],\n                          (size_t)ppEVar1[3]);\n  if (iVar2 < 1) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"VERIFY_ERROR\";\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is verify_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return 0;\n}\n\n",
        "output": "The predicted function name is is_kdf_disabled"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  EVP_PKEY_CTX **ppEVar1;\n  \n  ppEVar1 = *(EVP_PKEY_CTX ***)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  CRYPTO_free(ppEVar1[2]);\n  CRYPTO_free(ppEVar1[4]);\n  EVP_PKEY_CTX_free(*ppEVar1);\n  return;\n}\n\n",
        "output": "The predicted function name is pkey_test_cleanup"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  size_t local_28;\n  uchar *local_20;\n  long local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  local_20 = (uchar *)0x0;\n  iVar1 = FUN_000064e0(*(undefined8 *)(local_18 + 0x20),FUN_00010395,\n                       *(undefined8 *)(local_18 + 0x10));\n  if (iVar1 == 0) {\n    *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DIGESTUPDATE_ERROR\";\n  }\n  else {\n    iVar1 = EVP_DigestSignFinal(*(EVP_MD_CTX **)(local_18 + 0x10),(uchar *)0x0,&local_28);\n    if (iVar1 == 0) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DIGESTSIGNFINAL_LENGTH_ERROR\";\n    }\n    else {\n      local_20 = (uchar *)CRYPTO_malloc((int)local_28,\"test/evp_test.c\",0xce8);\n      iVar1 = FUN_00018f92(\"test/evp_test.c\",0xce8,\"got = OPENSSL_malloc(got_len)\",local_20);\n      if (iVar1 == 0) {\n        *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"MALLOC_FAILURE\";\n      }\n      else {\n        local_28 = local_28 * 2;\n        iVar1 = EVP_DigestSignFinal(*(EVP_MD_CTX **)(local_18 + 0x10),local_20,&local_28);\n        if (iVar1 == 0) {\n          *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DIGESTSIGNFINAL_ERROR\";\n        }\n        else {\n          iVar1 = FUN_000060ba(param_1,\"SIGNATURE_MISMATCH\",*(undefined8 *)(local_18 + 0x38),\n                               *(undefined8 *)(local_18 + 0x40),local_20,local_28);\n          if (iVar1 != 0) {\n            *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n          }\n        }\n      }\n    }\n  }\n  CRYPTO_free(local_20);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return 1;\n}\n\n",
        "output": "The predicted function name is digestsign_test_run"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined * [MASK](char *param_1)\n\n{\n  int iVar1;\n  undefined **local_10;\n  \n  local_10 = &PTR_PTR_DAT_00224020;\n  while( true ) {\n    if (*local_10 == (undefined *)0x0) {\n      return (undefined *)0x0;\n    }\n    iVar1 = strcmp(param_1,*(char **)*local_10);\n    if (iVar1 == 0) break;\n    local_10 = local_10 + 1;\n  }\n  return *local_10;\n}\n\n",
        "output": "The predicted function name is find_test"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1)\n\n{\n  undefined8 uVar1;\n  int iVar2;\n  char *pcVar3;\n  long in_FS_OFFSET;\n  undefined8 uVar4;\n  int local_74;\n  undefined8 local_70;\n  size_t local_68;\n  EVP_MD_CTX *local_60;\n  EVP_PKEY *local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  uchar *local_40;\n  long local_38;\n  EVP_PKEY_CTX *local_30;\n  undefined8 local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  local_60 = (EVP_MD_CTX *)0x0;\n  local_70 = 0;\n  local_30 = (EVP_PKEY_CTX *)0x0;\n  local_58 = (EVP_PKEY *)0x0;\n  local_50 = 0;\n  local_48 = 0;\n  local_40 = (uchar *)0x0;\n  if (*(int *)(local_38 + 0x80) != 0) goto LAB_0000a182;\n  if (*(long *)(local_38 + 0x18) == 0) {\n    pcVar3 = OBJ_nid2sn(*(int *)(local_38 + 0x10));\n    FUN_00016f06(\"test/evp_test.c\",0x521,\"Trying the EVP_PKEY %s test\",pcVar3);\n  }\n  else {\n    uVar4 = *(undefined8 *)(local_38 + 0x18);\n    pcVar3 = OBJ_nid2sn(*(int *)(local_38 + 0x10));\n    FUN_00016f06(\"test/evp_test.c\",0x524,\"Trying the EVP_PKEY %s test with %s\",pcVar3,uVar4);\n  }\n  if (*(int *)(local_38 + 0x10) == 0x37e) {\n    if ((*(long *)(local_38 + 0x18) == 0) ||\n       (iVar2 = FUN_00011e77(*(undefined8 *)(local_38 + 0x18)), iVar2 == 0)) {\n      local_48 = EVP_CIPHER_fetch(DAT_002241a8,*(undefined8 *)(local_38 + 0x18),0);\n      iVar2 = FUN_00018f92(\"test/evp_test.c\",0x535,\n                           \"cipher = EVP_CIPHER_fetch(libctx, expected->alg, NULL)\",local_48);\n      if (iVar2 != 0) {\n        local_28 = OSSL_LIB_CTX_set0_default(DAT_002241a8);\n        local_58 = (EVP_PKEY *)\n                   EVP_PKEY_new_CMAC_key\n                             (0,*(undefined8 *)(local_38 + 0x20),*(undefined8 *)(local_38 + 0x28),\n                              local_48);\n        OSSL_LIB_CTX_set0_default(local_28);\n        goto LAB_00009e51;\n      }\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"MAC_KEY_CREATE_ERROR\";\n    }\n    else {\n      FUN_00016f06(\"test/evp_test.c\",0x530,\"skipping, PKEY CMAC \\'%s\\' is disabled\",\n                   *(undefined8 *)(local_38 + 0x18));\n      *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n      *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n    }\n  }\n  else {\n    uVar4 = *(undefined8 *)(local_38 + 0x28);\n    uVar1 = *(undefined8 *)(local_38 + 0x20);\n    pcVar3 = OBJ_nid2sn(*(int *)(local_38 + 0x10));\n    local_58 = (EVP_PKEY *)EVP_PKEY_new_raw_private_key_ex(DAT_002241a8,pcVar3,0,uVar1,uVar4);\nLAB_00009e51:\n    if (local_58 == (EVP_PKEY *)0x0) {\n      *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"MAC_KEY_CREATE_ERROR\";\n    }\n    else {\n      if ((*(int *)(local_38 + 0x10) == 0x357) && (*(long *)(local_38 + 0x18) != 0)) {\n        iVar2 = FUN_00011e19(*(undefined8 *)(local_38 + 0x18));\n        if (iVar2 != 0) {\n          FUN_00016f06(\"test/evp_test.c\",0x54a,\"skipping, HMAC \\'%s\\' is disabled\",\n                       *(undefined8 *)(local_38 + 0x18));\n          *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n          *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n          goto LAB_0000a135;\n        }\n        local_50 = *(undefined8 *)(local_38 + 0x18);\n      }\n      local_60 = (EVP_MD_CTX *)EVP_MD_CTX_new();\n      uVar4 = 0x9f1c;\n      iVar2 = FUN_00018f92(\"test/evp_test.c\",0x551,\"mctx = EVP_MD_CTX_new()\",local_60);\n      if (iVar2 == 0) {\n        *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"INTERNAL_ERROR\";\n      }\n      else {\n        iVar2 = EVP_DigestSignInit_ex(local_60,&local_70,local_50,DAT_002241a8,0,local_58,0,uVar4);\n        if (iVar2 == 0) {\n          *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DIGESTSIGNINIT_ERROR\";\n        }\n        else {\n          local_74 = 0;\n          while( true ) {\n            uVar4 = FUN_00005fa8(*(undefined8 *)(local_38 + 0x88));\n            iVar2 = OPENSSL_sk_num(uVar4);\n            if (iVar2 <= local_74) break;\n            uVar4 = FUN_00005fa8(*(undefined8 *)(local_38 + 0x88));\n            uVar4 = OPENSSL_sk_value(uVar4,local_74);\n            iVar2 = FUN_00009af7(param_1,local_70,uVar4);\n            if (iVar2 == 0) {\n              *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"EVPPKEYCTXCTRL_ERROR\";\n              goto LAB_0000a135;\n            }\n            local_74 = local_74 + 1;\n          }\n          iVar2 = EVP_DigestSignUpdate\n                            (local_60,*(undefined8 *)(local_38 + 0x40),\n                             *(undefined8 *)(local_38 + 0x48));\n          if (iVar2 == 0) {\n            *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"DIGESTSIGNUPDATE_ERROR\";\n          }\n          else {\n            iVar2 = EVP_DigestSignFinal(local_60,(uchar *)0x0,&local_68);\n            if (iVar2 == 0) {\n              *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) =\n                   \"DIGESTSIGNFINAL_LENGTH_ERROR\";\n            }\n            else {\n              local_40 = (uchar *)CRYPTO_malloc((int)local_68,\"test/evp_test.c\",0x568);\n              iVar2 = FUN_00018f92(\"test/evp_test.c\",0x568,\"got = OPENSSL_malloc(got_len)\",local_40)\n              ;\n              if (iVar2 == 0) {\n                *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"TEST_FAILURE\";\n              }\n              else {\n                iVar2 = EVP_DigestSignFinal(local_60,local_40,&local_68);\n                if ((iVar2 == 0) ||\n                   (iVar2 = FUN_000060ba(param_1,\"TEST_MAC_ERR\",*(undefined8 *)(local_38 + 0x50),\n                                         *(undefined8 *)(local_38 + 0x58),local_40,local_68),\n                   iVar2 == 0)) {\n                  *(char **)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = \"TEST_MAC_ERR\";\n                }\n                else {\n                  *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0000a135:\n  EVP_CIPHER_free(local_48);\n  EVP_MD_CTX_free(local_60);\n  CRYPTO_free(local_40);\n  EVP_PKEY_CTX_free(local_30);\n  EVP_PKEY_free(local_58);\nLAB_0000a182:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
        "output": "The predicted function name is mac_test_run_pkey"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined8 uVar3;\n  EVP_CIPHER *pEVar4;\n  char *pcVar5;\n  EVP_CIPHER **ppEVar6;\n  EVP_CIPHER *local_20;\n  \n  iVar1 = FUN_00011e77(param_2);\n  if (iVar1 == 0) {\n    ERR_set_mark();\n    pEVar4 = (EVP_CIPHER *)EVP_CIPHER_fetch(DAT_002241a8,param_2,0);\n    local_20 = pEVar4;\n    if ((pEVar4 == (EVP_CIPHER *)0x0) &&\n       (local_20 = EVP_get_cipherbyname(param_2), local_20 == (EVP_CIPHER *)0x0)) {\n      pcVar5 = strstr(param_2,\"HMAC\");\n      if (pcVar5 == (char *)0x0) {\n        ERR_clear_last_mark();\n        uVar3 = 0;\n      }\n      else {\n        ERR_pop_to_mark();\n        *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n        FUN_00016f06(\"test/evp_test.c\",0x238,\"skipping, \\'%s\\' is not available\",param_2);\n        uVar3 = 1;\n      }\n    }\n    else {\n      ERR_clear_last_mark();\n      ppEVar6 = (EVP_CIPHER **)CRYPTO_zalloc(0xe8,\"test/evp_test.c\",0x240);\n      iVar1 = FUN_00018f92(\"test/evp_test.c\",0x240,\"cdat = OPENSSL_zalloc(sizeof(*cdat))\",ppEVar6);\n      if (iVar1 == 0) {\n        uVar3 = 0;\n      }\n      else {\n        *ppEVar6 = local_20;\n        ppEVar6[1] = pEVar4;\n        *(undefined4 *)(ppEVar6 + 2) = 0xffffffff;\n        iVar1 = EVP_CIPHER_get_mode(local_20);\n        uVar2 = EVP_CIPHER_get_flags(local_20);\n        if ((uVar2 & 0x200000) == 0) {\n          *(undefined4 *)((long)ppEVar6 + 0x14) = 0;\n        }\n        else {\n          if (iVar1 == 0) {\n            iVar1 = -1;\n          }\n          *(int *)((long)ppEVar6 + 0x14) = iVar1;\n        }\n        *(EVP_CIPHER ***)(\"EVP_PKEY_verify_recover_init\" + param_1) = ppEVar6;\n        if (pEVar4 != (EVP_CIPHER *)0x0) {\n          FUN_00016f06(\"test/evp_test.c\",0x24e,\"%s is fetched\",param_2);\n        }\n        uVar3 = 1;\n      }\n    }\n  }\n  else {\n    *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 1;\n    FUN_00016f06(\"test/evp_test.c\",0x22d,\"skipping, \\'%s\\' is disabled\",param_2);\n    uVar3 = 1;\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is cipher_test_init"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](long param_1,char *param_2,char *param_3)\n\n{\n  long lVar1;\n  int iVar2;\n  undefined8 uVar3;\n  EVP_MD *pEVar4;\n  \n  lVar1 = *(long *)(\"EVP_PKEY_verify_recover_init\" + param_1);\n  iVar2 = strcmp(param_2,\"iter\");\n  if (iVar2 == 0) {\n    iVar2 = atoi(param_3);\n    *(int *)(lVar1 + 0x2c) = iVar2;\n    if (*(int *)(lVar1 + 0x2c) < 1) {\n      uVar3 = 0xffffffff;\n    }\n    else {\n      uVar3 = 1;\n    }\n  }\n  else {\n    iVar2 = strcmp(param_2,\"MD\");\n    if (iVar2 == 0) {\n      pEVar4 = EVP_get_digestbyname(param_3);\n      *(EVP_MD **)(lVar1 + 0x30) = pEVar4;\n      if (*(long *)(lVar1 + 0x30) == 0) {\n        uVar3 = 0xffffffff;\n      }\n      else {\n        uVar3 = 1;\n      }\n    }\n    else {\n      uVar3 = 0;\n    }\n  }\n  return uVar3;\n}\n\n",
        "output": "The predicted function name is pbkdf2_test_parse"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nvoid [MASK](long param_1)\n\n{\n  FUN_00016b1c(param_1);\n  ERR_clear_error();\n  if (*(long *)(\"EVP_PKEY_verify_recover_init\" + param_1) != 0) {\n    if (*(long *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0xf) != 0) {\n      (**(code **)(*(long *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0xf) + 0x10))(param_1);\n    }\n    CRYPTO_free(*(void **)(\"EVP_PKEY_verify_recover_init\" + param_1));\n    *(undefined8 *)(\"EVP_PKEY_verify_recover_init\" + param_1) = 0;\n  }\n  CRYPTO_free(*(void **)(\"EVP_CIPHER_CTX_set_flags\" + param_1 + 9));\n  *(undefined8 *)(\"EVP_CIPHER_CTX_set_flags\" + param_1 + 9) = 0;\n  CRYPTO_free(*(void **)(\"EVP_CIPHER_CTX_set_flags\" + param_1 + 0x11));\n  *(undefined8 *)(\"EVP_CIPHER_CTX_set_flags\" + param_1 + 0x11) = 0;\n  *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0x17) = 0;\n  *(undefined4 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 7) = 0;\n  *(undefined8 *)(\"EVP_CIPHER_CTX_get_updated_iv\" + param_1 + 0xf) = 0;\n  return;\n}\n\n",
        "output": "The predicted function name is clear_test"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](char *param_1,long param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  long lVar3;\n  \n  iVar1 = atoi(param_1);\n  if (((0 < iVar1) && (param_2 != 0)) && (iVar2 = FUN_00006028(param_2), iVar2 != 0)) {\n    iVar2 = FUN_00006028(param_2);\n    lVar3 = FUN_00006042(param_2,iVar2 + -1);\n    if (*(int *)(lVar3 + 0x18) == 0) {\n      *(long *)(lVar3 + 0x10) = (long)iVar1;\n      *(undefined4 *)(lVar3 + 0x18) = 1;\n      return 1;\n    }\n    return 0;\n  }\n  return 0;\n}\n\n",
        "output": "The predicted function name is evp_test_buffer_set_count"
    },
    {
        "instruction": "Suppose you are an expert in software reverse engineering. Here is a piece of decompiled code, you should infer code semantics and tell me the original function name from the contents of the function to replace [MASK]. Now the decompiled codes are as follows:",
        "input": "\nundefined8 [MASK](void)\n\n{\n  return 0;\n}\n\n",
        "output": "The predicted function name is is_mac_disabled"
    }
]